// ===== SISTEMA DE LOGGING CONTROLADO E PERFORMANCE =====
const DEBUG_MODE = false; // ⚡ ATIVA/DESATIVA DEBUG DE DETECÇÃO DE SESSÃO
const log = DEBUG_MODE ? console.log.bind(console) : () => {}; // Logs silenciosos por padrão
const logCritical = console.log.bind(console); // Apenas logs críticos sempre visíveis
const logError = console.error.bind(console); // Erros sempre visíveis

// 🚀 SISTEMA DE PERFORMANCE CRÍTICA - OBRIGATÓRIO
const PERFORMANCE_CONFIG = {
    maxElementsToProcess: 1000, // Máximo de elementos por processamento
    debounceDelay: 300, // Delay de debounce em ms
    idleCallbackTimeout: 5000, // Timeout para requestIdleCallback
    enableLazyLoading: true, // Habilitar lazy loading
    cleanupInterval: 30000, // Interval de cleanup em ms
};

// 🔧 THROTTLE GLOBAL OBRIGATÓRIO
const throttleGlobal = (func, delay) => {
    let timeoutId;
    let lastExecTime = 0;
    return function (...args) {
        const currentTime = Date.now();
        if (currentTime - lastExecTime > delay) {
            func.apply(this, args);
            lastExecTime = currentTime;
        } else {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                func.apply(this, args);
                lastExecTime = Date.now();
            }, delay);
        }
    };
};

// 🔧 DEBOUNCE GLOBAL OBRIGATÓRIO
const debounceGlobal = (func, delay) => {
    let timeoutId;
    return function (...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
};

// 🧹 SISTEMA DE CLEANUP GLOBAL - OTIMIZAÇÃO CRÍTICA PARA PERFORMANCE
const CLEANUP_SYSTEM = {
    timers: new Set(),
    observers: new Set(),
    intervals: new Set(),

    // Registrar timer para cleanup automático
    addTimer(timerId) {
        this.timers.add(timerId);
        return timerId;
    },

    // Registrar observer para cleanup automático
    addObserver(observer) {
        this.observers.add(observer);
        return observer;
    },

    // Registrar interval para cleanup automático
    addInterval(intervalId) {
        this.intervals.add(intervalId);
        return intervalId;
    },

    // Cleanup forçado de todos os recursos
    cleanupAll() {
        console.log("🧹 CLEANUP: Iniciando limpeza de recursos...");

        // Limpar timers
        this.timers.forEach((timerId) => clearTimeout(timerId));
        this.timers.clear();

        // Limpar intervals
        this.intervals.forEach((intervalId) => clearInterval(intervalId));
        this.intervals.clear();

        // Desconectar observers
        this.observers.forEach((observer) => {
            try {
                observer.disconnect();
            } catch (e) {}
        });
        this.observers.clear();

        console.log("✅ CLEANUP: Recursos limpos com sucesso");
    },
};

// Auto-cleanup a cada 2 minutos para prevenir memory leaks
CLEANUP_SYSTEM.addInterval(
    setInterval(() => {
        CLEANUP_SYSTEM.cleanupAll();
    }, PERFORMANCE_CONFIG.cleanupInterval)
);

// 🚨 FLAG GLOBAL - DESABILITAR SUBSTITUIÇÃO DE ESTRELAS
const DISABLE_STAR_REPLACEMENTS = true; // ⛔ PROTEÇÃO: Impede substituição de estrelas

// 🚨 INTERCEPTAÇÃO ULTRA-PRECOCE - CAPTURA AMBAS AS FUNÇÕES PROBLEMÁTICAS
(function interceptacaoUltraPrecoce() {
    logCritical(
        "🎨 PERSONALIZAÇÃO: Customizando apenas aparência das estrelas (SEM interceptar funções)..."
    );

    //   FUNÇÃO ULTRA-SEGURA PARA EVENTO - COMPLETAMENTE DESABILITADA
    function switchRelevanciaEventoUltraSegura(
        idEvento,
        relevancia,
        tipo,
        urlAjax
    ) {
        // COMPLETAMENTE DESABILITADO para preservar funcionalidade do eProc
        console.log(
            "⚠️ INTERCEPTAÇÃO DESABILITADA: switchRelevanciaEvento não será interceptada"
        );
        return false; // Não fazer nada
    }

    //  🔥 FORÇA BRUTAL: Redefinir switchRelevanciaEvento IMEDIATAMENTE - DESABILITADO
    const forcarInterceptacaoEvento = () => {
        if (typeof window.switchRelevanciaEvento === "function") {
            const codigo = window.switchRelevanciaEvento.toString();
            if (
                codigo.includes("substring") ||
                codigo.includes("controlador.php")
            ) {
                logCritical(
                    "🚨 FUNÇÃO PROBLEMÁTICA DETECTADA! Mas não interceptaremos mais..."
                );
                // REMOVIDA: Interceptação completa de switchRelevanciaEvento
                /*
                window.switchRelevanciaEvento = function (
                    idEvento,
                    relevancia,
                    tipo,
                    urlAjax
                ) {
                    console.log(
                        "🛡️ INTERCEPTAÇÃO FORÇADA: switchRelevanciaEvento redirecionada para função segura"
                    );
                    return switchRelevanciaEventoUltraSegura(
                        idEvento,
                        relevancia,
                        tipo,
                        urlAjax
                    );
                };
                */
            }
        }
        // DESABILITADO: Não repetir verificação para switchRelevanciaEvento
        // setTimeout(forcarInterceptacaoEvento, 100);
    };

    // Criar nossa função robusta para switchRelevanciaDocumento - DESABILITADA
    function switchRelevanciaDocumentoUltraSegura(
        idEvento,
        relevancia,
        tipo,
        urlAjax
    ) {
        // COMPLETAMENTE DESABILITADO para preservar funcionalidade do eProc
        console.log(
            "⚠️ INTERCEPTAÇÃO DESABILITADA: switchRelevanciaDocumento não será interceptada"
        );
        return false; // Não fazer nada

        /* CÓDIGO ORIGINAL DESABILITADO:
        try {
            logCritical(
                "🛡️ ULTRA-SEGURA: switchRelevanciaDocumento interceptada:",
                {
                    idEvento,
                    relevancia,
                    tipo,
                    urlAjax,
                }
            );

            // 🚨 CORREÇÃO CRÍTICA: Validação mais robusta dos parâmetros
            if (idEvento === undefined || idEvento === null) {
                console.error("❌ ERRO: idEvento é undefined ou null");
                return false;
            }

            if (urlAjax === undefined || urlAjax === null) {
                console.error("❌ ERRO: urlAjax é undefined ou null");
                return false;
            }

            // Converter para string de forma segura
            const idEventoStr = String(idEvento);
            const urlAjaxStr = String(urlAjax);

            // Verificar se a conversão foi bem-sucedida
            if (idEventoStr === "undefined" || urlAjaxStr === "undefined") {
                console.error(
                    "❌ ERRO: Parâmetros convertidos resultaram em 'undefined'"
                );
                return false;
            }

            // Construir URL com máxima segurança usando as strings validadas
            let fullUrl = urlAjaxStr;
            const separator = fullUrl.includes("?") ? "&" : "?";
            const params = `idEvento=${encodeURIComponent(
                idEventoStr
            )}&relevancia=${encodeURIComponent(
                String(relevancia || "")
            )}&tipo=${encodeURIComponent(String(tipo || ""))}`;
            fullUrl += separator + params;

            logCritical("🌐 URL CONSTRUÍDA:", fullUrl);

            // AJAX ultra-robusto
            const xhr = new XMLHttpRequest();
            xhr.open("GET", fullUrl, true);

            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        logCritical(
                            "✅ SUCESSO ULTRA-SEGURO:",
                            xhr.responseText
                        );

                        // Atualizar ícone após sucesso usando ID validado
                        setTimeout(() => {
                            atualizarIconeUltraSeguro(idEventoStr, relevancia);
                        }, 50);

                        // Verificar se deve recarregar
                        const resposta = String(
                            xhr.responseText || ""
                        ).toLowerCase();
                        if (
                            resposta.includes("reload") ||
                            resposta.includes("location")
                        ) {
                            setTimeout(() => window.location.reload(), 300);
                        }
                    } else {
                        console.error("❌ ERRO HTTP:", xhr.status);
                    }
                }
            };

            xhr.onerror = () => console.error("❌ ERRO REDE");
            xhr.ontimeout = () => console.error("❌ TIMEOUT");
            xhr.timeout = 15000;

            xhr.send();
            return true;
        } catch (error) {
            console.error("❌ ERRO CRÍTICO na função ultra-segura:", error);
            return false;
        }
        */ // FIM DO CÓDIGO DESABILITADO
    }

    // DESABILITADO: Função ultra-segura para atualizar ícones (interferindo com eProc)
    function atualizarIconeUltraSeguro(idEvento, relevancia) {
        // COMPLETAMENTE DESABILITADO para não interferir com switchRelevanciaEvento do eProc
        logCritical(
            `⚠️ ATUALIZAÇÃO DE ÍCONE DESABILITADA: ${idEvento} -> ${relevancia} (preservando funcionalidade original)`
        );
        return true; // Retornar sucesso sem fazer modificações

        // Código original comentado para preservar funcionalidade do eProc:
        /*
        try {
            logCritical(`🌟 ATUALIZANDO ÍCONE: ${idEvento} -> ${relevancia}`);

            const seletores = [
                `img[onclick*="${idEvento}"]`,
                `a[onclick*="${idEvento}"]`,
                `[onclick*="switchRelevanciaDocumento('${idEvento}'"]`,
                `[onclick*='switchRelevanciaDocumento("${idEvento}"']`,
                `img[src*="estrela"]`,
                `img[alt*="estrela"]`,
            ];

            let iconesAtualizados = 0;

            for (const seletor of seletores) {
                try {
                    const elementos = document.querySelectorAll(seletor);
                    elementos.forEach((elemento) => {
                        if (elemento.tagName === "IMG" && elemento.src) {
                            const srcOriginal = elemento.src;
                            let novoSrc = srcOriginal;

                            // Lógica robusta de troca de ícones
                            if (
                                relevancia === "S" ||
                                relevancia === "1" ||
                                relevancia === 1
                            ) {
                                // Marcar como relevante
                                novoSrc = novoSrc
                                    .replace(/estrela[_\-]?off/gi, "estrela_on")
                                    .replace(
                                        /estrela[_\-]?apagada/gi,
                                        "estrela_acesa"
                                    )
                                    .replace(/EstrelaApagada/gi, "EstrelaAcesa")
                                    .replace(/estrela\.gif/gi, "estrela_on.gif")
                                    .replace(/estrela_0/gi, "estrela_1");
                            } else {
                                // Marcar como não relevante
                                novoSrc = novoSrc
                                    .replace(/estrela[_\-]?on/gi, "estrela_off")
                                    .replace(
                                        /estrela[_\-]?acesa/gi,
                                        "estrela_apagada"
                                    )
                                    .replace(/EstrelaAcesa/gi, "EstrelaApagada")
                                    .replace(/estrela_on\.gif/gi, "estrela.gif")
                                    .replace(/estrela_1/gi, "estrela_0");
                            }

                            if (novoSrc !== srcOriginal) {
                                elemento.src = novoSrc;
                                iconesAtualizados++;
                                logCritical(
                                    `✅ Ícone ${iconesAtualizados}: ${srcOriginal} → ${novoSrc}`
                                );
                            }
                        }
                    });
                } catch (selectorError) {
                    console.warn(
                        `⚠️ Erro com seletor ${seletor}:`,
                        selectorError
                    );
                }
            }

            logCritical(`🎯 Total de ícones atualizados: ${iconesAtualizados}`);
        } catch (error) {
            console.error("❌ Erro ao atualizar ícones:", error);
        }
        */
        // FIM DA FUNÇÃO COMENTADA
    }

    // ️ FUNÇÃO ULTRA-SEGURA PARA switchRelevanciaEvento
    function switchRelevanciaEventoUltraSegura(
        idEvento,
        relevancia,
        tipo,
        urlAjax
    ) {
        console.log(
            "🔥 INTERCEPTAÇÃO CONFIRMADA: switchRelevanciaEvento chamada com parâmetros:",
            {
                idEvento: typeof idEvento + " = " + idEvento,
                relevancia: typeof relevancia + " = " + relevancia,
                tipo: typeof tipo + " = " + tipo,
                urlAjax:
                    typeof urlAjax +
                    " = " +
                    (urlAjax ? String(urlAjax).substring(0, 50) : "undefined") +
                    "...",
            }
        );

        try {
            logCritical(
                "🛡️ ULTRA-SEGURA: switchRelevanciaEvento interceptada:",
                {
                    idEvento,
                    relevancia,
                    tipo,
                    urlAjax,
                }
            );

            // 🚨 CORREÇÃO CRÍTICA: Validação mais robusta dos parâmetros
            if (idEvento === undefined || idEvento === null) {
                console.error("❌ ERRO: idEvento é undefined ou null");
                return false;
            }

            if (urlAjax === undefined || urlAjax === null) {
                console.error("❌ ERRO: urlAjax é undefined ou null");
                return false;
            }

            // Converter para string de forma segura
            const idEventoStr = String(idEvento);
            const urlAjaxStr = String(urlAjax);

            // Verificar se a conversão foi bem-sucedida
            if (idEventoStr === "undefined" || urlAjaxStr === "undefined") {
                console.error(
                    "❌ ERRO: Parâmetros convertidos resultaram em 'undefined'"
                );
                return false;
            }

            // Construir URL com máxima segurança usando as strings validadas
            let fullUrl = urlAjaxStr;
            const separator = fullUrl.includes("?") ? "&" : "?";
            const params = `idEvento=${encodeURIComponent(
                idEventoStr
            )}&relevancia=${encodeURIComponent(
                String(relevancia || "")
            )}&tipo=${encodeURIComponent(String(tipo || ""))}`;
            fullUrl += separator + params;

            logCritical("🌐 switchRelevanciaEvento URL CONSTRUÍDA:", fullUrl);

            // AJAX ultra-robusto - MESMA LÓGICA
            const xhr = new XMLHttpRequest();
            xhr.open("GET", fullUrl, true);

            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        logCritical(
                            "✅ switchRelevanciaEvento SUCESSO:",
                            xhr.responseText
                        );

                        // Atualizar ícone após sucesso usando ID validado
                        setTimeout(() => {
                            atualizarIconeUltraSeguro(idEventoStr, relevancia);
                        }, 50);

                        // Verificar se deve recarregar
                        const resposta = String(
                            xhr.responseText || ""
                        ).toLowerCase();
                        if (
                            resposta.includes("reload") ||
                            resposta.includes("location")
                        ) {
                            setTimeout(() => window.location.reload(), 300);
                        }
                    } else {
                        console.error(
                            "❌ switchRelevanciaEvento ERRO HTTP:",
                            xhr.status
                        );
                    }
                }
            };

            xhr.onerror = () =>
                console.error("❌ switchRelevanciaEvento ERRO REDE");
            xhr.ontimeout = () =>
                console.error("❌ switchRelevanciaEvento TIMEOUT");
            xhr.timeout = 15000;

            xhr.send();
            return true;
        } catch (error) {
            console.error(
                "❌ ERRO CRÍTICO na switchRelevanciaEvento ultra-segura:",
                error
            );
            return false;
        }
    }

    // 🔒 INTERCEPTAÇÃO MAIS INTELIGENTE - Fallback para função original
    let funcaoOriginalEproc = null; // Armazenar a função original do eProc se existir
    let interceptacaoAtiva = true; // Circuit breaker para parar loops infinitos
    let contadorTentativas = 0; // Contador de tentativas de redefinição
    const maxTentativas = 10; // Máximo de tentativas permitidas

    let funcaoInterceptada = function (idEvento, relevancia, tipo, urlAjax) {
        try {
            // Tentar nossa função ultra-segura primeiro
            const resultado = switchRelevanciaDocumentoUltraSegura(
                idEvento,
                relevancia,
                tipo,
                urlAjax
            );
            if (resultado === true) {
                return true;
            }
        } catch (error) {
            console.warn(
                "⚠️ Função ultra-segura falhou, tentando fallback:",
                error
            );
        }

        // Se nossa função falhou, tentar função original do eProc (se segura)
        if (funcaoOriginalEproc && typeof funcaoOriginalEproc === "function") {
            try {
                console.log(
                    "🔄 Tentando função original do eProc como fallback..."
                );
                return funcaoOriginalEproc.call(
                    this,
                    idEvento,
                    relevancia,
                    tipo,
                    urlAjax
                );
            } catch (error) {
                console.error("❌ Função original também falhou:", error);
                return false;
            }
        }

        console.error("❌ Todas as tentativas falharam");
        return false;
    };

    // Marcar nossa função para identificação
    funcaoInterceptada.__eprobeInterceptada = true;
    let tentativasRedefinicao = 0;

    // DESABILITADO: Object.defineProperty(window, "switchRelevanciaDocumento", {
    /*
    Object.defineProperty(window, "switchRelevanciaDocumento", {
        get: function () {
            return funcaoInterceptada;
        },
        set: function (novaFuncao) {
            contadorTentativas++;

            // 🚨 CIRCUIT BREAKER: Parar loop infinito
            if (contadorTentativas > maxTentativas) {
                console.warn(
                    `⚠️ CIRCUIT BREAKER: Máximo de ${maxTentativas} tentativas atingido. Parando interceptação.`
                );
                interceptacaoAtiva = false;
                return;
            }

            if (!interceptacaoAtiva) {
                console.log(
                    "⏸️ INTERCEPTAÇÃO DESABILITADA: Permitindo redefinição direta"
                );
                funcaoInterceptada = novaFuncao;
                return;
            }

            logCritical(
                `🚨 TENTATIVA ${contadorTentativas} DE REDEFINIÇÃO INTERCEPTADA!`
            );

            // Analisar a função que está tentando ser definida
            if (typeof novaFuncao === "function") {
                const codigoFuncao = novaFuncao.toString();
                logCritical(
                    "🔍 Analisando função:",
                    codigoFuncao.substring(0, 200) + "..."
                );

                // Se parece ser a função original do eProc (mas não problemática), armazenar como fallback
                if (
                    codigoFuncao.includes("controlador.php") &&
                    !codigoFuncao.includes("ULTRA-SEGURA") &&
                    codigoFuncao.length > 100 // Parece ser uma função real
                ) {
                    console.log(
                        "💾 Armazenando função original do eProc como fallback"
                    );
                    funcaoOriginalEproc = novaFuncao;

                    // Ainda manter nossa função como principal, mas agora com fallback
                    logCritical(
                        "🛡️ Função original armazenada, mantendo interceptação ativa"
                    );
                    return;
                }

                // Se for nossa própria função sendo redefinida, permitir
                if (
                    codigoFuncao.includes("ULTRA-SEGURA") ||
                    codigoFuncao.includes(
                        "switchRelevanciaDocumentoUltraSegura"
                    )
                ) {
                    console.log(
                        "✅ Permitindo redefinição da nossa própria função"
                    );
                    funcaoInterceptada = novaFuncao;
                    return;
                }
                if (
                    codigoFuncao.includes("substring") ||
                    codigoFuncao.includes("controlador.php")
                ) {
                    logCritical(
                        "🛡️ FUNÇÃO PROBLEMÁTICA DETECTADA E BLOQUEADA!"
                    );
                }
            }

            // NÃO permitir a redefinição - manter sempre nossa função
            return;
        },
        configurable: false,
        enumerable: true,
    });
    */ // FIM DA INTERCEPTAÇÃO DESABILITADA

    // 🔒 INTERCEPTAÇÃO ADICIONAL - switchRelevanciaEvento com sistema híbrido
    let funcaoOriginalEprocEvento = null; // Armazenar a função original do eProc se existir
    // REMOVIDO: Interceptação completa de switchRelevanciaEvento
    /*
    // DESABILITADO: Circuit breaker para switchRelevanciaEvento
    let interceptacaoAtivaEvento = false; // Desabilitado para preservar funcionalidade original
    let contadorTentativasEvento = 0; // Contador de tentativas para evento

    let funcaoEventoInterceptada = function (
        idEvento,
        relevancia,
        tipo,
        urlAjax
    ) {
        try {
            // Tentar nossa função ultra-segura primeiro
            const resultado = switchRelevanciaEventoUltraSegura(
                idEvento,
                relevancia,
                tipo,
                urlAjax
            );
            if (resultado === true) {
                return true;
            }
        } catch (error) {
            console.warn("⚠️ switchRelevanciaEvento falhou:", error);
        }

        // 🚨 NUNCA USAR FALLBACK - A função original do eProc é problemática!
        console.error(
            "❌ switchRelevanciaEvento: Todas as tentativas falharam, retornando false para segurança"
        );
        return false; // Sempre retornar false em vez de tentar função problemática
    };

    // Marcar nossa função de evento para identificação
    funcaoEventoInterceptada.__eprobeInterceptadaEvento = true;
    let tentativasRedefinicaoEvento = 0;
    */

    // REMOVIDO: Object.defineProperty para switchRelevanciaEvento (causava erro)
    /*
    Object.defineProperty(window, "switchRelevanciaEvento", {
        get: function () {
            // DESABILITADO: return funcaoEventoInterceptada;
            return undefined; // Permitir que função original funcione
        },
        set: function (novaFuncao) {
            // DESABILITADO: Não interceptar mais, permitir definição normal
            // A função original do eProc pode ser definida sem interferência

            if (!interceptacaoAtivaEvento) {
                console.log(
                    "⏸️ INTERCEPTAÇÃO EVENTO DESABILITADA: Permitindo redefinição direta"
                );
                funcaoEventoInterceptada = novaFuncao;
                return;
            }

            logCritical(
                `🚨 switchRelevanciaEvento: TENTATIVA ${contadorTentativasEvento} DE REDEFINIÇÃO BLOQUEADA!`
            );

            // Analisar a função que está tentando ser definida
            if (typeof novaFuncao === "function") {
                const codigoFuncao = novaFuncao.toString();
                logCritical(
                    "🔍 switchRelevanciaEvento código analisando:",
                    codigoFuncao.substring(0, 200) + "..."
                );

                // 🚨 NUNCA ARMAZENAR função original - é problemática!
                if (
                    codigoFuncao.includes("controlador.php") &&
                    !codigoFuncao.includes("ULTRA-SEGURA") &&
                    codigoFuncao.length > 100 // Parece ser uma função real
                ) {
                    logCritical(
                        "  FUNÇÃO ORIGINAL DO EPROC DETECTADA E BLOQUEADA - contém bugs!"
                    );
                    logCritical(
                        "🛡️ Mantendo nossa função segura, nunca usando fallback problemático"
                    );
                    return; // Bloquear e nunca armazenar
                }

                // Se for nossa própria função sendo redefinida, permitir
                if (
                    codigoFuncao.includes("ULTRA-SEGURA") ||
                    codigoFuncao.includes("__eprobeInterceptadaEvento")
                ) {
                    console.log(
                        "✅ Permitindo redefinição da nossa própria função de evento"
                    );
                    funcaoEventoInterceptada = novaFuncao;
                    return;
                }

                // Se for a função problemática do eProc, bloquear
                if (
                    codigoFuncao.includes("substring") &&
                    codigoFuncao.includes("controlador.php")
                ) {
                    logCritical(
                        "🛡️ switchRelevanciaEvento FUNÇÃO PROBLEMÁTICA DETECTADA E BLOQUEADA!"
                    );
                }
            }

            // NÃO permitir a redefinição - manter sempre nossa função
            return;
        },
        configurable: false,
        enumerable: true,
    });
    */

    // 🔄 VERIFICAÇÃO CONTÍNUA ULTRA-AGRESSIVA - DESABILITADA
    let verificacaoAtiva = false; // ⛔ DESABILITADO para preservar funcionalidade do eProc
    let totalVerificacoes = 0; // Contador total de verificações

    const verificarIntegridade = () => {
        if (!verificacaoAtiva) return;

        try {
            // Verificar switchRelevanciaDocumento
            if (window.switchRelevanciaDocumento !== funcaoInterceptada) {
                logCritical(
                    "🚨 switchRelevanciaDocumento ALTERADA! Forçando restore..."
                );

                // Tentar forçar nossa função de volta
                try {
                    delete window.switchRelevanciaDocumento;
                } catch (e) {}

                window.switchRelevanciaDocumento = funcaoInterceptada;
            }

            // Verificar se as funções existem e são nossas
            const funcaoDocumento = window.switchRelevanciaDocumento;
            if (typeof funcaoDocumento === "function" && interceptacaoAtiva) {
                // Verificar se é nossa função usando marcação
                if (
                    !funcaoDocumento.__eprobeInterceptada &&
                    !funcaoDocumento.toString().includes("ULTRA-SEGURA")
                ) {
                    logCritical(
                        "🚨 switchRelevanciaDocumento ESTRANHA DETECTADA! Substituindo..."
                    );
                    window.switchRelevanciaDocumento = funcaoInterceptada;
                } else {
                    // É nossa função, não fazer nada
                    if (funcaoDocumento.__eprobeInterceptada) {
                        console.log(
                            "✅ switchRelevanciaDocumento é nossa função (marcada)"
                        );
                    }
                }
            }

            const funcaoEvento = window.switchRelevanciaEvento;
            if (
                typeof funcaoEvento === "function" &&
                interceptacaoAtivaEvento
            ) {
                // Verificar se é nossa função usando marcação
                if (
                    !funcaoEvento.__eprobeInterceptadaEvento &&
                    !funcaoEvento.toString().includes("ULTRA-SEGURA")
                ) {
                    logCritical(
                        "🚨 switchRelevanciaEvento ESTRANHA DETECTADA! Mas não substituiremos mais..."
                    );
                    // REMOVIDO: window.switchRelevanciaEvento = funcaoEventoInterceptada;
                } else {
                    // É nossa função, não fazer nada
                    if (funcaoEvento.__eprobeInterceptadaEvento) {
                        console.log(
                            "✅ switchRelevanciaEvento é nossa função (marcada)"
                        );
                    }
                }
            }
        } catch (error) {
            console.warn("⚠️ Erro na verificação de integridade:", error);
        }

        // 🚨 CIRCUIT BREAKER DEFINITIVO: Parar verificações após período inicial
        totalVerificacoes++;

        // Dar tempo inicial para estabilizar (50 verificações = ~5 segundos)
        if (totalVerificacoes > 50) {
            console.log(
                "⏹️ VERIFICAÇÃO PERIÓDICA FINALIZADA: Sistema estabilizado após 50 verificações"
            );
            verificacaoAtiva = false;
            return; // Para definitivamente as verificações
        }

        // Verificar se ambas as funções estão estáveis (são nossas)
        const funcaoDocumentoAtual = window.switchRelevanciaDocumento;
        const funcaoEventoAtual = window.switchRelevanciaEvento;

        const documentoEstavel =
            funcaoDocumentoAtual && funcaoDocumentoAtual.__eprobeInterceptada;
        const eventoEstavel =
            funcaoEventoAtual && funcaoEventoAtual.__eprobeInterceptadaEvento;

        if (documentoEstavel && eventoEstavel && totalVerificacoes > 10) {
            console.log(
                "✅ SISTEMA ESTÁVEL: Ambas funções são nossas, parando verificações periódicas"
            );
            verificacaoAtiva = false;
            return; // Para as verificações quando tudo está estável
        }

        // Continuar verificações apenas se necessário
        if (totalVerificacoes <= 50 && verificacaoAtiva) {
            setTimeout(verificarIntegridade, 200); // Verificar menos frequentemente
        }
    };

    // Iniciar verificação imediata
    setTimeout(verificarIntegridade, 50);

    // 🎯 INTERCEPTAÇÃO ADICIONAL - Window.prototype - DESABILITADA
    const originalDefineProperty = Object.defineProperty;

    // ️ INTERCEPTAÇÃO DE EVAL E NEW FUNCTION - DESABILITADA
    const originalEval = window.eval;

    // 🔍 INTERCEPTAÇÃO ADICIONAL - QUALQUER FUNÇÃO COM 'switchRelevancia'
    // Interceptar QUALQUER definição de função que contenha 'switchRelevancia'
    const monitorarDefinicoesFuncoes = () => {
        const originalFunction = window.Function;
        window.Function = function (...args) {
            const codigo = args[args.length - 1] || "";
            if (
                codigo.includes("switchRelevancia") &&
                codigo.includes("substring")
            ) {
                logCritical(
                    "🚨 FUNÇÃO PROBLEMÁTICA DETECTADA VIA Function():",
                    codigo.substring(0, 200)
                );
                // Retornar nossa função segura em vez da problemática
                return function (idEvento, relevancia, tipo, urlAjax) {
                    if (codigo.includes("switchRelevanciaEvento")) {
                        return switchRelevanciaEventoUltraSegura(
                            idEvento,
                            relevancia,
                            tipo,
                            urlAjax
                        );
                    } else {
                        return switchRelevanciaDocumentoUltraSegura(
                            idEvento,
                            relevancia,
                            tipo,
                            urlAjax
                        );
                    }
                };
            }
            return originalFunction.apply(this, args);
        };
    };

    // DESABILITADO: Não monitorar definições de funções para switchRelevanciaEvento
    // monitorarDefinicoesFuncoes();

    // 🕷️ INTERCEPTAÇÃO DE SCRIPT TAGS - Última linha de defesa
    const observarScripts = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === "childList") {
                mutation.addedNodes.forEach((node) => {
                    if (node.tagName === "SCRIPT" && node.textContent) {
                        const conteudo = node.textContent;
                        if (
                            conteudo.includes("switchRelevancia") &&
                            conteudo.includes("substring")
                        ) {
                            logCritical(
                                "🚨 SCRIPT PROBLEMÁTICO DETECTADO E REMOVIDO!"
                            );
                            node.remove();
                        }
                    }
                });
            }
        });
    });

    // 🎯 INTERCEPTAÇÃO ULTRA-AGRESSIVA - Monitorar TODA criação de propriedade no window
    const monitorarPropriedadesWindow = () => {
        const todasPropriedades = Object.getOwnPropertyNames(window);

        const verificarNovasPropriedades = () => {
            try {
                const novasPropriedades = Object.getOwnPropertyNames(window);
                const adicionadas = novasPropriedades.filter(
                    (prop) => !todasPropriedades.includes(prop)
                );

                adicionadas.forEach((prop) => {
                    if (
                        prop.includes("switchRelevancia") &&
                        typeof window[prop] === "function"
                    ) {
                        const funcaoString = window[prop].toString();
                        if (funcaoString.includes("substring")) {
                            logCritical(
                                `🚨 FUNÇÃO PROBLEMÁTICA DETECTADA DINAMICAMENTE: ${prop}`
                            );

                            // DESABILITADO: Não substituir switchRelevanciaEvento
                            if (prop.includes("Evento")) {
                                // NÃO substituir - deixar função original funcionar
                                logCritical(
                                    `⚠️ ${prop} detectada, mas NÃO substituída para preservar funcionalidade`
                                );
                            } else {
                                window[prop] =
                                    switchRelevanciaDocumentoUltraSegura;
                                logCritical(
                                    `✅ ${prop} substituída por versão segura!`
                                );
                            }
                        }
                    }
                    todasPropriedades.push(prop);
                });
            } catch (error) {
                // Ignorar erros de acesso a propriedades
            }
        };

        // Verificar a cada 50ms inicialmente (mais agressivo)
        const intervaloRapido = setInterval(verificarNovasPropriedades, 50);

        // Depois de 5 segundos, reduzir para 200ms
        setTimeout(() => {
            clearInterval(intervaloRapido);
            setInterval(verificarNovasPropriedades, 200);
        }, 5000);
    };

    // DESABILITADO: Não monitorar propriedades para switchRelevanciaEvento
    // monitorarPropriedadesWindow();

    logCritical(
        "🔒 INTERCEPTAÇÃO ATIVADA: switchRelevanciaDocumento protegida (switchRelevanciaEvento REMOVIDA)!"
    );
    logCritical(
        "✅ switchRelevanciaDocumento substituída:",
        typeof window.switchRelevanciaDocumento
    );
    // REMOVIDO: verificação de switchRelevanciaEvento

    // Testar apenas switchRelevanciaDocumento
    setTimeout(() => {
        logCritical("🧪 TESTE IMEDIATO DA INTERCEPTAÇÃO DE DOCUMENTO:");
        logCritical(
            "  - switchRelevanciaDocumento existe:",
            typeof window.switchRelevanciaDocumento === "function"
        );
        logCritical(
            "  - switchRelevanciaDocumento é nossa:",
            window.switchRelevanciaDocumento &&
                window.switchRelevanciaDocumento
                    .toString()
                    .includes("ULTRA-SEGURA")
        );
        // REMOVIDO: testes de switchRelevanciaEvento
        logCritical(
            "  - Tentativas bloqueadas (Documento):",
            tentativasRedefinicao
        );
        // COMENTADO: Tentativas de evento (variável não existe mais)
        // logCritical(
        //     "  - Tentativas bloqueadas (Evento):",
        //     tentativasRedefinicaoEvento
        // );

        // 🔍 VERIFICAÇÃO ADICIONAL - Detectar funções problemáticas que podem ter escapado
        setTimeout(() => {
            logCritical(
                "🔍 VERIFICAÇÃO FINAL - Buscando funções problemáticas..."
            );

            // Verificar se há funções problemáticas no window
            for (const prop in window) {
                try {
                    if (
                        typeof window[prop] === "function" &&
                        window[prop].toString().includes("substring") &&
                        prop.includes("switchRelevancia")
                    ) {
                        logCritical(
                            `🚨 FUNÇÃO PROBLEMÁTICA ENCONTRADA: ${prop}`
                        );
                        logCritical("🔧 Substituindo por versão segura...");

                        if (prop.includes("Evento")) {
                            // DESABILITADO: Não substituir switchRelevanciaEvento
                            logCritical(
                                `⚠️ ${prop} detectada, mas NÃO substituída - preservando funcionalidade original`
                            );
                        } else {
                            window[prop] = switchRelevanciaDocumentoUltraSegura;
                        }

                        logCritical(`✅ ${prop} substituída com sucesso!`);
                    }
                } catch (e) {
                    // Ignorar erros de acesso a propriedades
                }
            }
        }, 100);
    }, 10);
})();

// ===== PERSONALIZAÇÃO VISUAL DAS ESTRELAS - SEM INTERFERIR NAS FUNÇÕES =====
(function personalizarEstrelasEventos() {
    logCritical(
        "🎨 PERSONALIZAÇÃO: Iniciando customização das estrelas de eventos..."
    );

    function aplicarPersonalizacaoEstrelas() {
        try {
            // Buscar fieldset de eventos especificamente
            const fieldsetEventos = document.querySelector(
                'fieldset.infraFieldset[aria-label="Eventos"]'
            );
            if (!fieldsetEventos) {
                log(
                    "⚠️ Fieldset de eventos não encontrado ainda, tentando novamente..."
                );
                return false;
            }

            logCritical("✅ FIELDSET: Fieldset de eventos encontrado");

            // DESABILITADO: Personalização de estrelas para não interferir na funcionalidade do eProc
            logCritical(
                "⚠️ PERSONALIZAÇÃO: Desabilitada para preservar funcionalidade das estrelas do eProc"
            );
            return true; // Retornar sucesso sem fazer modificações
        } catch (error) {
            logError("❌ Erro na personalização das estrelas:", error);
            return false;
        }
    }

    // Tentar aplicar personalização quando DOM estiver pronto
    let tentativas = 0;
    const maxTentativas = 10;

    function tentarPersonalizar() {
        if (aplicarPersonalizacaoEstrelas() || tentativas >= maxTentativas) {
            if (tentativas >= maxTentativas) {
                logCritical("⚠️ PERSONALIZAÇÃO: Limite de tentativas atingido");
            }
            return;
        }

        tentativas++;
        setTimeout(tentarPersonalizar, 1000);
    }

    // Executar quando DOM estiver pronto
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", tentarPersonalizar);
    } else {
        setTimeout(tentarPersonalizar, 500);
    }
})();

// ===== APLICAÇÃO INSTANTÂNEA DA NAVBAR - ANTES DE QUALQUER FLASH =====
(function aplicarNavbarInstantaneo() {
    // CSS da navbar aplicado IMEDIATAMENTE ao carregar o arquivo
    // Detectar domínio para tema padrão
    const currentUrl = window.location.href;
    let temaDefault = "blue"; // tema padrão geral

    if (currentUrl.includes("eproc2g.tjsc.jus.br")) {
        temaDefault = "green"; // Verde para eproc2g
    } else if (currentUrl.includes("eproc1g.tjsc.jus.br")) {
        temaDefault = "blue"; // Azul para eproc1g
    }

    const temaLocalStorage = localStorage.getItem("eprobe_selected_theme");
    const tema = temaLocalStorage || temaDefault;

    const gradientes = {
        blue: "linear-gradient(to left, #0d1c2c, #007ebd)",
        dark: "linear-gradient(to left, #1a1a1a, #696363)",
        light: "linear-gradient(to left, #94A3B8, #475569)",
        violet: "linear-gradient(to left, #6b46c1, #4c1d95)",
        green: "linear-gradient(to left, #17a394, #0c4f5c)",
    };
    const gradiente = gradientes[tema];

    const cssNavbarImediato = document.createElement("style");
    cssNavbarImediato.id = "eprobe-navbar-instant-immediate";
    cssNavbarImediato.textContent = `
        /* NAVBAR APLICADA IMEDIATAMENTE NO CARREGAMENTO DO SCRIPT */
        #navbar.navbar.bg-instancia,
        .navbar.bg-instancia,
        nav.navbar.bg-instancia,
        .navbar.text-white.bg-instancia,
        .navbar.text-white.d-xl-flex.bg-instancia {
            background-image: ${gradiente} !important;
            display: flex !important;
            align-items: center !important;
            min-height: 50px !important;
            opacity: 1 !important;
            visibility: visible !important;
            transition: none !important; /* Sem transições para evitar flash */
        }
        
        #navbar.navbar.bg-instancia > *,
        .navbar.bg-instancia > *,
        nav.navbar.bg-instancia > * {
            display: flex !important; 
            align-items: center !important;
            min-height: 50px !important;
        }
        
        /* 🎯 REGRA CRÍTICA OBRIGATÓRIA: .d-none.d-md-flex SEMPRE FLEX */
        .d-none.d-md-flex,
        div.d-none.d-md-flex,
        .navbar .d-none.d-md-flex,
        #navbar .d-none.d-md-flex {
            display: flex !important;
            align-items: center !important;
        }
    `;

    // APLICAÇÃO MAIS ROBUSTA E IMEDIATA
    const aplicarCSS = () => {
        // Remover CSS anterior se existir
        const cssAnterior = document.getElementById(
            "eprobe-navbar-instant-immediate"
        );
        if (cssAnterior) {
            cssAnterior.remove();
        }

        const head =
            document.head ||
            document.getElementsByTagName("head")[0] ||
            document.documentElement;
        if (head) {
            head.insertBefore(cssNavbarImediato, head.firstChild);
            console.log(
                `⚡ NAVBAR IMEDIATO: Tema ${tema} aplicado instantaneamente`
            );
            return true;
        }
        return false;
    };

    // Aplicar imediatamente se possível
    if (!aplicarCSS()) {
        // Se falhou, tentar novamente em intervalos mínimos
        const tentativas = 5;
        let tentativa = 0;

        const intervalo = setInterval(() => {
            if (aplicarCSS() || tentativa >= tentativas) {
                clearInterval(intervalo);
            }
            tentativa++;
        }, 1);
    }

    // Listener para mudanças de tema em tempo real
    window.addEventListener("storage", (e) => {
        if (e.key === "eprobe_selected_theme") {
            // Atualizar tema e reaplicar CSS
            const novoTema = e.newValue || "blue";
            const gradientes = {
                blue: "linear-gradient(to left, #0d1c2c, #007ebd)",
                dark: "linear-gradient(to left, #1a1a1a, #696363)",
                light: "linear-gradient(to left, #94A3B8, #475569)",
                violet: "linear-gradient(to left, #6b46c1, #4c1d95)",
                green: "linear-gradient(to left, #17a394, #0c4f5c)",
            };
            const novoGradiente = gradientes[novoTema];

            // Atualizar CSS instantaneamente
            const cssExistente = document.getElementById(
                "eprobe-navbar-instant-immediate"
            );
            if (cssExistente) {
                cssExistente.textContent = cssExistente.textContent.replace(
                    /background-image: [^;]+/g,
                    `background-image: ${novoGradiente}`
                );
                console.log(
                    `⚡ NAVBAR: Tema atualizado para ${novoTema} instantaneamente`
                );
            }
        }
    });

    // Listener para evento customizado de mudança de tema
    window.addEventListener("eprobe-theme-changed", (e) => {
        const { theme, gradient } = e.detail;

        // Forçar aplicação imediata nos elementos da navbar
        const navbarElements = document.querySelectorAll(
            "#navbar.navbar.bg-instancia, .navbar.bg-instancia, nav.navbar.bg-instancia"
        );

        navbarElements.forEach((navbar) => {
            navbar.style.setProperty("background-image", gradient, "important");
        });

        console.log(`⚡ NAVBAR: Evento customizado aplicou tema ${theme}`);
    });
})();

// ===== SISTEMA ANTI-FLASH UNIFICADO - SIMPLES E EFICIENTE =====
(function sistemaAntiFlashUnificado() {
    // Função única para aplicar personalizações sem flash
    window.eprobeAntiFlash = {
        aplicado: false,

        // Aplicar CSS crítico uma única vez
        aplicarCSS: function () {
            if (this.aplicado) return;

            // CSS já está no ultraAntiFlash acima - apenas marcar como aplicado
            this.aplicado = true;
            console.log("✅ ANTI-FLASH UNIFICADO: Sistema ativado");
        },

        // DESABILITADO: Revelar ícone personalizado (pode interferir com IDs do eProc)
        revelarIcone: function (elemento) {
            // DESABILITADO: Não modificar elementos para preservar funcionalidade do eProc
            /*
            if (elemento && elemento.tagName) {
                elemento.setAttribute("data-eprobe-icon-replaced", "true");
                elemento.style.setProperty(
                    "display",
                    "inline-block",
                    "important"
                );
                elemento.style.setProperty("opacity", "1", "important");
                elemento.style.setProperty(
                    "visibility",
                    "visible",
                    "important"
                );
            }
            */
            // FUNÇÃO DESABILITADA
        },

        // DESABILITADO: Ocultar ícone original (pode interferir com IDs do eProc)
        ocultarIcone: function (elemento) {
            // DESABILITADO: Não modificar elementos para preservar funcionalidade do eProc
            /*
            if (
                elemento &&
                elemento.classList &&
                elemento.classList.contains("material-icons")
            ) {
                elemento.style.setProperty("display", "none", "important");
                elemento.style.setProperty("opacity", "0", "important");
                elemento.style.setProperty("visibility", "hidden", "important");
            }
            */
            // FUNÇÃO DESABILITADA
        },

        // ⚡ NOVO: Revelar elemento personalizado (navbar, botões, etc.)
        revelarElemento: function (elemento) {
            if (elemento && elemento.tagName) {
                elemento.setAttribute("data-eprobe-processed", "true");
                elemento.style.setProperty("opacity", "1", "important");
                elemento.style.setProperty(
                    "visibility",
                    "visible",
                    "important"
                );
                elemento.style.removeProperty("transition");
            }
        },

        // ⚡ NOVO: Ocultar elemento temporariamente
        ocultarElemento: function (elemento) {
            if (elemento && elemento.tagName) {
                elemento.style.setProperty("opacity", "0.5", "important");
                elemento.style.setProperty("transition", "none", "important");
            }
        },

        // ⚡ NOVO: Aplicar anti-flash a navbar
        stabilizarNavbar: function () {
            const navbars = document.querySelectorAll(
                ".navbar, #navbar, .navbar-nav, .navbar-collapse"
            );
            navbars.forEach((navbar) => {
                navbar.style.setProperty("transition", "none", "important");
                navbar.style.setProperty("will-change", "auto", "important");
                navbar.style.setProperty(
                    "backface-visibility",
                    "hidden",
                    "important"
                );
                navbar.style.setProperty(
                    "transform",
                    "translateZ(0)",
                    "important"
                );
            });
        },

        // ⚡ NOVO: Aplicar anti-flash a botões
        stabilizarBotoes: function () {
            const botoes = document.querySelectorAll(
                '.btn, button, .botaoLerMais, input[type="button"], input[type="submit"]'
            );
            botoes.forEach((botao) => {
                botao.style.setProperty("transition", "none", "important");
                botao.style.setProperty("will-change", "auto", "important");
            });
        },

        // ⚡ NOVO: Detectar página de processo e marcar body
        detectarPaginaProcesso: function () {
            const url = window.location.href;
            const isPaginaProcesso =
                url.includes("consultar_processo") ||
                url.includes("processo_selecionar") ||
                url.includes("acessar_documento") ||
                document.querySelector("#legMinutas") ||
                document.querySelector(".infraFieldset") ||
                document.querySelector('a[aria-label*="Lembrete"]');

            if (isPaginaProcesso) {
                document.body.setAttribute("data-eprobe-processo-page", "true");
                console.log(
                    "🎯 PÁGINA DE PROCESSO DETECTADA: Anti-flash aplicado"
                );
                return true;
            } else {
                document.body.removeAttribute("data-eprobe-processo-page");
                console.log(
                    "📄 Página não é de processo: Ícones normais preservados"
                );
                return false;
            }
        },

        // ⚡ NOVO: Anti-flash total
        aplicarAntiFlashTotal: function () {
            // Detectar página de processo primeiro
            const isPaginaProcesso = this.detectarPaginaProcesso();

            if (isPaginaProcesso) {
                this.aplicarCSS();
                this.stabilizarNavbar();
                this.stabilizarBotoes();

                // Forçar estabilidade visual geral apenas em páginas de processo
                document.documentElement.style.setProperty(
                    "backface-visibility",
                    "hidden",
                    "important"
                );

                console.log(
                    "🚀 ANTI-FLASH TOTAL: Aplicado apenas em página de processo"
                );
            } else {
                console.log(
                    "⏸️ ANTI-FLASH: Não aplicado - página não é de processo"
                );
            }
        },
    };

    // Aplicar anti-flash total imediatamente
    window.eprobeAntiFlash.aplicarAntiFlashTotal();
})();

// ===== INTERCEPTAÇÃO PRECOCE DE FLASH - APLICAR ANTES DO DOM =====
(function antiFlashPrecoce() {
    // Executar no momento mais precoce possível
    const aplicarAntiFlashImediato = () => {
        // Verificar se é página de processo antes de aplicar
        const url = window.location.href;
        const isPaginaProcesso =
            url.includes("consultar_processo") ||
            url.includes("processo_selecionar") ||
            url.includes("acessar_documento");

        // Só aplicar anti-flash se for página de processo
        if (!isPaginaProcesso) {
            console.log(
                "📄 Página não é de processo: Anti-flash precoce não aplicado"
            );
            return;
        }

        console.log(
            "🎯 Página de processo detectada: Aplicando anti-flash precoce"
        );

        // 1. Ocultar elementos que podem causar flash APENAS em páginas de processo
        const style = document.createElement("style");
        style.id = "eprobe-precoce-anti-flash";
        style.textContent = `
            /* ANTI-FLASH PRECOCE - REMOVER regras problemáticas */
            
            .navbar, #navbar, .navbar-nav { 
                transition: none !important; 
                backface-visibility: hidden !important; 
            }
            
            .btn, button, .botaoLerMais { 
                transition: none !important; 
                will-change: auto !important; 
            }
            
            * { 
                backface-visibility: hidden !important; 
            }
        `;

        // Inserir no head como primeiro elemento
        if (document.head) {
            document.head.insertBefore(style, document.head.firstChild);
        } else {
            document.documentElement.appendChild(style);
        }
    };

    // Aplicar imediatamente se DOM já existir
    if (document.documentElement) {
        aplicarAntiFlashImediato();
    }

    // Também aplicar quando DOM for criado
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", aplicarAntiFlashImediato);
    }
})();

// ===== ULTRA ANTI-FLASH - EXECUÇÃO IMEDIATA ANTES DE QUALQUER RENDERIZAÇÃO =====
(function ultraAntiFlash() {
    // Executar IMEDIATAMENTE - antes mesmo do DOM começar
    const iniciarUltraAntiFlash = () => {
        log("⚡ ULTRA ANTI-FLASH: Interceptando renderização...");

        // 1. CSS CRÍTICO INLINE - Aplicado instantaneamente ANTES da renderização
        const cssUltraCritico = document.createElement("style");
        cssUltraCritico.setAttribute("data-eprobe-ultra-critical", "true");
        cssUltraCritico.textContent = `
            /* ===== ULTRA ANTI-FLASH CRITICAL STYLES ===== */
            
            /* Preparação instantânea do body */
            body {
                visibility: visible !important;
                opacity: 1 !important;
                transition: none !important;
            }
            
            /* INTERCEPTAÇÃO TOTAL: Divs de lembrete - estilos aplicados ANTES da renderização */
            div.divLembrete[style*="background-color:#efef8f"],
            div.divLembrete[style*="background-color: #efef8f"],
            div[style*="background-color:#efef8f"]:not([data-eprobe-processed]) {
                background: linear-gradient(#F9EFAF, #F7E98D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            div.divLembrete[style*="background-color:#efef8f"]:hover,
            div.divLembrete[style*="background-color: #efef8f"]:hover,
            div[style*="background-color:#efef8f"]:not([data-eprobe-processed]):hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            div.divLembrete[style*="background-color:#efef8f"]:focus,
            div.divLembrete[style*="background-color: #efef8f"]:focus,
            div[style*="background-color:#efef8f"]:not([data-eprobe-processed]):focus {
                box-shadow: 0 5px 12px !important;
            }
            
            div.divLembrete[style*="background-color:#db8080"],
            div.divLembrete[style*="background-color: #db8080"],
            div[style*="background-color:#db8080"]:not([data-eprobe-processed]) {
                background: linear-gradient(#FAAFAF, #F78D8D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            div.divLembrete[style*="background-color:#db8080"]:hover,
            div.divLembrete[style*="background-color: #db8080"]:hover,
            div[style*="background-color:#db8080"]:not([data-eprobe-processed]):hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            div.divLembrete[style*="background-color:#db8080"]:focus,
            div.divLembrete[style*="background-color: #db8080"]:focus,
            div[style*="background-color:#db8080"]:not([data-eprobe-processed]):focus {
                box-shadow: 0 5px 12px !important;
            }
            
            div.divLembrete[style*="background-color:#87adcd"],
            div.divLembrete[style*="background-color: #87adcd"],
            div[style*="background-color:#87adcd"]:not([data-eprobe-processed]) {
                background: linear-gradient(#AFCFFA, #8DC0F7) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            div.divLembrete[style*="background-color:#87adcd"]:hover,
            div.divLembrete[style*="background-color: #87adcd"]:hover,
            div[style*="background-color:#87adcd"]:not([data-eprobe-processed]):hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            div.divLembrete[style*="background-color:#87adcd"]:focus,
            div.divLembrete[style*="background-color: #87adcd"]:focus,
            div[style*="background-color:#87adcd"]:not([data-eprobe-processed]):focus {
                box-shadow: 0 5px 12px !important;
            }
            
            div.divLembrete[style*="background-color:#a7eda7"],
            div.divLembrete[style*="background-color: #a7eda7"],
            div[style*="background-color:#a7eda7"]:not([data-eprobe-processed]) {
                background: linear-gradient(#AFFAB6, #8DF792) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            div.divLembrete[style*="background-color:#a7eda7"]:hover,
            div.divLembrete[style*="background-color: #a7eda7"]:hover,
            div[style*="background-color:#a7eda7"]:not([data-eprobe-processed]):hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            div.divLembrete[style*="background-color:#a7eda7"]:focus,
            div.divLembrete[style*="background-color: #a7eda7"]:focus,
            div[style*="background-color:#a7eda7"]:not([data-eprobe-processed]):focus {
                box-shadow: 0 5px 12px !important;
            }
            
            div.divLembrete[style*="background-color:#f5b574"],
            div.divLembrete[style*="background-color: #f5b574"],
            div[style*="background-color:#f5b574"]:not([data-eprobe-processed]) {
                background: linear-gradient(#FAD3AF, #F7C68D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            div.divLembrete[style*="background-color:#f5b574"]:hover,
            div.divLembrete[style*="background-color: #f5b574"]:hover,
            div[style*="background-color:#f5b574"]:not([data-eprobe-processed]):hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            div.divLembrete[style*="background-color:#f5b574"]:focus,
            div.divLembrete[style*="background-color: #f5b574"]:focus,
            div[style*="background-color:#f5b574"]:not([data-eprobe-processed]):focus {
                box-shadow: 0 5px 12px !important;
            }
            
            /* INTERCEPTAÇÃO DE ELEMENTOS LISTA: Para estruturas .lista-lembretes */
            .lista-lembretes .lembrete[style*="background-color:#efef8f"],
            .lista-lembretes .lembrete[style*="background-color: #efef8f"] {
                background: linear-gradient(#F9EFAF, #F7E98D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#efef8f"]:hover,
            .lista-lembretes .lembrete[style*="background-color: #efef8f"]:hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#efef8f"]:focus,
            .lista-lembretes .lembrete[style*="background-color: #efef8f"]:focus {
                box-shadow: 0 5px 12px !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#db8080"],
            .lista-lembretes .lembrete[style*="background-color: #db8080"] {
                background: linear-gradient(#FAAFAF, #F78D8D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#db8080"]:hover,
            .lista-lembretes .lembrete[style*="background-color: #db8080"]:hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#db8080"]:focus,
            .lista-lembretes .lembrete[style*="background-color: #db8080"]:focus {
                box-shadow: 0 5px 12px !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#87adcd"],
            .lista-lembretes .lembrete[style*="background-color: #87adcd"] {
                background: linear-gradient(#AFCFFA, #8DC0F7) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#87adcd"]:hover,
            .lista-lembretes .lembrete[style*="background-color: #87adcd"]:hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#87adcd"]:focus,
            .lista-lembretes .lembrete[style*="background-color: #87adcd"]:focus {
                box-shadow: 0 5px 12px !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#a7eda7"],
            .lista-lembretes .lembrete[style*="background-color: #a7eda7"] {
                background: linear-gradient(#AFFAB6, #8DF792) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#a7eda7"]:hover,
            .lista-lembretes .lembrete[style*="background-color: #a7eda7"]:hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#a7eda7"]:focus,
            .lista-lembretes .lembrete[style*="background-color: #a7eda7"]:focus {
                box-shadow: 0 5px 12px !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#f5b574"],
            .lista-lembretes .lembrete[style*="background-color: #f5b574"] {
                background: linear-gradient(#FAD3AF, #F7C68D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#f5b574"]:hover,
            .lista-lembretes .lembrete[style*="background-color: #f5b574"]:hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#f5b574"]:focus,
            .lista-lembretes .lembrete[style*="background-color: #f5b574"]:focus {
                box-shadow: 0 5px 12px !important;
            }
            
            /* Spacing fixes para lembretes - aplicados instantaneamente */
            .divLembretePara, .lblLembretePara {
                margin-bottom: 15px !important;
                justify-content: space-around !important;
                font-size: small !important;
                -webkit-font-smoothing: antialiased !important;
            }
            
            .divLembreteData, .lblLembreteData {
                /* margin-top removido - sem mais forçar margem superior */
            }
            
            /* Novos estilos para classes do eProc */
            .desLembrete {
                margin: 15px 15px 15px 15px !important;
                align-items: baseline !important;
            }
            
            .divLembretePara {
                justify-content: space-around !important;
                font-size: small !important;
                -webkit-font-smoothing: antialiased !important;
            }
            
            /* INTERCEPTAÇÃO TOTAL: Botões de ler mais - ocultar ANTES da renderização */
            div.botaoLerMais:not([data-eprobe-expandir-replaced]):not([data-eprobe-processed]) {
                visibility: hidden !important;
                opacity: 0 !important;
                position: absolute !important;
                left: -9999px !important;
                pointer-events: none !important;
                margin-bottom: inherit !important;
            }
            
            /* Botões marcados para substituição - ocultar completamente */
            div.botaoLerMais[data-eprobe-will-replace="true"] {
                display: none !important;
                visibility: hidden !important;
            }
            
            /* Elementos eProbe - garantir visibilidade imediata */
            [id*="eprobe"], [class*="eprobe"], [data-eprobe-expandir-replaced] {
                visibility: visible !important;
                opacity: 1 !important;
                position: static !important;
                pointer-events: auto !important;
            }
            
            /* Navbar preparação - evitar interferência */
            .navbar, #navbar, .infraBarraComandos {
                align-items: center !important;
            }
            
            /* NAVBAR ANTI-FLASH INSTANTÂNEO */
            #navbar.navbar.bg-instancia,
            .navbar.bg-instancia,
            nav.navbar.bg-instancia,
            .navbar.text-white.bg-instancia,
            .navbar.text-white.d-xl-flex.bg-instancia {
                display: flex !important;
                align-items: center !important;
                min-height: 50px !important;
            }
            
            /* Alinhamento instantâneo dos elementos internos da navbar */
            #navbar.navbar.bg-instancia > *,
            .navbar.bg-instancia > *,
            nav.navbar.bg-instancia > * {
                display: flex !important; 
                align-items: center !important;
                min-height: 50px !important;
            }
            
            /* ANTI-FLASH UNIVERSAL: Prevenir qualquer transição visível */
            .divLembrete, .lista-lembretes .lembrete {
                will-change: auto !important;
                backface-visibility: hidden !important;
                transform: translateZ(0) !important;
            }
            
            /* 🎯 REGRA CRÍTICA OBRIGATÓRIA: .d-none.d-md-flex SEMPRE FLEX - ULTRA PRIORITÁRIO */
            .d-none.d-md-flex,
            div.d-none.d-md-flex,
            .navbar .d-none.d-md-flex,
            #navbar .d-none.d-md-flex,
            .navbar-nav .d-none.d-md-flex,
            .navbar-collapse .d-none.d-md-flex {
                display: flex !important;
                align-items: center !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            /* ===== SISTEMA ANTI-FLASH ESPECÍFICO PARA PÁGINAS DE PROCESSO ===== */
            
            /* NOVA ABORDAGEM: APENAS ocultar ícones em div.divLembrete */
            .divLembrete .material-icons:not([data-eprobe-icon-replaced="true"]),
            .lista-lembretes .lembrete .material-icons:not([data-eprobe-icon-replaced="true"]) {
                display: none !important;
            }
            
            /* GARANTIR: Apenas ícones específicos do eProbe permanecem visíveis */
            .material-icons[data-eprobe-icon],
            .eprobe-icon .material-icons,
            [data-eprobe-container] .material-icons {
                display: inline-block !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            /* ===== ANTI-FLASH TOTAL PARA TODOS OS ELEMENTOS ===== */
            
            /* NAVBAR: Evitar flash da barra de navegação */
            .navbar,
            #navbar,
            .navbar-nav,
            .navbar-collapse,
            .navbar-brand {
                transition: none !important;
                will-change: auto !important;
                backface-visibility: hidden !important;
                transform: translateZ(0) !important;
            }
            
            /* BOTÕES: Evitar flash de botões que serão customizados */
            .botaoLerMais,
            .btn,
            button,
            input[type="button"],
            input[type="submit"] {
                transition: none !important;
                will-change: auto !important;
            }
            
            /* BOTÕES ESPECÍFICOS: Ocultar botões que serão substituídos */
            .botaoLerMais:not([data-eprobe-processed]) {
                opacity: 0.8 !important;
                transition: none !important;
            }
            
            /* ELEMENTOS EPROBE: Revelar apenas elementos processados */
            [data-eprobe-processed],
            [data-eprobe-personalized],
            .eprobe-custom-element {
                opacity: 1 !important;
                visibility: visible !important;
                transition: opacity 0.2s ease !important;
            }
            
          
            /* ESPECÍFICO: Elementos do eProc que causam flash */
            .infraFieldset,
            .infraLegendObrigatorio,
            #divInfraAreaGlobal {
                transition: none !important;
            }
        `;

        // Inserir no head IMEDIATAMENTE
        if (document.head) {
            document.head.insertBefore(
                cssUltraCritico,
                document.head.firstChild
            );
        } else {
            // Se head não existe ainda, criar e inserir
            const head = document.createElement("head");
            head.appendChild(cssUltraCritico);
            if (document.documentElement) {
                document.documentElement.insertBefore(
                    head,
                    document.documentElement.firstChild
                );
            }
        }

        log("✅ ULTRA ANTI-FLASH: CSS crítico aplicado instantaneamente");

        // 2. MARCAR BOTÕES QUE SERÃO SUBSTITUÍDOS - Antes da renderização
        const marcarBotoesParaSubstituicao = () => {
            const botoesLerMais = document.querySelectorAll(
                "div.botaoLerMais:not([data-eprobe-processed])"
            );
            botoesLerMais.forEach((botao) => {
                const texto = (botao.textContent || "").toLowerCase();
                if (
                    texto.includes("ler mais") ||
                    texto.includes("...ler mais")
                ) {
                    const lembreteParent = botao.closest(".divLembrete");
                    if (lembreteParent) {
                        const desLembrete =
                            lembreteParent.querySelector(".desLembrete");
                        if (desLembrete) {
                            const textoCompleto = desLembrete.textContent || "";
                            const temTextoTruncado =
                                textoCompleto.length > 150 ||
                                desLembrete.scrollHeight >
                                    desLembrete.clientHeight ||
                                textoCompleto.includes("...") ||
                                window.getComputedStyle(desLembrete)
                                    .textOverflow === "ellipsis";

                            if (temTextoTruncado) {
                                botao.setAttribute(
                                    "data-eprobe-will-replace",
                                    "true"
                                );
                                botao.style.display = "none";
                                botao.style.visibility = "hidden";
                            }
                        }
                    }
                }
                // Marcar como processado para evitar reprocessamento
                botao.setAttribute("data-eprobe-processed", "true");
            });
        };

        // FUNÇÃO ULTRA-OTIMIZADA: Marcar lembretes como processados instantaneamente
        const marcarLembretesComoProcessados = () => {
            const lembretes = document.querySelectorAll(
                'div.divLembrete:not([data-eprobe-processed]), .lista-lembretes .lembrete:not([data-eprobe-processed]), div[style*="background-color:#"]:not([data-eprobe-processed])'
            );

            lembretes.forEach((elemento) => {
                const style = elemento.getAttribute("style") || "";
                const coresLembrete = [
                    "#efef8f",
                    "#db8080",
                    "#87adcd",
                    "#a7eda7",
                    "#f5b574",
                ];

                // Verificar se é um lembrete colorido
                const isLembrete =
                    coresLembrete.some((cor) => style.includes(cor)) ||
                    elemento.classList.contains("divLembrete") ||
                    elemento.classList.contains("lembrete");

                if (isLembrete) {
                    elemento.setAttribute("data-eprobe-processed", "true");
                    elemento.classList.add("eprobe-lembrete-processado");
                }
            });
        };

        // 3. OBSERVADOR ULTRARRÁPIDO para elementos que aparecem
        const observadorUltraRapido = new MutationObserver((mutations) => {
            let needsUpdate = false;
            let newLembretes = [];

            mutations.forEach((mutation) => {
                if (mutation.type === "childList") {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) {
                            // Element node

                            // INTERCEPTAÇÃO INSTANTÂNEA: Aplicar estilos ANTES da renderização
                            if (node.classList?.contains("divLembrete")) {
                                // É um divLembrete direto
                                newLembretes.push(node);
                                needsUpdate = true;
                            } else if (node.querySelector?.(".divLembrete")) {
                                // Contém divLembrete dentro
                                const innerLembretes =
                                    node.querySelectorAll(".divLembrete");
                                newLembretes.push(
                                    ...Array.from(innerLembretes)
                                );
                                needsUpdate = true;
                            }

                            // Verificar também elementos com cores de fundo específicas
                            const coresLembrete = [
                                "#efef8f",
                                "#db8080",
                                "#87adcd",
                                "#a7eda7",
                                "#f5b574",
                            ];
                            coresLembrete.forEach((cor) => {
                                const style =
                                    node.style?.backgroundColor ||
                                    node.getAttribute?.("style") ||
                                    "";
                                if (style.includes(cor)) {
                                    newLembretes.push(node);
                                    needsUpdate = true;
                                }
                            });
                        }
                    });
                }
            });

            if (needsUpdate && newLembretes.length > 0) {
                // APLICAÇÃO INSTANTÂNEA: Processar novos lembretes IMEDIATAMENTE
                newLembretes.forEach((elemento) => {
                    if (
                        !elemento.classList.contains(
                            "eprobe-lembrete-processado"
                        )
                    ) {
                        // Detectar cor e aplicar estilo instantaneamente
                        const style = elemento.getAttribute("style") || "";
                        let gradiente = "";

                        if (style.includes("#efef8f")) {
                            gradiente = "linear-gradient(#F9EFAF, #F7E98D)";
                        } else if (style.includes("#db8080")) {
                            gradiente = "linear-gradient(#FAAFAF, #F78D8D)";
                        } else if (style.includes("#87adcd")) {
                            gradiente = "linear-gradient(#AFCFFA, #8DC0F7)";
                        } else if (style.includes("#a7eda7")) {
                            gradiente = "linear-gradient(#AFFAB6, #8DF792)";
                        } else if (style.includes("#f5b574")) {
                            gradiente = "linear-gradient(#FAD3AF, #F7C68D)";
                        }

                        if (gradiente) {
                            // Aplicar todos os estilos instantaneamente
                            elemento.style.setProperty(
                                "background",
                                gradiente,
                                "important"
                            );
                            elemento.style.setProperty(
                                "padding",
                                "20px",
                                "important"
                            );
                            elemento.style.setProperty(
                                "min-width",
                                "315px",
                                "important"
                            );
                            elemento.style.setProperty(
                                "min-height",
                                "140px",
                                "important"
                            );
                            elemento.style.setProperty(
                                "box-shadow",
                                "0 4px 6px rgba(0, 0, 0, 0.1)",
                                "important"
                            );
                            elemento.style.setProperty(
                                "transition",
                                "box-shadow 0.2s ease",
                                "important"
                            );
                            elemento.style.setProperty(
                                "-webkit-font-smoothing",
                                "subpixel-antialiased",
                                "important"
                            );
                            elemento.style.setProperty(
                                "visibility",
                                "visible",
                                "important"
                            );
                            elemento.style.setProperty(
                                "opacity",
                                "1",
                                "important"
                            );
                            elemento.classList.add(
                                "eprobe-lembrete-processado"
                            );
                        }
                    }
                });

                // Marcar botões para substituição também
                setTimeout(marcarBotoesParaSubstituicao, 0);
            }
        });

        // Iniciar observação imediata
        if (document.documentElement) {
            observadorUltraRapido.observe(document.documentElement, {
                childList: true,
                subtree: true,
            });
        }

        // 4. APLICAÇÃO INICIAL se já há elementos - ULTRA-OTIMIZADA
        setTimeout(() => {
            marcarBotoesParaSubstituicao();
            marcarLembretesComoProcessados();
        }, 0);

        // APLICAÇÃO SECUNDÁRIA para elementos que aparecem após inicialização
        setTimeout(() => {
            marcarBotoesParaSubstituicao();
            marcarLembretesComoProcessados();
        }, 50);

        log("⚡ ULTRA ANTI-FLASH: Sistema ativado - zero flash garantido");
    };

    // Executar IMEDIATAMENTE
    if (document.readyState === "loading") {
        // Ainda carregando - aplicar agora
        iniciarUltraAntiFlash();
    } else {
        // Já carregado - aplicar agora mesmo assim
        iniciarUltraAntiFlash();
    }
})();

// ===== APLICAÇÃO INSTANTÂNEA DE ESTILOS - ELIMINAR FLASH =====
(function aplicarEstilosInstantaneos() {
    log("⚡ INSTANT: Aplicando estilos críticos instantaneamente...");

    // CSS crítico aplicado IMEDIATAMENTE para eliminar flash
    const cssInstantaneo = document.createElement("style");
    cssInstantaneo.id = "eprobe-instant-styles";
    cssInstantaneo.textContent = `
        /* ===== ESTILOS INSTANTÂNEOS ANTI-FLASH ===== */
        
        /* Ocultar flash inicial com transição suave */
        body {
            transition: opacity 0.1s ease-in-out !important;
        }
        
        /* Preparar containers para elementos eProbe */
        .navbar, #navbar {
            display: flex !important; 
            align-items: center !important;
        }
        
        /* ANTI-FLASH NAVBAR INSTANTÂNEO */
        #navbar.navbar.bg-instancia,
        .navbar.bg-instancia,
        nav.navbar.bg-instancia {
            display: flex !important;
            align-items: center !important;
            min-height: 50px !important;
        }
        
        #navbar.navbar.bg-instancia > *,
        .navbar.bg-instancia > *,
        nav.navbar.bg-instancia > * {
            display: flex !important; 
            align-items: center !important;
            min-height: 50px !important;
            
        }
        
        /* Fontes críticas carregadas instantaneamente */
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@300;400;500;600;700&display=swap');
        
        /* 🎨 ALINHAMENTO PADRONIZADO DE ÍCONES SVG - eProbe */
        span[data-eprobe-icon-container] {
            display: inline-flex !important;
            align-items: center !important;
            vertical-align: middle !important;
            margin-right: 4px !important;
        }
        
        span[data-eprobe-icon-container] svg {
            flex-shrink: 0 !important;
            vertical-align: middle !important;
        }
        
        /* Alinhamento específico para ícones de ação */
        .iconeAcao,
        span:has(> svg.iconeAcao) {
            display: inline-flex !important;
            align-items: center !important;
            vertical-align: middle !important;
        }
        
        /* Cards de sessão unificados */
        .session-card {
            opacity: 1;
            transform: translateX(0);
        }
        
        /* Navbar sem animação */
        #eprobe-navbar-element {
            display: flex !important; 
            align-items: center !important;
            transition: all 0.3s ease !important;
        }
        
        /* Efeito hover na logo eProbe */
        #eprobe-navbar-element:hover {
            background-color: rgba(255, 255, 255, 0.2784313725) !important;
            border-radius: 5px !important;
        }
        
        /* Botões da extensão com transição suave */
        [id*="sent1"], [class*="eprobe"] {
            opacity: 0;
            animation: fadeInElement 0.5s ease-out 0.3s forwards;
        }
        
        @keyframes fadeInElement {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Tooltips preparados */
        .eprobe-tooltip {
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        
        /* ===== ESTILOS SVG FIGMA INSTANTÂNEOS ===== */
        .eprobe-figma-card-svg {
            display: inline-block;
            margin: 8px 0;
            position: relative;
            opacity: 0;
            animation: fadeInElement 0.5s ease-out 0.4s forwards;
        }
        
        .eprobe-figma-svg-container {
            position: relative;
            display: inline-block;
        }
        
        .eprobe-figma-svg-container svg {
            transition: all 0.2s ease;
            display: block;
        }
        
        .eprobe-figma-card-svg:hover .eprobe-figma-svg-container svg {
            transform: translateY(-1px);
            filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
        }
        
        .eprobe-figma-data-overlay {
            position: absolute;
            bottom: 12px;
            left: 24px;
            right: 24px;
            pointer-events: none;
            z-index: 10;
        }
        
        .eprobe-figma-data-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 11px;
            font-weight: 500;
            color: #1D1B20;
            opacity: 0.9;
            text-align: left;
            display: block;
            line-height: 1.2;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px 4px;
            border-radius: 4px;
            backdrop-filter: blur(4px);
        }
        
        /* ===== ELEMENTOS DE INTERFACE PREPARADOS ===== */
        #sent1-auto-button,
        .documento-relevante-button,
        .eprobe-button {
            opacity: 0;
            animation: fadeInElement 0.5s ease-out 0.3s forwards;
            margin-right: 3px !important;
        }
        
        /* ===== MODAL E NOTIFICAÇÕES PREPARADAS ===== */
        .eprobe-modal,
        .eprobe-notification {
            opacity: 0;
            animation: fadeInElement 0.3s ease-out forwards;
        }
        
        /* ===== ESTILOS PARA ESTRELAS PERSONALIZADAS (SEM INTERFERIR NA FUNCIONALIDADE) ===== */
        .eprobe-estrela-personalizada:hover {
            transform: scale(1.1) !important;
            filter: brightness(1.5) contrast(1.3) drop-shadow(0 0 3px gold) !important;
        }
        
        /* ===== ESTILOS PARA LEMBRETES ===== */
        .divLembretePara {
            margin-bottom: 15px !important;
            justify-content: space-around !important;
            font-size: small !important;
            -webkit-font-smoothing: antialiased !important;
        }
        
        /* 🎯 REGRA CRÍTICA OBRIGATÓRIA: .d-none.d-md-flex SEMPRE FLEX - INSTANTÂNEO */
        .d-none.d-md-flex,
        div.d-none.d-md-flex,
        .navbar .d-none.d-md-flex,
        #navbar .d-none.d-md-flex,
        .navbar-nav .d-none.d-md-flex,
        .navbar-collapse .d-none.d-md-flex {
            display: flex !important;
            align-items: center !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        /* Classe do eProc - desLembrete com novos estilos */
        .desLembrete {
            margin: 25px 25px 25px 25px !important;
            align-items: baseline !important;
        }
        
        /* Classe do eProc - divLembretePara com novos estilos */
        .divLembretePara {
            justify-content: space-around !important;
            font-size: small !important;
            -webkit-font-smoothing: antialiased !important;
        }
    `;

    // Inserir no head IMEDIATAMENTE - antes de qualquer outro script
    const head =
        document.head ||
        document.getElementsByTagName("head")[0] ||
        document.documentElement;
    if (head) {
        head.insertBefore(cssInstantaneo, head.firstChild);
        logCritical("✅ INSTANT: CSS crítico aplicado no topo do head");
    }

    // ===== FUNÇÃO OBRIGATÓRIA: FORÇAR FLEXBOX NA NAVBAR =====
    function forcarFlexboxNavbar() {
        // Aplicar estilos inline obrigatórios em todos os elementos .d-none.d-md-flex
        const elementosNavbar = document.querySelectorAll(".d-none.d-md-flex");
        elementosNavbar.forEach((elemento) => {
            elemento.style.setProperty("display", "flex", "important");
            elemento.style.setProperty("align-items", "center", "important");
            elemento.style.setProperty("visibility", "visible", "important");
            elemento.style.setProperty("opacity", "1", "important");
        });

        if (elementosNavbar.length > 0) {
            console.log(
                `🎯 NAVBAR OBRIGATÓRIO: Flexbox forçado em ${elementosNavbar.length} elementos`
            );
        }
    }

    // ===== OBSERVADOR CRÍTICO PARA NAVBAR - OTIMIZADO PARA PERFORMANCE =====
    const observadorNavbar = new MutationObserver(
        debounceGlobal((mutations) => {
            let needsUpdate = false;

            // 🚀 FILTRAR MUTATIONS RELEVANTES: Reduzir processamento
            const mutationsRelevantes = mutations.filter(
                (mutation) =>
                    mutation.type === "childList" &&
                    mutation.addedNodes.length > 0
            );

            if (mutationsRelevantes.length === 0) return;

            mutationsRelevantes.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === 1) {
                        // Element node
                        // Verificar se é um elemento .d-none.d-md-flex ou contém um
                        if (
                            node.classList?.contains("d-none") &&
                            node.classList?.contains("d-md-flex")
                        ) {
                            needsUpdate = true;
                        } else if (
                            node.querySelector &&
                            node.querySelector(".d-none.d-md-flex")
                        ) {
                            needsUpdate = true;
                        }

                        // Verificar se contém elementos .d-none.d-md-flex
                        const elementosNavbar =
                            node.querySelectorAll?.(".d-none.d-md-flex");
                        if (elementosNavbar && elementosNavbar.length > 0) {
                            needsUpdate = true;
                        }
                    }
                });
            });

            if (needsUpdate) {
                // Aplicar com pequeno delay para garantir que DOM esteja atualizado
                setTimeout(forcarFlexboxNavbar, 1);
            }
        }, PERFORMANCE_CONFIG.debounceDelay)
    );

    // Iniciar observação IMEDIATA COM CLEANUP AUTOMÁTICO
    if (document.body) {
        // 🚀 REGISTRAR NO SISTEMA DE CLEANUP
        CLEANUP_SYSTEM.addObserver(observadorNavbar);

        observadorNavbar.observe(document.body, {
            childList: true,
            subtree: false, // 🚀 OTIMIZAÇÃO: Reduzir escopo de observação
            attributes: false, // 🚀 OTIMIZAÇÃO: Desabilitar observação de atributos
        });

        // Aplicação inicial
        forcarFlexboxNavbar();

        console.log(
            "🔍 NAVBAR OBSERVER: Monitoramento de flexbox obrigatório ativado"
        );
    } else {
        // Se body ainda não existe, aplicar quando existir
        document.addEventListener("DOMContentLoaded", () => {
            observadorNavbar.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ["class", "style"],
            });
            forcarFlexboxNavbar();
            console.log(
                "🔍 NAVBAR OBSERVER: Monitoramento de flexbox obrigatório ativado (DOMContentLoaded)"
            );
        });
    }

    // ===== APLICAÇÃO ULTRA-RÁPIDA DE ELEMENTOS CRÍTICOS =====
    // Executar imediatamente após 1ms para garantir que DOM básico está pronto
    setTimeout(() => {
        try {
            // Navbar já está com CSS completo aplicado - apenas verificar
            const navbar =
                document.querySelector("#navbar.navbar.bg-instancia") ||
                document.querySelector(".navbar.bg-instancia") ||
                document.querySelector("nav.navbar.bg-instancia");

            if (navbar) {
                log(
                    "⚡ INSTANT: Navbar encontrada com CSS completo já aplicado"
                );
            }
        } catch (error) {
            console.warn("⚠️ INSTANT: Erro na verificação:", error);
        }
    }, 1);
})();

// ===== INTERCEPTAÇÃO ÚNICA E SILENCIOSA =====
(function interceptarEventListenersUnico() {
    "use strict";

    const nativeAddEventListener = EventTarget.prototype.addEventListener;

    // Eventos que devem ser passivos (SEM LOGS)
    const passiveEvents = [
        "scroll",
        "wheel",
        "touchstart",
        "touchmove",
        "touchend",
        "mouseenter",
        "mouseleave",
        "mouseover",
        "mouseout",
        "mousedown",
        "mouseup",
        "mousemove",
        "pointermove",
        "pointerdown",
        "pointerup",
        "pointerenter",
        "pointerleave",
        "focus",
        "blur",
        "input",
        "change",
        "select",
        "resize",
        "orientationchange",
        "contextmenu",
        "dragstart",
        "dragover",
        "drop",
        "keydown",
        "keyup",
        "load",
        "DOMContentLoaded",
    ];

    // Interceptação SILENCIOSA - elimina violações sem spam de logs
    EventTarget.prototype.addEventListener = function (
        type,
        listener,
        options
    ) {
        if (passiveEvents.includes(type)) {
            const newOptions =
                typeof options === "boolean"
                    ? { capture: options, passive: true }
                    : { ...(options || {}), passive: true };
            return nativeAddEventListener.call(
                this,
                type,
                listener,
                newOptions
            );
        }
        return nativeAddEventListener.call(this, type, listener, options);
    };
})();

(async function () {
    "use strict";

    // SISTEMA DE PROTEÇÃO ABSOLUTA - Garantir namespace independente de erros
    let namespaceCreated = false;
    let mainExecutionCompleted = false;

    // Função de emergência para criar namespace mínimo
    const garantirNamespace = () => {
        if (namespaceCreated || mainExecutionCompleted) return;

        try {
            console.log("🆘 EMERGÊNCIA: Criando namespace de fallback...");

            // Namespace mínimo mas funcional - APENAS SE NÃO EXISTIR
            if (typeof window.SENT1_AUTO === "undefined") {
                window.SENT1_AUTO = {
                    // Funções essenciais que sempre devem existir
                    detectarCardSessaoSimplificado: () => {
                        return detectarSessoesUnificado();
                    },
                    testarDeteccaoRobusta: () => {
                        console.log(
                            "🧪 TESTE: Função de emergência - sistema em modo degradado"
                        );
                    },
                    forcarFlexboxNavbar: () => {
                        const elementosNavbar =
                            document.querySelectorAll(".d-none.d-md-flex");
                        elementosNavbar.forEach((elemento) => {
                            elemento.style.setProperty(
                                "display",
                                "flex",
                                "important"
                            );
                            elemento.style.setProperty(
                                "align-items",
                                "center",
                                "important"
                            );
                            elemento.style.setProperty(
                                "visibility",
                                "visible",
                                "important"
                            );
                            elemento.style.setProperty(
                                "opacity",
                                "1",
                                "important"
                            );
                        });

                        if (elementosNavbar.length > 0) {
                            console.log(
                                `🎯 NAVBAR CRÍTICO: Flexbox forçado em ${elementosNavbar.length} elementos via namespace`
                            );
                        }
                        return elementosNavbar.length;
                    },

                    // Metadados de status
                    status: "namespace-emergencia",
                    versao: "1.0.0-emergencia",
                    erro: "Script principal não completou, usando namespace de emergência",
                    timestamp: new Date().toISOString(),
                    totalFuncoes: 5,
                };

                namespaceCreated = true;
                console.log(
                    "✅ EMERGÊNCIA: Namespace de fallback criado com",
                    Object.keys(window.SENT1_AUTO).length,
                    "propriedades"
                );
            } else {
                console.log(
                    "✅ EMERGÊNCIA: Namespace já existe, mantendo o atual"
                );
            }
        } catch (e) {
            console.error(
                "💥 CRÍTICO: Falha até mesmo no namespace de emergência:",
                e
            );
        }
    };

    // Timeout de segurança - criar namespace após 3 segundos se script não completar
    const timeoutSeguranca = setTimeout(garantirNamespace, 3000);

    // 🚨 VERIFICAÇÃO CRÍTICA - DETECTAR ERROS EARLY
    try {
        logCritical("🚀 IIFE: Iniciando execução da IIFE principal");

        // 🔍 DIAGNÓSTICO INICIAL
        logCritical("🔍 IIFE: Verificando ambiente...");
        logCritical("📍 URL:", window.location.href);
        logCritical("📄 DOM Ready:", document.readyState);
        logCritical("⏰ Timestamp:", new Date().toISOString());

        // 2.5. FUNÇÃO DEBOUNCE GLOBAL PARA PERFORMANCE
        window.debounce = (func, delay) => {
            let timeoutId;
            const debounced = function (...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(this, args), delay);
            };

            // Método para cancelar timeout pendente
            debounced.cancel = () => {
                clearTimeout(timeoutId);
                timeoutId = null;
            };

            return debounced;
        };

        // 🔧 AGUARDAR APIS DE EXTENSÃO (CORREÇÃO PARA EDGE)
        function aguardarAPIsExtensao() {
            return new Promise((resolve) => {
                if (typeof chrome !== "undefined" && chrome.runtime) {
                    log("✅ INIT: APIs de extensão já disponíveis");
                    resolve(true);
                    return;
                }

                let tentativas = 0;
                const maxTentativas = 50; // 5 segundos máximo

                function verificar() {
                    tentativas++;

                    if (typeof chrome !== "undefined" && chrome.runtime) {
                        log(
                            `✅ INIT: APIs disponíveis após ${
                                tentativas * 100
                            }ms`
                        );
                        resolve(true);
                        return;
                    }

                    if (tentativas >= maxTentativas) {
                        log(
                            "⚠️ INIT: Continuando sem APIs de extensão (pode afetar funcionalidades)"
                        );
                        resolve(false);
                        return;
                    }

                    setTimeout(verificar, 100);
                }

                verificar();
            });
        }

        // Aguardar APIs antes de continuar
        await aguardarAPIsExtensao();

        // ============================================================================
        // 🔍 FUNÇÕES AUXILIARES GLOBAIS - DEFINIDAS PRIMEIRO
        // ============================================================================

        /**
         * 🚀 SISTEMA UNIFICADO DE DETECÇÃO DE SESSÕES - ÚNICA IMPLEMENTAÇÃO
         * Consolida TODAS as funções de detecção, extração e tooltip em um só local
         * Remove redundâncias e conflitos entre funções duplicadas
         */

        // ========================================
        // 🎯 FUNÇÃO ÚNICA DE DETECÇÃO DE SESSÕES
        // ========================================

        function detectarSessoesUnificado(forcarDeteccao = false) {
            console.log(
                "🎯 DETECÇÃO UNIFICADA: Iniciando detecção única de sessões com nova estrutura DOM..."
            );

            // 🛡️ PROTEÇÃO ANTI-DUPLICAÇÃO ROBUSTA
            const processoAtual = obterNumeroProcesso();
            const chaveProtecao = `eprobe_deteccao_${processoAtual}`;

            // Verificar se já está em execução para este processo
            if (window[chaveProtecao] === "executando") {
                console.log(
                    "🚨 PROTEÇÃO: Detecção já em execução para este processo, ignorando chamada duplicada"
                );
                return null;
            }

            // Marcar como em execução
            if (!forcarDeteccao) {
                window[chaveProtecao] = "executando";
            }

            // 0. VERIFICAR SE JÁ TEMOS DADOS VÁLIDOS (anti-duplicação)
            if (
                !forcarDeteccao &&
                hasDataSessaoPautado() &&
                processoComDataSessao === processoAtual
            ) {
                console.log(
                    "✅ DETECÇÃO: Dados já existem para este processo, retornando cache"
                );

                // Marcar como concluído
                window[chaveProtecao] = "concluido";

                return {
                    sessaoPrincipal: dataSessaoPautado,
                    todasSessoes: [dataSessaoPautado],
                    totalSessoes: 1,
                    processo: processoAtual,
                    timestamp: Date.now(),
                };
            }

            // 1. Verificar página correta
            if (
                !window.location.href.includes(
                    "controlador.php?acao=processo_selecionar"
                )
            ) {
                console.log("❌ DETECÇÃO: Página incorreta");
                // Limpar proteção em caso de erro
                window[chaveProtecao] = "erro";
                return null;
            }

            // 2. NOVA ESTRUTURA: Buscar container principal de minutas
            const containerMinutas = document.querySelector("#conteudoMinutas");
            if (!containerMinutas) {
                console.log(
                    "❌ DETECÇÃO: Container #conteudoMinutas não encontrado"
                );
                // Limpar proteção em caso de erro
                window[chaveProtecao] = "erro";
                return null;
            }

            console.log("✅ DETECÇÃO: Container #conteudoMinutas encontrado");

            // 3. BUSCAR TODAS AS MINUTAS: div[id^="conteudoMinutas_"] exceto conteudoMinutas_0
            const minutasEncontradas = containerMinutas.querySelectorAll(
                'div[id^="conteudoMinutas_"]:not([id="conteudoMinutas_0"])'
            );

            if (minutasEncontradas.length === 0) {
                console.log("❌ DETECÇÃO: Nenhuma minuta encontrada");
                // Limpar proteção em caso de erro
                window[chaveProtecao] = "erro";
                return null;
            }

            console.log(
                `🔍 DETECÇÃO: ${minutasEncontradas.length} minutas encontradas`
            );

            // 4. PROCESSAR CADA MINUTA INDIVIDUALMENTE
            const sessoes = [];

            minutasEncontradas.forEach((minuta, index) => {
                const minutaId = minuta.id;
                console.log(`📋 PROCESSANDO MINUTA ${index + 1}: ${minutaId}`);

                // 5. NAVEGAR PARA O BOTÃO DE SESSÃO: fieldset#fldMinutas → legend → span#historico → button
                const fieldsetMinuta = minuta.querySelector(
                    "fieldset#fldMinutas"
                );
                if (!fieldsetMinuta) {
                    console.log(
                        `   ⚠️ MINUTA ${
                            index + 1
                        }: fieldset#fldMinutas não encontrado`
                    );
                    return;
                }

                const spanHistorico = fieldsetMinuta.querySelector(
                    "legend span#historico"
                );
                if (!spanHistorico) {
                    console.log(
                        `   ⚠️ MINUTA ${
                            index + 1
                        }: span#historico não encontrado`
                    );
                    return;
                }

                const botaoSessao = spanHistorico.querySelector(
                    "button[id^='legMinutasMaisMenos_']"
                );
                if (!botaoSessao) {
                    console.log(
                        `   ⚠️ MINUTA ${
                            index + 1
                        }: botão de sessão não encontrado`
                    );
                    return;
                }

                const textoCompleto = botaoSessao.textContent?.trim();
                if (!textoCompleto) {
                    console.log(`   ⚠️ MINUTA ${index + 1}: botão sem texto`);
                    return;
                }

                console.log(
                    `   ✅ MINUTA ${
                        index + 1
                    }: Texto encontrado: ${textoCompleto.substring(0, 100)}...`
                );

                // 6. APLICAR PADRÕES REGEX PARA ESTA MINUTA - CORRIGIDOS
                const padroesValidos = [
                    {
                        nome: "Incluído em Pauta",
                        regex: /^([A-Za-zÀ-ÿ\s]+?)\s*\(Incluído em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Incluído",
                    },
                    {
                        nome: "Incluído em Mesa",
                        regex: /^([A-Za-zÀ-ÿ\s]+?)\s*\(Incluído em Mesa em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Incluído",
                    },
                    {
                        nome: "Pedido de Vista em Pauta",
                        regex: /^([A-Za-zÀ-ÿ\s]+?)\s*\(Pedido de Vista em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Vista",
                    },
                    {
                        nome: "Convertido em Diligência em Pauta",
                        regex: /^([A-Za-zÀ-ÿ\s]+?)\s*\(Convertido em Diligência em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Diligência",
                    },
                    {
                        nome: "Julgado em Pauta",
                        regex: /^([A-Za-zÀ-ÿ\s]+?)\s*\(Julgado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Julgado",
                    },
                    {
                        nome: "Retirado em Pauta",
                        regex: /^([A-Za-zÀ-ÿ\s]+?)\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Retirado",
                    },
                ];

                padroesValidos.forEach((padrao) => {
                    console.log(
                        `   🔍 MINUTA ${index + 1}: Testando padrão ${
                            padrao.nome
                        }`
                    );
                    console.log(`   📝 REGEX: ${padrao.regex}`);
                    console.log(`   📝 TEXTO: "${textoCompleto}"`);

                    // Resetar regex para esta iteração
                    padrao.regex.lastIndex = 0;

                    let match;
                    while (
                        (match = padrao.regex.exec(textoCompleto)) !== null
                    ) {
                        console.log(`   ✅ MATCH ENCONTRADO:`, match);
                        const [textoMatchCompleto, tipoCapturado, data, orgao] =
                            match;

                        // 🔧 LIMPEZA DO TIPO: Extrair apenas o tipo real
                        let tipoLimpo = tipoCapturado.trim();

                        // Pegar apenas as últimas palavras que realmente são o tipo
                        const tiposValidos = [
                            "Embargos de Declaração",
                            "Mérito",
                            "Preliminar",
                            "Cautelar",
                            "Agravo Interno",
                            "Agravo",
                            "Apelação",
                            "Recurso",
                            "Juízo de Retratação",
                        ];

                        // Tentar encontrar um tipo válido no final da string capturada
                        let tipoEncontrado = null;
                        for (const tipoValido of tiposValidos) {
                            if (
                                tipoLimpo
                                    .toLowerCase()
                                    .includes(tipoValido.toLowerCase())
                            ) {
                                const index = tipoLimpo
                                    .toLowerCase()
                                    .lastIndexOf(tipoValido.toLowerCase());
                                if (index !== -1) {
                                    tipoEncontrado = tipoLimpo.substring(
                                        index,
                                        index + tipoValido.length
                                    );
                                    break;
                                }
                            }
                        }

                        // Se não encontrou um tipo específico, pegar as últimas palavras
                        if (!tipoEncontrado) {
                            const palavras = tipoLimpo
                                .split(/\s+/)
                                .filter((p) => p.length > 2);
                            if (palavras.length > 0) {
                                tipoEncontrado = palavras.slice(-3).join(" ");
                            } else {
                                tipoEncontrado = "Julgamento";
                            }
                        }

                        console.log(
                            `    LIMPEZA TIPO: "${tipoCapturado}" → "${tipoEncontrado}"`
                        );

                        const sessao = {
                            tipo: extrairTipoSessao(textoCompleto),
                            status: padrao.status,
                            data: data.trim(),
                            orgao: orgao.trim(),
                            textoCompleto: textoMatchCompleto,
                            cor: obterCorPorStatus(padrao.status),
                            minutaId: minutaId,
                        };

                        // 🎯 EXTRAIR DADOS DE PAUTA/MESA PARA SESSÕES "Incluído em Pauta"
                        if (padrao.status.toLowerCase().includes("incluído")) {
                            console.log(
                                "🔍 PAUTA/MESA: Sessão 'Incluído' detectada, buscando dados de pauta/mesa..."
                            );
                            const dadosPautaMesa = extrairDadosPautaMesa(
                                data.trim()
                            );
                            if (dadosPautaMesa) {
                                sessao.dadosPauta = dadosPautaMesa;
                                console.log(
                                    "✅ PAUTA/MESA: Dados integrados à sessão:",
                                    dadosPautaMesa
                                );
                            } else {
                                console.log(
                                    "❌ PAUTA/MESA: Nenhum dado de pauta/mesa encontrado para esta data"
                                );
                            }
                        }

                        console.log(
                            `   ✅ SESSÃO DETECTADA (${padrao.nome}):`,
                            sessao
                        );
                        sessoes.push(sessao);
                    }
                });
            });

            if (sessoes.length === 0) {
                console.log("❌ DETECÇÃO: Nenhuma sessão válida encontrada");
                // Limpar proteção em caso de erro
                window[chaveProtecao] = "erro";
                return null;
            }

            // 7. ORDENAR SESSÕES POR DATA (mais recente primeiro)
            sessoes.sort((a, b) => {
                try {
                    // Converter datas para comparação (DD/MM/YYYY -> YYYY-MM-DD)
                    const [diaA, mesA, anoA] = a.data.split("/");
                    const [diaB, mesB, anoB] = b.data.split("/");

                    const dataA = new Date(anoA, mesA - 1, diaA);
                    const dataB = new Date(anoB, mesB - 1, diaB);

                    return dataB - dataA; // Mais recente primeiro
                } catch (error) {
                    console.error(
                        "❌ ORDENAÇÃO: Erro ao comparar datas:",
                        error
                    );
                    return 0;
                }
            });

            console.log(
                "📊 SESSÕES ORDENADAS (mais recente primeiro):",
                sessoes.map((s) => `${s.tipo} (${s.status} em ${s.data})`)
            );

            // 8. Retornar dados estruturados - SESSÃO PRINCIPAL = MAIS RECENTE
            const resultado = {
                sessaoPrincipal: sessoes[0],
                todasSessoes: sessoes,
                totalSessoes: sessoes.length,
                processo: obterNumeroProcesso(),
                timestamp: Date.now(),
            };

            console.log("🎯 DETECÇÃO CONCLUÍDA:", resultado);

            // 9. Salvar dados globais - CORRIGIDO: salvar objeto completo
            dataSessaoPautado = resultado.sessaoPrincipal; // Objeto completo, não apenas a data
            processoComDataSessao = resultado.processo;
            window.dadosCompletosMinutas = resultado.sessaoPrincipal;
            window.SENT1_AUTO.todasSessoesDetectadas = sessoes;

            // 10. CRIAR CARD AUTOMATICAMENTE
            console.log("🎨 AUTO-CRIAÇÃO: Criando card automaticamente...");
            try {
                // Aguardar um pouco para garantir que as variáveis globais estão definidas
                setTimeout(() => {
                    if (typeof inserirDataSessaoNaInterface === "function") {
                        const cardCriado = inserirDataSessaoNaInterface();
                        console.log(
                            "✅ AUTO-CRIAÇÃO: Card criado:",
                            cardCriado
                        );
                    } else {
                        console.error(
                            "❌ AUTO-CRIAÇÃO: Função inserirDataSessaoNaInterface não disponível"
                        );
                    }
                }, 100);
            } catch (error) {
                console.error("❌ AUTO-CRIAÇÃO: Erro ao criar card:", error);
            }

            // 🛡️ MARCAR PROTEÇÃO COMO CONCLUÍDA
            window[chaveProtecao] = "concluido";
            console.log(
                "🛡️ PROTEÇÃO: Detecção concluída, marcando como finalizada"
            );

            return resultado;
        }

        // 🧪 FUNÇÃO DE TESTE ESPECÍFICA PARA O PROBLEMA ATUAL
        function testarRegexEspecifica() {
            console.log("🧪 TESTE ESPECÍFICO: Validando regex com texto real");

            const textoReal =
                "Mérito (Incluído em Pauta em 29/07/2025 - CAMPUB5)";

            const padraoCorrigido =
                /^([A-Za-zÀ-ÿ\s]+?)\s*\(Incluído em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi;

            console.log("📝 Texto real:", textoReal);
            console.log("🎯 Regex corrigida:", padraoCorrigido);

            const match = padraoCorrigido.exec(textoReal);

            if (match) {
                console.log("✅ SUCESSO! Match encontrado:", match);
                console.log("   - Texto completo:", match[0]);
                console.log("   - Tipo capturado:", match[1]);
                console.log("   - Data capturada:", match[2]);
                console.log("   - Órgão capturado:", match[3]);
                return true;
            } else {
                console.log("❌ FALHA: Regex não capturou o texto");
                return false;
            }
        }

        // 🧪 FUNÇÃO DE TESTE PARA EXTRAÇÃO DE TIPOS
        function testarExtracaoTipos() {
            console.log("🧪 TESTE: Validando extração de tipos de sessão...");

            const exemplos = [
                "Mérito (Julgado em Pauta em 01/07/2025 - CAMPUB5)",
                "Embargos de Declaração (Julgado em Pauta em 19/03/2024 - CAMPUB5)",
                "Agravo Interno (Julgado em Pauta em 22/07/2025 - CAMPUB5)",
                "Preliminar (Incluído em Pauta em 15/08/2025 - CAMCIV2)",
                "Cautelar (Convertido em Diligência em Pauta em 30/06/2025 - CAMCOM1)",
                "1. Recurso Especial (Retirado em Pauta em 10/09/2025 - SORGESP)",
                "Juízo de Retratação (Incluído em Mesa em 21/08/2025 - CAMPUB5)",
            ];

            exemplos.forEach((exemplo, index) => {
                const tipoExtraido = extrairTipoSessao(exemplo);
                console.log(`   ${index + 1}. "${exemplo}"`);
                console.log(`      → Tipo extraído: "${tipoExtraido}"`);
                console.log("");
            });

            return true;
        }

        // 🔍 FUNÇÃO DE DEBUG ESPECÍFICA PARA TOOLTIP E TIPO
        function debugTooltipComTipo() {
            console.log(
                "🔍 DEBUG: Verificando tooltip e exibição do tipo de sessão..."
            );

            // 1. Verificar se existe card
            const card = document.querySelector(
                "#eprobe-card-sessao-material, #eprobe-data-sessao"
            );
            console.log("📋 Card encontrado:", !!card);

            if (!card) {
                console.log(
                    "❌ Nenhum card encontrado. Execute primeiro window.SENT1_AUTO.detectarSessoesUnificado()"
                );
                return false;
            }

            // 2. Verificar dados de sessão
            const dadosSessoes = window.SENT1_AUTO.todasSessoesDetectadas;
            console.log("📊 Dados de sessões:", dadosSessoes);

            if (!dadosSessoes || dadosSessoes.length === 0) {
                console.log("❌ Nenhum dado de sessão encontrado");
                return false;
            }

            // 3. Verificar tooltip existente
            const tooltipExistente = document.getElementById(
                "eprobe-rich-tooltip"
            );
            console.log("🎨 Tooltip existe:", !!tooltipExistente);

            // 4. Testar criação de tooltip com dados reais
            console.log("🧪 Testando criação de tooltip...");
            const resultadoTooltip = aplicarTooltipUnificado(
                card,
                dadosSessoes
            );
            console.log("📋 Resultado aplicação tooltip:", resultadoTooltip);

            // 5. Verificar se tooltip foi criado e contém tipo
            setTimeout(() => {
                const novoTooltip = document.getElementById(
                    "eprobe-rich-tooltip"
                );
                if (novoTooltip) {
                    console.log("✅ Tooltip criado com sucesso");
                    const conteudoTooltip = novoTooltip.innerHTML;
                    const contemTipo =
                        conteudoTooltip.includes("Tipo do Julgamento");
                    const contemIconeBalance =
                        conteudoTooltip.includes("balance") ||
                        conteudoTooltip.includes("M60.65-108.65");

                    console.log("🔍 Análise do tooltip:");
                    console.log(
                        "  - Contém seção 'Tipo do Julgamento':",
                        contemTipo
                    );
                    console.log(
                        "  - Contém ícone balance:",
                        contemIconeBalance
                    );

                    // Verificar tipos extraídos
                    dadosSessoes.forEach((sessao, index) => {
                        console.log(`  - Sessão ${index + 1}:`);
                        console.log(
                            `    - Texto original: "${sessao.textoCompleto}"`
                        );
                        console.log(`    - Tipo extraído: "${sessao.tipo}"`);
                        console.log(
                            `    - Tipo no HTML: ${conteudoTooltip.includes(
                                sessao.tipo
                            )}`
                        );
                    });
                } else {
                    console.log("❌ Tooltip não foi criado");
                }
            }, 100);

            return true;
        }

        /**
         * 🎯 FUNÇÃO PARA EXTRAIR TIPO DE SESSÃO - REGRA: Tudo antes do primeiro parênteses
         * @param {string} textoCompleto - Texto completo da sessão
         * @returns {string} - Tipo da sessão limpo e formatado
         */
        function extrairTipoSessao(textoCompleto) {
            console.log(
                "🔍 EXTRAIR TIPO: Iniciando extração de tipo de sessão..."
            );
            console.log("📝 EXTRAIR TIPO: Texto de entrada:", textoCompleto);

            if (!textoCompleto) {
                console.log(
                    "❌ EXTRAIR TIPO: Texto vazio, retornando padrão 'Julgamento'"
                );
                return "Julgamento";
            }

            // Extrair tudo antes do primeiro parênteses
            const partesTipo = textoCompleto.split("(")[0];
            console.log(
                "✂️ EXTRAIR TIPO: Parte antes do parênteses:",
                partesTipo
            );

            if (!partesTipo) {
                console.log(
                    "❌ EXTRAIR TIPO: Nenhuma parte encontrada antes do parênteses, retornando padrão"
                );
                return "Julgamento";
            }

            // Limpar e formatar
            let tipoLimpo = partesTipo.trim();
            console.log("🧹 EXTRAIR TIPO: Após trim inicial:", tipoLimpo);

            // Remover prefixos comuns como números, etc
            const tipoAntes = tipoLimpo;
            tipoLimpo = tipoLimpo.replace(/^\d+\s*[-.]?\s*/, ""); // Remove números no início
            tipoLimpo = tipoLimpo.replace(/^\W+/, ""); // Remove caracteres especiais no início
            tipoLimpo = tipoLimpo.trim();

            if (tipoAntes !== tipoLimpo) {
                console.log(
                    "🔧 EXTRAIR TIPO: Após limpeza de prefixos:",
                    tipoAntes,
                    "→",
                    tipoLimpo
                );
            }

            // Se ficou vazio, retornar padrão
            if (!tipoLimpo || tipoLimpo.length < 2) {
                console.log(
                    "❌ EXTRAIR TIPO: Tipo muito curto ou vazio após limpeza, retornando padrão"
                );
                return "Julgamento";
            }

            // Aplicar formatação de title case para tipos conhecidos
            const tiposEspeciais = {
                merito: "Mérito",
                preliminar: "Preliminar",
                cautelar: "Cautelar",
                "embargos de declaracao": "Embargos de Declaração",
                "agravo interno": "Agravo Interno",
                agravo: "Agravo",
                apelacao: "Apelação",
                recurso: "Recurso",
                "recurso especial": "Recurso Especial",
                "recurso extraordinario": "Recurso Extraordinário",
            };

            const tipoNormalizado = tipoLimpo
                .toLowerCase()
                .normalize("NFD")
                .replace(/[\u0300-\u036f]/g, ""); // Remove acentos para comparação

            console.log(
                "🔤 EXTRAIR TIPO: Tipo normalizado para comparação:",
                tipoNormalizado
            );

            // Verificar se é um tipo especial
            for (const [chave, valor] of Object.entries(tiposEspeciais)) {
                const chaveNormalizada = chave
                    .toLowerCase()
                    .normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, "");
                if (tipoNormalizado === chaveNormalizada) {
                    console.log(
                        `✅ EXTRAIR TIPO: Match especial encontrado! "${tipoNormalizado}" → "${valor}"`
                    );
                    return valor;
                }
            }

            // Se não é um tipo especial, aplicar title case simples
            const tipoFormatado = tipoLimpo
                .split(" ")
                .map(
                    (palavra) =>
                        palavra.charAt(0).toUpperCase() +
                        palavra.slice(1).toLowerCase()
                )
                .join(" ");

            console.log(
                `🎨 EXTRAIR TIPO: Aplicando title case genérico: "${tipoLimpo}" → "${tipoFormatado}"`
            );
            console.log(`✅ EXTRAIR TIPO: Resultado final: "${tipoFormatado}"`);

            return tipoFormatado;
        }

        /**
         * 🎯 FUNÇÃO PARA EXTRAIR DADOS DE PAUTA/MESA DOS EVENTOS
         * Busca na tabela de eventos do eProc informações sobre inclusão em pauta/mesa
         * @param {string} dataSessao - Data da sessão para comparar (formato DD/MM/YYYY)
         * @returns {Object|null} - Dados da pauta/mesa ou null se não encontrado
         */
        function extrairDadosPautaMesa(dataSessao) {
            console.log(
                "🔍 PAUTA/MESA: Iniciando extração de dados de pauta/mesa..."
            );
            console.log(
                "📅 PAUTA/MESA: Data da sessão para comparar:",
                dataSessao
            );

            // Buscar tabela de eventos
            const tabelaEventos = document.querySelector("#tblEventos");
            if (!tabelaEventos) {
                console.log("❌ PAUTA/MESA: Tabela #tblEventos não encontrada");
                return null;
            }

            console.log("✅ PAUTA/MESA: Tabela de eventos encontrada");

            // Buscar todas as linhas de evento com ID trEvento + número
            const linhasEvento =
                tabelaEventos.querySelectorAll('tr[id^="trEvento"]');
            console.log(
                `🔢 PAUTA/MESA: ${linhasEvento.length} eventos encontrados`
            );

            for (let i = 0; i < linhasEvento.length; i++) {
                const linha = linhasEvento[i];
                const eventoId = linha.id;

                console.log(`🔍 PAUTA/MESA: Analisando evento ${eventoId}...`);

                // Buscar label com descrição do evento
                const labelDescricao = linha.querySelector(
                    "label.infraEventoDescricao"
                );
                if (!labelDescricao) {
                    console.log(
                        `⚠️ PAUTA/MESA: ${eventoId} - Label de descrição não encontrado`
                    );
                    continue;
                }

                const textoEvento = labelDescricao.textContent || "";
                console.log(
                    `📝 PAUTA/MESA: ${eventoId} - Texto: "${textoEvento}"`
                );

                // Verificar se é um evento de inclusão em pauta ou mesa
                const isInclusaoPauta = textoEvento.includes(
                    "Inclusão em pauta de julgamento pelo relator"
                );
                const isInclusaoMesa = textoEvento.includes(
                    "Incluído em mesa para julgamento"
                );

                if (!isInclusaoPauta && !isInclusaoMesa) {
                    console.log(
                        `⏭️ PAUTA/MESA: ${eventoId} - Não é evento de pauta/mesa, continuando...`
                    );
                    continue;
                }

                console.log(
                    `🎯 PAUTA/MESA: ${eventoId} - Evento de ${
                        isInclusaoPauta ? "PAUTA" : "MESA"
                    } encontrado!`
                );

                // Extrair o HTML completo do evento para análise
                const htmlCompleto = linha.innerHTML;

                // Padrões regex para extração
                const padroes = {
                    // Sessão Ordinária Física - Data da sessão: 21/08/2025 14:00
                    sessaoFisica:
                        /<b>Sessão Ordinária Física<\/b><br>Data da sessão: <b>(\d{1,2}\/\d{1,2}\/\d{4})/i,
                    // Sessão Virtual - Período da sessão: 19/08/2025 00:00 a 19/08/2025 18:00
                    sessaoVirtual:
                        /<b>Sessão Virtual[^<]*<\/b><br>Período da sessão: <b>(\d{1,2}\/\d{1,2}\/\d{4})/i,
                    // Sequencial: 18
                    sequencial: /Sequencial:\s*(\d+)/i,
                };

                let modalidade = null;
                let dataEncontrada = null;
                let sequencial = null;

                // Verificar modalidade física
                const matchFisica = htmlCompleto.match(padroes.sessaoFisica);
                if (matchFisica) {
                    modalidade = "Física";
                    dataEncontrada = matchFisica[1];
                    console.log(
                        `🏛️ PAUTA/MESA: ${eventoId} - Sessão FÍSICA detectada, data: ${dataEncontrada}`
                    );
                }

                // Verificar modalidade virtual
                const matchVirtual = htmlCompleto.match(padroes.sessaoVirtual);
                if (matchVirtual && !modalidade) {
                    // só se não encontrou física
                    modalidade = "Virtual";
                    dataEncontrada = matchVirtual[1];
                    console.log(
                        `💻 PAUTA/MESA: ${eventoId} - Sessão VIRTUAL detectada, data: ${dataEncontrada}`
                    );
                }

                // Extrair sequencial
                const matchSequencial = htmlCompleto.match(padroes.sequencial);
                if (matchSequencial) {
                    sequencial = parseInt(matchSequencial[1]);
                    console.log(
                        `🔢 PAUTA/MESA: ${eventoId} - Sequencial: ${sequencial}`
                    );
                }

                // Verificar se a data coincide
                const dataCoincide =
                    dataEncontrada && dataEncontrada === dataSessao;
                console.log(
                    `📅 PAUTA/MESA: ${eventoId} - Comparação de datas:`
                );
                console.log(`   Data encontrada: "${dataEncontrada}"`);
                console.log(`   Data da sessão: "${dataSessao}"`);
                console.log(`   Coincidem: ${dataCoincide ? "✅" : "❌"}`);

                if (dataCoincide && modalidade && sequencial !== null) {
                    const tipoInclusao = isInclusaoPauta
                        ? "Incluído em pauta"
                        : "Incluído em mesa";

                    const resultado = {
                        tipoInclusao,
                        modalidade,
                        sequencial,
                        dataEncontrada,
                        eventoId,
                    };

                    console.log(
                        `🎉 PAUTA/MESA: Dados completos encontrados:`,
                        resultado
                    );
                    return resultado;
                }
            }

            console.log(
                "❌ PAUTA/MESA: Nenhum evento de pauta/mesa com data coincidente encontrado"
            );
            return null;
        }

        /**
         * ÚNICA função para obter cor por status - substitui todas as outras
         * @param {string} status - Status da sessão
         * @returns {string} - Cor hexadecimal
         */
        function obterCorPorStatus(status) {
            const cores = {
                Julgado: "#3AB795",
                Retirado: "#CE2D4F",
                Incluído: "#5C85B4",
                Pautado: "#5C85B4",
                Vista: "#FFBF46",
                Diligência: "#00171F",
            };
            return cores[status] || "#6B7280";
        }

        // 🧪 FUNÇÃO DE TESTE PARA A NOVA ESTRUTURA DOM
        function debugDeteccaoSessaoRapida() {
            console.log(
                "🧪 TESTE RÁPIDO: Nova estrutura DOM de detecção de sessões"
            );

            try {
                // 1. Verificar container principal
                const containerMinutas =
                    document.querySelector("#conteudoMinutas");
                console.log(
                    "📋 Container #conteudoMinutas:",
                    !!containerMinutas
                );

                if (!containerMinutas) {
                    console.log("❌ TESTE: Container não encontrado");
                    return {
                        erro: "Container #conteudoMinutas não encontrado",
                    };
                }

                // 2. Buscar minutas (exceto conteudoMinutas_0)
                const minutas = containerMinutas.querySelectorAll(
                    'div[id^="conteudoMinutas_"]:not([id="conteudoMinutas_0"])'
                );
                console.log(`📁 Minutas encontradas: ${minutas.length}`);

                const resultados = [];

                minutas.forEach((minuta, index) => {
                    const minutaId = minuta.id;
                    console.log(`\n🔍 MINUTA ${index + 1}: ${minutaId}`);

                    const resultado = {
                        minutaId,
                        temFieldset: false,
                        temSpanHistorico: false,
                        temBotao: false,
                        textoEncontrado: null,
                    };

                    // Verificar fieldset
                    const fieldset = minuta.querySelector(
                        "fieldset#fldMinutas"
                    );
                    resultado.temFieldset = !!fieldset;
                    console.log(
                        `   📄 Fieldset #fldMinutas: ${resultado.temFieldset}`
                    );

                    if (fieldset) {
                        // Verificar span historico
                        const spanHistorico = fieldset.querySelector(
                            "legend span#historico"
                        );
                        resultado.temSpanHistorico = !!spanHistorico;
                        console.log(
                            `   📋 Span #historico: ${resultado.temSpanHistorico}`
                        );

                        if (spanHistorico) {
                            // Verificar botão
                            const botao = spanHistorico.querySelector(
                                "button[id^='legMinutasMaisMenos_']"
                            );
                            resultado.temBotao = !!botao;
                            console.log(
                                `   🔘 Botão encontrado: ${resultado.temBotao}`
                            );

                            if (botao) {
                                resultado.textoEncontrado =
                                    botao.textContent?.trim();
                                console.log(
                                    `   📝 Texto: ${resultado.textoEncontrado?.substring(
                                        0,
                                        80
                                    )}...`
                                );
                            }
                        }
                    }

                    resultados.push(resultado);
                });

                const resumo = {
                    totalMinutas: minutas.length,
                    comFieldset: resultados.filter((r) => r.temFieldset).length,
                    comSpanHistorico: resultados.filter(
                        (r) => r.temSpanHistorico
                    ).length,
                    comBotao: resultados.filter((r) => r.temBotao).length,
                    comTexto: resultados.filter((r) => r.textoEncontrado)
                        .length,
                    resultados,
                };

                console.log("\n📊 RESUMO DO TESTE:", resumo);

                // 3. Testar detecção unificada
                console.log("\n🎯 TESTANDO DETECÇÃO UNIFICADA...");
                const deteccao = detectarSessoesUnificado(true);
                console.log("📊 RESULTADO DA DETECÇÃO:", deteccao);

                return { resumo, deteccao };
            } catch (error) {
                console.error("❌ TESTE: Erro durante execução:", error);
                return { erro: error.message };
            }
        }

        // ========================================
        // 🎨 FUNÇÃO ÚNICA DE TOOLTIP DIRETO NO CARD
        // ========================================

        /**
         * ÚNICA função para aplicar tooltip - substitui adicionarTooltipUnificado e todas as outras
         * @param {HTMLElement} cardElement - Elemento do card
         * @param {Array} sessoes - Array de sessões (opcional)
         * @returns {Object} - Status da operação
         */
        function aplicarTooltipUnificado(cardElement, sessoes = null) {
            console.log(
                "🎨 TOOLTIP UNIFICADO: Aplicando tooltip direto no card"
            );

            if (!cardElement) {
                console.error("❌ TOOLTIP: Card element não fornecido");
                return { status: "erro", motivo: "card_inexistente" };
            }

            // 1. Obter sessões se não fornecidas
            if (!sessoes) {
                const dadosDetectados = detectarSessoesUnificado();
                sessoes = dadosDetectados ? dadosDetectados.todasSessoes : [];
            }

            if (!sessoes || sessoes.length === 0) {
                console.log(
                    "⚠️ TOOLTIP: Nenhuma sessão para mostrar no tooltip"
                );
                return { status: "aviso", motivo: "sem_sessoes" };
            }

            // 2. Remover tooltip existente APENAS UMA VEZ para evitar flash
            const tooltipExistente = document.getElementById(
                "eprobe-rich-tooltip"
            );
            if (tooltipExistente) {
                console.log(
                    "🔄 TOOLTIP: Removendo tooltip existente para evitar duplicação"
                );
                tooltipExistente.remove();
            }

            // 3. Criar tooltip HTML
            const tooltipHTML = criarHTMLTooltip(sessoes);

            // 4. Adicionar event listeners direto no card COM PASSIVE
            cardElement.addEventListener("mouseenter", mostrarTooltip, {
                passive: true,
            });
            cardElement.addEventListener("mouseleave", esconderTooltip, {
                passive: true,
            });

            // 5. Funções do tooltip
            let tooltipTimer = null; // Timer para controlar o escondimento

            function mostrarTooltip(e) {
                // 🛡️ CANCELAR TIMER DE ESCONDIMENTO SE EXISTIR
                if (tooltipTimer) {
                    clearTimeout(tooltipTimer);
                    tooltipTimer = null;
                    console.log("⏰ TOOLTIP: Timer de escondimento cancelado");
                }

                // 🛡️ PROTEÇÃO ANTI-FLASH: Verificar se já existe tooltip
                const tooltipExistente = document.getElementById(
                    "eprobe-rich-tooltip"
                );
                if (tooltipExistente) {
                    console.log(
                        "🔄 TOOLTIP: Reutilizando tooltip existente para evitar flash"
                    );

                    // Apenas mostrar o tooltip existente
                    tooltipExistente.style.opacity = "1";
                    tooltipExistente.style.visibility = "visible";
                    return;
                }

                console.log(
                    "🎨 TOOLTIP: Criando novo tooltip com tipos de sessão..."
                );

                const tooltip = document.createElement("div");
                tooltip.id = "eprobe-rich-tooltip";
                tooltip.innerHTML = tooltipHTML;
                tooltip.style.cssText = `
                    position: fixed !important;
                    background: transparent !important;
                    border: none !important;
                    border-radius: 0 !important;
                    padding: 0 !important;
                    box-shadow: none !important;
                    z-index: 999999 !important;
                    max-width: none !important;
                    font-size: inherit !important;
                    line-height: inherit !important;
                    pointer-events: auto !important;
                    opacity: 0 !important;
                    transition: opacity 0.15s ease-in-out !important;
                    left: 0px !important;
                    top: 0px !important;
                    transform: none !important;
                    margin: 0 !important;
                    filter: none !important;
                    visibility: hidden !important;
                `;

                // Adicionar ao DOM primeiro para permitir medição
                document.body.appendChild(tooltip);

                // 🎯 EVENT LISTENERS DO TOOLTIP PARA MANTER VISÍVEL DURANTE HOVER
                tooltip.addEventListener(
                    "mouseenter",
                    () => {
                        console.log(
                            "🖱️ TOOLTIP: Mouse sobre tooltip - mantendo visível"
                        );
                        // Cancelar qualquer timer de escondimento
                        if (tooltipTimer) {
                            clearTimeout(tooltipTimer);
                            tooltipTimer = null;
                            console.log(
                                "⏰ TOOLTIP: Timer cancelado durante hover no tooltip"
                            );
                        }
                        tooltip.style.opacity = "1";
                    },
                    { passive: true }
                );

                tooltip.addEventListener(
                    "mouseleave",
                    () => {
                        console.log(
                            "🖱️ TOOLTIP: Mouse saiu do tooltip - programando escondimento"
                        );
                        programarEscondimento();
                    },
                    { passive: true }
                );

                // 🔧 AGUARDAR RENDERIZAÇÃO PARA OBTER DIMENSÕES REAIS
                requestAnimationFrame(() => {
                    // 🎯 POSICIONAMENTO INTELIGENTE COM DIMENSÕES REAIS
                    posicionarTooltipRelativoAoCard(tooltip, cardElement, e);

                    // ✨ ANIMAÇÃO DE ENTRADA ELEGANTE
                    requestAnimationFrame(() => {
                        tooltip.style.visibility = "visible";
                        tooltip.style.opacity = "1";
                    });
                });
            }

            function esconderTooltip() {
                console.log(
                    "🖱️ TOOLTIP: Mouse saiu do card - programando escondimento"
                );
                programarEscondimento();
            }

            function programarEscondimento() {
                // Cancelar timer anterior se existir
                if (tooltipTimer) {
                    clearTimeout(tooltipTimer);
                }

                // Programar escondimento com delay
                tooltipTimer = setTimeout(() => {
                    const tooltip = document.getElementById(
                        "eprobe-rich-tooltip"
                    );
                    if (tooltip) {
                        console.log(
                            "🔄 TOOLTIP: Escondendo tooltip após delay"
                        );

                        // ✨ ANIMAÇÃO DE SAÍDA ELEGANTE
                        tooltip.style.opacity = "0";

                        // Remover após animação
                        setTimeout(() => {
                            if (tooltip.parentNode) {
                                tooltip.remove();
                                console.log(
                                    "✅ TOOLTIP: Removido do DOM com sucesso"
                                );
                            }
                        }, 200);
                    }
                    tooltipTimer = null;
                }, 300); // 300ms de delay
            }

            console.log("✅ TOOLTIP: Aplicado com sucesso");
            return { status: "sucesso", sessoes: sessoes.length };
        }

        /**
         * 🎯 FUNÇÃO ÚNICA E EXCLUSIVA DE POSICIONAMENTO DO TOOLTIP
         * Esta é a ÚNICA função responsável por posicionar tooltips na extensão
         * Busca o card de sessão diretamente no DOM para posicionamento ótimo
         * PRIORIDADES: 1) Abaixo 2) Direita 3) Esquerda 4) Acima
         * @param {HTMLElement} tooltip - Elemento do tooltip
         * @param {HTMLElement} cardElement - Card de referência (opcional, será ignorado)
         * @param {Event} mouseEvent - Evento do mouse para fallback
         */
        function posicionarTooltipRelativoAoCard(
            tooltip,
            cardElement,
            mouseEvent = null
        ) {
            console.log(
                "🎯 POSICIONAMENTO: Buscando card no DOM para posicionamento inteligente"
            );

            // 🔍 BUSCAR CARD DIRETAMENTE NO DOM PELO ID
            const cardNoDOM = document.getElementById(
                "eprobe-card-sessao-material"
            );

            if (!cardNoDOM) {
                console.warn(
                    "⚠️ POSICIONAMENTO: Card não encontrado no DOM, usando posicionamento do mouse"
                );

                // Fallback: usar posição do mouse ou posição fixa
                const mouseX = mouseEvent?.clientX || 200;
                const mouseY = mouseEvent?.clientY || 200;

                tooltip.style.left = mouseX + 15 + "px";
                tooltip.style.top = mouseY - 50 + "px";

                console.log(
                    `🎯 POSICIONAMENTO: Tooltip posicionado próximo ao mouse (${
                        mouseX + 15
                    }, ${mouseY - 50})`
                );
                return;
            }

            // 1. Obter dimensões da viewport
            const viewport = {
                width: window.innerWidth,
                height: window.innerHeight,
                scrollX: window.pageXOffset,
                scrollY: window.pageYOffset,
            };

            // 2. Obter posição e dimensões do card encontrado no DOM
            const cardRect = cardNoDOM.getBoundingClientRect();

            console.log("🔍 CARD ENCONTRADO NO DOM:", {
                id: cardNoDOM.id,
                rect: cardRect,
                offsetDimensions: `${cardNoDOM.offsetWidth}x${cardNoDOM.offsetHeight}`,
                clientDimensions: `${cardNoDOM.clientWidth}x${cardNoDOM.clientHeight}`,
                isVisible:
                    cardNoDOM.offsetWidth > 0 && cardNoDOM.offsetHeight > 0,
                display: window.getComputedStyle(cardNoDOM).display,
                visibility: window.getComputedStyle(cardNoDOM).visibility,
            });

            // 🚨 VERIFICAÇÃO CRÍTICA: Card com dimensões válidas?
            if (cardRect.width === 0 || cardRect.height === 0) {
                console.warn(
                    "⚠️ POSICIONAMENTO: Card encontrado mas sem dimensões válidas, usando posicionamento do mouse"
                );

                // Fallback: usar posição do mouse ou posição fixa
                const mouseX = mouseEvent?.clientX || 200;
                const mouseY = mouseEvent?.clientY || 200;

                tooltip.style.left = mouseX + 15 + "px";
                tooltip.style.top = mouseY - 50 + "px";

                console.log(
                    `🎯 POSICIONAMENTO: Tooltip posicionado próximo ao mouse (${
                        mouseX + 15
                    }, ${mouseY - 50})`
                );
                return;
            }

            const cardInfo = {
                left: cardRect.left,
                top: cardRect.top,
                right: cardRect.right,
                bottom: cardRect.bottom,
                width: cardRect.width,
                height: cardRect.height,
                centerX: cardRect.left + cardRect.width / 2,
                centerY: cardRect.top + cardRect.height / 2,
            };

            // 3. Obter dimensões do tooltip - AGUARDAR RENDERIZAÇÃO COMPLETA
            const tooltipRect = tooltip.getBoundingClientRect();
            let tooltipInfo = {
                width: tooltipRect.width,
                height: tooltipRect.height,
            };

            // 🚨 VERIFICAÇÃO CRÍTICA: Se dimensões são 0, aguardar renderização
            if (tooltipInfo.width === 0 || tooltipInfo.height === 0) {
                console.warn(
                    "⚠️ POSICIONAMENTO: Aguardando renderização para obter dimensões..."
                );

                // Aguardar um tick e tentar novamente
                setTimeout(() => {
                    const newRect = tooltip.getBoundingClientRect();
                    tooltipInfo = {
                        width: newRect.width || 320, // Fallback para largura padrão
                        height: newRect.height || 200, // Fallback para altura padrão
                    };
                    console.log("📐 DIMENSÕES OBTIDAS:", tooltipInfo);
                    continuarPosicionamento();
                }, 16); // ~1 frame
                return;
            }

            continuarPosicionamento();

            function continuarPosicionamento() {
                // 4. Definir margem mínima das bordas da tela
                const MARGEM_BORDA = 15;

                // 5. Calcular posições preferenciais (em ordem de prioridade)
                const posicoesCandidatas = [
                    // Posição 1: Abaixo do card (NOVA PREFERENCIAL)
                    {
                        name: "abaixo",
                        left: cardInfo.centerX - tooltipInfo.width / 2,
                        top: cardInfo.bottom + 12,
                        priority: 1,
                    },
                    // Posição 2: À direita do card
                    {
                        name: "direita",
                        left: cardInfo.right + 12,
                        top: cardInfo.centerY - tooltipInfo.height / 2,
                        priority: 2,
                    },
                    // Posição 3: À esquerda do card
                    {
                        name: "esquerda",
                        left: cardInfo.left - tooltipInfo.width - 12,
                        top: cardInfo.centerY - tooltipInfo.height / 2,
                        priority: 3,
                    },
                    // Posição 4: Acima do card (fallback)
                    {
                        name: "acima",
                        left: cardInfo.centerX - tooltipInfo.width / 2,
                        top: cardInfo.top - tooltipInfo.height - 12,
                        priority: 4,
                    },
                ];

                // 6. Verificar qual posição é viável (não sai da tela)
                let melhorPosicao = null;

                console.log(
                    "🔍 POSICIONAMENTO: Avaliando posições candidatas:"
                );
                console.log("📊 Viewport:", viewport);
                console.log("📦 Card:", cardInfo);
                console.log("🎯 Tooltip:", tooltipInfo);

                for (const posicao of posicoesCandidatas.sort(
                    (a, b) => a.priority - b.priority
                )) {
                    const dentroDoViewport =
                        posicao.left >= MARGEM_BORDA &&
                        posicao.left + tooltipInfo.width <=
                            viewport.width - MARGEM_BORDA &&
                        posicao.top >= MARGEM_BORDA &&
                        posicao.top + tooltipInfo.height <=
                            viewport.height - MARGEM_BORDA;

                    console.log(`📍 Testando posição "${posicao.name}":`, {
                        left: posicao.left,
                        top: posicao.top,
                        dentroDoViewport,
                        margens: {
                            esquerda: posicao.left >= MARGEM_BORDA,
                            direita:
                                posicao.left + tooltipInfo.width <=
                                viewport.width - MARGEM_BORDA,
                            topo: posicao.top >= MARGEM_BORDA,
                            baixo:
                                posicao.top + tooltipInfo.height <=
                                viewport.height - MARGEM_BORDA,
                        },
                    });

                    if (dentroDoViewport) {
                        melhorPosicao = posicao;
                        console.log(
                            `✅ POSICIONAMENTO: Posição "${posicao.name}" selecionada`
                        );
                        break;
                    }
                }

                // 7. Se nenhuma posição ideal, FORÇAR posição abaixo com ajustes inteligentes
                if (!melhorPosicao) {
                    console.log(
                        "⚠️ POSICIONAMENTO: FORÇANDO posição abaixo com ajustes inteligentes"
                    );

                    // SEMPRE usar posição abaixo como base
                    melhorPosicao = {
                        name: "abaixo_forcado",
                        left: cardInfo.centerX - tooltipInfo.width / 2,
                        top: cardInfo.bottom + 12,
                        priority: 1,
                    };

                    // Ajustar horizontalmente se necessário (centralizado no card)
                    if (melhorPosicao.left < MARGEM_BORDA) {
                        melhorPosicao.left = MARGEM_BORDA;
                    } else if (
                        melhorPosicao.left + tooltipInfo.width >
                        viewport.width - MARGEM_BORDA
                    ) {
                        melhorPosicao.left =
                            viewport.width - tooltipInfo.width - MARGEM_BORDA;
                    }

                    // Se sair da tela por baixo, ajustar para posição superior APENAS se necessário
                    if (
                        melhorPosicao.top + tooltipInfo.height >
                        viewport.height - MARGEM_BORDA
                    ) {
                        // Tentar posicionar acima do card apenas se realmente não couber
                        const posicaoAcima =
                            cardInfo.top - tooltipInfo.height - 12;
                        if (posicaoAcima >= MARGEM_BORDA) {
                            melhorPosicao.top = posicaoAcima;
                            melhorPosicao.name = "acima_forcado";
                            console.log(
                                "🔄 POSICIONAMENTO: Movido para acima por falta de espaço"
                            );
                        } else {
                            // Se nem acima nem abaixo cabem, usar o máximo possível abaixo
                            melhorPosicao.top =
                                viewport.height -
                                tooltipInfo.height -
                                MARGEM_BORDA;
                            console.log(
                                "🔄 POSICIONAMENTO: Ajustado para caber na tela (abaixo)"
                            );
                        }
                    }

                    console.log("✅ POSICIONAMENTO FORÇADO:", melhorPosicao);
                }

                // 8. Aplicar posição final com !important para forçar
                tooltip.style.setProperty(
                    "left",
                    Math.round(melhorPosicao.left) + "px",
                    "important"
                );
                tooltip.style.setProperty(
                    "top",
                    Math.round(melhorPosicao.top) + "px",
                    "important"
                );
                tooltip.style.setProperty("position", "fixed", "important");

                // 🔧 VERIFICAÇÃO IMEDIATA: Forçar aplicação e re-check
                setTimeout(() => {
                    const computedAfterSet = window.getComputedStyle(tooltip);
                    console.log("🔧 VERIFICAÇÃO IMEDIATA CSS:", {
                        position: computedAfterSet.position,
                        left: computedAfterSet.left,
                        top: computedAfterSet.top,
                        styleLeft: tooltip.style.left,
                        styleTop: tooltip.style.top,
                        stylePosition: tooltip.style.position,
                    });

                    // Se ainda não está correto, forçar novamente
                    if (computedAfterSet.position !== "fixed") {
                        console.warn("⚠️ FORÇANDO POSITION: fixed novamente");
                        tooltip.style.position = "fixed";
                        tooltip.style.setProperty(
                            "position",
                            "fixed",
                            "important"
                        );
                    }
                }, 10);

                // 🔍 DEBUG: Verificar posicionamento final
                const tooltipFinalRect = tooltip.getBoundingClientRect();
                const cardFinalRect = cardNoDOM.getBoundingClientRect();

                console.log("🔍 DEBUG POSICIONAMENTO FINAL:", {
                    tooltipComputedStyles: {
                        position: window.getComputedStyle(tooltip).position,
                        left: window.getComputedStyle(tooltip).left,
                        top: window.getComputedStyle(tooltip).top,
                        zIndex: window.getComputedStyle(tooltip).zIndex,
                        transform: window.getComputedStyle(tooltip).transform,
                    },
                    tooltipFinalRect: tooltipFinalRect,
                    cardFinalRect: cardFinalRect,
                    posicionamentoCalculado: {
                        left: Math.round(melhorPosicao.left),
                        top: Math.round(melhorPosicao.top),
                    },
                    distanciaRelativa: {
                        deltaX: tooltipFinalRect.left - cardFinalRect.left,
                        deltaY: tooltipFinalRect.top - cardFinalRect.top,
                    },
                    problemaPossivel: {
                        tooltipEstaOndeEsperado:
                            Math.abs(
                                tooltipFinalRect.left -
                                    Math.round(melhorPosicao.left)
                            ) < 5,
                        cardEstaVisivel:
                            cardFinalRect.width > 0 && cardFinalRect.height > 0,
                        tooltipEstaVisivel:
                            tooltipFinalRect.width > 0 &&
                            tooltipFinalRect.height > 0,
                    },
                    viewport: viewport,
                });

                console.log(
                    `🎯 POSICIONAMENTO: Tooltip posicionado em (${Math.round(
                        melhorPosicao.left
                    )}, ${Math.round(melhorPosicao.top)}) relativo ao card`
                );

                // 🔍 POSIÇÃO REAL vs ESPERADA
                console.log("📊 COMPARAÇÃO POSIÇÕES:");
                console.log(
                    `   Esperado: (${Math.round(
                        melhorPosicao.left
                    )}, ${Math.round(melhorPosicao.top)})`
                );
                console.log(
                    `   Real: (${tooltipFinalRect.left}, ${tooltipFinalRect.top})`
                );
                console.log(
                    `   Diferença: (${
                        tooltipFinalRect.left - Math.round(melhorPosicao.left)
                    }, ${tooltipFinalRect.top - Math.round(melhorPosicao.top)})`
                );

                // 🎯 VERIFICAÇÃO SE ESTÁ ABAIXO DO CARD (NOVA POSIÇÃO PREFERENCIAL)
                const estaAbaixoDoCard =
                    tooltipFinalRect.top > cardFinalRect.bottom;
                const estaCentralizado =
                    Math.abs(
                        tooltipFinalRect.left +
                            tooltipFinalRect.width / 2 -
                            (cardFinalRect.left + cardFinalRect.width / 2)
                    ) < 10;

                console.log("🎯 VERIFICAÇÃO POSICIONAMENTO:", {
                    estaAbaixoDoCard,
                    estaCentralizado,
                    distanciaVertical:
                        tooltipFinalRect.top - cardFinalRect.bottom,
                    posicaoSelecionada: melhorPosicao.name,
                });

                console.log("✅ POSICIONAMENTO FINAL:");
                console.log(`   Está abaixo do card: ${estaAbaixoDoCard}`);
                console.log(`   Está centralizado: ${estaCentralizado}`);
                console.log(
                    `   Distância do card: ${
                        tooltipFinalRect.top - cardFinalRect.bottom
                    }px`
                );
            }
        }

        /**
         * Cria HTML do tooltip com dados das sessões - Material Symbols Design
         */
        function criarHTMLTooltip(sessoes) {
            console.log(
                "🎨 TOOLTIP HTML: Iniciando criação do HTML do tooltip..."
            );
            console.log("📊 TOOLTIP HTML: Sessões recebidas:", sessoes);
            console.log(
                "🔢 TOOLTIP HTML: Total de sessões:",
                sessoes?.length || 0
            );

            // Log dos tipos das sessões
            if (sessoes && sessoes.length > 0) {
                console.log("📋 TOOLTIP HTML: Tipos das sessões encontradas:");
                sessoes.forEach((sessao, index) => {
                    console.log(
                        `   ${index + 1}. Tipo: "${
                            sessao.tipo || "N/A"
                        }" | Status: "${sessao.status}" | Data: "${
                            sessao.data
                        }"`
                    );
                });
            }

            // Determinar cor do header baseada na sessão atual
            let corHeader = "#5C85B4"; // Azul padrão do Figma

            if (sessoes && sessoes.length > 0) {
                // Pegar a primeira sessão (atual) ou procurar por uma marcada como atual
                const sessaoAtual =
                    sessoes.find((s) => s.isAtual) || sessoes[0];
                if (sessaoAtual && sessaoAtual.status) {
                    const status = sessaoAtual.status.toLowerCase();
                    if (
                        status.includes("incluído") ||
                        status.includes("pautado")
                    ) {
                        corHeader = "#5C85B4"; // Azul padrão do Figma
                    } else if (status.includes("retirado")) {
                        corHeader = "#CE2D4F"; // Vermelho
                    } else if (status.includes("vista")) {
                        corHeader = "#FFBF46"; // Amarelo
                    } else if (status.includes("julgado")) {
                        corHeader = "#3AB795"; // Verde do Figma
                    } else if (status.includes("adiado")) {
                        corHeader = "#F55D3E"; // Laranja do Figma
                    } else if (status.includes("sobrestado")) {
                        corHeader = "#FCB0B3"; // Rosa do Figma
                    } else if (
                        status.includes("diligência") ||
                        status.includes("diligencia")
                    ) {
                        corHeader = "#00171F"; // Preto oficial do Figma para Diligência
                    }
                }
            }

            // 🎨 MATERIAL SYMBOLS TOOLTIP - Clean and professional com proporções otimizadas
            let html = `
                <div style="
                    background: white;
                    border: 1px solid #e0e0e0;
                    border-radius: 12px;
                    width: 320px;
                    max-width: 90vw;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08);
                    font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    overflow: hidden;
                    font-size: 14px;
                    line-height: 1.4;
                ">
                    <!-- Header com Material Symbols -->
                    <div style="
                        background: ${corHeader};
                        color: white;
                        padding: 16px 20px;
                        display: flex;
                        align-items: center;
                        gap: 12px;
                    ">
                        <span class="material-symbols-outlined" style="
                            font-size: 28px !important;
                            vertical-align: middle;
                            flex-shrink: 0;
                        ">event_repeat</span>
                        <div>
                            <div style="font-weight: 600; font-size: 16px; margin-bottom: 2px;">
                                Sessões de Julgamento
                            </div>
                            <div style="font-size: 13px; opacity: 0.9;">
                                ${sessoes.length} ${
                sessoes.length === 1
                    ? "sessão encontrada"
                    : "sessões encontradas"
            }
                            </div>
                        </div>
                    </div>
                    
                    <!-- Conteúdo das sessões -->
                    <div style="padding: 20px;">`;

            sessoes.forEach((sessao, index) => {
                const isAtual = index === 0 || sessao.isAtual;

                // Determinar cor baseada no status da sessão individual
                let corStatus = "#757575"; // Cinza padrão
                if (sessao.status) {
                    const status = sessao.status.toLowerCase();
                    if (
                        status.includes("incluído") ||
                        status.includes("pautado")
                    ) {
                        corStatus = "#007acc"; // Azul para atual
                    } else if (status.includes("retirado")) {
                        corStatus = "#CE2D4F"; // Vermelho
                    } else if (status.includes("vista")) {
                        corStatus = "#FFBF46"; // Amarelo
                    } else if (status.includes("julgado")) {
                        corStatus = "#10B981"; // Verde
                    } else if (status.includes("adiado")) {
                        corStatus = "#F59E0B"; // Laranja
                    } else if (status.includes("sobrestado")) {
                        corStatus = "#8B5CF6"; // Roxo
                    }
                }

                // Background e border também usam a cor do status para sessão atual
                const backgroundCard = isAtual ? `${corStatus}15` : "#fafafa"; // 15 = ~8.5% opacity
                const borderCard = isAtual ? corStatus : "#e0e0e0";

                html += `
                    <div style="
                        background: ${backgroundCard};
                        border: 1px solid ${borderCard};
                        border-radius: 8px;
                        padding: 16px ${isAtual ? "50px" : "16px"} 16px 16px;
                        margin-bottom: ${
                            index < sessoes.length - 1 ? "12px" : "0"
                        };
                        position: relative;
                        transition: all 0.2s ease;
                        box-shadow: ${
                            isAtual
                                ? `0 4px 12px ${corStatus}20`
                                : "0 1px 3px rgba(0,0,0,0.08)"
                        };
                    ">
                        ${
                            isAtual
                                ? `
                        <div style="
                            position: absolute;
                            top: 8px;
                            right: 8px;
                            background: ${corStatus};
                            color: white;
                            padding: 3px 8px;
                            border-radius: 12px;
                            font-size: 9px;
                            font-weight: 600;
                            text-transform: uppercase;
                            letter-spacing: 0.5px;
                            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
                            z-index: 10;
                            min-width: 35px;
                            text-align: center;
                        ">ATUAL</div>
                        `
                                : ""
                        }
                        
                        <!-- Tipo de julgamento com Material Symbol -->
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 10px;
                            margin-bottom: 14px;
                        ">
                            <div style="
                                background: ${corStatus};
                                color: white;
                                padding: 6px 14px;
                                border-radius: 20px;
                                font-size: 11px;
                                font-weight: 600;
                                text-transform: uppercase;
                                letter-spacing: 0.5px;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                                flex-shrink: 0;
                            ">
                                ${(() => {
                                    const tipoFinal =
                                        sessao.tipo || "Julgamento";
                                    console.log(
                                        `🎯 TOOLTIP HTML: Inserindo tipo na sessão ${
                                            index + 1
                                        }: "${tipoFinal}"`
                                    );
                                    console.log(
                                        `📋 TOOLTIP HTML: Dados da sessão ${
                                            index + 1
                                        }:`,
                                        sessao
                                    );
                                    return tipoFinal;
                                })()}
                            </div>
                        </div>
                        
                        <!-- Status e Data com ícone gavel -->
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 10px;
                            margin-bottom: 12px;
                            flex-wrap: wrap;
                            min-height: 24px;
                        ">
                            <span class="material-symbols-outlined" style="
                                font-size: 16px;
                                color: #64748B;
                                vertical-align: middle;
                                flex-shrink: 0;
                            ">gavel</span>
                            <div style="
                                color: ${corStatus};
                                font-weight: 600;
                                font-size: 14px;
                                line-height: 1.2;
                                flex-shrink: 1;
                                word-break: break-word;
                            ">${sessao.status}</div>
                            <div style="
                                background: ${corStatus}20;
                                color: ${corStatus};
                                padding: 4px 10px;
                                border-radius: 12px;
                                font-size: 12px;
                                font-weight: 500;
                                white-space: nowrap;
                                flex-shrink: 0;
                            ">
                                ${sessao.data}
                            </div>
                        </div>
                        
                        <!-- Órgão Julgador com ícone -->
                        <div style="
                            display: flex;
                            align-items: flex-start;
                            gap: 8px;
                            color: #64748B;
                            font-size: 12px;
                            margin-bottom: 8px;
                            line-height: 1.4;
                        ">
                            <span class="material-symbols-outlined" style="
                                font-size: 16px !important;
                                vertical-align: middle;
                                color: #64748B;
                                flex-shrink: 0;
                                margin-top: 1px;
                            ">account_balance</span>
                            <span style="
                                font-weight: 500;
                                word-break: break-word;
                            ">${
                                traduzirSiglaOrgao(sessao.orgao) ||
                                "Órgão não identificado"
                            }</span>
                        </div>
                        
                        ${
                            sessao.dadosPauta
                                ? `
                        <!-- Modalidade da Sessão -->
                        <div style="
                            display: flex;
                            align-items: flex-start;
                            gap: 8px;
                            color: #64748B;
                            font-size: 12px;
                            margin-bottom: 8px;
                            line-height: 1.4;
                        ">
                            <span class="material-symbols-outlined" style="
                                font-size: 16px !important;
                                vertical-align: middle;
                                color: #64748B;
                                flex-shrink: 0;
                                margin-top: 1px;
                            ">${
                                sessao.dadosPauta.modalidade === "Virtual"
                                    ? "dvr"
                                    : "groups"
                            }</span>
                            <span style="
                                font-weight: 500;
                                word-break: break-word;
                            ">
                                ${
                                    sessao.dadosPauta.modalidade === "virtual"
                                        ? "Sessão Virtual"
                                        : "Sessão Física"
                                }
                            </span>
                        </div>
                        
                        <!-- Tipo de Inclusão + Sequencial -->
                        <div style="
                            display: flex;
                            align-items: flex-start;
                            gap: 8px;
                            color: #64748B;
                            font-size: 12px;
                            margin-bottom: 8px;
                            line-height: 1.4;
                        ">
                            <span class="material-symbols-outlined" style="
                                font-size: 16px !important;
                                vertical-align: middle;
                                color: #64748B;
                                flex-shrink: 0;
                                margin-top: 1px;
                            ">format_list_numbered</span>
                            <span style="
                                font-weight: 500;
                                word-break: break-word;
                            ">
                                ${
                                    sessao.dadosPauta.tipoInclusao ===
                                    "Incluído em mesa"
                                        ? "Mesa"
                                        : "Pauta"
                                } ${sessao.dadosPauta.sequencial}
                            </span>
                        </div>
                        `
                                : ""
                        }

                        ${
                            sessao.observacoes
                                ? `
                        <div style="
                            margin-top: 14px;
                            padding: 12px;
                            background: rgba(99, 102, 241, 0.06);
                            border-left: 3px solid #6366F1;
                            border-radius: 0 8px 8px 0;
                            font-size: 12px;
                            color: #4C4F69;
                            line-height: 1.5;
                        ">
                            <div style="display: flex; align-items: flex-start; gap: 8px;">
                                <span class="material-symbols-outlined" style="
                                    font-size: 16px;
                                    color: #6366F1;
                                    margin-top: 1px;
                                    flex-shrink: 0;
                                ">info</span>
                                <div>
                                    <strong>Observações:</strong> ${sessao.observacoes}
                                </div>
                            </div>
                        </div>
                        `
                                : ""
                        }
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            console.log("✅ TOOLTIP HTML: HTML do tooltip criado com sucesso!");
            console.log(
                "📏 TOOLTIP HTML: Tamanho do HTML gerado:",
                html.length,
                "caracteres"
            );
            console.log("🎯 TOOLTIP HTML: Resumo do conteúdo criado:");
            console.log(
                `   - ${sessoes.length} ${
                    sessoes.length === 1
                        ? "sessão processada"
                        : "sessões processadas"
                }`
            );
            console.log(`   - Cor do header: ${corHeader}`);

            // Verificar se tipos foram incluídos no HTML
            const tiposIncluidos = sessoes.map((s) => s.tipo || "Julgamento");
            console.log(
                "🔍 TOOLTIP HTML: Verificando inclusão dos tipos no HTML:"
            );
            tiposIncluidos.forEach((tipo, index) => {
                const incluido = html.includes(tipo);
                console.log(
                    `   ${index + 1}. "${tipo}": ${
                        incluido ? "✅ Incluído" : "❌ Não encontrado"
                    }`
                );
            });

            return html;
        }

        // ========================================
        // 🔧 FUNÇÃO ÚNICA DE DIAGNÓSTICO E CORREÇÃO
        // ========================================

        /**
         * ÚNICA função de diagnóstico - substitui diagnosticarECorrigirTooltip e todas as outras
         */
        function diagnosticarSistemaCompleto() {
            console.log(
                "🔧 DIAGNÓSTICO COMPLETO: Verificando sistema unificado..."
            );

            // 1. Detectar sessões
            const dadosSessoes = detectarSessoesUnificado(true);

            // 2. Verificar card
            const card = document.getElementById("eprobe-data-sessao");

            // 3. Aplicar tooltip se card existir
            if (card && dadosSessoes) {
                aplicarTooltipUnificado(card, dadosSessoes.todasSessoes);
                console.log("✅ DIAGNÓSTICO: Sistema corrigido com sucesso");
                return true;
            } else {
                console.log(
                    "❌ DIAGNÓSTICO: Card não encontrado ou sem dados de sessão"
                );
                return false;
            }
        }

        // ============================================================================
        // 🎨 SISTEMA DE TEMAS INTEGRADO (ex-themeApply.js)
        // ============================================================================

        // Função para controlar exibição da data da sessão
        function toggleSessionDateDisplay(isEnabled) {
            const sessionDateElement =
                document.getElementById("eprobe-data-sessao");

            if (sessionDateElement) {
                if (isEnabled) {
                    sessionDateElement.style.display = "flex";
                    log("✅ Data da sessão exibida");
                } else {
                    sessionDateElement.style.display = "none";
                    logError("❌ Data da sessão ocultada");
                }
            } else {
                log("ℹ️ Elemento da data da sessão não encontrado na página");
            }
        }

        // Função para aplicar estilos do tema (definida globalmente)
        function applyThemeStyles(themeName) {
            log(`🎨 Aplicando tema ${themeName}...`);

            // Salvar tema no localStorage
            localStorage.setItem("eprobe_selected_theme", themeName);

            // Definir gradientes dos temas
            const gradientes = {
                blue: "linear-gradient(to left, #0d1c2c, #007ebd)",
                dark: "linear-gradient(to left, #1a1a1a, #696363)",
                light: "linear-gradient(to left, #94A3B8, #475569)",
                violet: "linear-gradient(to left, #6b46c1, #4c1d95)",
                green: "linear-gradient(to left, #17a394, #0c4f5c)",
            };

            const gradiente = gradientes[themeName] || gradientes.blue;

            // Aplicar CSS imediatamente
            const cssNavbarTema = document.createElement("style");
            cssNavbarTema.id = "eprobe-navbar-instant-immediate";
            cssNavbarTema.textContent = `
                /* NAVBAR APLICADA IMEDIATAMENTE NO CARREGAMENTO DO SCRIPT */
                #navbar.navbar.bg-instancia,
                .navbar.bg-instancia,
                nav.navbar.bg-instancia,
                .navbar.text-white.bg-instancia,
                .navbar.text-white.d-xl-flex.bg-instancia {
                    background-image: ${gradiente} !important;
                    display: flex !important;
                    align-items: center !important;
                    min-height: 50px !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    transition: background-image 0.3s ease !important;
                }
                
                #navbar.navbar.bg-instancia > *,
                .navbar.bg-instancia > *,
                nav.navbar.bg-instancia > * {
                    display: flex !important; 
                    align-items: center !important;
                    min-height: 50px !important;
                }
                
                /* 🎯 REGRA CRÍTICA OBRIGATÓRIA: .d-none.d-md-flex SEMPRE FLEX */
                .d-none.d-md-flex,
                div.d-none.d-md-flex,
                .navbar .d-none.d-md-flex,
                #navbar .d-none.d-md-flex {
                    display: flex !important;
                    align-items: center !important;
                }
            `;

            // Remover CSS anterior se existir
            const cssAnterior = document.getElementById(
                "eprobe-navbar-instant-immediate"
            );
            if (cssAnterior) {
                cssAnterior.remove();
            }

            // Aplicar novo CSS
            const head =
                document.head ||
                document.getElementsByTagName("head")[0] ||
                document.documentElement;
            if (head) {
                head.insertBefore(cssNavbarTema, head.firstChild);
                log(`🎨 Tema ${themeName} aplicado com sucesso na navbar`);
            }

            // Disparar evento para notificar outros componentes
            window.dispatchEvent(
                new CustomEvent("eprobe-theme-changed", {
                    detail: { theme: themeName, gradient: gradiente },
                })
            );
        }

        /**
         * 🎯 FUNÇÃO PARA UNIFICAR ESTILOS DA NAVBAR
         * Força a aplicação dos estilos de navbar quando necessário
         */
        function unificarNavbarStyles() {
            console.log("🔧 NAVBAR: Unificando estilos da navbar...");

            try {
                // Obter tema atual
                const temaAtual =
                    localStorage.getItem("eprobe_selected_theme") || "blue";

                // Definir gradientes
                const gradientes = {
                    blue: "linear-gradient(to left, #0d1c2c, #007ebd)",
                    dark: "linear-gradient(to left, #1a1a1a, #696363)",
                    light: "linear-gradient(to left, #94A3B8, #475569)",
                    violet: "linear-gradient(to left, #6b46c1, #4c1d95)",
                    green: "linear-gradient(to left, #17a394, #0c4f5c)",
                };

                const gradiente = gradientes[temaAtual] || gradientes.blue;

                // Buscar elementos da navbar
                const navbarElements = document.querySelectorAll(
                    "#navbar.navbar.bg-instancia, .navbar.bg-instancia, nav.navbar.bg-instancia"
                );

                if (navbarElements.length > 0) {
                    navbarElements.forEach((navbar) => {
                        navbar.style.setProperty(
                            "background-image",
                            gradiente,
                            "important"
                        );
                        navbar.style.setProperty(
                            "display",
                            "flex",
                            "important"
                        );
                        navbar.style.setProperty(
                            "align-items",
                            "center",
                            "important"
                        );
                        navbar.style.setProperty(
                            "min-height",
                            "50px",
                            "important"
                        );
                    });

                    // Forçar flexbox nos elementos .d-none.d-md-flex
                    const flexElements =
                        document.querySelectorAll(".d-none.d-md-flex");
                    flexElements.forEach((element) => {
                        element.style.setProperty(
                            "display",
                            "flex",
                            "important"
                        );
                        element.style.setProperty(
                            "align-items",
                            "center",
                            "important"
                        );
                    });

                    console.log(
                        `✅ NAVBAR: Tema ${temaAtual} aplicado em ${navbarElements.length} elementos`
                    );
                    return true;
                } else {
                    console.log(
                        "⚠️ NAVBAR: Nenhum elemento de navbar encontrado"
                    );
                    return false;
                }
            } catch (error) {
                console.error("❌ NAVBAR: Erro ao unificar estilos:", error);
                return false;
            }
        }

        /**
         * 🔍 FUNÇÃO DE DEBUG PARA VERIFICAR CORES NA PÁGINA
         * Encontra elementos com cores específicas para diagnosticar
         */
        function debugEncontrarCores() {
            console.log(
                "🔍 DEBUG: Procurando elementos com cores específicas..."
            );

            const elementos = document.querySelectorAll("*");
            let elementosEncontrados = 0;
            let coresEncontradas = new Set();

            elementos.forEach((el) => {
                const style = window.getComputedStyle(el);
                const bgColor = style.backgroundColor;
                const bg = style.background;

                // Registrar todas as cores encontradas
                if (
                    bgColor &&
                    bgColor !== "rgba(0, 0, 0, 0)" &&
                    bgColor !== "transparent"
                ) {
                    coresEncontradas.add(bgColor);
                }

                // Procurar especificamente por nossa cor
                if (
                    bgColor.includes("235") &&
                    bgColor.includes("242") &&
                    bgColor.includes("223")
                ) {
                    elementosEncontrados++;

                    console.log(
                        `🎯 ELEMENTO ${elementosEncontrados} ENCONTRADO:`,
                        {
                            tag: el.tagName,
                            classe: el.className,
                            id: el.id,
                            backgroundColor: bgColor,
                            background: bg.substring(0, 100) + "...",
                            match: bgColor === "rgb(235, 242, 223)",
                        }
                    );
                }
            });

            console.log(`📊 RESUMO:`, {
                elementosComCorEspecifica: elementosEncontrados,
                totalCoresUnicas: coresEncontradas.size,
                amostrasCores: Array.from(coresEncontradas).slice(0, 10),
            });

            return {
                encontrados: elementosEncontrados,
                cores: Array.from(coresEncontradas),
            };
        }

        /**
         * 🎨 FUNÇÃO PARA CORREÇÃO CONSERVADORA DE COR DE FUNDO
         * Altera APENAS background-color preservando background-image
         * Corrige elementos com rgb(235, 242, 223) para #C8E6C9
         */
        function corrigirCorDeFundoConservadora() {
            console.log("🎨 CORREÇÃO: Alterando cor de fundo dos elementos...");

            const elementos = document.querySelectorAll("*");
            let elementosProcessados = 0;

            elementos.forEach((el) => {
                const style = window.getComputedStyle(el);
                const bgColor = style.backgroundColor;

                if (bgColor === "rgb(235, 242, 223)") {
                    elementosProcessados++;

                    console.log(`📦 ELEMENTO ${elementosProcessados}:`, {
                        tag: el.tagName,
                        classe: el.className,
                        corOriginal: bgColor,
                    });

                    try {
                        // Aplicar nova cor #C8E6C9
                        el.style.setProperty(
                            "background-color",
                            "#C8E6C9",
                            "important"
                        );

                        console.log(
                            `✅ ELEMENTO ${elementosProcessados}: Cor alterada para #C8E6C9!`
                        );
                    } catch (error) {
                        console.error(
                            `❌ ERRO no elemento ${elementosProcessados}:`,
                            error
                        );
                    }
                }
            });

            console.log(`\n📊 RESUMO FINAL:`);
            console.log(`  ✅ Elementos processados: ${elementosProcessados}`);
            console.log(`  🎯 Nova cor aplicada: #C8E6C9 (verde suave)`);

            return { processados: elementosProcessados };
        }

        // Função para verificar e aplicar tema salvo - SIMPLIFICADA
        function loadAndApplyTheme() {
            // CSS instantâneo já cuida da aplicação - apenas sincronizar storage
            try {
                const localTheme = localStorage.getItem(
                    "eprobe_selected_theme"
                );
                if (localTheme) {
                    log(
                        `⚡ Tema local encontrado: ${localTheme} - CSS instantâneo já aplicado`
                    );
                }
            } catch (e) {
                console.warn("⚠️ Erro ao acessar localStorage:", e);
            }

            // Sincronizar com chrome.storage sem reaplicar estilos
            if (typeof chrome !== "undefined" && chrome.storage) {
                chrome.storage.sync.get(["selectedTheme"], function (result) {
                    // Detectar tema padrão baseado no domínio
                    let temaDefault = "blue";
                    const currentUrl = window.location.href;

                    if (currentUrl.includes("eproc2g.tjsc.jus.br")) {
                        temaDefault = "green"; // Verde para eproc2g
                    } else if (currentUrl.includes("eproc1g.tjsc.jus.br")) {
                        temaDefault = "blue"; // Azul para eproc1g
                    }

                    const savedTheme = result.selectedTheme || temaDefault;
                    log(
                        `💾 Tema determinado: ${savedTheme} (domínio padrão: ${temaDefault})`
                    );

                    // Salvar no localStorage para próxima vez (CSS instantâneo usará isso)
                    try {
                        localStorage.setItem(
                            "eprobe_selected_theme",
                            savedTheme
                        );
                        log(`✅ Tema ${savedTheme} salvo no localStorage`);
                    } catch (e) {
                        console.warn("⚠️ Erro ao salvar no localStorage:", e);
                    }
                });
            } else {
                // Fallback: garantir tema baseado no domínio no localStorage
                const currentUrl = window.location.href;
                let temaDefault = "blue";

                if (currentUrl.includes("eproc2g.tjsc.jus.br")) {
                    temaDefault = "green"; // Verde para eproc2g
                } else if (currentUrl.includes("eproc1g.tjsc.jus.br")) {
                    temaDefault = "blue"; // Azul para eproc1g
                }

                log(
                    `🔄 Chrome storage não disponível, garantindo tema ${temaDefault}`
                );
                try {
                    localStorage.setItem("eprobe_selected_theme", temaDefault);
                } catch (e) {
                    console.warn("⚠️ Erro ao definir tema fallback:", e);
                }
            }
        }

        // Verifica configuração inicial da data da sessão - OTIMIZADA
        if (typeof chrome !== "undefined" && chrome.storage) {
            chrome.storage.sync.get(
                ["highlightSessionDate"],
                function (result) {
                    const isEnabled = result.highlightSessionDate !== false; // default true
                    log(
                        `💾 Configuração inicial do destaque da data da sessão: ${
                            isEnabled ? "ATIVO" : "INATIVO"
                        }`
                    );

                    // Aplica a configuração imediatamente se o elemento já existir
                    toggleSessionDateDisplay(isEnabled);
                }
            );
        }

        // Escuta mudanças no storage para sincronizar temas em tempo real
        if (typeof chrome !== "undefined" && chrome.storage) {
            chrome.storage.onChanged.addListener(function (changes, area) {
                log(
                    "🔄 STORAGE: Mudança detectada no storage:",
                    changes,
                    "área:",
                    area
                );
                if (area === "sync") {
                    // Mudança de tema - apenas sincronizar localStorage
                    if (changes.selectedTheme) {
                        const newTheme = changes.selectedTheme.newValue;
                        log(
                            `🔄 Tema alterado para: ${newTheme} - sincronizando localStorage`
                        );
                        try {
                            localStorage.setItem(
                                "eprobe_selected_theme",
                                newTheme
                            );
                            // CSS instantâneo detectará mudança via listener storage
                            log(
                                `✅ Tema ${newTheme} sincronizado - CSS instantâneo aplicará automaticamente`
                            );
                        } catch (e) {
                            console.warn("⚠️ Erro ao sincronizar tema:", e);
                        }
                    }

                    // Mudança no destaque da data da sessão
                    if (changes.highlightSessionDate) {
                        const isEnabled = changes.highlightSessionDate.newValue;
                        log(
                            `🔄 Destaque da data da sessão alterado para: ${
                                isEnabled ? "ATIVO" : "INATIVO"
                            }`
                        );
                        toggleSessionDateDisplay(isEnabled);
                    }
                }
            });
            log("✅ STORAGE: Listener de mudanças registrado");
        }

        // Aplica tema IMEDIATAMENTE para evitar delay visual
        logCritical("🎨 eProbe Theme Script carregado");
        loadAndApplyTheme();

        // Exposição das funções globais para chamada direta (debugging)
        window.applyThemeStyles = applyThemeStyles;
        window.unificarNavbarStyles = unificarNavbarStyles;
        window.testVioletTheme = function () {
            log("🧪 TESTE: Aplicando tema violeta diretamente...");
            applyThemeStyles("violet");
        };
        log("🌐 GLOBAL: Funções de tema expostas globalmente");
        log(
            "🧪 TESTE: Use window.testVioletTheme() para testar o tema violeta"
        );

        // ============================================================================
        // 🎨 FIM DO SISTEMA DE TEMAS INTEGRADO
        // ============================================================================

        // ============================================================================
        // 🧠 SEMANTIC KERNEL INTEGRADO (ex-semanticKernel.js)
        // ============================================================================

        /**
         * eProbe Semantic Kernel - Módulo Experimental
         * Implementação controlada para testes iniciais
         * Foco: Detecção inteligente de datas de sessão
         */

        // 🧠 CONFIGURAÇÃO EXPERIMENTAL DO SEMANTIC KERNEL
        class eProbeSemanticKernel {
            constructor() {
                this.isEnabled = false;
                this.testMode = true;
                this.fallbackToRegex = true;
                this.apiKey = null;
                this.requestCount = 0;
                this.maxRequests = 5; // Limite para testes

                log(
                    "🧠 SEMANTIC KERNEL: Módulo inicializado em modo experimental"
                );
            }

            // 🔧 CONFIGURAÇÃO E INICIALIZAÇÃO
            async initialize() {
                log("🧠 SEMANTIC KERNEL: Tentando inicializar...");

                try {
                    // Verificar se há API key configurada
                    this.apiKey = await this.getApiKey();
                    if (!this.apiKey) {
                        log(
                            "⚠️ SEMANTIC KERNEL: API Key não encontrada - usando modo fallback"
                        );
                        return false;
                    }

                    this.isEnabled = true;
                    logCritical("✅ SEMANTIC KERNEL: Inicializado com sucesso");
                    return true;
                } catch (error) {
                    console.error(
                        "❌ SEMANTIC KERNEL: Erro na inicialização:",
                        error
                    );
                    return false;
                }
            }

            async getApiKey() {
                // Reutilizar a mesma API key do eProbe
                if (typeof window.SENT1_AUTO?.getStoredApiKey === "function") {
                    return await window.SENT1_AUTO.getStoredApiKey();
                }
                return null;
            }

            // 🎯 FUNÇÃO PRINCIPAL: Detecção Inteligente de Datas
            async detectarDataSessaoIA(textoCompleto) {
                if (!this.isEnabled || this.requestCount >= this.maxRequests) {
                    log(
                        "🧠 SEMANTIC KERNEL: Usando fallback (regex tradicional)"
                    );
                    return await this.fallbackDetection(textoCompleto);
                }

                log(
                    "🧠 SEMANTIC KERNEL: Iniciando detecção inteligente de data da sessão"
                );
                this.requestCount++;

                try {
                    const prompt =
                        this.createDateDetectionPrompt(textoCompleto);
                    const response = await this.callOpenAI(prompt);
                    const resultado = this.parseResponse(response);

                    if (resultado && resultado.dataEncontrada) {
                        log(
                            `✅ SEMANTIC KERNEL: Data detectada via IA: ${resultado.dataEncontrada}`
                        );
                        return {
                            dataEncontrada: resultado.dataEncontrada,
                            confianca: resultado.confianca || 0.8,
                            contexto: resultado.contexto || "",
                            metodo: "semantic-kernel",
                        };
                    } else {
                        log(
                            "⚠️ SEMANTIC KERNEL: IA não encontrou data, usando fallback"
                        );
                        return await this.fallbackDetection(textoCompleto);
                    }
                } catch (error) {
                    console.error(
                        "❌ SEMANTIC KERNEL: Erro na detecção IA:",
                        error
                    );
                    return await this.fallbackDetection(textoCompleto);
                }
            }

            // 📝 CRIAÇÃO DO PROMPT ESPECIALIZADO
            createDateDetectionPrompt(textoCompleto) {
                // Limitar o texto para evitar custos excessivos
                const textoLimitado = textoCompleto.substring(0, 2000);

                return `Você é um especialista em documentos jurídicos brasileiros do sistema eProc/TJSC.

    TAREFA: Encontrar a data da sessão de julgamento no texto fornecido.

    CONTEXTO: O texto vem de uma página do eProc que pode conter informações sobre quando um processo foi pautado para julgamento.

    PADRÕES TÍPICOS A PROCURAR:
    - "Data da sessão: DD/MM/AAAA"
    - "Sessão de julgamento em DD/MM/AAAA"
    - "Julgamento para DD/MM/AAAA"
    - "Pautado em DD/MM/AAAA"
    - "Agendado para DD/MM/AAAA"

    FORMATO DE RESPOSTA OBRIGATÓRIO (JSON):
    {
    "dataEncontrada": "DD/MM/AAAA ou null",
    "confianca": 0.0-1.0,
    "contexto": "texto ao redor da data encontrada",
    "explicacao": "por que esta data foi escolhida"
    }

    REGRAS:
    1. Apenas datas no formato brasileiro DD/MM/AAAA
    2. Apenas datas entre 2020 e 2030
    3. Se não encontrar com certeza, retorne dataEncontrada: null
    4. Priorize datas relacionadas a sessões/julgamentos
    5. Ignore datas de protocolo, autuação ou outras não relacionadas a julgamento

    TEXTO PARA ANÁLISE:
    ${textoLimitado}

    RESPOSTA (apenas JSON válido):`;
            }

            // 🔗 CHAMADA PARA OPENAI API
            async callOpenAI(prompt) {
                const response = await fetch(
                    "https://api.openai.com/v1/chat/completions",
                    {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            Authorization: `Bearer ${this.apiKey}`,
                        },
                        body: JSON.stringify({
                            model: "gpt-3.5-turbo",
                            messages: [
                                {
                                    role: "user",
                                    content: prompt,
                                },
                            ],
                            max_tokens: 200,
                            temperature: 0.1, // Baixa temperatura para respostas mais consistentes
                            response_format: { type: "json_object" },
                        }),
                    }
                );

                if (!response.ok) {
                    throw new Error(
                        `API Error: ${response.status} ${response.statusText}`
                    );
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            // 📊 PARSE DA RESPOSTA DA IA
            parseResponse(responseText) {
                try {
                    const response = JSON.parse(responseText);

                    // Validar estrutura da resposta
                    if (typeof response === "object" && response !== null) {
                        return {
                            dataEncontrada: response.dataEncontrada || null,
                            confianca: parseFloat(response.confianca) || 0.5,
                            contexto: response.contexto || "",
                            explicacao: response.explicacao || "",
                        };
                    }

                    return null;
                } catch (error) {
                    console.error(
                        "❌ SEMANTIC KERNEL: Erro ao fazer parse da resposta:",
                        error
                    );
                    return null;
                }
            }

            // 🔄 FALLBACK PARA REGEX TRADICIONAL
            async fallbackDetection(textoCompleto) {
                log(
                    "🔄 SEMANTIC KERNEL: Executando detecção via regex (fallback)"
                );

                // Usar os mesmos padrões do sistema atual
                const padroes = [
                    /(?:data\s*da\s*sess[aã]o|sess[aã]o\s*(?:de|em|para|:)?)\s*:?\s*(\d{1,2}\/\d{1,2}\/\d{4})/i,
                    /(?:julgamento\s*(?:em|para|:)|para\s*julgamento)\s*:?\s*(\d{1,2}\/\d{1,2}\/\d{4})/i,
                    /(?:pautado|agendar|agendado|marcado).*?(\d{1,2}\/\d{1,2}\/\d{4})/i,
                ];

                for (const padrao of padroes) {
                    const match = textoCompleto.match(padrao);
                    if (match) {
                        return {
                            dataEncontrada: match[1],
                            confianca: 0.7,
                            contexto: match[0],
                            metodo: "regex-fallback",
                        };
                    }
                }

                return null;
            }

            // 📈 FUNÇÕES DE MONITORAMENTO E DEBUG
            getStats() {
                return {
                    enabled: this.isEnabled,
                    requestCount: this.requestCount,
                    maxRequests: this.maxRequests,
                    requestsRemaining: this.maxRequests - this.requestCount,
                    testMode: this.testMode,
                    fallbackEnabled: this.fallbackToRegex,
                };
            }

            reset() {
                this.requestCount = 0;
                log("🔄 SEMANTIC KERNEL: Contador de requisições resetado");
            }

            disable() {
                this.isEnabled = false;
                log("🚫 SEMANTIC KERNEL: Desabilitado");
            }

            enable() {
                this.isEnabled = true;
                log("✅ SEMANTIC KERNEL: Habilitado");
            }
        }

        // 🌍 INSTÂNCIA GLOBAL DO SEMANTIC KERNEL
        window.eProbeSemanticKernel = new eProbeSemanticKernel();

        // 🔗 INTEGRAÇÃO COM O SISTEMA EXISTENTE
        // Função melhorada que usa IA + fallback
        async function detectarDataSessaoComIA() {
            log("🧠 INICIANDO: Detecção de data da sessão com IA");

            const sk = window.eProbeSemanticKernel;

            // Verificar se o Semantic Kernel está disponível
            if (!sk.isEnabled) {
                await sk.initialize();
            }

            // Obter texto da página
            const textoCompleto = document.body.innerText;

            try {
                // Tentar detecção com IA
                const resultado = await sk.detectarDataSessaoIA(textoCompleto);

                if (resultado && resultado.dataEncontrada) {
                    // Validar a data usando a função existente
                    if (
                        typeof window.SENT1_AUTO?.validarDataBrasileira ===
                        "function"
                    ) {
                        const dataValidada =
                            window.SENT1_AUTO.validarDataBrasileira(
                                resultado.dataEncontrada
                            );

                        if (dataValidada) {
                            log(
                                `✅ IA + VALIDAÇÃO: Data validada: ${dataValidada.dataFormatada}`
                            );
                            log(
                                `📊 IA: Método: ${resultado.metodo}, Confiança: ${resultado.confianca}`
                            );

                            return {
                                ...dataValidada,
                                metodoDeteccao: resultado.metodo,
                                confiancaIA: resultado.confianca,
                                contexto: resultado.contexto,
                            };
                        }
                    }
                }

                log(
                    "⚠️ IA: Não encontrou data válida, usando sistema original"
                );
                return null;
            } catch (error) {
                console.error("❌ IA: Erro na detecção:", error);
                return null;
            }
        }

        // ============================================================================
        // 🧠 FIM DO SEMANTIC KERNEL INTEGRADO
        // ============================================================================

        log("🚀 INIT: Iniciando eProbe após APIs ficarem prontas...");

        // 🌐 VARIÁVEIS GLOBAIS PARA DADOS DE SESSÃO - DECLARADAS NO TOPO
        var TipoJulgamentoProcessoPautado = null;
        var StatusJulgamento = null;
        var DataSessao = null;

        // Armazenar a data da sessão quando detectada
        let dataSessaoPautado = null;

        // Variável para armazenar qual processo tem a data da sessão detectada
        let processoComDataSessao = null;

        // Armazenar dados completos da sessão obtidos do cruzamento
        let dadosCompletosSessionJulgamento = null;

        // 🎨 CONTROLE DE ESTADO DOS CARDS MATERIAL DESIGN
        let materialDesignState = {
            cardAtivo: false,
            ultimaDeteccao: null,
            ultimoProcesso: null,
        };

        // 🛡️ CONTROLE DE REQUISIÇÕES - Prevenir spam e logout
        let tentativasCruzamento = 0;
        let ultimaTentativaCruzamento = 0;
        let cruzamentoEmAndamento = false;
        let cacheResultadoSessoes = null;
        let cacheValidoAte = 0;

        // 🔐 CONTROLE ÚNICO POR PROCESSO - Garantir apenas uma busca por processo
        let processosJaProcessados = new Set(); // Armazenar números de processos já processados

        // 📊 DECLARAÇÕES ANTECIPADAS DE FUNÇÕES ESSENCIAIS
        let obterNumeroProcesso,
            hasDataSessaoPautado,
            getDataSessaoPautado,
            resetDataSessaoPautado,
            resetControlesRequisicao;
        let inserirDataSessaoNaInterface,
            processoJaFoiProcessado,
            marcarProcessoComoProcessado;

        // 🔧 IMPLEMENTAÇÃO ANTECIPADA DAS FUNÇÕES ESSENCIAIS
        obterNumeroProcesso = function () {
            try {
                // Estratégias múltiplas para obter número do processo
                const strategies = [
                    // 1. Meta tag específica do eProc
                    () => {
                        const meta = document.querySelector(
                            'meta[name="NG_PROCESSO"]'
                        );
                        return meta ? meta.getAttribute("content") : null;
                    },
                    // 2. URL parameter
                    () => {
                        const params = new URLSearchParams(
                            window.location.search
                        );
                        return params.get("num_processo");
                    },
                    // 2b. Extrair do dadosIconLink (base64)
                    () => {
                        try {
                            const params = new URLSearchParams(
                                window.location.search
                            );
                            const dadosIconLink = params.get("dadosIconLink");
                            if (dadosIconLink) {
                                const decoded = atob(dadosIconLink);
                                const match = decoded.match(
                                    /numProcesso";s:\d+:"(\d{20})"/
                                );
                                if (match) {
                                    // Converter para formato com separadores
                                    const num = match[1];
                                    return `${num.slice(0, 7)}-${num.slice(
                                        7,
                                        9
                                    )}.${num.slice(9, 13)}.${num.slice(
                                        13,
                                        14
                                    )}.${num.slice(14, 16)}.${num.slice(
                                        16,
                                        20
                                    )}`;
                                }
                            }
                            return null;
                        } catch (error) {
                            console.error(
                                "❌ Erro ao decodificar dadosIconLink:",
                                error
                            );
                            return null;
                        }
                    },
                    // 3. Título da página
                    () => {
                        const match = document.title.match(
                            /(\d{7}-\d{2}\.\d{4}\.\d{1}\.\d{2}\.\d{4})/
                        );
                        return match ? match[1] : null;
                    },
                    // 4. Breadcrumb ou elementos de navegação
                    () => {
                        const breadcrumbs = document.querySelectorAll(
                            ".infraLocalizador, .breadcrumb"
                        );
                        for (const bc of breadcrumbs) {
                            const match = bc.textContent.match(
                                /(\d{7}-\d{2}\.\d{4}\.\d{1}\.\d{2}\.\d{4})/
                            );
                            if (match) return match[1];
                        }
                        return null;
                    },
                ];

                for (const strategy of strategies) {
                    const result = strategy();
                    if (result) {
                        log(`✅ PROCESSO: Encontrado: ${result}`);
                        return result;
                    }
                }

                logError("⚠️ PROCESSO: Número não encontrado");
                return null;
            } catch (error) {
                console.error("❌ PROCESSO: Erro ao obter número:", error);
                return null;
            }
        };

        hasDataSessaoPautado = function () {
            return (
                dataSessaoPautado !== null &&
                dataSessaoPautado !== undefined &&
                typeof dataSessaoPautado === "object" &&
                dataSessaoPautado.data && // Verificar se tem a propriedade data
                processoComDataSessao === obterNumeroProcesso()
            );
        };

        getDataSessaoPautado = function () {
            return hasDataSessaoPautado() ? dataSessaoPautado : null;
        };

        resetDataSessaoPautado = function () {
            dataSessaoPautado = null;
            processoComDataSessao = null;
            log("🔄 RESET: Dados de sessão resetados");
            return true;
        };

        resetControlesRequisicao = function () {
            tentativasCruzamento = 0;
            ultimaTentativaCruzamento = 0;
            cruzamentoEmAndamento = false;
            log("🔄 RESET: Controles de requisição resetados");
            return true;
        };

        inserirDataSessaoNaInterface = function () {
            try {
                log("🎯 INTERFACE: Iniciando inserção de card de sessão...");
                logCritical(
                    "🚨 INTERFACE: INÍCIO - inserirDataSessaoNaInterface()"
                );

                // Remover cards existentes
                const cardsExistentes = [
                    document.getElementById("eprobe-data-sessao"),
                    document.getElementById("eprobe-card-sessao-material"),
                ];

                cardsExistentes.forEach((card) => {
                    if (card) {
                        card.remove();
                        log("🗑️ INTERFACE: Card anterior removido");
                    }
                });

                // Verificar se temos dados
                if (!hasDataSessaoPautado()) {
                    logError("⚠️ INTERFACE: Sem dados de sessão disponíveis");

                    // Tentar detectar dados primeiro
                    log("  INTERFACE: Tentando detectar dados de sessão...");
                    const dadosDetectados = detectarCardSessaoSimplificado();

                    if (!dadosDetectados) {
                        logError(
                            "❌ INTERFACE: Não foi possível detectar dados de sessão"
                        );
                        return false;
                    }

                    log(
                        "✅ INTERFACE: Dados detectados durante inserção:",
                        dadosDetectados
                    );
                }

                const dados = getDataSessaoPautado();
                log("📊 INTERFACE: Dados para criação do card:", dados);

                // Preparar dados para o card Material
                const cardInfo = {
                    data:
                        dados?.data ||
                        dados?.dataFormatada ||
                        "Data não disponível",
                    status: dados?.status || "PAUTADO",
                    orgao:
                        traduzirSiglaOrgao(dados?.orgao) ||
                        "Órgão não informado",
                    tipo: dados?.tipo || "Tipo não informado",
                    totalSessoes: dados?.totalSessoes || 1,
                    sessoes: dados?.sessoes || [],
                };

                log(
                    "🎨 INTERFACE: Chamando criarCardSessaoMaterial com:",
                    cardInfo
                );

                // Usar a função Material Design
                const cardCriado = criarCardSessaoMaterial(cardInfo);

                if (cardCriado !== null) {
                    log(
                        "✅ INTERFACE: Card Material Design criado com sucesso!"
                    );

                    // Verificar se o card foi inserido no DOM
                    setTimeout(() => {
                        const cardNoDOM = document.getElementById(
                            "eprobe-card-sessao-material"
                        );
                        if (cardNoDOM) {
                            logCritical(
                                "✅ VERIFICAÇÃO: Card encontrado no DOM!"
                            );
                        } else {
                            logError(
                                "❌ VERIFICAÇÃO: Card NÃO encontrado no DOM!"
                            );
                        }
                    }, 100);

                    return true;
                } else {
                    logError(
                        "❌ INTERFACE: Falha ao criar card Material Design"
                    );
                    return false;
                }
            } catch (error) {
                console.error("❌ INTERFACE: Erro ao inserir card:", error);
                return false;
            }
        };

        // 🎯 FUNÇÃO SIMPLIFICADA DE INSERÇÃO DE CARD
        function inserirCardNaInterface(card) {
            try {
                logCritical(
                    "🎯 INSERÇÃO: Procurando local para inserir card..."
                );

                // Buscar local de inserção no eProc - MÉTODO ESPECÍFICO PARA txtMagistrado
                const txtMagistrado = document.getElementById("txtMagistrado");
                if (txtMagistrado) {
                    logCritical(
                        "🎯 INSERÇÃO: txtMagistrado encontrado, posicionando ao lado direito..."
                    );

                    // Criar wrapper para posicionamento lado a lado
                    const wrapper = document.createElement("div");
                    wrapper.style.cssText = `
                        display: flex !important;
                        align-items: center !important;
                        gap: 12px !important;
                        flex-wrap: wrap !important;
                        width: 100% !important;
                    `;

                    // Encontrar o container do txtMagistrado
                    const parentContainer = txtMagistrado.parentNode;
                    if (parentContainer) {
                        // Inserir o wrapper antes do txtMagistrado
                        parentContainer.insertBefore(wrapper, txtMagistrado);

                        // Mover o txtMagistrado para dentro do wrapper
                        wrapper.appendChild(txtMagistrado);

                        // Adicionar o card ao lado direito no wrapper
                        wrapper.appendChild(card);

                        // Garantir que o card tenha estilo inline adequado
                        card.style.cssText += `
                            margin-left: auto !important;
                            flex-shrink: 0 !important;
                            position: relative !important;
                        `;

                        logCritical(
                            "✅ INSERÇÃO: Card posicionado ao lado direito do txtMagistrado"
                        );
                        return true;
                    }
                }

                // Fallback: inserir próximo ao título
                const titulo = document.querySelector(
                    "h1, .infraTituloAutor, .infraAreaDados h2"
                );
                if (titulo) {
                    titulo.parentNode.insertBefore(card, titulo.nextSibling);
                    logCritical("✅ INSERÇÃO: Card inserido próximo ao título");
                    return true;
                }

                // Fallback final: inserir no início do conteúdo principal
                const main = document.querySelector(
                    "#divInfraAreaGlobal, #conteudo, main, body"
                );
                if (main) {
                    main.insertBefore(card, main.firstChild);
                    logCritical(
                        "✅ INSERÇÃO: Card inserido no conteúdo principal"
                    );
                    return true;
                }

                logError("❌ INSERÇÃO: Nenhum local de inserção encontrado");
                return false;
            } catch (error) {
                console.error("❌ Erro ao inserir card na interface:", error);
                return false;
            }
        }

        // 🧪 TESTE CRÍTICO PARA DETECÇÃO DINÂMICA DE FIELDSET
        function testarDeteccaoDinamicaFieldset() {
            logCritical(
                "🧪 TESTE CRÍTICO: Iniciando teste de detecção dinâmica de fieldset..."
            );

            // Testar detecção em detectarCardSessaoSimplificado
            try {
                logCritical("🔍 TESTANDO: detectarCardSessaoSimplificado...");
                const resultado1 = detectarCardSessaoSimplificado();
                logCritical(
                    `📊 RESULTADO Card Sessão: ${JSON.stringify(resultado1)}`
                );
            } catch (error) {
                logCritical(
                    `❌ ERRO em detectarCardSessaoSimplificado: ${error.message}`
                );
            }

            // Testar detecção em extrairLinkSessao
            try {
                logCritical("🔍 TESTANDO: extrairLinkSessao...");
                const resultado2 = extrairLinkSessao(1);
                logCritical(`📊 RESULTADO Link Sessão: ${resultado2}`);
            } catch (error) {
                logCritical(`❌ ERRO em extrairLinkSessao: ${error.message}`);
            }

            // 🚨 REMOVIDO: Chamada duplicada desnecessária de detectarSessoesUnificado()
            // Esta função já é chamada automaticamente pela detecção unificada

            logCritical(
                "✅ TESTE CRÍTICO: Detecção dinâmica de fieldset concluída!"
            );
        }

        // 🎨 FUNÇÃO PARA CRIAR CARD MATERIAL DE SESSÃO - DESIGN FIGMA
        function criarCardSessaoMaterial(cardInfo) {
            try {
                // 🚨 LOG CRÍTICO: Início da criação do card
                logCritical(
                    "🚨 CARD MATERIAL: Iniciando criarCardSessaoMaterial()"
                );
                logCritical(
                    `🕐 TIMESTAMP: ${new Date().toLocaleString("pt-BR")}`
                );
                logCritical("📊 DADOS RECEBIDOS:", cardInfo);
                logCritical(`🔍 PROCESSO: ${obterNumeroProcesso() || "N/A"}`);

                log("🎨 CRIANDO CARD MATERIAL FIGMA:", cardInfo);

                if (!cardInfo) {
                    logError("❌ CARD: cardInfo é null ou undefined");
                    return null;
                }

                log(
                    "✅ CARD: Validação inicial passou, verificando card existente..."
                );

                // Verificar se já existe um card
                const cardExistente = document.getElementById(
                    "eprobe-card-sessao-material"
                );
                if (cardExistente) {
                    log("ℹ️ CARD: Removendo card existente");
                    cardExistente.remove();
                }

                log("🎨 CARD: Processando cores e status...");

                // Mapeamento de cores do Figma por status
                const coresFigma = {
                    PAUTADO: "#5C85B4",
                    INCLUIDO: "#5C85B4",
                    RETIRADO: "#CE2D4F",
                    VISTA: "#FFBF46",
                    JULGADO: "#3AB795",
                    ADIADO: "#F55D3E",
                    ADIADO_935: "#731963",
                    SOBRESTADO: "#FCB0B3",
                    DILIGENCIA: "#00171F",
                };

                // Determinar status e cor
                const status = cardInfo.status || "PAUTADO";
                const statusKey = status
                    .toUpperCase()
                    .replace(/\s+/g, "_")
                    .replace(/[()\.]/g, "")
                    .normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, ""); // Remove acentos
                const corIcon = coresFigma[statusKey] || coresFigma["PAUTADO"];

                log(
                    "🎨 STATUS DETECTADO:",
                    status,
                    "→",
                    statusKey,
                    "→",
                    corIcon
                );

                log("📦 CARD: Criando elemento DOM...");

                // Criar card Material Light pequeno (design Figma)
                const card = document.createElement("div");
                card.id = "eprobe-card-sessao-material";
                card.className = "session-card";

                // Estilo do card Figma: Material Light pequeno - OTIMIZADO PARA POSICIONAMENTO
                card.style.cssText = `
                width: 190px !important;
                height: 60px !important;
                background: #FEF7FF !important;
                border: 0.75px solid #CAC4D0 !important;
                border-radius: 9px !important;
                box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15) !important;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif !important;
                display: flex !important;
                align-items: center !important;
                padding: 8px 12px !important;
                gap: 8px !important;
                cursor: pointer !important;
                transition: transform 0.2s ease !important;
                margin: 0 !important;
                flex-shrink: 0 !important;
                position: relative !important;
                z-index: 1000 !important;
                max-width: 190px !important;
                min-width: 190px !important;
            `;

                // Ícone de clock pequeno do Figma
                const iconSvg = `
                <svg width="25" height="25" viewBox="0 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2.48973 23.5714C1.80506 23.5714 1.21914 23.3408 0.731981 22.8796C0.244824 22.4184 0.00082991 21.8633 0 21.2143V4.71429C0 4.06607 0.243994 3.51136 0.731981 3.05014C1.21997 2.58893 1.80589 2.35793 2.48973 2.35714H3.7346V0H6.22433V2.35714H16.1833V0H18.673V2.35714H19.9179C20.6025 2.35714 21.1889 2.58814 21.6768 3.05014C22.1648 3.51214 22.4084 4.06686 22.4076 4.71429V10.2241C22.4076 10.558 22.2881 10.8381 22.0491 11.0644C21.81 11.2907 21.5146 11.4035 21.1627 11.4027C20.8108 11.4019 20.5154 11.2888 20.2764 11.0633C20.0374 10.8378 19.9179 10.558 19.9179 10.2241V9.42857H2.48973V21.2143H9.70995C10.0627 21.2143 10.3585 21.3274 10.5975 21.5537C10.8366 21.78 10.9556 22.0597 10.9548 22.3929C10.954 22.726 10.8345 23.0061 10.5963 23.2332C10.3581 23.4603 10.0627 23.573 9.70995 23.5714H2.48973ZM18.673 24.75C16.9509 24.75 15.4832 24.1753 14.2699 23.0258C13.0566 21.8763 12.4495 20.4867 12.4487 18.8571C12.4478 17.2276 13.0549 15.838 14.2699 14.6885C15.4849 13.539 16.9526 12.9643 18.673 12.9643C20.3934 12.9643 21.8615 13.539 23.0773 14.6885C24.2931 15.838 24.8998 17.2276 24.8973 18.8571C24.8948 20.4867 24.2877 21.8766 23.0761 23.0269C21.8644 24.1772 20.3967 24.7516 18.673 24.75ZM20.7581 21.6562L21.6295 20.8313L19.2954 18.6214V15.3214H18.0506V19.0929L20.7581 21.6562Z" fill="${corIcon}"/>
                </svg>
            `;

                // Texto do status mapeado
                const statusTextos = {
                    PAUTADO: "Pautado",
                    INCLUIDO: "Incluído em Pauta",
                    RETIRADO: "Retirado de Pauta",
                    VISTA: "Pedido de Vista",
                    JULGADO: "Julgado",
                    ADIADO: "Adiado",
                    ADIADO_935: "Adiado (art. 935)",
                    SOBRESTADO: "Sobrestado (art. 942)",
                    DILIGENCIA: "Conv. em Diligência",
                };

                const statusTexto = statusTextos[statusKey] || status;
                const dataTexto = cardInfo.data || "getData()";

                card.innerHTML = `
                <style>
                    .session-card:hover {
                        box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.3), 0px 2px 6px 2px rgba(0, 0, 0, 0.15);
                    }
                </style>
                <div style="flex-shrink: 0;">
                    ${iconSvg}
                </div>
                <div style="flex: 1; min-width: 0;">
                    <div style="
                        font-size: 14px; 
                        font-weight: 500; 
                        color: #1C1B1F; 
                        line-height: 20px;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    ">${statusTexto}</div>
                    <div style="
                        font-size: 12px; 
                        color: #49454F; 
                        line-height: 16px;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    ">Sessão: ${dataTexto}</div>
                </div>
            `;

                // Sistema de tooltip agora usa apenas a função unificada
                log(
                    "ℹ️ TOOLTIP: Tooltip será configurado pela função unificada após inserção do card"
                );

                // Inserir card usando a função de interface específica
                logCritical(
                    "🎯 INSERÇÃO: Tentando inserir card na interface..."
                );
                log("📍 CARD: Procurando local para inserção...");

                const inserido = inserirCardNaInterface(card);
                if (!inserido) {
                    // Fallback: inserir no body se não conseguir inserir na interface
                    logCritical(
                        "⚠️ FALLBACK: Inserindo card no body como fallback"
                    );
                    document.body.appendChild(card);
                    logError("⚠️ CARD FIGMA: Inserido como fallback no body");
                    log("📍 CARD: Posição fallback aplicada no body");
                } else {
                    logCritical(
                        "✅ SUCESSO: Card inserido na interface com sucesso!"
                    );
                    log("📍 CARD: Inserido na posição correta da interface");
                }

                log("✅ CARD FIGMA: Criado com design Material Light pequeno!");
                log("🎨 COR APLICADA:", corIcon, "para status:", statusTexto);

                // Verificação final
                const cardNoDom = document.getElementById(
                    "eprobe-card-sessao-material"
                );
                const cardVisivel =
                    cardNoDom && cardNoDom.style.display !== "none";

                logCritical(
                    `🔍 VERIFICAÇÃO FINAL: Card no DOM: ${!!cardNoDom}, Visível: ${cardVisivel}`
                );

                if (cardNoDom) {
                    const rect = cardNoDom.getBoundingClientRect();
                    log(
                        `📐 CARD: Posição final - x:${rect.x}, y:${rect.y}, width:${rect.width}, height:${rect.height}`
                    );

                    // 🎯 APLICAR TOOLTIP UNIFICADO DIRETAMENTE NO CARD
                    log(
                        "🎯 TOOLTIP: Aplicando tooltip unificado direto no card..."
                    );
                    try {
                        // ✅ USAR APENAS A FUNÇÃO UNIFICADA PARA EVITAR DUPLICAÇÃO
                        const resultadoTooltip = aplicarTooltipUnificado(
                            cardNoDom,
                            window.SENT1_AUTO?.todasSessoesDetectadas || null
                        );
                        if (
                            resultadoTooltip &&
                            resultadoTooltip.status === "sucesso"
                        ) {
                            logCritical(
                                "✅ TOOLTIP: Tooltip aplicado diretamente no card!"
                            );
                        } else {
                            logError(
                                "❌ TOOLTIP: Falha ao aplicar tooltip no card"
                            );
                        }
                    } catch (tooltipError) {
                        logError(
                            "❌ TOOLTIP: Erro ao aplicar tooltip:",
                            tooltipError
                        );
                    }
                }

                logCritical("✅ CARD MATERIAL: Criação concluída com sucesso!");
                return card;
            } catch (error) {
                logError("❌ CARD FIGMA: Erro ao criar card:", error);
                logError("📍 STACK TRACE:", error.stack);
                return null;
            }
        }

        // 🏛️ MAPA OFICIAL DE ÓRGÃOS TJSC - Conversão Sigla → Nome Completo
        const mapaOrgaosTJSC = {
            CAMCIV1: "1ª Câmara de Direito Civil",
            CAMCIV2: "2ª Câmara de Direito Civil",
            CAMCIV3: "3ª Câmara de Direito Civil",
            CAMCIV4: "4ª Câmara de Direito Civil",
            CAMCIV5: "5ª Câmara de Direito Civil",
            CAMCIV6: "6ª Câmara de Direito Civil",
            CAMCIV7: "7ª Câmara de Direito Civil",
            CAMCIV8: "8ª Câmara de Direito Civil",
            CAMCOM1: "1ª Câmara de Direito Comercial",
            CAMCOM2: "2ª Câmara de Direito Comercial",
            CAMCOM3: "3ª Câmara de Direito Comercial",
            CAMCOM4: "4ª Câmara de Direito Comercial",
            CAMCOM5: "5ª Câmara de Direito Comercial",
            CAMCOM6: "6ª Câmara de Direito Comercial",
            CAMCRI1: "1ª Câmara Criminal",
            CAMCRI2: "2ª Câmara Criminal",
            CAMCRI3: "3ª Câmara Criminal",
            CAMCRI4: "4ª Câmara Criminal",
            CAMCRI5: "5ª Câmara Criminal",
            CAMEEA1S: "1ª Câmara Especial de Enfrentamento de Acervos",
            CAMEEA2S: "2ª Câmara Especial de Enfrentamento de Acervos",
            CAMEEA3S: "3ª Câmara Especial de Enfrentamento de Acervos",
            CAMPREC: "Câmara de Precatórios",
            CAMPUB1: "1ª Câmara de Direito Público",
            CAMPUB2: "2ª Câmara de Direito Público",
            CAMPUB3: "3ª Câmara de Direito Público",
            CAMPUB4: "4ª Câmara de Direito Público",
            CAMPUB5: "5ª Câmara de Direito Público",
            SGRUCIV: "Grupo de Câmaras de Direito Civil",
            SGRUCOM: "Grupo de Câmaras de Direito Comercial",
            SGRUCRI1: "Primeiro Grupo de Direito Criminal",
            SGRUCRI2: "Segundo Grupo de Direito Criminal",
            SGRUPUB: "Grupo de Câmaras de Direito Público",
            SORGESP: "Órgão Especial",
            SCAMRECD: "Câmara de Recursos Delegados",
            TPLTURUNIF: "Turma de Uniformização",
            VPRES1: "1ª Vice-Presidência",
            VPRES2: "2ª Vice-Presidência",
            VPRES3: "3ª Vice-Presidência",
            SSECCRI: "Seção Criminal",
        };

        // 🔄 TRADUZIR SIGLA DO ÓRGÃO
        function traduzirSiglaOrgao(sigla) {
            if (!sigla) return "Órgão não identificado";

            // Limpar espaços e converter para maiúsculo
            sigla = sigla.trim().toUpperCase();

            // Primeiro, tentar match exato no mapa oficial
            if (mapaOrgaosTJSC[sigla]) {
                return mapaOrgaosTJSC[sigla];
            }

            // Fallback para códigos não mapeados
            return `${sigla} (Órgão)`;
        }

        // 🔗 FUNÇÃO PARA EXTRAIR LINK DA SESSÃO - MÉTODO COM MODAL
        function extrairLinkSessao(indiceSessao = 1) {
            try {
                log(`🔗 LINK: Extraindo link para sessão ${indiceSessao}`);

                // ETAPA 0: Detectar qual fieldset contém as sessões
                logCritical(
                    "🔍 LINK: Detectando fieldset correto para extração..."
                );
                let fieldsetCorreto = null;

                for (const fieldsetNum of [6, 7]) {
                    const xpathTeste = `/html/body/div[2]/div[3]/div[2]/div/div[1]/form[2]/div[3]/div/div/fieldset[${fieldsetNum}]/div/div[2]/fieldset/legend/span[1]/button`;
                    const elementoTeste = document.evaluate(
                        xpathTeste,
                        document,
                        null,
                        XPathResult.FIRST_ORDERED_NODE_TYPE,
                        null
                    ).singleNodeValue;

                    if (elementoTeste) {
                        fieldsetCorreto = fieldsetNum;
                        logCritical(
                            `✅ LINK: Fieldset[${fieldsetNum}] detectado como container das sessões`
                        );
                        break;
                    }
                }

                if (!fieldsetCorreto) {
                    logCritical(
                        "❌ LINK: Nenhum fieldset com sessões encontrado"
                    );
                    return null;
                }

                // ETAPA 1: Primeiro precisamos abrir o modal clicando no SVG
                const indiceSessaoIndex = indiceSessao + 1;
                const xpathTriggerModal = `/html/body/div[2]/div[3]/div[2]/div/div[1]/form[2]/div[3]/div/div/fieldset[${fieldsetCorreto}]/div/div[${indiceSessaoIndex}]/fieldset/legend/span[3]/svg`;

                const triggerElement = document.evaluate(
                    xpathTriggerModal,
                    document,
                    null,
                    XPathResult.FIRST_ORDERED_NODE_TYPE,
                    null
                ).singleNodeValue;

                if (!triggerElement) {
                    logCritical(
                        `❌ LINK: Elemento trigger do modal não encontrado para sessão ${indiceSessao} em fieldset[${fieldsetCorreto}] - XPath: ${xpathTriggerModal}`
                    );
                    return null;
                }

                // Clicar no elemento para abrir o modal
                logCritical(
                    `🖱️ LINK: Clicando no elemento para abrir modal da sessão ${indiceSessao}`
                );

                // Simular click no SVG que tem o onclick
                if (triggerElement.onclick) {
                    // Se tem onclick, executar diretamente
                    triggerElement.onclick();
                } else if (
                    triggerElement.parentElement &&
                    triggerElement.parentElement.onclick
                ) {
                    // Ou executar do elemento pai
                    triggerElement.parentElement.onclick();
                } else {
                    // Caso contrário, simular click
                    triggerElement.click();
                }

                // ETAPA 2: Aguardar um pouco para o modal carregar
                return new Promise((resolve) => {
                    setTimeout(() => {
                        try {
                            // XPath para o link dentro do modal aberto
                            const xpathLinkModal = `/html/body/div[1]/div/div/div/div[1]/div/div/div/div[2]/div/form/div[2]/div/table/tbody/tr[${indiceSessao}]/td[1]/a`;

                            const linkElement = document.evaluate(
                                xpathLinkModal,
                                document,
                                null,
                                XPathResult.FIRST_ORDERED_NODE_TYPE,
                                null
                            ).singleNodeValue;

                            if (linkElement && linkElement.href) {
                                // Obter o href completo
                                const linkCompleto = linkElement.href;
                                const hrefBruto =
                                    linkElement.getAttribute("href");

                                log(
                                    `🔍 LINK: href decodificado:`,
                                    linkCompleto
                                );
                                logCritical(
                                    `🔍 LINK: href bruto do HTML:`,
                                    hrefBruto
                                );

                                // Verificar se é o link correto da sessão
                                const contemSessao =
                                    linkCompleto.includes(
                                        "sessao_julgamento_exibir_painel"
                                    ) ||
                                    hrefBruto.includes(
                                        "sessao_julgamento_exibir_painel"
                                    ) ||
                                    linkCompleto.includes(
                                        "julgamento_historico_listar"
                                    ) ||
                                    hrefBruto.includes(
                                        "julgamento_historico_listar"
                                    );

                                logCritical(
                                    `🔍 LINK: Verificando se é link de sessão:`,
                                    {
                                        linkCompleto: linkCompleto.substring(
                                            0,
                                            200
                                        ),
                                        hrefBruto: hrefBruto
                                            ? hrefBruto.substring(0, 200)
                                            : null,
                                        contemSessao: contemSessao,
                                    }
                                );

                                if (contemSessao) {
                                    // Processar o link para extrair a URL correta
                                    let linkFinal = hrefBruto || linkCompleto;

                                    // Decodificar &amp; se necessário
                                    if (linkFinal.includes("&amp;")) {
                                        linkFinal = linkFinal.replace(
                                            /&amp;/g,
                                            "&"
                                        );
                                    }

                                    // Verificar se tem os parâmetros essenciais para sessão de julgamento
                                    const parametrosEssenciais = [
                                        "id_sessao_julgamento",
                                        "id_orgao_julgador",
                                        "txtNumProcesso",
                                    ];

                                    const temParametrosEssenciais =
                                        parametrosEssenciais.every((param) =>
                                            linkFinal.includes(param)
                                        );

                                    logCritical(
                                        `✅ LINK: Encontrado e extraído do modal para sessão ${indiceSessao}:`,
                                        linkFinal
                                    );
                                    logCritical(
                                        `📏 LINK: Tamanho do link extraído: ${linkFinal.length} caracteres`
                                    );
                                    logCritical(
                                        `📊 LINK: Parâmetros essenciais presentes: ${temParametrosEssenciais}`
                                    );

                                    if (temParametrosEssenciais) {
                                        logCritical(
                                            `🎯 LINK: Link completo da sessão de julgamento encontrado!`
                                        );
                                    } else {
                                        logCritical(
                                            `⚠️ LINK: Link pode estar incompleto - faltam parâmetros essenciais`
                                        );
                                    }

                                    resolve(linkFinal);
                                } else {
                                    logCritical(
                                        `❌ LINK: Formato inválido encontrado no modal para sessão ${indiceSessao}:`,
                                        linkCompleto
                                    );
                                    resolve(null);
                                }
                            } else {
                                logCritical(
                                    `❌ LINK: Link não encontrado no modal para sessão ${indiceSessao} - XPath: ${xpathLinkModal}`
                                );
                                resolve(null);
                            }
                        } catch (error) {
                            console.error(
                                `❌ LINK: Erro ao processar modal da sessão ${indiceSessao}:`,
                                error
                            );
                            resolve(null);
                        }
                    }, 1000); // Aguardar 1 segundo para o modal carregar
                });
            } catch (error) {
                console.error(
                    `❌ LINK: Erro ao extrair link da sessão ${indiceSessao}:`,
                    error
                );
                return null;
            }
        }

        // 🌐 FUNÇÃO PARA CONSTRUIR URL DA SESSÃO
        async function construirUrlSessao(dadosSessao) {
            try {
                logCritical("🌐 URL: Construindo URL da sessão", dadosSessao);

                // VERIFICAR SE JÁ ESTÁ NA PÁGINA DE SESSÃO
                const urlAtual = window.location.href;
                if (urlAtual.includes("sessao_julgamento_exibir_painel")) {
                    logCritical(
                        "✅ URL: Já está na página de sessão, usando URL atual:",
                        urlAtual
                    );
                    return urlAtual;
                }

                // Se não está na página de sessão, tentar extrair link real abrindo o modal
                logCritical(
                    "🔄 URL: Não está na página de sessão, extraindo link do modal..."
                );
                const linkReal = await extrairLinkSessao(
                    dadosSessao.indice || 1
                );

                if (linkReal) {
                    logCritical(
                        "🔗 URL: Link real extraído do modal:",
                        linkReal
                    );

                    // Se encontrou link real, usar ele completamente
                    const baseUrl = window.location.origin;
                    let urlFinal;

                    if (linkReal.startsWith("http")) {
                        urlFinal = linkReal;
                    } else if (linkReal.startsWith("controlador.php")) {
                        urlFinal = `${baseUrl}/eproc/${linkReal}`;
                    } else if (linkReal.startsWith("/")) {
                        urlFinal = `${baseUrl}${linkReal}`;
                    } else {
                        urlFinal = `${baseUrl}/eproc/${linkReal}`;
                    }

                    logCritical(
                        "🚀 URL: URL final construída para o card:",
                        urlFinal
                    );
                    return urlFinal;
                }

                logCritical(
                    "❌ URL: extrairLinkSessao retornou null - não foi possível encontrar link real no modal"
                );

                // URL básica como fallback - mas agora com mais parâmetros se disponíveis
                const baseUrl = window.location.origin;
                const urlBasica = `${baseUrl}/eproc/controlador.php?acao=sessao_julgamento_exibir_painel`;

                const numeroProcesso = obterNumeroProcesso();
                if (numeroProcesso) {
                    return `${urlBasica}&txtNumProcesso=${numeroProcesso}`;
                }

                return urlBasica;
            } catch (error) {
                console.error(
                    "❌ URL: Erro ao construir URL da sessão:",
                    error
                );
                return null;
            }
        }

        // ❌ FUNÇÃO REMOVIDA: detectarCardSessaoSimplificado()
        // ✅ USE AGORA: detectarSessoesUnificado()

        processoJaFoiProcessado = function (numeroProcesso) {
            return numeroProcesso && processosJaProcessados.has(numeroProcesso);
        };

        marcarProcessoComoProcessado = function (numeroProcesso) {
            if (numeroProcesso) {
                processosJaProcessados.add(numeroProcesso);
            }
        };

        // ⚡ SISTEMA DE DEBOUNCE GLOBAL - Prevenir execuções redundantes
        const debounceTimers = new Map();
        const domCache = new Map(); // Cache para elementos DOM
        const CACHE_EXPIRY = 60000; // Cache expira em 1 minuto

        function debounceGlobal(func, key, delay = 300) {
            if (debounceTimers.has(key)) {
                clearTimeout(debounceTimers.get(key));
            }

            const timerId = setTimeout(() => {
                func();
                debounceTimers.delete(key);
            }, delay);

            debounceTimers.set(key, timerId);
        }

        // 🧹 LIMPEZA AUTOMÁTICA DO CACHE
        setInterval(() => {
            const now = Date.now();
            for (const [key, value] of domCache.entries()) {
                if (now - value.timestamp > CACHE_EXPIRY) {
                    domCache.delete(key);
                }
            }
        }, 10000); // Limpar a cada 10 segundos

        let processoAtual = null; // Processo atual sendo visualizado

        // 🚫 CONTROLE GLOBAL DE REQUISIÇÕES
        let REQUISICOES_AUTOMATICAS_DESABILITADAS = true; // DESABILITAR TODAS AS REQUISIÇÕES AUTOMÁTICAS

        // 🔥 CONTROLE DE PERFORMANCE ULTRA
        let MODO_ULTRA_PERFORMANCE = false; // Controla operações custosas para otimizar performance

        // Configurações de segurança MAIS RIGOROSAS
        const MAX_TENTATIVAS_CRUZAMENTO = 1; // REDUZIDO: Máximo 1 tentativa por processo
        const DELAY_ENTRE_TENTATIVAS = 60000; // AUMENTADO: 1 minuto entre tentativas
        const CACHE_DURATION = 600000; // AUMENTADO: Cache válido por 10 minutos

        // Injetar CSS apenas para elementos da extensão eProbe
        const extensionStyle = document.createElement("style");
        extensionStyle.textContent = `
        @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
        
        /* Padronização da fonte Roboto APENAS para elementos da extensão eProbe */
        [id*="sent1"], [id*="documento-relevante"], [class*="eprobe"], 
        #sent1-auto-button, #documento-relevante-options-menu,
        #documento-relevante-selection-modal, #documento-relevante-preview-modal,
        #api-config-modal, #error-logs-modal, #api-key-config,
        .eprobe-notification, .eprobe-tooltip, .eprobe-modal, .eprobe-button, .eprobe-menu {
            font-family: "Roboto", -apple-system, system-ui, sans-serif !important;
        }
        
        /* Estilo específico para o botão documento-relevante-auto-button */
        #documento-relevante-auto-button {
            margin-right: 3px !important;
        }
        
        /* Elementos criados dinamicamente pela extensão */
        [id*="sent1"] *, [id*="documento-relevante"] *, [class*="eprobe"] *,
        #sent1-auto-button *, #documento-relevante-options-menu *,
        #documento-relevante-selection-modal *, #documento-relevante-preview-modal *,
        #api-config-modal *, #error-logs-modal *, #api-key-config *,
        .eprobe-notification *, .eprobe-tooltip *, .eprobe-modal *, .eprobe-button *, .eprobe-menu * {
            font-family: "Roboto", -apple-system, system-ui, sans-serif !important;
        }
        
        /* CORREÇÃO CRÍTICA: Ícones substituídos não devem interceptar cliques */
        .substituted-icon:not(.clickable-icon) {
            pointer-events: none !important;
        }
        
        /* Material Icons substituídos também não devem interceptar cliques */
        .material-symbols-outlined.substituted-icon:not(.clickable-icon) {
            pointer-events: none !important;
        }

        /* CRÍTICO: Containers de ícones substituídos também não devem interceptar cliques */
        span:has(.substituted-icon:not(.clickable-icon)) {
            pointer-events: none !important;
        }
        
        /* Fallback para navegadores que não suportam :has() */
        .eprobe-icon-container:not(.clickable-container) {
            pointer-events: none !important;
        }
        
        /* FORÇA MÁXIMA: SVGs de ícones eProbe (mas não os em links) */
        svg.substituted-icon:not(.clickable-icon) {
            pointer-events: none !important;
        }
        
        svg.iconeFerramentas:not(.clickable-icon) {
            pointer-events: none !important;
        }
        
        /* Especificamente para elementos com data-eprobe-icon-replaced (mas não em links) */
        [data-eprobe-icon-replaced="true"]:not(.clickable-icon) {
            pointer-events: none !important;
        }
        
        /* PRESERVAR clicabilidade para ícones dentro de botões e links - CORREÇÃO CRÍTICA */
        button .substituted-icon,
        button .iconeFerramentas,
        button [data-eprobe-icon-replaced="true"],
        button span,
        a .substituted-icon,
        a .iconeFerramentas,
        a [data-eprobe-icon-replaced="true"],
        .infraLegendObrigatorio button .substituted-icon,
        .infraLegendObrigatorio button .iconeFerramentas,
        .infraLegendObrigatorio button [data-eprobe-icon-replaced="true"],
        .infraLegendObrigatorio button span,
        .infraLegendObrigatorio .substituted-icon,
        .infraLegendObrigatorio .iconeFerramentas,
        .infraLegendObrigatorio [data-eprobe-icon-replaced="true"] {
            pointer-events: auto !important;
        }

        /* 📏 DIMENSIONAMENTO ESPECÍFICO: Ícones em divListaRecursosMinuta devem ter 17.59x17.59 */
        #divListaRecursosMinuta svg[data-eprobe-icon-replaced="true"],
        #divListaRecursosMinuta [data-eprobe-recursos-minuta-sized="true"] {
            width: 17.59px !important;
            height: 17.59px !important;
            min-width: 17.59px !important;
            min-height: 17.59px !important;
            max-width: 17.59px !important;
            max-height: 17.59px !important;
            vertical-align: middle !important;
            display: inline-block !important;
        }
        
        /* ALINHAMENTO CRÍTICO: Garantir que containers estejam perfeitamente alinhados */
        #divListaRecursosMinuta span:has(svg[data-eprobe-icon-replaced="true"]) {
            width: 17.59px !important;
            height: 17.59px !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            vertical-align: middle !important;
            line-height: 1 !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* CORREÇÃO DE ALINHAMENTO: Ícones originais e personalizados na mesma linha */
        #divListaRecursosMinuta img,
        #divListaRecursosMinuta svg[data-eprobe-icon-replaced="true"] {
            vertical-align: middle !important;
            display: inline-block !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* GARANTIR consistência com ícones nativos do eProc */
        #divListaRecursosMinuta a,
        #divListaRecursosMinuta a img,
        #divListaRecursosMinuta a svg {
            vertical-align: middle !important;
            line-height: 1 !important;
            display: inline-flex !important;
            align-items: center !important;
        }

        /* Estilos para SVGs inline - permitir customização */
        .eprobe-svg-icon {
            pointer-events: none !important;
            transition: all 0.2s ease;
        }
        
        .eprobe-svg-icon:hover {
            transform: scale(1.1);
            filter: brightness(1.2);
        }
        
        /* SVG específicos por tipo */
        .eprobe-svg-bubble {
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
        }
        
        .eprobe-svg-config {
            opacity: 0.8;
        }
        
        .eprobe-svg-config:hover {
            opacity: 1;
            transform: rotate(15deg) scale(1.1);
        }
        
        /* ⚡ OTIMIZAÇÃO PERFORMANCE: CSS hover substitui event listeners */
        .eprobe-button-hover:hover {
            background-color: rgb(19, 67, 119) !important;
            border-color: rgb(19, 67, 119) !important;
            transform: translateY(-1px) !important;
        }
        
        .eprobe-button-hover:focus {
            background-color: rgb(19, 67, 119) !important;
            border-color: rgb(19, 67, 119) !important;
            outline: 2px solid #ffffffff !important;
        }
        
        .eprobe-button-hover:active {
            background-color: #0a2d4f !important;
            transform: translateY(0) !important;
        }
        
        /* Botões de cancelar otimizados */
        .eprobe-cancel-button:hover {
            background-color: #4b5563 !important;
        }
        
        .eprobe-process-button:hover {
            background-color: #059669 !important;
        }
        
        /* Botões PDF otimizados */
        .eprobe-pdf-cancel-button:hover {
            background-color: #91433d !important;
            border-color: #91433d !important;
        }
        
        /* ⚡ ANTI-FLASH TOTAL: Sistema robusto para eliminar completamente o flash visual */
        
        /* 1. Ocultar QUALQUER elemento de lembrete até ser processado */
        .lista-lembretes .lembrete:not(.eprobe-lembrete-processado),
        div.divLembrete:not(.eprobe-lembrete-processado) {
            visibility: hidden !important;
            opacity: 0 !important;
            position: relative !important;
            min-width: 315px !important;
            min-height: 140px !important;
        }
        
        /* 2. Mostrar apenas elementos processados */
        .lista-lembretes .lembrete.eprobe-lembrete-processado,
        div.divLembrete.eprobe-lembrete-processado {
            visibility: visible !important;
            opacity: 1 !important;
            transition: opacity 0.2s ease-in-out !important;
            min-width: 315px !important;
            min-height: 140px !important;
        }
        
        /* 3. Pré-aplicar estilos ANTES do elemento aparecer */
        .lista-lembretes .lembrete.eprobe-lembrete-processado,
        div.divLembrete.eprobe-lembrete-processado {
            padding: 20px !important;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
            transition: box-shadow 0.5s ease !important;
            -webkit-font-smoothing: subpixel-antialiased !important;
            min-width: 315px !important;
            min-height: 140px !important;


        }
        
        /* 4. Material Icons são tratados pela regra global posterior */
        
        /* Botões de abertura otimizados */
        .eprobe-open-button:hover {
            background-color: rgba(148, 163, 184, 0.1) !important;
        }
        
        /* Container e botão de remoção otimizados - MÚLTIPLAS ESPECIFICIDADES */
        .eprobe-container-hover .eprobe-remove-button {
            opacity: 0 !important;
            transition: opacity 0.2s ease !important;
        }
        
        /* Forçar especificidade extra para garantir que funcione */
        div.eprobe-container-hover .eprobe-remove-button,
        .eprobe-container-hover button.eprobe-remove-button {
            opacity: 0 !important;
            transition: opacity 0.2s ease !important;
        }
        
        .eprobe-container-hover:hover .eprobe-remove-button {
            opacity: 1 !important;
        }
        
        /* Hover com especificidade extra */
        div.eprobe-container-hover:hover .eprobe-remove-button,
        .eprobe-container-hover:hover button.eprobe-remove-button {
            opacity: 1 !important;
        }
        
        /* Efeitos hover para o ícone SVG do botão de remover */
        .eprobe-remove-button {
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            transition: all 0.2s ease !important;
        }
        
        .eprobe-remove-button svg {
            transition: all 0.2s ease !important;
        }
        
        .eprobe-remove-button:hover svg {
        fill: #dc2626 !important;
        transform: scale(1.1) !important;
        }
        
        /* Opções de menu otimizadas */
        .eprobe-menu-option {
            background-color: transparent !important;
            transition: background-color 0.2s ease;
        }
        
        .eprobe-menu-option:hover {
            background-color: #f8f9fa !important;
        }
    `;
        document.head.appendChild(extensionStyle);

        // Adicionar Material Icons History e Chat Bubble com PRELOAD para carregamento instantâneo
        if (
            !document.querySelector('link[href*="Material+Symbols+Outlined"]')
        ) {
            // Usar preload para carregamento mais rápido
            const materialIconsHistory = document.createElement("link");
            materialIconsHistory.rel = "preload";
            materialIconsHistory.as = "style";
            materialIconsHistory.href =
                "https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=history_2,gavel";
            materialIconsHistory.onload = function () {
                this.onload = null;
                this.rel = "stylesheet";
            };
            document.head.appendChild(materialIconsHistory);

            // Carregar CSS dos Material Symbols com preload
            const materialIconsCSS = document.createElement("link");
            materialIconsCSS.rel = "preload";
            materialIconsCSS.as = "style";

            // Verificar se chrome.runtime está disponível (contexto de extensão)
            if (
                typeof chrome !== "undefined" &&
                chrome.runtime &&
                chrome.runtime.getURL
            ) {
                materialIconsCSS.href = chrome.runtime.getURL(
                    "src/material-icons.css"
                );
            } else {
                // Fallback para teste local - usar caminho relativo
                materialIconsCSS.href = "src/material-icons.css";
            }

            materialIconsCSS.onload = function () {
                this.onload = null;
                this.rel = "stylesheet";
            };
            document.head.appendChild(materialIconsCSS);

            log(
                "⚡ FONTS: Material Icons carregados com preload para velocidade máxima"
            );
        }

        // ===== INÍCIO DO SISTEMA DE PROCESSAMENTO DE DOCUMENTOS =====
        (async function () {
            let debugMode = true;
            let isAutomationActive = false;

            // Configuração dos tipos de documentos relevantes - VERSÃO EXPANDIDA
            const TIPOS_DOCUMENTO_RELEVANTE = {
                SENT: { nome: "SENT", descricao: "Sentença", dataNome: "SENT" },
                INIC: {
                    nome: "INIC",
                    descricao: "Petição Inicial",
                    dataNome: "INIC",
                },
                PET1: {
                    nome: "PET1",
                    descricao: "Petição 1",
                    dataNome: "PET1",
                },
                /*          DECI: {
                nome: "DESPADEC",
                descricao: "Decisão",
                dataNome: "DESPADEC",
            }, */
            };

            function logDebug(message, ...args) {
                if (debugMode) {
                    console.log("PROCESSAR DOCUMENTO:", message, ...args);
                }
            }

            // Detectar tipo de página e formato de documento - usando expressão de função
            const detectPageType = function () {
                const url = window.location.href;
                logDebug("🔍 Detectando tipo de página. URL:", url);

                if (url.includes("processo_selecionar")) {
                    return "lista_documentos";
                } else if (url.includes("sessao_julgamento_exibir_painel")) {
                    logDebug("📊 Página de sessão de julgamento detectada");
                    return "sessao_julgamento";
                } else if (
                    url.includes("acessar_documento") ||
                    url.includes("processo_consultar_externo_documento")
                ) {
                    // 🔧 DETECÇÃO MELHORADA PARA EPROC
                    logDebug("🔍 Detectando tipo de documento no eProc...");

                    // ✅ ESTRATÉGIA 1: Verificar MimeType=pdf na URL (mais confiável)
                    const urlParams = new URLSearchParams(
                        window.location.search
                    );
                    const dadosIconLink = urlParams.get("dadosIconLink");

                    let isPdfByUrl = false;
                    if (dadosIconLink) {
                        try {
                            // Decodificar base64 e verificar MimeType
                            const decoded = atob(dadosIconLink);
                            isPdfByUrl =
                                decoded.includes('"MimeType";s:3:"pdf"') ||
                                decoded.includes("MimeType=pdf");
                            logDebug(
                                `✅ MimeType detectado na URL: ${
                                    isPdfByUrl ? "PDF" : "Outro"
                                }`
                            );
                        } catch (e) {
                            logDebug(
                                "⚠️ Erro ao decodificar dadosIconLink:",
                                e.message
                            );
                        }
                    }

                    // ✅ ESTRATÉGIA 2: Verificar URL diretamente
                    const isPdfByUrlDirect =
                        url.toLowerCase().includes("pdf") ||
                        url.includes("MimeType");

                    // Detectar se é documento HTML (sentença) ou PDF (petição inicial)
                    const sectionSentenca = document.querySelector(
                        'section[data-nome="sentenca"]'
                    );

                    // ✅ DETECÇÃO ESPECÍFICA PARA EPROC PDFs
                    const eprocPdfSelectors = [
                        // eProc usa principalmente estes padrões
                        'iframe[src*="acessar_documento"]',
                        'iframe[src*="processo_consultar"]',
                        'iframe[src*="pdf"]',
                        'iframe[title*="PDF"]',
                        'iframe[type*="pdf"]',
                        'embed[type="application/pdf"]',
                        'embed[src*="pdf"]',
                        'object[type="application/pdf"]',
                        'object[data*="pdf"]',
                        "#plugin", // Comum no eProc
                        'iframe[name="plugin"]',
                        'embed[name="plugin"]',
                        // Chrome PDF viewer específico
                        'embed[type="application/x-google-chrome-pdf"]',
                    ];

                    let pdfViewer = null;
                    let foundWith = null;

                    // Testar cada seletor específico para eProc
                    for (const selector of eprocPdfSelectors) {
                        pdfViewer = document.querySelector(selector);
                        if (pdfViewer) {
                            foundWith = selector;
                            logDebug(
                                `✅ PDF eProc encontrado com: ${selector}`
                            );
                            break;
                        }
                    }

                    // Se não encontrou com seletores específicos, analisar todos os elementos
                    if (!pdfViewer) {
                        const allElements = [
                            ...document.querySelectorAll("iframe"),
                            ...document.querySelectorAll("embed"),
                            ...document.querySelectorAll("object"),
                        ];

                        for (const element of allElements) {
                            const src = element.src || element.data || "";
                            const type = element.type || "";
                            const title = element.title || "";
                            const name = element.name || "";

                            // ✅ LÓGICA ESPECÍFICA PARA EPROC
                            const isPdfElement =
                                // URL contém parâmetros de documento eProc
                                src.includes("acessar_documento") ||
                                src.includes("processo_consultar") ||
                                // Tipo específico de PDF
                                type.toLowerCase().includes("pdf") ||
                                type.includes(
                                    "application/x-google-chrome-pdf"
                                ) ||
                                // Nome comum no eProc
                                name === "plugin" ||
                                // Título indica PDF
                                title.toLowerCase().includes("pdf") ||
                                // URL explicitamente PDF
                                src.toLowerCase().includes(".pdf");

                            if (isPdfElement) {
                                pdfViewer = element;
                                foundWith = `Análise de ${
                                    element.tagName
                                }: ${src.substring(0, 50)}...`;
                                logDebug(
                                    `✅ PDF eProc detectado por análise: ${foundWith}`
                                );
                                break;
                            }
                        }
                    }

                    // Debug detalhado
                    logDebug("🔍 Análise completa de elementos:", {
                        url: url.substring(0, 100),
                        isPdfByUrl: isPdfByUrl,
                        isPdfByUrlDirect: isPdfByUrlDirect,
                        sectionSentenca: !!sectionSentenca,
                        pdfViewer: !!pdfViewer,
                        foundWith: foundWith,
                        totalIframes:
                            document.querySelectorAll("iframe").length,
                        totalEmbeds: document.querySelectorAll("embed").length,
                        totalObjects:
                            document.querySelectorAll("object").length,
                        dadosIconLink: dadosIconLink
                            ? dadosIconLink.substring(0, 50) + "..."
                            : "N/A",
                    });

                    // ✅ DECISÃO FINAL: PDF detectado por qualquer estratégia
                    const isPdfDocument =
                        isPdfByUrl || isPdfByUrlDirect || !!pdfViewer;

                    // Determinar tipo final
                    if (sectionSentenca && !isPdfDocument) {
                        logDebug("📄 Documento HTML detectado (sentença)");
                        return "documento_html";
                    } else if (isPdfDocument) {
                        logDebug(
                            `📄 Documento PDF detectado! Método: ${
                                isPdfByUrl
                                    ? "URL MimeType"
                                    : isPdfByUrlDirect
                                    ? "URL Direct"
                                    : foundWith
                            }`
                        );
                        return "documento_pdf";
                    } else {
                        logDebug(
                            "📄 Documento específico (tipo indefinido) - verificando conteúdo..."
                        );

                        // Verificar se há conteúdo típico de documento
                        const hasDocumentContent =
                            document.querySelector(".documento") ||
                            document.querySelector(".conteudo") ||
                            document.querySelector(".texto") ||
                            document.querySelector("main") ||
                            document.querySelector("article") ||
                            document.body.textContent.length > 1000;

                        if (hasDocumentContent) {
                            logDebug(
                                "📄 Conteúdo de documento detectado - assumindo documento específico"
                            );
                            return "documento_especifico";
                        } else {
                            logDebug(
                                "❌ Nenhum conteúdo de documento detectado"
                            );
                            return "desconhecida";
                        }
                    }
                }

                return "desconhecida";
            };
            function isValidPageForButton() {
                // Verificar se está na página do processo (formulário frmProcessoLista + título específico)
                const formProcessoLista =
                    document.querySelector("#frmProcessoLista");
                const tituloConsultaProcessual = document.querySelector("h1");

                const hasTituloCorreto =
                    tituloConsultaProcessual &&
                    tituloConsultaProcessual.textContent.includes(
                        "Consulta Processual - Detalhes do Processo"
                    );

                if (formProcessoLista && hasTituloCorreto) {
                    log(
                        "Página válida detectada: formulário #frmProcessoLista E título 'Consulta Processual - Detalhes do Processo' encontrados (página do processo)"
                    );
                    return true;
                }

                // Para compatibilidade com documento específico (página de visualização do documento)
                const pageType = detectPageType();
                if (
                    pageType === "documento_especifico" ||
                    pageType === "documento_html" ||
                    pageType === "documento_pdf"
                ) {
                    log("Página válida detectada: documento específico");
                    return true;
                }

                // Verificar URLs específicas do eProc que podem conter documentos
                const url = window.location.href;
                if (
                    url.includes("eproc") &&
                    (url.includes("documento") || url.includes("processo"))
                ) {
                    log(
                        "Página válida detectada: URL contém eproc e documento/processo"
                    );
                    return true;
                }

                // Verificar se há tabelas com links de documentos relevantes (SENT, INIC, etc.)
                const hasDocumentLinks = !!(
                    document.querySelector('[href*="SENT"]') ||
                    document.querySelector('[href*="INIC"]') ||
                    document.querySelector('[href*="DECI"]') ||
                    document.querySelector('[href*="DESP"]')
                );

                if (hasDocumentLinks) {
                    log(
                        "Página válida detectada: contém links de documentos relevantes"
                    );
                    return true;
                }

                log("Página não é válida para o botão:", {
                    url: url,
                    pageType: pageType,
                    hasFormProcessoLista: !!formProcessoLista,
                    hasTituloCorreto: hasTituloCorreto,
                    tituloAtual: tituloConsultaProcessual
                        ? tituloConsultaProcessual.textContent
                        : "não encontrado",
                    hasTable: !!document.querySelector("table"),
                    hasDocumentLinks: hasDocumentLinks,
                    hasEventDesc: !!document.querySelector(
                        ".infraEventoDescricao"
                    ),
                });
                return false;
            }

            // 📋 FUNÇÕES DE DETECÇÃO E PROCESSAMENTO DA PÁGINA "MEUS LOCALIZADORES"

            // Função para salvar separadores no localStorage
            function salvarSeparadores(separadores) {
                try {
                    const chave = "eprobe_separadores_localizadores";
                    localStorage.setItem(chave, JSON.stringify(separadores));
                    log("💾 LOCALIZADORES: Separadores salvos no localStorage");
                } catch (error) {
                    console.error(
                        "❌ LOCALIZADORES: Erro ao salvar separadores:",
                        error
                    );
                }
            }

            // Função para carregar separadores do localStorage
            function carregarSeparadores() {
                try {
                    const chave = "eprobe_separadores_localizadores";
                    const dados = localStorage.getItem(chave);
                    if (dados) {
                        const separadores = JSON.parse(dados);
                        log(
                            "📂 LOCALIZADORES: Separadores carregados do localStorage:",
                            separadores.length
                        );
                        return separadores;
                    }
                } catch (error) {
                    console.error(
                        "❌ LOCALIZADORES: Erro ao carregar separadores:",
                        error
                    );
                }
                return [];
            }

            // Função para salvar lista de separadores removidos
            function salvarSeparadoresRemovidos(removidos) {
                try {
                    const chave = "eprobe_separadores_removidos";
                    localStorage.setItem(chave, JSON.stringify(removidos));
                    log(
                        "🗑️ LOCALIZADORES: Lista de removidos salva no localStorage"
                    );
                } catch (error) {
                    console.error(
                        "❌ LOCALIZADORES: Erro ao salvar removidos:",
                        error
                    );
                }
            }

            // Função para carregar lista de separadores removidos
            function carregarSeparadoresRemovidos() {
                try {
                    const chave = "eprobe_separadores_removidos";
                    const dados = localStorage.getItem(chave);
                    if (dados) {
                        const removidos = JSON.parse(dados);
                        log(
                            "📂 LOCALIZADORES: Separadores removidos carregados:",
                            removidos.length
                        );
                        return removidos;
                    }
                } catch (error) {
                    console.error(
                        "❌ LOCALIZADORES: Erro ao carregar removidos:",
                        error
                    );
                }
                return [];
            }

            // Função para detectar e processar página "Meus Localizadores"
            function detectarPaginaLocalizadores() {
                const currentUrl = window.location.href;

                // Verifica se está na página de Meus Localizadores
                if (
                    !currentUrl.includes(
                        "acao=usuario_tipo_monitoramento_localizador_listar"
                    )
                ) {
                    return false;
                }

                console.log(
                    "📋 LOCALIZADORES: Página 'Meus Localizadores' detectada"
                );

                // Processa a tabela de localizadores
                processarTabelaLocalizadores();

                return true;
            }

            // Função para processar a tabela de localizadores
            function processarTabelaLocalizadores() {
                console.log(
                    "🔍 LOCALIZADORES: Iniciando processamento da tabela"
                );

                // Busca a tabela de localizadores
                const tabela = document.querySelector(
                    'table.infraTable[summary*="Localizadores"]'
                );

                if (!tabela) {
                    console.log(
                        "⚠️ LOCALIZADORES: Tabela de localizadores não encontrada"
                    );
                    return;
                }

                console.log(
                    "✅ LOCALIZADORES: Tabela encontrada, processando..."
                );

                // Destaca localizadores urgentes
                destacarLocalizadoresUrgentes(tabela);

                // Adiciona interface de separadores
                adicionarInterfaceSeparadores(tabela);

                // Restaurar separadores salvos
                restaurarSeparadores(tabela);
            } // Função para restaurar separadores salvos
            function restaurarSeparadores(tabela) {
                log("🔄 LOCALIZADORES: Restaurando separadores salvos");

                // Verificar se já existem separadores na página para evitar duplicação
                const separadoresExistentes = tabela.querySelectorAll(
                    ".eprobe-divisor-linha"
                );
                if (separadoresExistentes.length > 0) {
                    log(
                        "ℹ️ LOCALIZADORES: Separadores já existem na página, evitando duplicação"
                    );
                    return;
                }

                const separadoresSalvos = carregarSeparadores();

                if (separadoresSalvos.length === 0) {
                    log("ℹ️ LOCALIZADORES: Nenhum separador salvo encontrado");
                    return;
                }

                const tbody = tabela.querySelector("tbody");
                if (!tbody) {
                    log(
                        "⚠️ LOCALIZADORES: tbody não encontrado para restaurar separadores"
                    );
                    return;
                }

                const linhasOriginais = Array.from(
                    tbody.querySelectorAll("tr:not(.eprobe-divisor-linha)")
                );

                // Ordenar separadores por posição para inserir na ordem correta
                separadoresSalvos.sort((a, b) => a.posicao - b.posicao);

                separadoresSalvos.forEach((separadorData) => {
                    let linhaReferencia = null;

                    // Encontrar linha de referência pela posição
                    if (
                        separadorData.posicao > 0 &&
                        separadorData.posicao <= linhasOriginais.length
                    ) {
                        linhaReferencia =
                            linhasOriginais[separadorData.posicao - 1];
                    }

                    // Criar o separador com flag de restauração para evitar salvar novamente
                    const separadorCriado = criarDivisorEditavel(
                        tabela,
                        linhaReferencia,
                        separadorData.texto,
                        true
                    );

                    // Adicionar ID do separador salvo ao elemento restaurado
                    if (separadorCriado) {
                        separadorCriado.setAttribute(
                            "data-separador-id",
                            separadorData.id
                        );
                        log(
                            `✅ LOCALIZADORES: Separador "${separadorData.texto}" restaurado na posição ${separadorData.posicao}`
                        );
                    }
                });

                log(
                    `🔄 LOCALIZADORES: ${separadoresSalvos.length} separador(es) restaurado(s)`
                );
            }

            // Função para destacar localizadores com palavra "urgente"
            function destacarLocalizadoresUrgentes(tabela) {
                log("🔴 LOCALIZADORES: Destacando localizadores urgentes");

                const linhas = tabela.querySelectorAll("tbody tr");
                let urgentesEncontrados = 0;

                linhas.forEach((linha, index) => {
                    const primeiraColuna =
                        linha.querySelector("td:first-child");

                    if (primeiraColuna) {
                        const textoLocalizador =
                            primeiraColuna.textContent.toLowerCase();

                        // Verifica se contém a palavra "urgente" (case insensitive)
                        if (textoLocalizador.includes("urgente")) {
                            // Aplica estilo de destaque vermelho suave
                            linha.style.backgroundColor = "#fecaca";
                            linha.style.border = "1px solid #f87171";
                            linha.style.transition = "all 0.2s ease";

                            urgentesEncontrados++;
                            log(
                                `🔴 LOCALIZADORES: Linha ${
                                    index + 1
                                } marcada como urgente: "${primeiraColuna.textContent.trim()}"`
                            );
                        }
                    }
                });

                if (urgentesEncontrados > 0) {
                    log(
                        `✅ LOCALIZADORES: ${urgentesEncontrados} localizador(es) urgente(s) destacado(s)`
                    );
                } else {
                    log(
                        "ℹ️ LOCALIZADORES: Nenhum localizador urgente encontrado"
                    );
                }
            }

            // Função para criar divisores editáveis na tabela de localizadores
            function criarDivisorEditavel(
                tabela,
                linhaPosicao,
                textoInicial = "Seção",
                isRestoracao = false
            ) {
                log("📝 LOCALIZADORES: Criando divisor editável");
                log("🔧 DEBUG: Parâmetros recebidos:", {
                    tabela,
                    linhaPosicao,
                    textoInicial,
                    isRestoracao,
                });

                if (!tabela) {
                    log(
                        "⚠️ LOCALIZADORES: Tabela não fornecida para criar divisor"
                    );
                    return null;
                }

                const tbody = tabela.querySelector("tbody");
                log("🔧 DEBUG: tbody encontrado:", tbody);

                if (!tbody) {
                    logError(
                        "⚠️ LOCALIZADORES: tbody não encontrado na tabela"
                    );
                    return null;
                }

                // Contar colunas da tabela para criar divisor do tamanho correto
                const primeiraLinhaComCelulas =
                    tbody.querySelector("tr") ||
                    tabela.querySelector("thead tr");
                let totalColunas = 2; // Padrão para localizadores

                if (primeiraLinhaComCelulas) {
                    const celulas =
                        primeiraLinhaComCelulas.querySelectorAll("td, th");
                    totalColunas = celulas.length;
                }

                log(`🔧 DEBUG: Número de colunas detectado: ${totalColunas}`);

                // Criar nova linha divisor
                const linhaDivisor = document.createElement("tr");
                linhaDivisor.className = "eprobe-divisor-linha";
                linhaDivisor.style.backgroundColor = "#f3f4f6";
                linhaDivisor.style.borderTop = "2px solid #6b7280";
                linhaDivisor.style.borderBottom = "1px solid #d1d5db";

                // Criar célula que ocupa todas as colunas
                const celulaDivisor = document.createElement("td");
                celulaDivisor.colSpan = totalColunas;
                celulaDivisor.style.padding = "12px";
                celulaDivisor.style.textAlign = "center";
                celulaDivisor.style.position = "relative";

                // Criar container para o título editável
                const containerTitulo = document.createElement("div");
                containerTitulo.style.position = "relative";
                containerTitulo.style.display = "inline-flex";
                containerTitulo.style.alignItems = "center";
                containerTitulo.style.justifyContent = "center";

                // Criar ícone do separador
                const iconeSeparador = document.createElement("span");
                iconeSeparador.style.cssText = `
                display: grid !important;
                margin-right: 10px !important;
                vertical-align: middle !important;
                width: 16px !important;
                height: 16px !important;
            `;
                iconeSeparador.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 3px !important; vertical-align: middle;">
                    <path d="m16 16-4 4-4-4"/>
                    <path d="M3 12h18"/>
                    <path d="m8 8 4-4 4 4"/>
                </svg>
            `;

                // Criar título editável (sem caixa, apenas texto)
                const tituloEditavel = document.createElement("span");
                tituloEditavel.textContent = textoInicial;
                tituloEditavel.contentEditable = true;
                tituloEditavel.style.cssText = `
            font-weight: bold;
            color: #374151;
            font-size: 14px;
            cursor: text;
            outline: none;
            border: none;
            background: transparent;
            min-width: 100px;
            display: inline-block;
            text-align: center;
            transition: background-color 0.2s ease;
        `;

                // Adicionar eventos para edição
                tituloEditavel.addEventListener("focus", function () {
                    this.style.backgroundColor = "#f3f4f6";
                    this.style.borderRadius = "4px";
                    this.style.padding = "2px 6px";
                });

                tituloEditavel.addEventListener("blur", function () {
                    this.style.backgroundColor = "transparent";
                    this.style.padding = "0";

                    // Salvar alteração na persistência
                    salvarAlteracaoSeparador(
                        linhaDivisor,
                        this.textContent.trim()
                    );
                });

                tituloEditavel.addEventListener("keydown", function (e) {
                    if (e.key === "Enter") {
                        e.preventDefault();
                        this.blur(); // Força o blur para salvar
                    }
                    if (e.key === "Escape") {
                        e.preventDefault();
                        this.textContent = textoInicial; // Restaura valor original
                        this.blur();
                    }
                });

                // Adicionar tooltip com instruções
                tituloEditavel.title =
                    "Clique para editar o nome do separador\n• Enter: Salvar\n• Escape: Cancelar";

                // Criar botão para remover divisor (discreto, só aparece no hover)
                const botaoRemover = document.createElement("button");
                botaoRemover.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="16px" viewBox="0 -960 960 960" width="16px" fill="#374151"><path d="m350-281 130.19-130.19L610.37-281 679-349.63 548.81-479.81 679-610l-69-69-130.19 130.19L349.63-679 281-610.37l130.19 130.18L281-350l69 69ZM218.87-113.7q-43.63 0-74.4-30.77-30.77-30.77-30.77-74.4v-522.26q0-43.63 30.77-74.4 30.77-30.77 74.4-30.77h522.26q43.63 0 74.4 30.77 30.77 30.77 30.77 74.4v522.26q0 43.63-30.77 74.4-30.77 30.77-74.4 30.77H218.87Zm0-105.17h522.26v-522.26H218.87v522.26Zm0-522.26v522.26-522.26Z"/></svg>`;
                botaoRemover.style.cssText = `
            position: relative;
            top: 0;
            margin-left: 8px;
            border: none;
            background: transparent;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            line-height: 1;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: middle;
            padding: 4px;
        `;
                botaoRemover.title = "Remover divisor";

                // ⚡ OTIMIZAÇÃO: CSS hover em vez de event listeners
                containerTitulo.classList.add("eprobe-container-hover");
                botaoRemover.classList.add("eprobe-remove-button");

                // Evento para remover divisor
                botaoRemover.addEventListener("click", function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // Remover da persistência antes de remover do DOM
                    removerSeparadorDoPersistencia(linhaDivisor);

                    linhaDivisor.remove();
                    log("🗑️ LOCALIZADORES: Divisor removido");
                });

                // Adicionar elementos ao container
                containerTitulo.appendChild(iconeSeparador);
                containerTitulo.appendChild(tituloEditavel);
                containerTitulo.appendChild(botaoRemover);
                celulaDivisor.appendChild(containerTitulo);
                linhaDivisor.appendChild(celulaDivisor);

                // Inserir divisor na posição especificada
                log("🔧 DEBUG: Inserindo divisor. linhaPosicao:", linhaPosicao);
                if (linhaPosicao && linhaPosicao.nextSibling) {
                    tbody.insertBefore(linhaDivisor, linhaPosicao.nextSibling);
                    log("🔧 DEBUG: Divisor inserido após linha específica");
                } else {
                    tbody.appendChild(linhaDivisor);
                    log("🔧 DEBUG: Divisor inserido no final da tabela");
                }

                logCritical("✅ LOCALIZADORES: Divisor criado com sucesso");

                // Salvar separador na persistência (apenas se não for uma restauração)
                if (!isRestoracao) {
                    salvarSeparadorNaPersistencia(
                        linhaDivisor,
                        textoInicial,
                        linhaPosicao
                    );
                }

                return linhaDivisor;
            }

            // Função para salvar separador na persistência
            function salvarSeparadorNaPersistencia(
                linhaDivisor,
                texto,
                linhaPosicao
            ) {
                const tabela = linhaDivisor.closest("table");
                if (!tabela) return;

                const tbody = tabela.querySelector("tbody");
                const todasLinhas = Array.from(
                    tbody.querySelectorAll("tr:not(.eprobe-divisor-linha)")
                );

                // Calcular posição baseada na linha de referência
                let posicao = todasLinhas.length; // Por padrão, no final

                if (linhaPosicao) {
                    const indice = todasLinhas.findIndex(
                        (linha) => linha === linhaPosicao
                    );
                    if (indice !== -1) {
                        posicao = indice + 1; // Posição após a linha de referência
                    }
                }

                const separadoresSalvos = carregarSeparadores();

                const novoSeparador = {
                    id: Date.now(), // ID único baseado em timestamp
                    texto: texto,
                    posicao: posicao,
                    criadoEm: new Date().toISOString(),
                };

                separadoresSalvos.push(novoSeparador);
                salvarSeparadores(separadoresSalvos);

                // Adicionar ID ao elemento para facilitar remoção
                linhaDivisor.setAttribute(
                    "data-separador-id",
                    novoSeparador.id
                );

                log(
                    "💾 LOCALIZADORES: Separador salvo na persistência:",
                    novoSeparador
                );
            }

            // Função para remover separador da persistência
            function removerSeparadorDoPersistencia(linhaDivisor) {
                const separadorId =
                    linhaDivisor.getAttribute("data-separador-id");
                if (!separadorId) return;

                const separadoresSalvos = carregarSeparadores();
                const separadoresFiltrados = separadoresSalvos.filter(
                    (sep) => sep.id != separadorId
                );

                salvarSeparadores(separadoresFiltrados);
                log(
                    "🗑️ LOCALIZADORES: Separador removido da persistência:",
                    separadorId
                );
            }

            // Função para salvar alteração no texto do separador
            function salvarAlteracaoSeparador(linhaDivisor, novoTexto) {
                const separadorId =
                    linhaDivisor.getAttribute("data-separador-id");
                if (!separadorId || !novoTexto) return;

                const separadoresSalvos = carregarSeparadores();
                const separadorIndex = separadoresSalvos.findIndex(
                    (sep) => sep.id == separadorId
                );

                if (separadorIndex !== -1) {
                    separadoresSalvos[separadorIndex].texto = novoTexto;
                    separadoresSalvos[separadorIndex].modificadoEm =
                        new Date().toISOString();

                    salvarSeparadores(separadoresSalvos);
                    log(
                        `📝 LOCALIZADORES: Separador ${separadorId} atualizado para: "${novoTexto}"`
                    );
                }
            }

            // Função para limpar todos os separadores salvos (útil para debug/reset)
            function limparTodosSeparadores() {
                try {
                    const chave = "eprobe_separadores_localizadores";
                    const chaveRemovidos = "eprobe_separadores_removidos";

                    localStorage.removeItem(chave);
                    localStorage.removeItem(chaveRemovidos);

                    log(
                        "🧹 LOCALIZADORES: Todos os separadores e lista de removidos foram limpos do localStorage"
                    );

                    // Remover também do DOM se estiver na página
                    const separadoresExistentes = document.querySelectorAll(
                        ".eprobe-divisor-linha"
                    );
                    separadoresExistentes.forEach((separador) =>
                        separador.remove()
                    );

                    return true;
                } catch (error) {
                    console.error(
                        "❌ LOCALIZADORES: Erro ao limpar separadores:",
                        error
                    );
                    return false;
                }
            }

            // Função para adicionar interface de separadores na página de localizadores
            function adicionarInterfaceSeparadores(tabela) {
                log("🛠️ LOCALIZADORES: Adicionando interface para separadores");

                // Adicionar texto informativo no lugar do botão
                adicionarTextoInformativoSeparadores(tabela);

                // Adicionar menu de contexto nas linhas da tabela
                adicionarMenuContextoLinhas(tabela);
            } // Função para adicionar texto informativo sobre separadores
            function adicionarTextoInformativoSeparadores(tabela) {
                // Procurar container adequado para o texto (acima da tabela)
                const containerTabela =
                    tabela.closest(".infraAreaTabela") || tabela.parentElement;

                if (!containerTabela) {
                    log("⚠️ LOCALIZADORES: Container da tabela não encontrado");
                    return;
                }

                // Verificar se já existe o texto informativo
                if (document.getElementById("eprobe-info-separadores")) {
                    return;
                }

                // Criar container para o texto informativo
                const containerInfo = document.createElement("div");
                containerInfo.id = "eprobe-info-separadores";
                containerInfo.style.cssText = `
            margin-bottom: 10px;
            padding: 8px 12px;
            background-color: #f8f9fa;
            border-radius: 4px;
            display: flex;
            gap: 8px;
            align-items: center;
            color: #000000;
            font-size: 14px;
        `;

                // Criar ícone
                const icone = document.createElement("span");
                icone.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-satellite" style="vertical-align: middle;">
                <path d="m13.5 6.5-3.148-3.148a1.205 1.205 0 0 0-1.704 0L6.352 5.648a1.205 1.205 0 0 0 0 1.704L9.5 10.5"/>
                <path d="M16.5 7.5 19 5"/>
                <path d="m17.5 10.5 3.148 3.148a1.205 1.205 0 0 1 0 1.704l-2.296 2.296a1.205 1.205 0 0 1-1.704 0L13.5 14.5"/>
                <path d="M9 21a6 6 0 0 0-6-6"/>
                <path d="M9.352 10.648a1.205 1.205 0 0 0 0 1.704l2.296 2.296a1.205 1.205 0 0 0 1.704 0l4.296-4.296a1.205 1.205 0 0 0 0-1.704l-2.296-2.296a1.205 1.205 0 0 0-1.704 0z"/>
            </svg>
        `;

                // Criar texto
                const textoInfo = document.createElement("span");
                textoInfo.innerHTML =
                    'Função <strong><span style="color: #134377;">eProbe</span></strong>: clique com o botão direito em qualquer localizador para adicionar um separador';

                // Adicionar elementos ao container
                containerInfo.appendChild(icone);
                containerInfo.appendChild(textoInfo);

                // Inserir antes da tabela
                containerTabela.insertBefore(containerInfo, tabela);

                log(
                    "✅ LOCALIZADORES: Texto informativo de separadores adicionado"
                );
            }

            // Função para adicionar menu de contexto nas linhas
            function adicionarMenuContextoLinhas(tabela) {
                const linhas = tabela.querySelectorAll(
                    "tbody tr:not(.eprobe-divisor-linha)"
                );

                console.log(
                    `🔍 LOCALIZADORES: Adicionando menu de contexto a ${linhas.length} linhas`
                );

                linhas.forEach((linha, index) => {
                    // Remover event listeners existentes para evitar duplicação
                    const novaLinha = linha.cloneNode(true);
                    linha.parentNode.replaceChild(novaLinha, linha);

                    // Adicionar evento de clique direito na nova linha
                    novaLinha.addEventListener(
                        "contextmenu",
                        function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log(
                                `🖱️ LOCALIZADORES: Clique direito na linha ${
                                    index + 1
                                }`
                            );
                            mostrarMenuContextoSeparador(
                                e,
                                novaLinha,
                                tabela,
                                index + 1
                            );
                        },
                        { passive: false }
                    ); // Importante: não é passivo para permitir preventDefault

                    // Adicionar indicação visual de que é clicável
                    novaLinha.style.cursor = "context-menu";
                    novaLinha.title =
                        "Clique com o botão direito para adicionar separador";
                });

                console.log(
                    `✅ LOCALIZADORES: Menu de contexto adicionado a ${linhas.length} linhas`
                );
            }

            // Função para mostrar menu de contexto para separador
            function mostrarMenuContextoSeparador(
                event,
                linha,
                tabela,
                numeroLinha
            ) {
                console.log(
                    `🎯 LOCALIZADORES: Criando menu de contexto para linha ${numeroLinha}`
                );

                // IMPERATIVO: Prevenir menu nativo PRIMEIRO
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();

                // Remover menu existente se houver
                const menuExistente = document.getElementById(
                    "eprobe-menu-contexto-separador"
                );
                if (menuExistente) {
                    menuExistente.remove();
                    console.log("🗑️ LOCALIZADORES: Menu existente removido");
                }

                // TRUQUE: Criar overlay para bloquear menu nativo
                const overlay = document.createElement("div");
                overlay.id = "eprobe-menu-overlay";
                overlay.style.cssText = `
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999998 !important;
            background: transparent !important;
            pointer-events: auto !important;
        `;
                document.body.appendChild(overlay);

                // Criar menu de contexto
                const menu = document.createElement("div");
                menu.id = "eprobe-menu-contexto-separador";
                menu.style.cssText = `
            position: fixed !important;
            top: ${event.clientY + 2}px !important;
            left: 500px !important;
            background: white !important;
            border: 1px solid #ccc !important;
            border-radius: 6px !important;
            box-shadow: 0 8px 24px rgba(0,0,0,0.35) !important;
            z-index: 9999999 !important;
            min-width: 220px !important;
            max-width: 320px !important;
            font-family: 'Roboto', 'Segoe UI', sans-serif !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            transform: scale(1) !important;
            margin: 0 !important;
            padding: 4px 0 !important;
            backdrop-filter: blur(8px) !important;
            user-select: none !important;
        `;

                // Criar opção do menu
                const opcaoSeparador = document.createElement("div");
                opcaoSeparador.style.cssText = `
            padding: 12px 16px !important;
            cursor: pointer !important;
            border-bottom: 1px solid #f0f0f0 !important;
            font-size: 14px !important;
            display: flex !important;
            align-items: center !important;
            gap: 10px !important;
            background: white !important;
            color: #333 !important;
            text-decoration: none !important;
            transition: all 0.15s ease !important;
            margin: 0 !important;
            border-radius: 0 !important;
            width: 100% !important;
            box-sizing: border-box !important;
            font-weight: 500 !important;
            line-height: 1.4 !important;
        `;

                // Adicionar hover effect via JavaScript para garantir funcionamento
                opcaoSeparador.addEventListener("mouseenter", function () {
                    this.style.backgroundColor = "#f8f9fa !important";
                    this.style.color = "#1a73e8 !important";
                });

                opcaoSeparador.addEventListener("mouseleave", function () {
                    this.style.backgroundColor = "white !important";
                    this.style.color = "#333 !important";
                });

                opcaoSeparador.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
                <path d="m16 16-4 4-4-4"/>
                <path d="M3 12h18"/>
                <path d="m8 8 4-4 4 4"/>
            </svg>
            <span>Adicionar separador após linha ${numeroLinha}</span>
        `;

                // Evento da opção
                opcaoSeparador.addEventListener("click", function () {
                    console.log("📝 LOCALIZADORES: Opção do menu clicada");

                    // Remover overlay e menu imediatamente
                    overlay.remove();
                    menu.remove();

                    const nomeSecao = prompt(
                        "Digite o nome da seção:",
                        "Nova Seção"
                    );
                    if (nomeSecao !== null && nomeSecao.trim() !== "") {
                        console.log(
                            `🎯 LOCALIZADORES: Criando separador "${nomeSecao}" após linha ${numeroLinha}`
                        );
                        try {
                            const separadorCriado = criarDivisorEditavel(
                                tabela,
                                linha,
                                nomeSecao.trim()
                            );
                            if (separadorCriado) {
                                console.log(
                                    `✅ LOCALIZADORES: Separador "${nomeSecao}" criado com sucesso`
                                );
                            } else {
                                console.error(
                                    "❌ LOCALIZADORES: Falha ao criar separador"
                                );
                            }
                        } catch (error) {
                            console.error(
                                "❌ LOCALIZADORES: Erro ao criar separador:",
                                error
                            );
                        }
                    } else {
                        console.log(
                            "ℹ️ LOCALIZADORES: Criação de separador cancelada pelo usuário"
                        );
                    }
                });

                // Adicionar opção ao menu
                menu.appendChild(opcaoSeparador);

                // Adicionar menu ao overlay (que já está no body)
                overlay.appendChild(menu);
                console.log("📋 LOCALIZADORES: Menu adicionado ao overlay");

                // Remover menu ao clicar fora (no overlay)
                overlay.addEventListener("click", function (e) {
                    if (e.target === overlay) {
                        overlay.remove();
                        console.log(
                            "🗑️ LOCALIZADORES: Menu removido por clique no overlay"
                        );
                    }
                });

                // Escape key para fechar
                const fecharComEscape = function (e) {
                    if (e.key === "Escape") {
                        overlay.remove();
                        document.removeEventListener(
                            "keydown",
                            fecharComEscape
                        );
                        console.log(
                            "🗑️ LOCALIZADORES: Menu removido por Escape"
                        );
                    }
                };
                document.addEventListener("keydown", fecharComEscape);

                // Ajustar posição se sair da tela
                setTimeout(() => {
                    const rect = menu.getBoundingClientRect();
                    let newTop = event.clientY + 2;
                    let newLeft = event.clientX + 2;

                    if (rect.right > window.innerWidth) {
                        newLeft = event.clientX - rect.width - 2;
                    }
                    if (rect.bottom > window.innerHeight) {
                        newTop = event.clientY - rect.height - 2;
                    }

                    menu.style.top = newTop + "px";
                    menu.style.left = newLeft + "px";
                }, 10);

                console.log(
                    "✅ LOCALIZADORES: Menu de contexto criado e posicionado com overlay"
                );
            }

            // Sistema robusto de criação de botão com múltiplas tentativas
            let buttonCreationAttempts = 0;
            const MAX_BUTTON_CREATION_ATTEMPTS = 5;

            function ensureButtonExists() {
                // Verificar se já existe algum botão
                const existingButton =
                    document.getElementById(
                        "documento-relevante-auto-button"
                    ) || document.getElementById("sent1-auto-button");

                if (existingButton) {
                    log("✅ BOTÃO: Já existe, cancelando verificação");
                    buttonCreationAttempts = 0;
                    return true;
                }

                // Incrementar tentativas
                buttonCreationAttempts++;

                if (buttonCreationAttempts > MAX_BUTTON_CREATION_ATTEMPTS) {
                    log(
                        "⚠️ BOTÃO: Máximo de tentativas atingido, parando verificação"
                    );
                    return false;
                }

                log(
                    `🔄 BOTÃO: Tentativa ${buttonCreationAttempts}/${MAX_BUTTON_CREATION_ATTEMPTS} de criação`
                );

                // Verificar se a página atende aos critérios
                let shouldShowIntegrated = false;
                let shouldShowFloating = false;

                try {
                    if (typeof shouldShowIntegratedButton === "function") {
                        shouldShowIntegrated = shouldShowIntegratedButton();
                    }
                    if (typeof shouldShowFloatingButton === "function") {
                        shouldShowFloating = shouldShowFloatingButton();
                    }
                } catch (e) {
                    console.warn(
                        "⚠️ Erro ao verificar critérios dos botões:",
                        e.message
                    );
                }

                log("🔍 BOTÃO: Critérios de validação:", {
                    shouldShowIntegrated,
                    shouldShowFloating,
                    pageUrl: window.location.href,
                });

                if (shouldShowIntegrated || shouldShowFloating) {
                    createAutomationButton();

                    // Verificar se foi criado com sucesso após um pequeno delay
                    setTimeout(() => {
                        const buttonAfterCreation =
                            document.getElementById(
                                "documento-relevante-auto-button"
                            ) || document.getElementById("sent1-auto-button");

                        if (buttonAfterCreation) {
                            logCritical("✅ BOTÃO: Criado com sucesso");
                            buttonCreationAttempts = 0;
                        } else {
                            log(
                                "⚠️ BOTÃO: Falha na criação, tentando novamente com backoff"
                            );
                            // Backoff exponencial baseado nas tentativas
                            const backoffDelay = Math.min(
                                1000 *
                                    Math.pow(1.5, buttonCreationAttempts - 1),
                                5000
                            );
                            setTimeout(ensureButtonExists, backoffDelay);
                        }
                    }, 200);
                } else {
                    log(
                        "❌ BOTÃO: Página não atende aos critérios, tentando novamente com backoff"
                    );
                    // Backoff exponencial para páginas que ainda estão carregando
                    const backoffDelay = Math.min(
                        2000 * Math.pow(1.2, buttonCreationAttempts - 1),
                        8000
                    );
                    setTimeout(ensureButtonExists, backoffDelay);
                }

                return false;
            }

            // Função melhorada para verificar se deve mostrar o botão integrado
            function shouldShowIntegratedButton() {
                // Verificações básicas de URL
                const url = window.location.href;
                if (
                    !url.includes("eproc") ||
                    (!url.includes("processo") && !url.includes("documento"))
                ) {
                    log(
                        "❌ BOTÃO INTEGRADO: URL não contém eproc + processo/documento"
                    );
                    return false;
                }

                // Verificar título da página
                const h1Element = document.querySelector("h1");
                if (h1Element) {
                    const titleText = h1Element.textContent.trim();
                    const hasCorrectTitle =
                        titleText ===
                        "Consulta Processual - Detalhes do Processo";

                    log("🔍 BOTÃO INTEGRADO: Verificando título:", {
                        titleFound: titleText,
                        isCorrect: hasCorrectTitle,
                    });

                    if (hasCorrectTitle) {
                        return true;
                    }
                }

                // Verificações alternativas para páginas de documento
                const hasFormProcesso =
                    !!document.querySelector("#frmProcessoLista");
                const hasDocumentContent = !!document.querySelector(
                    '[href*="acessar_documento"]'
                );
                const hasMinutasContent = !!document.querySelector(
                    "#conteudoMinutas, #fldMinutas"
                );

                log("🔍 BOTÃO INTEGRADO: Verificações alternativas:", {
                    hasFormProcesso,
                    hasDocumentContent,
                    hasMinutasContent,
                });

                return (
                    hasFormProcesso || hasDocumentContent || hasMinutasContent
                );
            }

            // Função melhorada para verificar se deve mostrar o botão flutuante
            function shouldShowFloatingButton() {
                // Se deve mostrar botão integrado, não mostrar flutuante
                try {
                    if (
                        typeof shouldShowIntegratedButton === "function" &&
                        shouldShowIntegratedButton()
                    ) {
                        return false;
                    }
                } catch (e) {
                    console.warn(
                        "⚠️ Erro ao verificar shouldShowIntegratedButton:",
                        e.message
                    );
                }

                const url = window.location.href;

                // Verificar se é uma página de documento específico
                if (
                    url.includes("acessar_documento") ||
                    url.includes("processo_consultar_externo_documento")
                ) {
                    log(
                        "✅ BOTÃO FLUTUANTE: Página de documento específico detectada"
                    );
                    return true;
                }

                // Verificar conteúdo da página
                const pageHTML = document.documentElement.outerHTML;
                const hasDocumentHtml = pageHTML.includes(
                    "acessar_documento&id"
                );
                const hasDocumentPdf = pageHTML.includes(
                    "acessar_documento&amp"
                );
                const hasDocumentLinks = !!document.querySelector(
                    '[href*="SENT"], [href*="INIC"], [href*="DECI"]'
                );

                log("🔍 BOTÃO FLUTUANTE: Verificando critérios:", {
                    hasDocumentHtml,
                    hasDocumentPdf,
                    hasDocumentLinks,
                    shouldShow:
                        hasDocumentHtml || hasDocumentPdf || hasDocumentLinks,
                    url,
                });

                return hasDocumentHtml || hasDocumentPdf || hasDocumentLinks;
            }

            // Função aprimorada para encontrar descrição do evento
            function findEventDescription(linkElement) {
                const strategies = [
                    () => findEventDescriptionInSameRow(linkElement),
                    () => findEventDescriptionInPreviousRows(linkElement),
                    () => findEventDescriptionByTextPattern(linkElement),
                    () => findEventDescriptionInTableStructure(linkElement),
                    () => findEventDescriptionByProximity(linkElement),
                ];

                for (let i = 0; i < strategies.length; i++) {
                    try {
                        log(`Executando estratégia ${i + 1} para descrição...`);
                        const result = strategies[i]();
                        if (result && result.trim().length > 3) {
                            log(`Estratégia ${i + 1} bem-sucedida:`, result);
                            return result.trim();
                        }
                    } catch (e) {
                        log(`Erro na estratégia ${i + 1}:`, e);
                    }
                }

                log("Nenhuma estratégia encontrou descrição válida");
                return "";
            }

            // Estratégia 1: Buscar na mesma linha do link
            function findEventDescriptionInSameRow(linkElement) {
                const currentRow = linkElement.closest("tr");
                if (!currentRow) return "";

                log("Buscando na linha atual...");

                // Buscar por seletores conhecidos
                const selectors = [
                    "td.infraEventoDescricao",
                    "label.infraEventoDescricao",
                    "td[class*='evento'][class*='descricao']",
                    "td[class*='Evento'][class*='Descricao']",
                ];

                for (const selector of selectors) {
                    const element = currentRow.querySelector(selector);
                    if (element) {
                        const text = element.textContent.trim();
                        if (text && !text.toLowerCase().includes("sent")) {
                            log(`Encontrado via seletor ${selector}:`, text);
                            return text;
                        }
                    }
                }

                return "";
            }

            // Estratégia 2: Buscar em linhas anteriores (evento pode estar em linha separada)
            function findEventDescriptionInPreviousRows(linkElement) {
                const currentRow = linkElement.closest("tr");
                if (!currentRow) return "";

                log("Buscando em linhas anteriores...");

                let previousRow = currentRow.previousElementSibling;
                let attempts = 0;

                while (previousRow && attempts < 10) {
                    attempts++;

                    // Verificar se esta linha contém descrição de evento
                    const eventDescSelectors = [
                        "td.infraEventoDescricao",
                        "label.infraEventoDescricao",
                        "td[class*='evento']",
                        "td[class*='Evento']",
                    ];

                    for (const selector of eventDescSelectors) {
                        const element = previousRow.querySelector(selector);
                        if (element) {
                            const text = element.textContent.trim();
                            if (
                                text &&
                                text.length > 5 &&
                                !text.toLowerCase().includes("sent")
                            ) {
                                log(
                                    `Encontrado em linha anterior (${attempts}):`,
                                    text
                                );
                                return text;
                            }
                        }
                    }

                    previousRow = previousRow.previousElementSibling;
                }

                return "";
            }

            // Estratégia 3: Buscar por padrões de texto típicos de descrição de evento
            function findEventDescriptionByTextPattern(linkElement) {
                const currentRow = linkElement.closest("tr");
                if (!currentRow) return "";

                log("Buscando por padrões de texto...");

                // Expandir busca para linhas próximas
                const rowsToCheck = [];

                // Adicionar linha atual
                rowsToCheck.push(currentRow);

                // Adicionar linhas anteriores
                let prevRow = currentRow.previousElementSibling;
                for (let i = 0; i < 5 && prevRow; i++) {
                    rowsToCheck.unshift(prevRow);
                    prevRow = prevRow.previousElementSibling;
                }

                // Adicionar linhas posteriores
                let nextRow = currentRow.nextElementSibling;
                for (let i = 0; i < 2 && nextRow; i++) {
                    rowsToCheck.push(nextRow);
                    nextRow = nextRow.nextElementSibling;
                }

                // Padrões que indicam descrição de evento judicial
                const eventPatterns = [
                    /julgamento/i,
                    /decisão/i,
                    /sentença/i,
                    /prolação/i,
                    /publicação/i,
                    /audiência/i,
                    /despacho/i,
                    /determinação/i,
                    /intimação/i,
                    /citação/i,
                    /distribuição/i,
                    /remessa/i,
                    /devolução/i,
                    /conclusão/i,
                ];

                for (const row of rowsToCheck) {
                    const cells = row.querySelectorAll("td");
                    for (const cell of cells) {
                        const text = cell.textContent.trim();

                        // Verificar se o texto tem tamanho razoável e contém padrões de evento
                        if (text.length > 10 && text.length < 200) {
                            for (const pattern of eventPatterns) {
                                if (
                                    pattern.test(text) &&
                                    !text.toLowerCase().includes("sent1")
                                ) {
                                    log(
                                        `Encontrado por padrão "${pattern}":`,
                                        text
                                    );
                                    return text;
                                }
                            }
                        }
                    }
                }

                return "";
            }

            // Estratégia 4: Analisar estrutura da tabela para encontrar coluna de descrição
            function findEventDescriptionInTableStructure(linkElement) {
                const table = linkElement.closest("table");
                if (!table) return "";

                log("Analisando estrutura da tabela...");

                const currentRow = linkElement.closest("tr");
                const linkCellIndex = Array.from(currentRow.cells).findIndex(
                    (cell) => cell.contains(linkElement)
                );

                // Buscar na mesma linha, mas em células que podem conter descrição
                for (let i = 0; i < currentRow.cells.length; i++) {
                    if (i === linkCellIndex) continue; // Pular célula do link

                    const cell = currentRow.cells[i];
                    const text = cell.textContent.trim();

                    // Verificar se parece uma descrição (texto médio, não apenas números/datas)
                    if (text.length > 15 && text.length < 150) {
                        // Verificar se não é apenas data, números ou links
                        if (
                            !/^\d+[\d\/\-\s]*$/.test(text) &&
                            !text.toLowerCase().includes("sent") &&
                            !/^https?:\/\//.test(text)
                        ) {
                            log(
                                `Encontrado na estrutura da tabela (célula ${i}):`,
                                text
                            );
                            return text;
                        }
                    }
                }

                return "";
            }

            // Estratégia 5: Buscar por proximidade usando XPath-like logic
            function findEventDescriptionByProximity(linkElement) {
                log("Buscando por proximidade...");

                // Buscar elementos próximos que podem conter descrição
                const parent =
                    linkElement.closest("td") || linkElement.closest("tr");
                if (!parent) return "";

                // Buscar em elementos irmãos
                const siblings = parent.parentElement
                    ? Array.from(parent.parentElement.children)
                    : [];

                for (const sibling of siblings) {
                    if (sibling === parent) continue;

                    const text = sibling.textContent.trim();
                    if (
                        text.length > 20 &&
                        text.length < 200 &&
                        !text.toLowerCase().includes("sent") &&
                        !/^\d+[\d\/\-\s]*$/.test(text)
                    ) {
                        // Verificar se contém palavras típicas de processo judicial
                        if (
                            /julgamento|decisão|sentença|audiência|despacho|intimação|publicação|prolação/i.test(
                                text
                            )
                        ) {
                            log(`Encontrado por proximidade:`, text);
                            return text;
                        }
                    }
                }

                return "";
            } // Encontrar documentos relevantes com informações detalhadas
            function findDocumentosRelevantes() {
                const pageType = detectPageType();
                log(` Tipo de página detectado: ${pageType}`);

                // Estratégias múltiplas para encontrar documentos relevantes
                const estrategias = [
                    // Estratégia 1: Seletores específicos do eProc com data-nome
                    () => {
                        const selectors = Object.values(
                            TIPOS_DOCUMENTO_RELEVANTE
                        )
                            .map((tipo) => [
                                `a.infraLinkDocumento[data-nome="${tipo.dataNome}"]`,
                                `a[data-nome="${tipo.dataNome}"]`,
                                `a.infraLinkDocumento[data-nome*="${tipo.dataNome}"]`,
                            ])
                            .flat()
                            .join(", ");
                        return document.querySelectorAll(selectors);
                    },

                    // Estratégia 2: Buscar por texto dos links que contenha os tipos
                    () => {
                        const tiposValidos = Object.values(
                            TIPOS_DOCUMENTO_RELEVANTE
                        ).map((t) => t.nome);
                        const todosLinks = document.querySelectorAll(
                            'a.infraLinkDocumento, a[href*="documento"]'
                        );
                        return Array.from(todosLinks).filter((link) => {
                            const texto = link.textContent.trim().toUpperCase();
                            return tiposValidos.some((tipo) =>
                                texto.includes(tipo)
                            );
                        });
                    },

                    // Estratégia 3: Buscar por padrões específicos no href
                    () => {
                        const patterns = [
                            "SENT",
                            "INIC",
                            "DECI",
                            "DESP",
                            "PETI",
                        ];
                        const selector = patterns
                            .map((p) => `a[href*="${p}"]`)
                            .join(", ");
                        return document.querySelectorAll(selector);
                    },

                    // Estratégia 4: Buscar em tabelas de eventos
                    () => {
                        const linksEmTabelas = document.querySelectorAll(
                            'table a[href*="documento"], table a.infraLinkDocumento'
                        );
                        return Array.from(linksEmTabelas).filter((link) => {
                            const texto = link.textContent.trim().toUpperCase();
                            return ["SENT", "INIC", "DECI", "DESP"].some(
                                (tipo) => texto.includes(tipo)
                            );
                        });
                    },
                ];

                let links = [];
                let estrategiaUsada = 0;

                // Testar estratégias até encontrar documentos
                for (let i = 0; i < estrategias.length; i++) {
                    try {
                        const resultados = estrategias[i]();
                        if (resultados && resultados.length > 0) {
                            links = Array.from(resultados);
                            estrategiaUsada = i + 1;
                            log(
                                `✅ Estratégia ${estrategiaUsada} funcionou - encontrados ${links.length} links`
                            );
                            break;
                        }
                    } catch (error) {
                        log(`❌ Estratégia ${i + 1} falhou:`, error);
                    }
                }

                log(
                    ` Links de documentos relevantes encontrados: ${links.length} (estratégia ${estrategiaUsada})`
                );

                if (links.length === 0) {
                    // Debug detalhado quando não encontrar nada
                    log(
                        "🔍 DEBUG: Nenhum documento encontrado. Analisando página..."
                    );
                    log("📊 ANÁLISE DA PÁGINA:");
                    log(
                        "  - Todos os links:",
                        document.querySelectorAll("a").length
                    );
                    log(
                        "  - Links com classe infraLinkDocumento:",
                        document.querySelectorAll("a.infraLinkDocumento").length
                    );
                    log(
                        "  - Links com href contendo 'documento':",
                        document.querySelectorAll('a[href*="documento"]').length
                    );
                    log(
                        "  - Elementos com data-nome:",
                        document.querySelectorAll("[data-nome]").length
                    );

                    // Buscar patterns específicos no DOM
                    const todosLinks = Array.from(
                        document.querySelectorAll("a")
                    );
                    const linksSuspeitos = todosLinks.filter((link) => {
                        const texto = link.textContent.trim().toUpperCase();
                        const href = link.getAttribute("href") || "";
                        return ["SENT", "INIC", "DECI", "DESP", "PETI"].some(
                            (tipo) =>
                                texto.includes(tipo) ||
                                href.toUpperCase().includes(tipo)
                        );
                    });

                    log(
                        "📋 Links suspeitos encontrados:",
                        linksSuspeitos.length
                    );
                    linksSuspeitos.forEach((link, i) => {
                        log(
                            `  ${
                                i + 1
                            }. "${link.textContent.trim()}" -> ${link.getAttribute(
                                "href"
                            )}`
                        );
                    });
                }

                const documentosData = [];

                // PRIMEIRA ETAPA: Coletar informações básicas dos links
                links.forEach((link, i) => {
                    const texto = link.textContent.trim();
                    const href = link.getAttribute("href");

                    log(` DOC ${i + 1}:`, {
                        texto: texto,
                        href: href,
                        dataId: link.getAttribute("data-id"),
                        onClick: link.getAttribute("onclick"),
                        element: link,
                    });

                    // Verificar se é um dos tipos configurados
                    const tipoEncontrado = Object.values(
                        TIPOS_DOCUMENTO_RELEVANTE
                    ).find(
                        (tipo) =>
                            texto === tipo.nome || texto.includes(tipo.nome)
                    );

                    if (tipoEncontrado) {
                        // Extrair informações do tooltip para diferenciar as sentenças
                        const onmouseover =
                            link.getAttribute("onmouseover") || "";
                        const dadosIconLink =
                            href.match(/dadosIconLink=([^&]+)/)?.[1] || "";

                        // Tentar extrair número do evento da URL
                        const eventoMatch = href.match(/evento=([^&]+)/);
                        const docMatch = href.match(/doc=([^&]+)/);
                        const seqEventoMatch =
                            href.match(/numSeqEvento.*?(\d+)/);

                        // Extrair informações do tooltip se disponível
                        let tipoDocumento = "";
                        let tamanho = "";
                        let seqEvento = "";

                        if (onmouseover.includes("infraTooltipMostrar")) {
                            const tooltipMatch = onmouseover.match(
                                /infraTooltipMostrar\('([^']+)'/
                            );
                            if (tooltipMatch) {
                                const tooltipContent = tooltipMatch[1];
                                const tipoMatch = tooltipContent.match(
                                    /Tipo Documento:.*?<font[^>]*>([^<]+)/
                                );
                                const tamanhoMatch = tooltipContent.match(
                                    /Tamanho:.*?<font[^>]*>([^<]+)/
                                );

                                if (tipoMatch)
                                    tipoDocumento = tipoMatch[1].trim();
                                if (tamanhoMatch)
                                    tamanho = tamanhoMatch[1].trim();
                            }
                        }

                        // Tentar extrair sequência do evento dos dados codificados
                        if (dadosIconLink) {
                            try {
                                const decoded = atob(dadosIconLink);
                                const seqMatch = decoded.match(
                                    /"numSeqEvento";s:\d+:"(\d+)"/
                                );
                                if (seqMatch) seqEvento = seqMatch[1];
                            } catch (e) {
                                log(" Erro ao decodificar dadosIconLink:", e);
                            }
                        }

                        // Armazenar dados básicos do link
                        documentosData.push({
                            element: link,
                            href: href,
                            texto: texto,
                            tipo: tipoEncontrado,
                            eventoId: eventoMatch?.[1] || "",
                            docId: docMatch?.[1] || "",
                            seqEvento: seqEvento || seqEventoMatch?.[1] || "",
                            tipoDocumento:
                                tipoDocumento || tipoEncontrado.descricao,
                            tamanho: tamanho || "",
                            index: i + 1,
                        });

                        log(
                            ` Documento encontrado: ${texto} (${tipoEncontrado.descricao})!`,
                            {
                                index: i + 1,
                                url: href,
                                eventoId: eventoMatch?.[1],
                                seqEvento: seqEvento,
                                tipoDocumento: tipoDocumento,
                                tamanho: tamanho,
                            }
                        );
                    }
                });

                // SEGUNDA ETAPA: Se estivermos na página da lista de documentos, buscar as descrições dos eventos
                if (
                    pageType === "lista_documentos" &&
                    documentosData.length > 0
                ) {
                    log(
                        " Página da lista de documentos detectada - buscando descrições dos eventos..."
                    );

                    // Para cada documento relevante, encontrar a descrição na mesma linha (tr)
                    documentosData.forEach((linkData, index) => {
                        log(
                            ` Buscando descrição para documento #${
                                index + 1
                            }...`
                        );

                        let eventoDescricao = "";
                        let eventoData = "";
                        let eventoMagistrado = "";
                        const linkElement = linkData.element; // Encontrar a linha (tr) do evento que contém o link
                        // O link está em uma tabela aninhada, então precisamos buscar o tr principal
                        const eventRow =
                            linkElement.closest("tr[id^='trEvento']") ||
                            linkElement.closest("tr[id*='Evento']") ||
                            linkElement.closest("tr[data-parte]");

                        if (eventRow) {
                            log(
                                ` Link está na linha do evento: ${
                                    eventRow.id ||
                                    eventRow.getAttribute("data-parte") ||
                                    "identificador não encontrado"
                                }`
                            );

                            // Buscar a célula de descrição do evento na mesma linha
                            const eventDescCell = eventRow.querySelector(
                                "td.infraEventoDescricao"
                            );

                            if (eventDescCell) {
                                eventoDescricao =
                                    eventDescCell.textContent.trim();
                                log(
                                    `📝 Descrição encontrada na linha do evento: "${eventoDescricao}"`
                                );
                            } else {
                                log(
                                    "⚠️ Célula td.infraEventoDescricao não encontrada na linha do evento"
                                );

                                // Fallback: buscar qualquer elemento com classe infraEventoDescricao na linha
                                const fallbackDescElement =
                                    eventRow.querySelector(
                                        ".infraEventoDescricao"
                                    );
                                if (fallbackDescElement) {
                                    eventoDescricao =
                                        fallbackDescElement.textContent.trim();
                                    log(
                                        `📝 Descrição encontrada via fallback: "${eventoDescricao}"`
                                    );
                                } else {
                                    // Debug: mostrar todas as células da linha para entender a estrutura
                                    const allCells =
                                        eventRow.querySelectorAll("td");
                                    log(
                                        `🔍 Debug - Total de células na linha: ${allCells.length}`
                                    );
                                    allCells.forEach((cell, index) => {
                                        log(
                                            `📋 Célula ${
                                                index + 1
                                            }: "${cell.textContent
                                                .trim()
                                                .substring(0, 50)}" (classe: ${
                                                cell.className
                                            })`
                                        );
                                    });
                                }
                            }

                            // Buscar informações do magistrado/vara
                            const magistradoCell =
                                eventRow.querySelector(
                                    "label.infraEventoUsuario"
                                ) ||
                                eventRow.querySelector("td.infraEventoUsuario");

                            log(
                                `🔍 Debug Magistrado - Célula encontrada: ${!!magistradoCell} (${
                                    magistradoCell
                                        ? magistradoCell.tagName.toLowerCase()
                                        : "N/A"
                                })`
                            );
                            if (magistradoCell) {
                                log(
                                    `🔍 Debug Magistrado - Elemento: <${magistradoCell.tagName.toLowerCase()}> com classe: ${
                                        magistradoCell.className
                                    }`
                                );
                                log(
                                    `🔍 Debug Magistrado - Conteúdo da célula: "${magistradoCell.textContent.trim()}"`
                                );

                                const onmouseoverAttr =
                                    magistradoCell.getAttribute("onmouseover");
                                const titleAttr =
                                    magistradoCell.getAttribute("title");
                                const tooltipAttr =
                                    magistradoCell.getAttribute("data-tooltip");

                                log(
                                    `🔍 Debug Magistrado - Atributo onmouseover: ${!!onmouseoverAttr}`
                                );
                                log(
                                    `🔍 Debug Magistrado - Atributo title: ${!!titleAttr}`
                                );
                                log(
                                    `🔍 Debug Magistrado - Atributo data-tooltip: ${!!tooltipAttr}`
                                );

                                // Tentar extrair de onmouseover primeiro
                                if (onmouseoverAttr) {
                                    log(
                                        `🔍 Debug Magistrado - Conteúdo onmouseover: "${onmouseoverAttr}"`
                                    );

                                    // Estratégias múltiplas para extrair o texto do magistrado
                                    let magistradoEncontrado = false;

                                    // Estratégia 1 ESPECÍFICA: carregarInfoUsuarioOutroGrau com estrutura HTML
                                    if (
                                        onmouseoverAttr.includes(
                                            "carregarInfoUsuarioOutroGrau"
                                        )
                                    ) {
                                        const carregarMatch =
                                            onmouseoverAttr.match(
                                                /carregarInfoUsuarioOutroGrau\(['"]([^'"]+)['"][\)\;]/
                                            );
                                        if (carregarMatch && carregarMatch[1]) {
                                            let textoCompleto =
                                                carregarMatch[1];

                                            // Decodificar HTML entities
                                            textoCompleto =
                                                textoCompleto.replace(
                                                    /&lt;/g,
                                                    "<"
                                                );
                                            textoCompleto =
                                                textoCompleto.replace(
                                                    /&gt;/g,
                                                    ">"
                                                );
                                            textoCompleto =
                                                textoCompleto.replace(
                                                    /&amp;/g,
                                                    "&"
                                                );

                                            // Dividir por <br/> para obter partes estruturadas
                                            const partes = textoCompleto
                                                .split(/<br\s*\/?>/i)
                                                .map((p) => p.trim())
                                                .filter((p) => p);

                                            log(
                                                `🔍 Estratégia 1 ESPECÍFICA - Partes encontradas: ${JSON.stringify(
                                                    partes
                                                )}`
                                            );

                                            // Estrutura típica: [NOME, TIPO, VARA]
                                            if (partes.length >= 3) {
                                                const nome = partes[0].trim();
                                                const tipo = partes[1].trim();
                                                const vara = partes[2].trim();

                                                // Criar objeto estruturado com informações corretas
                                                eventoMagistrado = {
                                                    nome: nome,
                                                    tipo: tipo.toLowerCase(), // ✅ Normalizar para minúsculo
                                                    vara: vara,
                                                    textoCompleto: `${nome} (${tipo}) - ${vara}`,
                                                };

                                                magistradoEncontrado = true;
                                                log(
                                                    `🔍 Estratégia 1 ESPECÍFICA - Magistrado estruturado: ${JSON.stringify(
                                                        eventoMagistrado
                                                    )}`
                                                );
                                            } else if (partes.length >= 2) {
                                                // Fallback: pelo menos nome e uma informação adicional
                                                eventoMagistrado = {
                                                    nome: partes[0].trim(),
                                                    tipo: partes[1]
                                                        .trim()
                                                        .toLowerCase(), // ✅ Normalizar para minúsculo
                                                    vara: null,
                                                    textoCompleto:
                                                        partes.join(" - "),
                                                };
                                                magistradoEncontrado = true;
                                                log(
                                                    `🔍 Estratégia 1 ESPECÍFICA - Magistrado parcial: ${JSON.stringify(
                                                        eventoMagistrado
                                                    )}`
                                                );
                                            }
                                        }
                                    }

                                    // Estratégia 2: Texto entre aspas simples ou duplas (fallback)
                                    if (!magistradoEncontrado) {
                                        const magistradoMatch1 =
                                            onmouseoverAttr.match(
                                                /['"]([^'"]+)['"]/
                                            );
                                        if (
                                            magistradoMatch1 &&
                                            magistradoMatch1[1]
                                        ) {
                                            eventoMagistrado =
                                                magistradoMatch1[1].trim();
                                            magistradoEncontrado = true;
                                            log(
                                                `🔍 Estratégia 2 - Magistrado/Vara encontrado: "${eventoMagistrado}"`
                                            );
                                        }
                                    }

                                    // Estratégia 3: Texto após "infraTooltipMostrar"
                                    // Estratégia 3: Texto após "infraTooltipMostrar"
                                    if (!magistradoEncontrado) {
                                        const magistradoMatch2 =
                                            onmouseoverAttr.match(
                                                /infraTooltipMostrar\(['"]([^'"]+)['"]\)/
                                            );
                                        if (
                                            magistradoMatch2 &&
                                            magistradoMatch2[1]
                                        ) {
                                            eventoMagistrado =
                                                magistradoMatch2[1].trim();
                                            magistradoEncontrado = true;
                                            log(
                                                `🔍 Estratégia 3 - Magistrado/Vara encontrado: "${eventoMagistrado}"`
                                            );
                                        }
                                    }

                                    // Estratégia 4: Qualquer texto que pareça nome/cargo entre parênteses ou tags
                                    // Estratégia 4: Qualquer texto que pareça nome/cargo entre parênteses ou tags
                                    if (!magistradoEncontrado) {
                                        const magistradoMatch3 =
                                            onmouseoverAttr.match(
                                                />\s*([^<>]+(?:juiz|magistrad|vara|gabinete)[^<>]*)\s*</i
                                            );
                                        if (
                                            magistradoMatch3 &&
                                            magistradoMatch3[1]
                                        ) {
                                            eventoMagistrado =
                                                magistradoMatch3[1].trim();
                                            magistradoEncontrado = true;
                                            log(
                                                `🔍 Estratégia 4 - Magistrado/Vara encontrado: "${eventoMagistrado}"`
                                            );
                                        }
                                    }

                                    // Estratégia 5: Fallback - qualquer texto substancial
                                    // Estratégia 5: Fallback - qualquer texto substancial
                                    if (!magistradoEncontrado) {
                                        const magistradoMatch4 =
                                            onmouseoverAttr.match(
                                                />\s*([A-Za-zÀ-ÿ\s]{10,})\s*</
                                            );
                                        if (
                                            magistradoMatch4 &&
                                            magistradoMatch4[1]
                                        ) {
                                            eventoMagistrado =
                                                magistradoMatch4[1].trim();
                                            magistradoEncontrado = true;
                                            log(
                                                `🔍 Estratégia 5 - Magistrado/Vara encontrado: "${eventoMagistrado}"`
                                            );
                                        }
                                    }

                                    if (!magistradoEncontrado) {
                                        log(
                                            `❌ Nenhuma estratégia conseguiu extrair texto do onmouseover`
                                        );
                                    }
                                }

                                // Se não conseguiu pelo onmouseover, tentar title
                                if (!eventoMagistrado && titleAttr) {
                                    log(
                                        `🔍 Tentando extrair do atributo title: "${titleAttr}"`
                                    );
                                    if (titleAttr.length > 5) {
                                        eventoMagistrado = titleAttr.trim();
                                        log(
                                            `🔍 Magistrado/Vara encontrado no title: "${eventoMagistrado}"`
                                        );
                                    }
                                }

                                // Se não conseguiu pelo title, tentar data-tooltip
                                if (!eventoMagistrado && tooltipAttr) {
                                    log(
                                        `🔍 Tentando extrair do atributo data-tooltip: "${tooltipAttr}"`
                                    );
                                    if (tooltipAttr.length > 5) {
                                        eventoMagistrado = tooltipAttr.trim();
                                        log(
                                            `🔍 Magistrado/Vara encontrado no data-tooltip: "${eventoMagistrado}"`
                                        );
                                    }
                                }

                                // Fallback final: usar o texto da própria célula se tiver conteúdo
                                if (!eventoMagistrado) {
                                    const cellText =
                                        magistradoCell.textContent.trim();
                                    if (
                                        cellText &&
                                        cellText.length > 3 &&
                                        !cellText.match(/^\d+$/)
                                    ) {
                                        eventoMagistrado = cellText;
                                        log(
                                            `🔍 Magistrado/Vara encontrado no texto da célula: "${eventoMagistrado}"`
                                        );
                                    }
                                }

                                // Formatar informações do magistrado/advogado
                                if (eventoMagistrado) {
                                    // Verificar se já temos dados estruturados da nova estratégia
                                    if (
                                        typeof eventoMagistrado === "object" &&
                                        eventoMagistrado.nome
                                    ) {
                                        // Dados já estruturados da estratégia específica
                                        linkData.magistradoInfo = {
                                            tipo:
                                                eventoMagistrado.tipo ||
                                                "magistrado",
                                            nome: eventoMagistrado.nome,
                                            vara: eventoMagistrado.vara,
                                        };
                                        linkData.eventoMagistrado =
                                            eventoMagistrado.nome; // Para compatibilidade

                                        log(
                                            `✅ Magistrado estruturado: Nome="${eventoMagistrado.nome}", Tipo="${eventoMagistrado.tipo}", Vara="${eventoMagistrado.vara}"`
                                        );
                                    } else {
                                        // Formato antigo - processar com a função existente
                                        const magistradoFormatado =
                                            formatarMagistradoAdvogado(
                                                eventoMagistrado
                                            );
                                        if (
                                            typeof magistradoFormatado ===
                                                "object" &&
                                            magistradoFormatado.tipo
                                        ) {
                                            // Armazenar informações estruturadas
                                            linkData.magistradoInfo =
                                                magistradoFormatado;
                                            eventoMagistrado =
                                                magistradoFormatado.nome;
                                        } else {
                                            eventoMagistrado =
                                                magistradoFormatado;
                                        }

                                        log(
                                            `🔍 Informações formatadas (método antigo): "${eventoMagistrado}"`
                                        );
                                    }
                                }

                                if (!eventoMagistrado) {
                                    log(
                                        `❌ Nenhuma informação de magistrado/advogado encontrada`
                                    );
                                }
                            } else {
                                log(
                                    `❌ Elemento label.infraEventoUsuario OU td.infraEventoUsuario não encontrado`
                                );

                                // Debug: verificar todas as células da linha para encontrar possíveis alternativas
                                const allCells =
                                    eventRow.querySelectorAll("td, label");
                                log(
                                    `🔍 Debug - Verificando todos os ${allCells.length} elementos (td/label) da linha:`
                                );
                                allCells.forEach((cell, idx) => {
                                    log(
                                        `📋 Elemento ${
                                            idx + 1
                                        }: <${cell.tagName.toLowerCase()}> classe="${
                                            cell.className
                                        }", texto="${cell.textContent
                                            .trim()
                                            .substring(
                                                0,
                                                30
                                            )}", onmouseover="${!!cell.getAttribute(
                                            "onmouseover"
                                        )}"`
                                    );
                                });
                            }

                            // Buscar a célula de data do evento na mesma linha (geralmente é a 3ª coluna)
                            const eventCells = eventRow.querySelectorAll("td");
                            if (eventCells.length >= 3) {
                                // A data geralmente está na 3ª célula (índice 2)
                                const dateCell = eventCells[2];
                                if (dateCell) {
                                    const dateText =
                                        dateCell.textContent.trim();
                                    // Verificar se parece uma data (formato XX/XX/XXXX)
                                    if (dateText.match(/\d{2}\/\d{2}\/\d{4}/)) {
                                        eventoData = dateText;
                                        log(
                                            `📅 Data encontrada na linha do evento: "${eventoData}"`
                                        );
                                    }
                                }
                            }

                            if (!eventoData) {
                                // Fallback: buscar qualquer texto que pareça uma data na linha
                                const allText = eventRow.textContent;
                                const dateMatch = allText.match(
                                    /(\d{2}\/\d{2}\/\d{4}[\s\d:]*)/
                                );
                                if (dateMatch) {
                                    eventoData = dateMatch[1].trim();
                                    log(
                                        `📅 Data encontrada via fallback: "${eventoData}"`
                                    );
                                }
                            }
                        } else {
                            log(
                                " Não foi possível encontrar a linha (tr) do evento que contém o link do documento"
                            );

                            // Debug: verificar estrutura ao redor do link
                            log(" Debug - Estrutura ao redor do link:");
                            let parent = linkElement.parentElement;
                            let level = 0;
                            while (parent && level < 5) {
                                log(
                                    ` Nível ${level}: ${parent.tagName} (id: ${
                                        parent.id || "N/A"
                                    }, classe: ${parent.className || "N/A"})`
                                );
                                parent = parent.parentElement;
                                level++;
                            }
                        }

                        // Adicionar a descrição, data e magistrado encontrados ao objeto do link
                        linkData.eventoDescricao =
                            eventoDescricao || linkData.tipo.descricao;
                        linkData.eventoData = eventoData || "";

                        // Tratar eventoMagistrado corretamente (pode ser string ou objeto)
                        if (
                            typeof eventoMagistrado === "object" &&
                            eventoMagistrado.nome
                        ) {
                            // Se é objeto estruturado, usar o nome
                            linkData.eventoMagistrado = eventoMagistrado.nome;
                        } else {
                            // Se é string, usar diretamente
                            linkData.eventoMagistrado = eventoMagistrado || "";
                        }

                        log(
                            `📋 Dados finais para documento #${
                                index + 1
                            }: Descrição: "${
                                linkData.eventoDescricao
                            }", Data: "${linkData.eventoData}", Magistrado: "${
                                linkData.eventoMagistrado
                            }"`
                        );
                    });
                } else {
                    log(
                        " Não é página de lista de documentos ou não há documentos relevantes - descrições não serão buscadas"
                    );
                    // Se não estivermos na lista de documentos, usar descrição padrão do tipo
                    documentosData.forEach((linkData) => {
                        linkData.eventoDescricao = linkData.tipo.descricao;
                        linkData.eventoData = "";
                        linkData.eventoMagistrado = "";
                    });
                }

                // Converter dados coletados para o formato final
                const documentosRelevantes = documentosData.map((linkData) => ({
                    element: linkData.element,
                    href: linkData.href,
                    texto: linkData.texto,
                    tipo: linkData.tipo,
                    eventoId: linkData.eventoId,
                    docId: linkData.docId,
                    seqEvento: linkData.seqEvento,
                    tipoDocumento: linkData.tipoDocumento,
                    tamanho: linkData.tamanho,
                    eventoDescricao: linkData.eventoDescricao,
                    eventoData: linkData.eventoData,
                    eventoMagistrado: linkData.eventoMagistrado,
                    magistradoInfo: linkData.magistradoInfo, // Informações estruturadas
                    index: linkData.index,
                }));

                // VERIFICAÇÃO FINAL E FALLBACK
                if (documentosRelevantes.length === 0) {
                    log(
                        "⚠️ NENHUM DOCUMENTO ENCONTRADO - Tentando estratégias de fallback..."
                    );

                    // Fallback 1: Buscar qualquer link que tenha padrões suspeitos
                    const linksSuspeitos = Array.from(
                        document.querySelectorAll("a")
                    ).filter((link) => {
                        const texto = link.textContent.trim().toUpperCase();
                        const href = link.getAttribute("href") || "";

                        // Padrões mais amplos
                        const padroesSuspeitos = [
                            /SENT\d*/i,
                            /INIC\d*/i,
                            /DECI\d*/i,
                            /DESP\d*/i,
                            /PETI\d*/i,
                            /DOCUMENTO\s*\d+/i,
                            /SENTENÇA/i,
                            /PETIÇÃO/i,
                            /DECISÃO/i,
                            /DESPACHO/i,
                        ];

                        const temPadraoTexto = padroesSuspeitos.some((padrao) =>
                            padrao.test(texto)
                        );
                        const temPadraoHref = padroesSuspeitos.some((padrao) =>
                            padrao.test(href)
                        );

                        return (
                            temPadraoTexto ||
                            temPadraoHref ||
                            (href.includes("documento") && texto.length > 2)
                        );
                    });

                    if (linksSuspeitos.length > 0) {
                        log(
                            `✅ FALLBACK: Encontrados ${linksSuspeitos.length} links suspeitos`
                        );

                        // Converter para o formato esperado
                        const documentosFallback = linksSuspeitos
                            .slice(0, 10)
                            .map((link, index) => {
                                // Limitado a 10 para performance
                                const texto = link.textContent.trim();
                                const href = link.getAttribute("href") || "";

                                // Determinar tipo baseado no texto
                                let tipoDetectado = null;
                                const tiposDisponiveis = Object.values(
                                    TIPOS_DOCUMENTO_RELEVANTE
                                );

                                for (const tipo of tiposDisponiveis) {
                                    if (
                                        texto
                                            .toUpperCase()
                                            .includes(tipo.nome) ||
                                        href
                                            .toUpperCase()
                                            .includes(tipo.dataNome)
                                    ) {
                                        tipoDetectado = tipo;
                                        break;
                                    }
                                }

                                // Fallback para tipo genérico
                                if (!tipoDetectado) {
                                    tipoDetectado = {
                                        nome: texto.substring(0, 8) || "DOC",
                                        descricao: "Documento Relevante",
                                        dataNome: "DOC",
                                    };
                                }

                                return {
                                    element: link,
                                    href: href,
                                    texto: texto,
                                    tipo: tipoDetectado,
                                    eventoId: "",
                                    docId: "",
                                    seqEvento: "",
                                    tipoDocumento: tipoDetectado.descricao,
                                    tamanho: "",
                                    eventoDescricao: tipoDetectado.descricao,
                                    eventoData: "",
                                    eventoMagistrado: "",
                                    magistradoInfo: null,
                                    index: index + 1,
                                    origem: "fallback",
                                };
                            });

                        log(
                            `✅ FALLBACK: Retornando ${documentosFallback.length} documentos`
                        );
                        return documentosFallback;
                    }
                }

                log(
                    `✅ RESULTADO FINAL: ${documentosRelevantes.length} documentos relevantes encontrados`
                );
                return documentosRelevantes;
            }

            // Abrir documento relevante automaticamente (com suporte a múltiplos documentos) - usando expressão de função
            const autoOpenDocumentoRelevante = async function () {
                const pageType = detectPageType();
                log(" Tipo de página:", pageType);

                if (pageType !== "lista_documentos") {
                    log(" Não está na página de lista de documentos");
                    return false;
                }

                const documentosRelevantes = findDocumentosRelevantes();

                if (documentosRelevantes.length === 0) {
                    log(" Nenhum documento relevante encontrado");
                    showNotification(
                        "Nenhum documento relevante encontrado nesta página",
                        "error"
                    );
                    return false;
                }

                let selectedDocument;

                if (documentosRelevantes.length === 1) {
                    // Apenas um documento encontrado
                    selectedDocument = documentosRelevantes[0];
                    log(
                        " Um documento encontrado, selecionando automaticamente"
                    );
                } else {
                    // Múltiplos documentos encontrados
                    log(
                        ` ${documentosRelevantes.length} documentos encontrados, solicitando seleção do usuário`
                    );

                    log(
                        " DEBUG: documentosRelevantes antes do modal:",
                        documentosRelevantes.map((doc) => ({
                            index: doc.index,
                            tipo: doc.tipo.descricao,
                            eventoDescricao: doc.eventoDescricao,
                            seqEvento: doc.seqEvento,
                        }))
                    );
                    selectedDocument = await showDocumentSelectionModal(
                        documentosRelevantes
                    );

                    if (!selectedDocument) {
                        log(" Usuário cancelou a seleção");
                        return false;
                    }
                }

                log(" Abrindo documento selecionado:", selectedDocument.href);
                showNotification(
                    `Abrindo ${selectedDocument.tipo.descricao} selecionada...`,
                    "info"
                );

                // Abrir em uma nova aba
                window.open(selectedDocument.href, "_blank");

                return true;
            };

            // Extrair texto do documento - usando expressão de função
            const autoExtractText = async function () {
                const pageType = detectPageType();
                log("🔍 Tipo de página detectado:", pageType);

                // ✅ NOVA LÓGICA: Usar resultado da detecção melhorada
                if (pageType === "documento_pdf") {
                    log(
                        "📄 PDF confirmado - extraindo texto automaticamente..."
                    );
                    showNotification("📄 Extraindo texto do PDF...", "info");

                    try {
                        const textoExtraido = await extractTextFromPDF();

                        if (!textoExtraido || textoExtraido.length < 100) {
                            throw new Error(
                                "Texto extraído é muito pequeno ou vazio"
                            );
                        }

                        showNotification(
                            `✅ Texto extraído: ${textoExtraido.length} caracteres`,
                            "success"
                        );
                        return textoExtraido;
                    } catch (error) {
                        console.error("❌ Falha na extração de PDF:", error);
                        showNotification(
                            `❌ Erro ao extrair PDF: ${error.message}`,
                            "error"
                        );
                        return null;
                    }
                }

                // ✅ ESTRATÉGIA ESPECÍFICA PARA PDFS: Verificar clipboard inteligente
                const currentPageType = detectPageType();
                if (currentPageType === "documento_pdf") {
                    console.log(
                        "📄 PDF detectado - verificando clipboard para texto copiado..."
                    );

                    try {
                        const clipboardText =
                            await navigator.clipboard.readText();
                        if (clipboardText && clipboardText.length > 50) {
                            console.log(
                                "📋 Texto encontrado no clipboard:",
                                clipboardText.length,
                                "caracteres"
                            );

                            // Verificar se parece com conteúdo de documento jurídico
                            const contemTermosJuridicos =
                                /\b(processo|sentença|decisão|despacho|petição|comarca|juiz|tribunal|recurso|apelação|embargos|tjsc|eproc|art|artigo|inciso|parágrafo|código|lei)\b/i.test(
                                    clipboardText
                                );
                            const contemFormatoData =
                                /\d{1,2}\/\d{1,2}\/\d{4}/.test(clipboardText);
                            const contemNumeroProcesso =
                                /\d{7}-\d{2}\.\d{4}\.\d{1}\.\d{2}\.\d{4}/.test(
                                    clipboardText
                                );
                            const contemTextoEstruturado =
                                clipboardText.split("\n").length > 5;

                            if (
                                contemTermosJuridicos ||
                                contemFormatoData ||
                                contemNumeroProcesso ||
                                contemTextoEstruturado
                            ) {
                                console.log(
                                    "✅ Texto jurídico detectado no clipboard - usando automaticamente"
                                );
                                showNotification(
                                    "📋 Texto extraído do clipboard automaticamente!",
                                    "success"
                                );
                                return clipboardText.trim();
                            } else {
                                console.log(
                                    "⚠️ Texto no clipboard não parece ser de documento jurídico"
                                );
                            }
                        }
                    } catch (clipError) {
                        console.log(
                            "⚠️ Não foi possível acessar clipboard:",
                            clipError.message
                        );
                    }

                    // Se chegou aqui, é PDF mas não tem texto adequado no clipboard
                    showNotification(
                        `
                        📄 PDF detectado! Para extrair:
                        
                        1️⃣ Aguarde carregar completamente
                        2️⃣ Selecione todo texto (Ctrl+A)
                        3️⃣ Copie (Ctrl+C)
                        4️⃣ Clique novamente no botão
                        
                        ⚡ Detecção automática ativada!
                    `.trim(),
                        "info",
                        6000
                    );

                    return null; // Não prosseguir para outras estratégias
                }

                // Aceitar múltiplos tipos de página de documento HTML
                const validDocumentTypes = [
                    "documento_especifico",
                    "documento_html",
                ];

                if (!validDocumentTypes.includes(pageType)) {
                    // Se não é um tipo de documento reconhecido, verificar se há documentos na página
                    const pageHTML = document.documentElement.outerHTML;
                    const hasDocumentHtml = pageHTML.includes(
                        "acessar_documento&id"
                    );
                    const hasDocumentPdf = pageHTML.includes(
                        "acessar_documento&amp"
                    );

                    log(
                        "⚠️ Verificação adicional para página não reconhecida:",
                        {
                            pageType: pageType,
                            hasDocumentHtml: hasDocumentHtml,
                            hasDocumentPdf: hasDocumentPdf,
                        }
                    );

                    if (!hasDocumentHtml && !hasDocumentPdf) {
                        log("❌ Não está na página do documento específico");
                        showNotification(
                            "Execute na página do documento, não na lista",
                            "error"
                        );
                        return null;
                    } else {
                        log(
                            "✅ Página contém documentos, prosseguindo com extração..."
                        );
                    }
                }

                // Aguardar documento carregar completamente
                await waitForDocumentLoad();

                // ✅ NOVA LÓGICA: PDF já foi processado acima
                // SE NÃO É PDF, PROCESSAR COMO DOCUMENTO HTML NORMAL
                log("📄 Documento HTML detectado, processando...");

                // Verificar se há seção do documento (para sentenças HTML)
                const sectionDocumento = document.querySelector(
                    'section[data-nome="sentenca"]'
                );
                if (!sectionDocumento) {
                    log("⚠️ Section do documento não encontrada");

                    // Buscar texto alternativo
                    const allText =
                        document.body.textContent ||
                        document.body.innerText ||
                        "";
                    if (allText.length < 100) {
                        log("❌ Pouco conteúdo encontrado na página");
                        showNotification(
                            "Pouco conteúdo encontrado. Verifique se está na página correta.",
                            "error"
                        );
                        return null;
                    }

                    log(
                        "✅ Texto encontrado no body da página:",
                        allText.length,
                        "caracteres"
                    );
                    return allText;
                }

                // Extrair texto da seção do documento HTML
                log("✅ Section do documento encontrada, processando...");

                // Extrair usando classes específicas do eProc
                const seletorParagrafos = [
                    "p.paragrafoPadrao",
                    "p.paragrafoComRecuo",
                    "p.paragrafoCentralizado",
                    "p.paragrafoSemRecuo",
                    "p.citacao",
                    "p.citacao2",
                    "span.dispositivo",
                    "div.paragrafoPadrao",
                    "div.paragrafoComRecuo",
                    "div.paragrafoCentralizado",
                    "div.paragrafoSemRecuo",
                ].join(", ");

                const paragrafosTexto =
                    sectionDocumento.querySelectorAll(seletorParagrafos);
                log(
                    ` Encontrados ${paragrafosTexto.length} parágrafos com classes específicas`
                );

                let textosParágrafos = [];

                if (paragrafosTexto.length > 0) {
                    // Extrair texto dos parágrafos com classes específicas
                    paragrafosTexto.forEach((paragrafo, idx) => {
                        const textoP =
                            paragrafo.innerText || paragrafo.textContent || "";
                        if (textoP.trim().length > 0) {
                            textosParágrafos.push(textoP.trim());
                            log(
                                ` P${idx + 1} (${
                                    paragrafo.className
                                }): ${textoP.substring(0, 100)}...`
                            );
                        }
                    });
                } else {
                    log(" Nenhum parágrafo com classes específicas encontrado");
                    log(" Tentando extração da seção completa...");

                    // Fallback: extrair texto completo da seção (limpo)
                    const elementoLimpo = sectionDocumento.cloneNode(true);

                    // Remover elementos indesejados
                    const elementosParaRemover = elementoLimpo.querySelectorAll(
                        "nav, header, footer, .menu, .navbar, .breadcrumb, .navigation, " +
                            '[class*="link"], [class*="menu"], [class*="nav"], [class*="toolbar"], ' +
                            '[class*="button"], [class*="btn"], [id*="menu"], [id*="nav"], ' +
                            "a, button, input, select, textarea, script, style, " +
                            '[class*="infra"], [id*="infra"], [class*="processo"], [id*="processo"], ' +
                            '[class*="evento"], [id*="evento"], [class*="documento"], [id*="documento"], ' +
                            ".fechar, .copiar, .print, .imprimir, .voltar, .close"
                    );

                    elementosParaRemover.forEach((el) => el.remove());

                    const textoCompleto =
                        elementoLimpo.innerText ||
                        elementoLimpo.textContent ||
                        "";
                    if (textoCompleto.trim().length > 0) {
                        textosParágrafos.push(textoCompleto.trim());
                    }
                }

                if (textosParágrafos.length === 0) {
                    log(" Nenhum texto válido encontrado");
                    showNotification(
                        " Nenhum texto válido encontrado no documento",
                        "error"
                    );
                    return null;
                }

                const textoFinal = textosParágrafos.join("\n\n");

                // Limpeza final de metadados residuais
                const texto = textoFinal
                    .replace(/processo\s+\d+[-\d.]+\/\w+/gi, "") // Remove números de processo
                    .replace(/evento\s+\d+/gi, "") // Remove referências a eventos
                    .replace(/SENT\d+/gi, "") // Remove referências SENT
                    .replace(/DOC\d+/gi, "") // Remove referências DOC
                    .replace(/\d+\.\d+/g, "") // Remove números de seção
                    .replace(/Fechar|Copiar|Print|Imprimir|Voltar/gi, "") // Remove textos de botões
                    .replace(/Copiar link para documento:/gi, "") // Remove texto específico
                    .replace(/^\s*[^\w\s]*\s*/, "") // Remove caracteres especiais do início
                    .replace(/\s+/g, " ") // Normaliza espaços
                    .trim();

                log(" Texto extraído:", texto.length, "caracteres");
                log(" Prévia do texto:", texto.substring(0, 200) + "...");

                if (texto.trim().length < 100) {
                    log(" Texto muito pequeno");
                    showNotification(
                        "Texto extraído é muito pequeno",
                        "warning"
                    );
                    return null;
                }

                showNotification(
                    ` Texto extraído: ${texto.length} caracteres`,
                    "success"
                );
                return texto.trim();
            };

            // 🔧 FUNÇÃO DE DEBUG PARA PDF DO EPROC - MOVIDA PARA ESCOPO CORRETO
            function debugPDFExtracao() {
                console.log("🔍 DEBUG PDF EPROC: Analisando página atual...");

                const info = {
                    url: window.location.href,
                    isEprocDocument:
                        window.location.href.includes("acessar_documento"),
                    urlParams: Object.fromEntries(
                        new URLSearchParams(window.location.search)
                    ),

                    // Elementos PDF na página
                    elementos: {},

                    // Estado do PDF.js
                    pdfjs: {
                        carregado: typeof pdfjsLib !== "undefined",
                        versao:
                            typeof pdfjsLib !== "undefined"
                                ? pdfjsLib.version
                                : null,
                    },

                    // Informações da página
                    titulo: document.title,
                    temIframes: document.querySelectorAll("iframe").length,
                    temEmbeds: document.querySelectorAll("embed").length,
                    temObjects: document.querySelectorAll("object").length,
                };

                // Analisar elementos PDF
                const selectors = [
                    'iframe[src*="pdf"]',
                    'embed[type="application/pdf"]',
                    'object[type="application/pdf"]',
                    'iframe[src*="acessar_documento"]',
                    "#plugin",
                    'embed[type="application/x-google-chrome-pdf"]',
                ];

                selectors.forEach((selector) => {
                    const elemento = document.querySelector(selector);
                    info.elementos[selector] = elemento
                        ? {
                              encontrado: true,
                              src: elemento.src || elemento.data || "N/A",
                              type: elemento.type || "N/A",
                              id: elemento.id || "N/A",
                              className: elemento.className || "N/A",
                          }
                        : { encontrado: false };
                });

                // Listar todos os iframes para debug
                info.todosIframes = Array.from(
                    document.querySelectorAll("iframe")
                ).map((iframe, i) => ({
                    indice: i,
                    src: iframe.src || "N/A",
                    title: iframe.title || "N/A",
                    id: iframe.id || "N/A",
                    className: iframe.className || "N/A",
                }));

                console.log("📊 RELATÓRIO COMPLETO:", info);
                return info;
            }

            // Solucao automatica para extracao de texto de PDF (SEM DOWNLOADS)
            async function extractTextFromPDF() {
                console.log(
                    "Iniciando extracao automatica de PDF (sem downloads)..."
                );

                // Limpeza de clipboard se contem notificacoes eProbe
                try {
                    const clipboardContent =
                        await navigator.clipboard.readText();
                    if (clipboardContent) {
                        const contentLower = clipboardContent.toLowerCase();
                        const eProbeIndicators = [
                            "resumir documento",
                            "pdf detectado",
                            "clique dentro do pdf",
                            "aguarde o pdf carregar",
                            "selecione todo o texto do pdf",
                        ];
                        const hasEProbeContent = eProbeIndicators.some(
                            (indicator) => contentLower.includes(indicator)
                        );
                        if (hasEProbeContent) {
                            console.log(
                                "Limpando clipboard com conteudo eProbe"
                            );
                            await navigator.clipboard.writeText("");
                        }
                    }
                } catch (error) {
                    console.log(
                        "Aviso: Nao foi possivel verificar/limpar clipboard:",
                        error.message
                    );
                }

                // Verificacao de pagina
                const pageType = detectPageType();
                if (pageType !== "documento_pdf") {
                    throw new Error("Nao e uma pagina de documento PDF");
                }

                // Detectar elemento PDF apenas para validar existencia
                const pdfElement = document.querySelector(
                    'iframe[src*="pdf"], embed[type="application/pdf"], object[type="application/pdf"]'
                );
                if (!pdfElement) {
                    console.log("Elemento PDF nao encontrado no DOM");
                }

                console.log(
                    "Usando estrategias nativas (sem qualquer download)..."
                );

                // Estrategia 1: texto ja renderizado em iframes acessiveis
                const iframes = document.querySelectorAll(
                    'iframe[src*="acessar_documento"], iframe[src*="pdf"]'
                );
                for (const iframe of iframes) {
                    try {
                        const iframeDoc =
                            iframe.contentDocument ||
                            iframe.contentWindow.document;
                        if (iframeDoc && iframeDoc.body) {
                            const textoIframe =
                                iframeDoc.body.innerText ||
                                iframeDoc.body.textContent;
                            if (textoIframe && textoIframe.length > 100) {
                                console.log(
                                    "Texto extraido de iframe:",
                                    textoIframe.length,
                                    "caracteres"
                                );
                                return textoIframe.trim();
                            }
                        }
                    } catch (e) {
                        console.log("Iframe inacessivel (CORS):", e.message);
                    }
                }

                // Estrategia 2: Simulacao fisica
                console.log("Iniciando simulacao fisica no plugin PDF...");
                const textoSimulacao = await simularInteracaoFisicaPDF();
                if (textoSimulacao) {
                    console.log("Simulacao fisica bem sucedida");
                    showNotification(
                        "Texto extraido via simulacao automatica",
                        "success",
                        2000
                    );
                    return textoSimulacao.trim();
                }

                // Instrucoes manuais (ASCII apenas)
                console.log("Fallback: instrucoes manuais para copia do PDF");
                showNotification(
                    "Instrucao manual:\n1) Clique dentro do PDF\n2) Pressione Ctrl+A e depois Ctrl+C\n3) Clique novamente no botao eProbe para validar o texto",
                    "info",
                    12000
                );

                // Verificar clipboard (usuario pode ja ter copiado)
                try {
                    const clipboardText = await navigator.clipboard.readText();
                    if (clipboardText && clipboardText.length > 100) {
                        console.log(
                            "Texto encontrado no clipboard:",
                            clipboardText.length,
                            "caracteres"
                        );
                        const textoValidado = await checkClipboardForPDFText();
                        if (textoValidado) {
                            console.log("Texto juridico validado do PDF");
                            return textoValidado.trim();
                        } else {
                            console.log("Texto do clipboard rejeitado");
                        }
                    }
                } catch (clipError) {
                    console.log(
                        "Aviso: Nao foi possivel acessar clipboard:",
                        clipError.message
                    );
                }

                // Funcao interna para validar clipboard (sem emojis)
                async function checkClipboardForPDFText() {
                    try {
                        const text = await navigator.clipboard.readText();
                        if (!text || text.length < 100) return null;
                        const textLower = text.toLowerCase();
                        const eProbeIndicators = [
                            "resumir documento",
                            "pdf detectado",
                            "clique dentro do pdf",
                            "aguarde o pdf carregar",
                            "selecione todo o texto do pdf",
                            "copie o texto do pdf",
                            "clique novamente no botao eprobe",
                            "nao copie texto do console",
                            "copie apenas o texto do documento pdf",
                        ];
                        const eProbeCount = eProbeIndicators.filter((i) =>
                            textLower.includes(i)
                        ).length;
                        if (eProbeCount > 0) {
                            console.log(
                                "Texto rejeitado: contem notificacoes eProbe"
                            );
                            return null;
                        }
                        const logIndicators = [
                            "console.log",
                            "error:",
                            "warning:",
                            "debug:",
                        ];
                        const logCount = logIndicators.filter((i) =>
                            textLower.includes(i)
                        ).length;
                        if (logCount > 2) {
                            console.log(
                                "Texto rejeitado: contem logs de debug"
                            );
                            return null;
                        }
                        const termosJuridicos = [
                            "tribunal",
                            "juiz",
                            "processo",
                            "sentenca",
                            "decisao",
                            "despacho",
                            "acordao",
                            "recurso",
                            "apelacao",
                            "embargos",
                            "requerente",
                            "requerido",
                            "autor",
                            "reu",
                            "defesa",
                            "peticao",
                            "contestacao",
                            "agravo",
                            "mandado",
                            "citacao",
                        ];
                        const termosEncontrados = termosJuridicos.filter((t) =>
                            textLower.includes(t)
                        ).length;
                        if (termosEncontrados >= 2) {
                            console.log(
                                "Texto juridico validado (",
                                termosEncontrados,
                                "termos)"
                            );
                            return text;
                        }
                        return null;
                    } catch (error) {
                        console.log(
                            "Erro ao verificar clipboard:",
                            error.message
                        );
                        return null;
                    }
                }

                // Selecionar automaticamente (nao faz download)
                console.log("Tentando automacao de selecao...");
                const textFromSelection = await tryAutomaticSelection();
                if (textFromSelection) {
                    console.log("Extracao via selecao automatica bem sucedida");
                    return textFromSelection;
                }

                console.log(
                    "Falha: nenhuma estrategia sem download obteve texto"
                );
                showNotification(
                    "Nao foi possivel extrair texto automaticamente. Tente copiar manualmente e repetir.",
                    "warning",
                    5000
                );
                return null;
            }

            // 🤖 FUNÇÃO DE AUTOMAÇÃO COMPLETA - Ctrl+A + Ctrl+C automáticos
            async function tentarSelecaoAutomaticaCompleta() {
                console.log("🤖 Iniciando automação completa de seleção...");

                try {
                    // 1. Encontrar elemento PDF
                    const pdfElements = [
                        document.querySelector(
                            'iframe[src*="acessar_documento"]'
                        ),
                        document.querySelector('iframe[src*="pdf"]'),
                        document.querySelector('embed[type="application/pdf"]'),
                        document.querySelector(
                            'object[type="application/pdf"]'
                        ),
                        document.querySelector("#plugin"),
                        document.querySelector(
                            'embed[type="application/x-google-chrome-pdf"]'
                        ),
                    ].filter((el) => el !== null);

                    if (pdfElements.length === 0) {
                        console.log("❌ Nenhum elemento PDF encontrado");
                        return null;
                    }

                    const pdfElement = pdfElements[0];
                    console.log(
                        "📄 Elemento PDF encontrado:",
                        pdfElement.tagName
                    );

                    // 2. Focar no elemento PDF - VERSÃO ROBUSTA PARA IFRAMES EPROC
                    try {
                        pdfElement.focus();
                        pdfElement.click(); // Garantir foco

                        // ESTRATÉGIA ESPECIAL PARA IFRAME EPROC
                        if (
                            pdfElement.tagName === "IFRAME" &&
                            pdfElement.src.includes("acessar_documento")
                        ) {
                            console.log(
                                "🎯 Iframe eProc detectado - aplicando estratégias especiais..."
                            );

                            // Múltiplos cliques para garantir foco
                            pdfElement.click();
                            await new Promise((resolve) =>
                                setTimeout(resolve, 200)
                            );
                            pdfElement.click();
                            await new Promise((resolve) =>
                                setTimeout(resolve, 200)
                            );

                            // Tentar focar na janela do iframe se possível
                            try {
                                if (
                                    pdfElement.contentWindow &&
                                    !pdfElement.contentWindow.closed
                                ) {
                                    pdfElement.contentWindow.focus();
                                    console.log(
                                        "✅ Foco aplicado na janela do iframe"
                                    );
                                }
                            } catch (corsError) {
                                console.log(
                                    "⚠️ CORS bloqueou acesso ao iframe - isso é normal para eProc"
                                );
                            }
                        }

                        console.log("✅ Foco aplicado no PDF");
                    } catch (e) {
                        console.log("⚠️ Erro ao focar no PDF:", e.message);
                    }

                    // 3. Aguardar um momento MAIOR para o PDF carregar completamente (iframes eProc demoram mais)
                    console.log("⏳ Aguardando PDF carregar completamente...");
                    await new Promise((resolve) => setTimeout(resolve, 3000)); // 3 segundos para eProc

                    // 4. ESTRATÉGIA ESPECIAL: Tentar múltiplas abordagens para selecionar texto
                    console.log(
                        "🎯 Iniciando múltiplas estratégias de seleção..."
                    );

                    // ESTRATÉGIA A: KeyboardEvent padrão
                    console.log("🎯 Estratégia A: KeyboardEvent padrão...");
                    let textoSelecionado = await tentarSelecaoKeyboard(
                        pdfElement
                    );
                    if (textoSelecionado) {
                        console.log("✅ Sucesso com KeyboardEvent!");
                        return textoSelecionado;
                    }

                    // ESTRATÉGIA B: execCommand (mais compatível com iframes)
                    console.log("🎯 Estratégia B: execCommand...");
                    textoSelecionado = await tentarSelecaoExecCommand(
                        pdfElement
                    );
                    if (textoSelecionado) {
                        console.log("✅ Sucesso com execCommand!");
                        return textoSelecionado;
                    }

                    // ESTRATÉGIA C: Eventos nativos do browser
                    console.log("🎯 Estratégia C: Eventos nativos...");
                    textoSelecionado = await tentarSelecaoEventosNativos(
                        pdfElement
                    );
                    if (textoSelecionado) {
                        console.log("✅ Sucesso com eventos nativos!");
                        return textoSelecionado;
                    }

                    console.log("❌ Todas as estratégias de seleção falharam");
                    return null;
                } catch (error) {
                    console.log(
                        "❌ Erro na automação completa:",
                        error.message
                    );
                    return null;
                }
            }

            // Função auxiliar para validar texto jurídico
            async function validarTextoJuridico(texto) {
                if (!texto || texto.length < 100) {
                    return null;
                }

                const textLower = texto.toLowerCase();

                // Rejeitar notificações do eProbe
                const eProbeIndicators = [
                    "resumir documento",
                    "pdf detectado",
                    "clique dentro do pdf",
                    "aguarde o pdf carregar",
                    "selecione todo o texto do pdf",
                ];

                const hasEProbeContent = eProbeIndicators.some((indicator) =>
                    textLower.includes(indicator)
                );

                if (hasEProbeContent) {
                    console.log(
                        "❌ Texto rejeitado: contém notificações eProbe"
                    );
                    return null;
                }

                // Verificar termos jurídicos
                const termosJuridicos = [
                    "tribunal",
                    "juiz",
                    "processo",
                    "sentença",
                    "decisão",
                    "despacho",
                    "acórdão",
                    "recurso",
                    "requerente",
                    "requerido",
                ];

                const termosEncontrados = termosJuridicos.filter((termo) =>
                    textLower.includes(termo)
                ).length;

                if (termosEncontrados >= 2) {
                    console.log(
                        `✅ Texto jurídico validado (${termosEncontrados} termos)`
                    );
                    return texto;
                }

                console.log("⚠️ Texto não parece ser documento jurídico");
                return null;
            }

            // Função de validação FLEXÍVEL para debug e casos difíceis
            async function validarTextoJuridicoFlexivel(texto) {
                if (!texto || texto.length < 50) {
                    // Reduzido de 100 para 50
                    console.log("❌ Texto muito pequeno:", texto?.length);
                    return null;
                }

                const textLower = texto.toLowerCase();

                // 🚨 CRÍTICO: Rejeitar apenas notificações ÓBVIAS do eProbe
                const eProbeIndicatorsObvios = [
                    "resumir documento",
                    "executando automação:",
                    "clique no botão eprobe",
                    "estratégia de automação",
                    "aguarde pdf carregar",
                ];

                const hasEProbeObvio = eProbeIndicatorsObvios.some(
                    (indicator) => textLower.includes(indicator)
                );

                if (hasEProbeObvio) {
                    console.log(
                        "❌ Validação flexível: contém notificações óbvias eProbe"
                    );
                    return null;
                }

                // Verificar termos jurídicos - MUITO MAIS FLEXÍVEL
                const termosJuridicos = [
                    // Termos básicos
                    "tribunal",
                    "juiz",
                    "processo",
                    "sentença",
                    "decisão",
                    "despacho",
                    // Termos processuais
                    "acórdão",
                    "recurso",
                    "apelação",
                    "embargos",
                    // Partes processuais
                    "requerente",
                    "requerido",
                    "autor",
                    "réu",
                    "demandante",
                    "demandado",
                    // Documentos
                    "petição",
                    "contestação",
                    "agravo",
                    "mandado",
                    "citação",
                    // Outros termos jurídicos
                    "advogado",
                    "defesa",
                    "ação",
                    "causa",
                    "direito",
                    "lei",
                    "código",
                    "artigo",
                    "parágrafo",
                    "inciso",
                    "jurisprudência",
                    "precedente",
                    // Termos do eProc específicos
                    "tjsc",
                    "santa catarina",
                    "comarca",
                    "vara",
                    "juízo",
                ];

                const termosEncontrados = termosJuridicos.filter((termo) =>
                    textLower.includes(termo)
                ).length;

                console.log(
                    `🔍 Validação flexível: ${termosEncontrados} termos jurídicos encontrados`
                );

                // CRITÉRIO MUITO MAIS FLEXÍVEL: apenas 1 termo já basta
                if (termosEncontrados >= 1) {
                    console.log(
                        `✅ Validação flexível passou com ${termosEncontrados} termos`
                    );
                    return texto;
                }

                // Se não tem termos jurídicos, verificar se pelo menos parece ser texto estruturado
                const pareceBemFormatado =
                    texto.length > 200 &&
                    (texto.includes("\n") ||
                        texto.includes(".") ||
                        texto.includes(",")) &&
                    !textLower.includes("console.log") &&
                    !textLower.includes("error") &&
                    !textLower.includes("function");

                if (pareceBemFormatado) {
                    console.log(
                        "✅ Validação flexível: parece texto bem formatado, aprovando"
                    );
                    return texto;
                }

                console.log(
                    "❌ Validação flexível: não atende critérios mínimos"
                );
                console.log(
                    "🔍 Debug: Texto preview:",
                    texto.substring(0, 200)
                );
                return null;
            }

            // 🎯 NOVA FUNÇÃO: Automação com Validação RIGOROSA para eProc
            async function tentarAutomacaoComValidacaoRigorosa() {
                console.log(
                    "🔍 Iniciando automação com validação rigorosa de conteúdo eProc..."
                );

                try {
                    // 1. Limpar clipboard antes de começar
                    await navigator.clipboard.writeText("");
                    console.log("🧹 Clipboard limpo para automação rigorosa");

                    // 2. Encontrar elemento PDF específico do eProc
                    const pdfElement = document.querySelector(
                        'iframe[src*="acessar_documento"]'
                    );
                    if (!pdfElement) {
                        console.log(
                            "❌ Iframe eProc específico não encontrado"
                        );
                        return null;
                    }

                    console.log("📄 Iframe eProc encontrado:", pdfElement.src);

                    // 3. Foco agressivo no iframe
                    pdfElement.focus();
                    pdfElement.click();
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // 4. Tentar múltiplas abordagens de seleção
                    const estrategias = [
                        () => tentarSelecaoComValidacao("execCommand"),
                        () => tentarSelecaoComValidacao("keyboardEvent"),
                        () => tentarSelecaoComValidacao("eventosNativos"),
                    ];

                    for (const [index, estrategia] of estrategias.entries()) {
                        console.log(
                            `🎯 Tentativa ${
                                index + 1
                            }/3 com validação rigorosa...`
                        );

                        const resultado = await estrategia();
                        if (resultado) {
                            console.log(
                                `✅ Sucesso na tentativa ${index + 1}!`
                            );
                            return resultado;
                        }

                        // Aguardar antes da próxima tentativa
                        await new Promise((resolve) =>
                            setTimeout(resolve, 1500)
                        );
                    }

                    console.log(
                        "❌ Todas as tentativas de automação rigorosa falharam"
                    );
                    return null;
                } catch (error) {
                    console.log(
                        "❌ Erro na automação rigorosa:",
                        error.message
                    );
                    return null;
                }
            }

            // Função auxiliar: Tentar seleção com validação específica
            async function tentarSelecaoComValidacao(metodo) {
                try {
                    const pdfElement = document.querySelector(
                        'iframe[src*="acessar_documento"]'
                    );
                    if (!pdfElement) return null;

                    // Re-focar
                    pdfElement.focus();
                    pdfElement.click();

                    if (metodo === "execCommand") {
                        // Método execCommand
                        document.execCommand("selectAll");
                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000)
                        );
                        document.execCommand("copy");
                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000)
                        );
                    } else if (metodo === "keyboardEvent") {
                        // Método KeyboardEvent
                        const selectEvent = new KeyboardEvent("keydown", {
                            key: "a",
                            code: "KeyA",
                            ctrlKey: true,
                            bubbles: true,
                        });
                        pdfElement.dispatchEvent(selectEvent);
                        document.dispatchEvent(selectEvent);

                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000)
                        );

                        const copyEvent = new KeyboardEvent("keydown", {
                            key: "c",
                            code: "KeyC",
                            ctrlKey: true,
                            bubbles: true,
                        });
                        pdfElement.dispatchEvent(copyEvent);
                        document.dispatchEvent(copyEvent);

                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000)
                        );
                    } else if (metodo === "eventosNativos") {
                        // Método eventos nativos - triplo clique
                        const tripleClick = new MouseEvent("click", {
                            detail: 3,
                            bubbles: true,
                            cancelable: true,
                        });
                        pdfElement.dispatchEvent(tripleClick);
                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000)
                        );
                    }

                    // Verificar clipboard com validação RIGOROSA
                    const clipboardText = await navigator.clipboard.readText();
                    if (clipboardText && clipboardText.length > 50) {
                        console.log(
                            `🔍 ${metodo}: Texto obtido:`,
                            clipboardText.length,
                            "chars"
                        );
                        console.log(
                            `🔍 ${metodo}: Preview:`,
                            clipboardText.substring(0, 200)
                        );

                        // VALIDAÇÃO RIGOROSA: Verificar se é realmente conteúdo eProc/jurídico
                        const isConteudoEproc =
                            validarConteudoEprocRigoroso(clipboardText);
                        if (isConteudoEproc) {
                            console.log(
                                `✅ ${metodo}: Conteúdo eProc válido detectado!`
                            );
                            return clipboardText;
                        } else {
                            console.log(
                                `❌ ${metodo}: Conteúdo NÃO é eProc - rejeitado`
                            );
                            // Limpar clipboard inválido
                            await navigator.clipboard.writeText("");
                        }
                    }

                    return null;
                } catch (error) {
                    console.log(`❌ Erro no método ${metodo}:`, error.message);
                    return null;
                }
            }

            // Função de validação RIGOROSA específica para conteúdo eProc
            function validarConteudoEprocRigoroso(texto) {
                if (!texto || texto.length < 100) {
                    console.log("❌ Validação rigorosa: texto muito pequeno");
                    return false;
                }

                const textLower = texto.toLowerCase();

                // 🚨 REJEITAR IMEDIATAMENTE conteúdo obviamente não-eProc
                const indicadoresNaoEproc = [
                    "mercadolivre.com",
                    "produto.mercadolivre",
                    "polycard_client",
                    "facebook.com",
                    "google.com",
                    "youtube.com",
                    "amazon.com",
                    "tracking_id",
                    "search_layout",
                    "boneco",
                    "action figure",
                    "cavaleiros do zodiaco",
                    "bandai",
                    "cloth myth",
                    "whatsapp",
                    "instagram",
                    "twitter",
                    "linkedin",
                ];

                const temConteudoNaoEproc = indicadoresNaoEproc.some(
                    (indicador) => textLower.includes(indicador)
                );

                if (temConteudoNaoEproc) {
                    console.log(
                        "❌ Validação rigorosa: conteúdo não-eProc detectado"
                    );
                    return false;
                }

                // ✅ ACEITAR APENAS conteúdo com indicadores ESPECÍFICOS do eProc
                const indicadoresEproc = [
                    // Sistema eProc
                    "eproc",
                    "tjsc",
                    "tribunal de justica",
                    "santa catarina",
                    // Termos processuais específicos
                    "sentença",
                    "processo",
                    "decisão",
                    "despacho",
                    "acórdão",
                    "comarca",
                    "vara",
                    "juízo",
                    "magistrado",
                    "juiz",
                    // Documentos específicos
                    "petição inicial",
                    "contestação",
                    "recurso",
                    "agravo",
                    "mandado",
                    "citação",
                    "intimação",
                    "audiência",
                    // Partes processuais
                    "requerente",
                    "requerido",
                    "autor",
                    "réu",
                    "apelante",
                    "apelado",
                    // Assinaturas e autenticação
                    "assinatura digital",
                    "certificado digital",
                    "mp 2.200",
                    "documento assinado",
                    "hash",
                    "validacao",
                    // Conteúdo jurídico estruturado
                    "artigo",
                    "lei",
                    "código",
                    "constituição",
                    "jurisprudência",
                ];

                const termosEprocEncontrados = indicadoresEproc.filter(
                    (termo) => textLower.includes(termo)
                ).length;

                console.log(
                    `🔍 Validação rigorosa: ${termosEprocEncontrados} indicadores eProc encontrados`
                );

                // Critério rigoroso: pelo menos 2 termos específicos do eProc
                if (termosEprocEncontrados >= 2) {
                    console.log(
                        "✅ Validação rigorosa: conteúdo eProc autêntico confirmado"
                    );
                    return true;
                }

                // Fallback: verificar se parece estrutura de documento jurídico
                const pareceDocumentoJuridico =
                    texto.length > 500 &&
                    textLower.includes("tribunal") &&
                    (textLower.includes("processo") ||
                        textLower.includes("ação")) &&
                    !textLower.includes("http://") &&
                    !textLower.includes("www.");

                if (pareceDocumentoJuridico) {
                    console.log(
                        "✅ Validação rigorosa: aprovado como documento jurídico estruturado"
                    );
                    return true;
                }

                console.log(
                    "❌ Validação rigorosa: não atende critérios eProc específicos"
                );
                return false;
            }

            // 🤐 NOVA FUNÇÃO: Automação SILENCIOSA sem interferências visuais
            async function tentarAutomacaoSilenciosa() {
                console.log(
                    "🤐 Iniciando automação SILENCIOSA focada no PDF..."
                );

                try {
                    // 1. LIMPAR COMPLETAMENTE o clipboard
                    await navigator.clipboard.writeText("");
                    console.log("🧹 Clipboard totalmente limpo");

                    // 2. Encontrar APENAS o iframe do PDF (mais específico)
                    const iframePDF =
                        document.querySelector(
                            'iframe[src*="acessar_documento_implementacao"]'
                        ) ||
                        document.querySelector(
                            'iframe[src*="acessar_documento"]'
                        );

                    if (!iframePDF) {
                        console.log("❌ Iframe PDF específico não encontrado");
                        return null;
                    }

                    console.log("📄 Iframe PDF encontrado (silencioso)");

                    // 3. FOCO TOTAL no iframe - múltiplas tentativas
                    for (let i = 0; i < 3; i++) {
                        iframePDF.focus();
                        iframePDF.click();

                        // Tentar focar dentro do iframe se possível
                        try {
                            if (
                                iframePDF.contentWindow &&
                                !iframePDF.contentWindow.closed
                            ) {
                                iframePDF.contentWindow.focus();
                                if (
                                    iframePDF.contentWindow.document &&
                                    iframePDF.contentWindow.document.body
                                ) {
                                    iframePDF.contentWindow.document.body.focus();
                                }
                            }
                        } catch (corsError) {
                            // CORS esperado - ignorar silenciosamente
                        }

                        await new Promise((resolve) =>
                            setTimeout(resolve, 500)
                        );
                    }

                    console.log("📍 Foco exclusivo aplicado no PDF");

                    // 4. AGUARDAR PDF carregar COMPLETAMENTE
                    await new Promise((resolve) => setTimeout(resolve, 3000));

                    // 5. SELEÇÃO DIRETA no iframe (método mais direto)
                    console.log("🎯 Executando seleção direta...");

                    // Método A: execCommand direto
                    const selectSuccess = document.execCommand("selectAll");
                    console.log("📋 SelectAll resultado:", selectSuccess);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    const copySuccess = document.execCommand("copy");
                    console.log("📋 Copy resultado:", copySuccess);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // 6. VERIFICAR clipboard com validação MÁXIMA
                    const clipboardText = await navigator.clipboard.readText();

                    if (clipboardText && clipboardText.length > 100) {
                        console.log(
                            "🔍 Texto obtido (silencioso):",
                            clipboardText.length,
                            "chars"
                        );

                        // VALIDAÇÃO EXTREMA: deve ser conteúdo PDF real
                        const isConteudoPDFReal =
                            validarConteudoPDFReal(clipboardText);
                        if (isConteudoPDFReal) {
                            console.log("✅ Conteúdo PDF real validado!");
                            return clipboardText;
                        } else {
                            console.log("❌ Ainda não é conteúdo PDF real");
                            // Limpar clipboard inválido
                            await navigator.clipboard.writeText("");
                        }
                    }

                    // Método B: KeyboardEvent se execCommand falhou
                    console.log("🔄 Tentando KeyboardEvent...");

                    const selectEvent = new KeyboardEvent("keydown", {
                        key: "a",
                        code: "KeyA",
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                    });

                    iframePDF.dispatchEvent(selectEvent);
                    document.dispatchEvent(selectEvent);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    const copyEvent = new KeyboardEvent("keydown", {
                        key: "c",
                        code: "KeyC",
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                    });

                    iframePDF.dispatchEvent(copyEvent);
                    document.dispatchEvent(copyEvent);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // Verificar novamente
                    const clipboardText2 = await navigator.clipboard.readText();
                    if (
                        clipboardText2 &&
                        clipboardText2 !== clipboardText &&
                        clipboardText2.length > 100
                    ) {
                        console.log(
                            "🔍 Novo texto obtido:",
                            clipboardText2.length,
                            "chars"
                        );

                        const isConteudoPDFReal2 =
                            validarConteudoPDFReal(clipboardText2);
                        if (isConteudoPDFReal2) {
                            console.log(
                                "✅ Conteúdo PDF real validado (KeyboardEvent)!"
                            );
                            return clipboardText2;
                        }
                    }

                    console.log(
                        "❌ Automação silenciosa não conseguiu extrair conteúdo válido"
                    );
                    return null;
                } catch (error) {
                    console.log(
                        "❌ Erro na automação silenciosa:",
                        error.message
                    );
                    return null;
                }
            }

            // Validação EXTREMA: apenas conteúdo que é REALMENTE de PDF jurídico
            function validarConteudoPDFReal(texto) {
                if (!texto || texto.length < 200) {
                    console.log("❌ Validação PDF: texto muito pequeno");
                    return false;
                }

                const textLower = texto.toLowerCase();

                // 🚨 REJEITAR IMEDIATAMENTE conteúdo que NÃO é PDF real
                const indicadoresNaoPDF = [
                    // Notificações eProbe
                    "resumir documento",
                    "problema detectado",
                    "solução garantida",
                    "feche outras abas",
                    "clique dentro",
                    "aguarde carregar",
                    "pressione ctrl",
                    "botão eprobe",
                    "automação",

                    // Logs do console
                    "main.js:",
                    "console.log",
                    "error:",
                    "warning:",
                    "debug:",
                    "interceptação",
                    "navbar",
                    "observer",
                    "função",
                    "✅",
                    "❌",
                    "🔍",
                    "🎯",
                    "📄",
                    "🚀",
                    "⚡",

                    // URLs e conteúdo web
                    "http://",
                    "https://",
                    "www.",
                    ".com",
                    ".br",
                    "mercadolivre",
                    "polycard_client",
                    "tracking_id",

                    // Conteúdo de outras abas
                    "search_layout",
                    "boneco",
                    "cloth myth",
                    "bandai",
                    "cavaleiros",
                    "action figure",
                ];

                const temConteudoNaoPDF = indicadoresNaoPDF.some((indicador) =>
                    textLower.includes(indicador)
                );

                if (temConteudoNaoPDF) {
                    console.log("❌ Validação PDF: contém conteúdo não-PDF");
                    return false;
                }

                // ✅ ACEITAR APENAS se tem MÚLTIPLOS indicadores de documento jurídico real
                const indicadoresPDFJuridico = [
                    // Assinaturas digitais típicas de PDF
                    "assinado digitalmente",
                    "certificado digital",
                    "hash",
                    "documento assinado eletrônicamente",
                    "validação",

                    // Estrutura típica de documentos jurídicos
                    "tribunal de justiça",
                    "poder judiciário",
                    "comarca",
                    "processo n",
                    "autos n",
                    "vara cível",
                    "vara criminal",

                    // Conteúdo jurídico estruturado
                    "vistos",
                    "relatório",
                    "fundamentação",
                    "dispositivo",
                    "isto posto",
                    "julgo",
                    "condeno",
                    "declaro",
                    "determino",
                    "defiro",
                    "indefiro",

                    // Partes processuais claras
                    "autor:",
                    "réu:",
                    "requerente:",
                    "requerido:",
                    "apelante:",
                    "apelado:",

                    // Citações legais
                    "código civil",
                    "código penal",
                    "constituição federal",
                    "lei n",
                    "artigo",
                    "parágrafo",
                    "inciso",

                    // Datas e protocolos processuais
                    "audiência",
                    "prazo",
                    "citação",
                    "intimação",
                    "recurso",
                ];

                const indicadoresEncontrados = indicadoresPDFJuridico.filter(
                    (indicador) => textLower.includes(indicador)
                ).length;

                console.log(
                    `🔍 Validação PDF: ${indicadoresEncontrados} indicadores jurídicos encontrados`
                );

                // Critério RÍGIDO: pelo menos 3 indicadores específicos
                if (indicadoresEncontrados >= 3) {
                    console.log(
                        "✅ Validação PDF: documento jurídico autêntico confirmado"
                    );
                    return true;
                }

                // Fallback: verificar estrutura típica de sentença/decisão
                const temEstruturaSentenca =
                    textLower.includes("tribunal") &&
                    textLower.includes("processo") &&
                    (textLower.includes("sentença") ||
                        textLower.includes("decisão") ||
                        textLower.includes("despacho")) &&
                    texto.length > 1000 &&
                    !textLower.includes("main.js");

                if (temEstruturaSentenca) {
                    console.log(
                        "✅ Validação PDF: estrutura de sentença detectada"
                    );
                    return true;
                }

                console.log(
                    "❌ Validação PDF: não atende critérios de documento jurídico real"
                );
                return false;
            }

            // 🖱️ NOVA FUNÇÃO: Simulação FÍSICA de interação com plugin PDF
            async function simularInteracaoFisicaPDF() {
                console.log("🖱️ Iniciando simulação física no plugin PDF...");

                try {
                    // 1. Limpar clipboard completamente
                    await navigator.clipboard.writeText("");
                    console.log("🧹 Clipboard limpo para simulação física");

                    // 2. Encontrar o container do PDF (iframe ou embed)
                    const pdfContainer =
                        document.querySelector(
                            'iframe[src*="acessar_documento"]'
                        ) ||
                        document.querySelector(
                            'embed[type="application/pdf"]'
                        ) ||
                        document.querySelector(
                            'object[type="application/pdf"]'
                        );

                    if (!pdfContainer) {
                        console.log("❌ Container PDF não encontrado");
                        return null;
                    }

                    console.log(
                        "📄 Container PDF encontrado:",
                        pdfContainer.tagName
                    );

                    // 3. Obter dimensões e posição do container
                    const rect = pdfContainer.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    console.log(
                        `📐 Dimensões PDF: ${rect.width}x${rect.height}`
                    );
                    console.log(
                        `🎯 Centro calculado: (${centerX}, ${centerY})`
                    );

                    // 4. SIMULAÇÃO FÍSICA: Clique no centro do PDF
                    console.log(
                        "🖱️ Simulando clique físico no centro do PDF..."
                    );

                    // Criar e disparar evento de clique no centro exato
                    const clickEvent = new MouseEvent("click", {
                        view: window,
                        bubbles: true,
                        cancelable: true,
                        clientX: centerX,
                        clientY: centerY,
                        button: 0,
                        buttons: 1,
                    });

                    pdfContainer.dispatchEvent(clickEvent);

                    // Também tentar foco direto
                    pdfContainer.focus();

                    // Aguardar o plugin responder ao clique
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // 5. SIMULAÇÃO FÍSICA: Ctrl+A (Selecionar tudo)
                    console.log("⌨️ Simulando Ctrl+A físico...");

                    const selectAllEvent = new KeyboardEvent("keydown", {
                        key: "a",
                        code: "KeyA",
                        keyCode: 65,
                        which: 65,
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                        view: window,
                    });

                    // Disparar em múltiplos alvos
                    document.dispatchEvent(selectAllEvent);
                    pdfContainer.dispatchEvent(selectAllEvent);
                    window.dispatchEvent(selectAllEvent);

                    // Aguardar seleção
                    await new Promise((resolve) => setTimeout(resolve, 1500));

                    // 6. SIMULAÇÃO FÍSICA: Ctrl+C (Copiar)
                    console.log("⌨️ Simulando Ctrl+C físico...");

                    const copyEvent = new KeyboardEvent("keydown", {
                        key: "c",
                        code: "KeyC",
                        keyCode: 67,
                        which: 67,
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                        view: window,
                    });

                    // Disparar em múltiplos alvos
                    document.dispatchEvent(copyEvent);
                    pdfContainer.dispatchEvent(copyEvent);
                    window.dispatchEvent(copyEvent);

                    // Aguardar cópia
                    await new Promise((resolve) => setTimeout(resolve, 1500));

                    // 7. Verificar clipboard
                    const clipboardText = await navigator.clipboard.readText();

                    if (clipboardText && clipboardText.length > 100) {
                        console.log(
                            "🔍 Texto obtido via simulação física:",
                            clipboardText.length,
                            "chars"
                        );
                        console.log(
                            "🔍 Preview:",
                            clipboardText.substring(0, 300)
                        );

                        // Validar se é conteúdo PDF real
                        const isConteudoPDFReal =
                            validarConteudoPDFReal(clipboardText);
                        if (isConteudoPDFReal) {
                            console.log(
                                "✅ Simulação física extraiu conteúdo PDF válido!"
                            );
                            return clipboardText;
                        } else {
                            console.log(
                                "❌ Simulação física: conteúdo não é PDF válido"
                            );
                        }
                    } else {
                        console.log(
                            "❌ Simulação física: clipboard vazio ou muito pequeno"
                        );
                    }

                    // 8. TENTATIVA ALTERNATIVA: Usar execCommand
                    console.log("🔄 Tentativa alternativa: execCommand...");

                    const selectSuccess = document.execCommand("selectAll");
                    console.log("📋 execCommand selectAll:", selectSuccess);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    const copySuccess = document.execCommand("copy");
                    console.log("📋 execCommand copy:", copySuccess);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    const clipboardText2 = await navigator.clipboard.readText();
                    if (
                        clipboardText2 &&
                        clipboardText2 !== clipboardText &&
                        clipboardText2.length > 100
                    ) {
                        console.log(
                            "🔍 Novo texto via execCommand:",
                            clipboardText2.length,
                            "chars"
                        );

                        const isConteudoPDF2 =
                            validarConteudoPDFReal(clipboardText2);
                        if (isConteudoPDF2) {
                            console.log(
                                "✅ execCommand extraiu conteúdo PDF válido!"
                            );
                            return clipboardText2;
                        }
                    }

                    console.log(
                        "❌ Simulação física não conseguiu extrair conteúdo válido"
                    );
                    return null;
                } catch (error) {
                    console.log("❌ Erro na simulação física:", error.message);
                    return null;
                }
            }

            //  FUNÇÃO: Instrução para seleção manual do PDF (SEM DOWNLOADS)
            async function instruirSelecaoManualPDF() {
                console.log(
                    "📄 Instruindo seleção manual do PDF (sem downloads)..."
                );

                try {
                    // Instruções para seleção manual
                    showNotification(
                        "📄 Para extrair texto do PDF:\n\n✅ INSTRUÇÕES:\n1. Pressione Ctrl+A para selecionar todo o texto\n2. Pressione Ctrl+C para copiar\n3. Clique no botão eProbe novamente\n\n🎯 O texto será detectado automaticamente!",
                        "info",
                        8000
                    );

                    // Aguardar um pouco e verificar clipboard
                    setTimeout(async () => {
                        const clipboardCheck =
                            await navigator.clipboard.readText();
                        if (clipboardCheck && clipboardCheck.length > 200) {
                            const isValid =
                                validarConteudoPDFReal(clipboardCheck);
                            if (isValid) {
                                showNotification(
                                    "✅ Texto detectado automaticamente!",
                                    "success",
                                    3000
                                );
                            }
                        }
                    }, 5000);

                    return null; // Aguardar ação manual
                } catch (error) {
                    console.log("❌ Erro na instrução manual:", error.message);
                    return null;
                }
            }

            // ESTRATÉGIA A: KeyboardEvent padrão melhorado
            async function tentarSelecaoKeyboard(pdfElement) {
                try {
                    // Re-focar antes de tentar
                    pdfElement.focus();
                    pdfElement.click();

                    const selectAllEvent = new KeyboardEvent("keydown", {
                        key: "a",
                        code: "KeyA",
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                    });

                    // Disparar em múltiplos alvos
                    pdfElement.dispatchEvent(selectAllEvent);
                    document.dispatchEvent(selectAllEvent);
                    window.dispatchEvent(selectAllEvent);

                    await new Promise((resolve) => setTimeout(resolve, 2000)); // Mais tempo

                    // Verificar seleção
                    const selection = window.getSelection();
                    const selectedText = selection.toString();

                    if (selectedText && selectedText.length > 100) {
                        console.log(
                            "✅ Texto selecionado via KeyboardEvent:",
                            selectedText.length,
                            "chars"
                        );
                        return await validarTextoJuridico(selectedText);
                    }

                    // Se não conseguiu via getSelection, tentar Ctrl+C
                    const copyEvent = new KeyboardEvent("keydown", {
                        key: "c",
                        code: "KeyC",
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                    });

                    pdfElement.dispatchEvent(copyEvent);
                    document.dispatchEvent(copyEvent);
                    window.dispatchEvent(copyEvent);

                    await new Promise((resolve) => setTimeout(resolve, 1500));

                    const clipboardText = await navigator.clipboard.readText();
                    if (clipboardText && clipboardText.length > 100) {
                        console.log(
                            "✅ Texto do clipboard via KeyboardEvent:",
                            clipboardText.length,
                            "chars"
                        );

                        // 🔍 DEBUG: Mostrar conteúdo real
                        console.log(
                            "🔍 DEBUG KeyboardEvent: Primeiros 500 chars:",
                            clipboardText.substring(0, 500)
                        );

                        const textoValidado =
                            await validarTextoJuridicoFlexivel(clipboardText);
                        if (textoValidado) {
                            return textoValidado;
                        } else {
                            console.log(
                                "⚠️ KeyboardEvent: Retornando texto bruto"
                            );
                            return clipboardText;
                        }
                    }

                    return null;
                } catch (error) {
                    console.log(
                        "❌ Erro na seleção KeyboardEvent:",
                        error.message
                    );
                    return null;
                }
            }

            // ESTRATÉGIA B: execCommand (mais compatível)
            async function tentarSelecaoExecCommand(pdfElement) {
                try {
                    pdfElement.focus();
                    pdfElement.click();

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // Selecionar tudo
                    const selectAllSuccess = document.execCommand("selectAll");
                    console.log(
                        "📋 execCommand selectAll resultado:",
                        selectAllSuccess
                    );

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // Verificar se há seleção
                    const selection = window.getSelection();
                    const selectedText = selection.toString();

                    if (selectedText && selectedText.length > 100) {
                        console.log(
                            "✅ Texto selecionado via execCommand:",
                            selectedText.length,
                            "chars"
                        );
                        return await validarTextoJuridico(selectedText);
                    }

                    // Copiar
                    const copySuccess = document.execCommand("copy");
                    console.log("📋 execCommand copy resultado:", copySuccess);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    const clipboardText = await navigator.clipboard.readText();
                    if (clipboardText && clipboardText.length > 100) {
                        console.log(
                            "✅ Texto do clipboard via execCommand:",
                            clipboardText.length,
                            "chars"
                        );

                        // 🔍 DEBUG: Mostrar conteúdo real para diagnóstico
                        console.log(
                            "🔍 DEBUG: Primeiros 500 chars do clipboard:",
                            clipboardText.substring(0, 500)
                        );
                        console.log(
                            "🔍 DEBUG: Últimos 200 chars do clipboard:",
                            clipboardText.slice(-200)
                        );

                        // Tentar validação menos restritiva
                        const textoValidado =
                            await validarTextoJuridicoFlexivel(clipboardText);
                        if (textoValidado) {
                            console.log("✅ Validação flexível passou!");
                            return textoValidado;
                        } else {
                            // Se falhou na validação flexível, tentar retornar texto bruto
                            console.log(
                                "⚠️ Validação flexível falhou, retornando texto bruto para análise"
                            );
                            return clipboardText; // Retornar mesmo assim para debug
                        }
                    }

                    return null;
                } catch (error) {
                    console.log(
                        "❌ Erro na seleção execCommand:",
                        error.message
                    );
                    return null;
                }
            }

            // ESTRATÉGIA C: Eventos nativos do browser
            async function tentarSelecaoEventosNativos(pdfElement) {
                try {
                    pdfElement.focus();
                    pdfElement.click();

                    // Simular clique triplo para seleção (funciona em muitos casos)
                    const clickEvent = new MouseEvent("click", {
                        detail: 3, // Triplo clique
                        bubbles: true,
                        cancelable: true,
                    });

                    pdfElement.dispatchEvent(clickEvent);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // Verificar seleção
                    const selection = window.getSelection();
                    const selectedText = selection.toString();

                    if (selectedText && selectedText.length > 100) {
                        console.log(
                            "✅ Texto selecionado via eventos nativos:",
                            selectedText.length,
                            "chars"
                        );
                        return await validarTextoJuridico(selectedText);
                    }

                    // Tentar Range API para seleção manual de todo o documento
                    try {
                        const range = document.createRange();
                        range.selectNodeContents(pdfElement);
                        selection.removeAllRanges();
                        selection.addRange(range);

                        await new Promise((resolve) =>
                            setTimeout(resolve, 500)
                        );

                        const rangeText = selection.toString();
                        if (rangeText && rangeText.length > 100) {
                            console.log(
                                "✅ Texto selecionado via Range API:",
                                rangeText.length,
                                "chars"
                            );
                            return await validarTextoJuridico(rangeText);
                        }
                    } catch (rangeError) {
                        console.log("⚠️ Range API falhou:", rangeError.message);
                    }

                    return null;
                } catch (error) {
                    console.log(
                        "❌ Erro na seleção com eventos nativos:",
                        error.message
                    );
                    return null;
                }
            }

            // ❌ FUNÇÃO DESABILITADA: Fetch direto do PDF (violava políticas do eProc)
            async function tryFetchPDFExtraction() {
                console.log(
                    "❌ FETCH PDF DESABILITADO: Esta função foi desabilitada por violação às políticas do eProc"
                );
                return null; // Sempre retorna null
            }

            // Estratégia 3: Automação de seleção FOCADA NO PDF
            async function tryAutomaticSelection() {
                try {
                    console.log(
                        "🤖 Iniciando seleção automática FOCADA no PDF..."
                    );

                    // 1. Encontrar elemento PDF específico
                    const pdfContainer = findPDFContainer();
                    if (!pdfContainer) {
                        console.log(
                            "❌ Container do PDF não encontrado - abortando seleção automática"
                        );
                        return null;
                    }

                    console.log(
                        "📍 Container do PDF encontrado:",
                        pdfContainer.tagName,
                        pdfContainer.className || pdfContainer.id
                    );

                    // 2. ESTRATÉGIA ESPECÍFICA PARA IFRAME EPROC
                    if (
                        pdfContainer.tagName === "IFRAME" &&
                        pdfContainer.src.includes("acessar_documento")
                    ) {
                        console.log(
                            "🎯 IFRAME eProc detectado - usando estratégia específica"
                        );

                        try {
                            // Tentar acessar conteúdo do iframe
                            const iframeDoc =
                                pdfContainer.contentDocument ||
                                pdfContainer.contentWindow.document;
                            if (iframeDoc) {
                                console.log(
                                    "✅ Iframe acessível - tentando seleção interna"
                                );

                                // Focar no iframe primeiro
                                pdfContainer.focus();
                                await new Promise((resolve) =>
                                    setTimeout(resolve, 300)
                                );

                                // Selecionar conteúdo do iframe
                                const iframeSelection =
                                    iframeDoc.getSelection();
                                iframeSelection.removeAllRanges();

                                const range = iframeDoc.createRange();
                                range.selectNodeContents(
                                    iframeDoc.body || iframeDoc.documentElement
                                );
                                iframeSelection.addRange(range);

                                await new Promise((resolve) =>
                                    setTimeout(resolve, 500)
                                );

                                // Tentar copiar conteúdo do iframe
                                let copySuccess = false;
                                try {
                                    copySuccess = iframeDoc.execCommand("copy");
                                } catch (e) {
                                    console.log(
                                        "⚠️ execCommand no iframe falhou:",
                                        e.message
                                    );
                                }

                                if (copySuccess) {
                                    await new Promise((resolve) =>
                                        setTimeout(resolve, 500)
                                    );
                                    const clipboardText =
                                        await navigator.clipboard.readText();
                                    if (
                                        clipboardText &&
                                        clipboardText.length > 100
                                    ) {
                                        console.log(
                                            "✅ Texto extraído do iframe:",
                                            clipboardText.length,
                                            "chars"
                                        );
                                        return await validarTextoJuridicoFlexivel(
                                            clipboardText
                                        );
                                    }
                                }
                            }
                        } catch (iframeError) {
                            console.log(
                                "⚠️ Iframe não acessível (CORS):",
                                iframeError.message
                            );
                        }

                        // Fallback para iframe: simular teclas diretamente no iframe
                        console.log(
                            "🔄 Fallback: simulação de teclas no iframe"
                        );
                        return await simularTeclasNoElemento(pdfContainer);
                    }

                    // 3. ESTRATÉGIA PARA ELEMENTOS EMBED/OBJECT
                    if (
                        pdfContainer.tagName === "EMBED" ||
                        pdfContainer.tagName === "OBJECT"
                    ) {
                        console.log(
                            "🎯 Elemento EMBED/OBJECT detectado - usando estratégia de plugin"
                        );
                        return await simularTeclasNoElemento(pdfContainer);
                    }

                    // 4. FALLBACK: Tentar seleção no container geral
                    console.log("  Usando estratégia geral para container");
                    return await simularTeclasNoElemento(pdfContainer);
                } catch (error) {
                    console.log(
                        "❌ Erro na seleção automática:",
                        error.message
                    );
                    return null;
                }
            }

            // Função auxiliar: Simular teclas Ctrl+A e Ctrl+C em elemento específico
            async function simularTeclasNoElemento(elemento) {
                try {
                    console.log(
                        "⌨️ Simulando teclas no elemento:",
                        elemento.tagName
                    );

                    // ESTRATÉGIA ESPECIAL PARA IFRAME EPROC
                    if (
                        elemento.tagName === "IFRAME" &&
                        elemento.src.includes("acessar_documento")
                    ) {
                        console.log(
                            "🎯 IFRAME eProc - usando estratégia especializada"
                        );

                        // 1. Múltiplos focos para garantir ativação
                        for (let i = 0; i < 3; i++) {
                            elemento.focus();
                            elemento.click();
                            await new Promise((resolve) =>
                                setTimeout(resolve, 200)
                            );
                        }

                        // 2. Tentar estratégias múltiplas de seleção
                        let resultado = await tentarSelecaoViaEventos(elemento);
                        if (resultado) return resultado;

                        resultado = await tentarSelecaoViaExecCommand(elemento);
                        if (resultado) return resultado;

                        // 3. Fallback: Aguardar ação manual com instruções específicas
                        return await aguardarAcaoManualEproc(elemento);
                    }

                    // ESTRATÉGIA PADRÃO PARA OUTROS ELEMENTOS
                    return await simularTeclasPadrao(elemento);
                } catch (error) {
                    console.log(
                        "❌ Erro na simulação de teclas:",
                        error.message
                    );
                    return null;
                }
            }

            // Estratégia 1: Eventos de teclado diretos no iframe
            async function tentarSelecaoViaEventos(iframe) {
                console.log("🔄 Tentando seleção via eventos de teclado...");

                // Focar iframe
                iframe.focus();
                await new Promise((resolve) => setTimeout(resolve, 500));

                // Simular Ctrl+A no iframe
                const selectEvent = new KeyboardEvent("keydown", {
                    key: "a",
                    code: "KeyA",
                    ctrlKey: true,
                    bubbles: true,
                    cancelable: true,
                });

                iframe.dispatchEvent(selectEvent);
                document.dispatchEvent(selectEvent);

                await new Promise((resolve) => setTimeout(resolve, 800));

                // Simular Ctrl+C no iframe
                const copyEvent = new KeyboardEvent("keydown", {
                    key: "c",
                    code: "KeyC",
                    ctrlKey: true,
                    bubbles: true,
                    cancelable: true,
                });

                iframe.dispatchEvent(copyEvent);
                document.dispatchEvent(copyEvent);

                await new Promise((resolve) => setTimeout(resolve, 1000));

                // Verificar clipboard
                const texto = await navigator.clipboard.readText();
                if (texto && texto.length > 200) {
                    console.log(
                        "✅ Texto obtido via eventos:",
                        texto.length,
                        "chars"
                    );
                    const textoValidado = await validarTextoJuridicoFlexivel(
                        texto
                    );
                    if (textoValidado) {
                        return cleanExtractedText(textoValidado);
                    }
                }

                console.log("❌ Seleção via eventos falhou");
                return null;
            }

            // Estratégia 2: execCommand no contexto global
            async function tentarSelecaoViaExecCommand(iframe) {
                console.log("🔄 Tentando seleção via execCommand...");

                iframe.focus();
                await new Promise((resolve) => setTimeout(resolve, 500));

                // Tentar selectAll global
                const selectSuccess = document.execCommand("selectAll");
                console.log("📋 execCommand selectAll:", selectSuccess);

                if (selectSuccess) {
                    await new Promise((resolve) => setTimeout(resolve, 800));

                    const copySuccess = document.execCommand("copy");
                    console.log("📋 execCommand copy:", copySuccess);

                    if (copySuccess) {
                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000)
                        );

                        const texto = await navigator.clipboard.readText();
                        if (texto && texto.length > 200) {
                            console.log(
                                "✅ Texto obtido via execCommand:",
                                texto.length,
                                "chars"
                            );
                            const textoValidado =
                                await validarTextoJuridicoFlexivel(texto);
                            if (textoValidado) {
                                return cleanExtractedText(textoValidado);
                            }
                        }
                    }
                }

                console.log("❌ Seleção via execCommand falhou");
                return null;
            }

            // Estratégia 3: Aguardar ação manual específica para eProc
            async function aguardarAcaoManualEproc(iframe) {
                console.log(
                    "🔄 Iniciando aguardo de ação manual para eProc..."
                );

                // Instruções específicas para PDF do eProc
                showNotification(
                    "INSTRUCOES PARA PDF EPROC:\n\n" +
                        "1. CLIQUE dentro da area do PDF (documento azul)\n" +
                        "2. Pressione CTRL+A (selecionar tudo)\n" +
                        "3. Pressione CTRL+C (copiar)\n" +
                        "4. Clique no botao eProbe novamente\n\n" +
                        "O sistema detectara automaticamente o texto copiado!",
                    "info",
                    15000
                );

                // Aguardar e verificar clipboard periodicamente
                for (let i = 0; i < 20; i++) {
                    // 20 segundos max
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    try {
                        const texto = await navigator.clipboard.readText();
                        if (texto && texto.length > 200) {
                            console.log(
                                "🔍 Verificando texto do clipboard:",
                                texto.length,
                                "chars"
                            );

                            const textoValidado =
                                await validarTextoJuridicoFlexivel(texto);
                            if (textoValidado) {
                                console.log(
                                    "✅ Texto jurídico válido detectado!"
                                );
                                showNotification(
                                    "Texto extraido com sucesso!",
                                    "success",
                                    3000
                                );
                                return cleanExtractedText(textoValidado);
                            }
                        }
                    } catch (e) {
                        // Continuar tentando
                    }
                }

                console.log("⏰ Timeout: aguardo de ação manual expirou");
                return null;
            }

            // Estratégia padrão para elementos não-iframe
            async function simularTeclasPadrao(elemento) {
                console.log(
                    "⌨️ Usando simulação padrão para:",
                    elemento.tagName
                );

                // 1. Focar elemento e aguardar
                elemento.focus();
                elemento.click();
                await new Promise((resolve) => setTimeout(resolve, 300));

                // 2. Simular Ctrl+A
                const selectAllEvent = new KeyboardEvent("keydown", {
                    key: "a",
                    code: "KeyA",
                    ctrlKey: true,
                    bubbles: true,
                    cancelable: true,
                });

                elemento.dispatchEvent(selectAllEvent);
                await new Promise((resolve) => setTimeout(resolve, 500));

                // 3. Simular Ctrl+C
                const copyEvent = new KeyboardEvent("keydown", {
                    key: "c",
                    code: "KeyC",
                    ctrlKey: true,
                    bubbles: true,
                    cancelable: true,
                });

                elemento.dispatchEvent(copyEvent);
                await new Promise((resolve) => setTimeout(resolve, 500));

                // 4. Verificar clipboard
                const clipboardText = await navigator.clipboard.readText();
                if (clipboardText && clipboardText.length > 100) {
                    console.log(
                        "✅ Texto extraído via simulação:",
                        clipboardText.length,
                        "chars"
                    );

                    // Validar se é conteúdo jurídico válido
                    const textoValidado = await validarTextoJuridicoFlexivel(
                        clipboardText
                    );
                    if (textoValidado) {
                        return cleanExtractedText(textoValidado);
                    }
                }

                console.log("❌ Simulação padrão não obteve texto válido");
                return null;
            }

            // Função auxiliar: Detectar URL do PDF
            function getPDFUrl() {
                // 1. Buscar elementos PDF incorporados
                const pdfSelectors = [
                    'iframe[src*="pdf"]',
                    'embed[type="application/pdf"]',
                    'object[type="application/pdf"]',
                    'iframe[src*="acessar_documento"]',
                    "#plugin",
                    'embed[type="application/x-google-chrome-pdf"]',
                ];

                for (const selector of pdfSelectors) {
                    const element = document.querySelector(selector);
                    if (element && (element.src || element.data)) {
                        return element.src || element.data;
                    }
                }

                // 2. Usar URL atual se for documento do eProc
                if (window.location.href.includes("acessar_documento")) {
                    return window.location.href;
                }

                return null;
            }

            // Função auxiliar: Encontrar container do PDF com foco preciso
            function findPDFContainer() {
                // 1. PRIORIDADE: Elementos PDF diretos (não body como fallback)
                const pdfElements = [
                    'iframe[src*="acessar_documento"]',
                    'embed[type="application/pdf"]',
                    'object[type="application/pdf"]',
                    'iframe[src*="pdf"]',
                    'embed[type="application/x-google-chrome-pdf"]',
                    "#plugin",
                ];

                for (const selector of pdfElements) {
                    const element = document.querySelector(selector);
                    if (element) {
                        console.log(
                            "📍 Container PDF específico encontrado:",
                            selector
                        );
                        return element;
                    }
                }

                // 2. Buscar por divs que podem conter PDF
                const pdfContainerSelectors = [
                    'div[class*="pdf"]',
                    'div[id*="pdf"]',
                    'div[class*="document"]',
                    'div[id*="document"]',
                ];

                for (const selector of pdfContainerSelectors) {
                    const element = document.querySelector(selector);
                    if (element && element.offsetHeight > 400) {
                        // Garantir que é um container significativo
                        console.log(
                            "📍 Container documento encontrado:",
                            selector
                        );
                        return element;
                    }
                }

                console.log("❌ Nenhum container PDF específico encontrado");
                return null; // NUNCA usar body como fallback
            }

            // Função auxiliar: Extrair texto com PDF.js
            async function extractWithPDFJS(arrayBuffer) {
                try {
                    console.log("📚 Extraindo com PDF.js...");

                    const pdf = await pdfjsLib.getDocument({
                        data: arrayBuffer,
                    }).promise;
                    console.log("📄 PDF carregado, páginas:", pdf.numPages);

                    let fullText = "";
                    const maxPages = Math.min(pdf.numPages, 15); // Limite de 15 páginas

                    for (let i = 1; i <= maxPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items
                            .map((item) => item.str)
                            .join(" ");
                        fullText += pageText + "\n\n";
                    }

                    if (fullText.trim().length > 100) {
                        return cleanExtractedText(fullText);
                    }

                    return null;
                } catch (error) {
                    console.log(
                        "❌ Erro na extração com PDF.js:",
                        error.message
                    );
                    return null;
                }
            }

            // Função auxiliar: Carregar PDF.js local (CSP-safe)
            async function loadLocalPDFJS() {
                try {
                    // Verificar se PDF.js já está disponível
                    if (typeof pdfjsLib !== "undefined") {
                        return true;
                    }

                    // Tentar carregar PDF.js do navegador (se disponível)
                    if (typeof window.pdfjsLib !== "undefined") {
                        window.pdfjsLib = window.pdfjsLib;
                        return true;
                    }

                    console.log(
                        "⚠️ PDF.js não disponível - usando apenas seleção automática"
                    );
                    return false;
                } catch (error) {
                    console.log("❌ Erro ao carregar PDF.js:", error.message);
                    return false;
                }
            }

            // Função auxiliar: Validar se é documento jurídico
            function isValidLegalDocument(text) {
                if (!text || text.length < 100) return false;

                // Detectar logs do console
                const logPatterns = [
                    /main\.js:/,
                    /🚨/,
                    /VM\d+/,
                    /📄|🔍|✅|❌|⚠️|🎯|📋|🔧|🌐|📊/,
                    /console\./,
                    /ERROR|WARNING|INFO|DEBUG/i,
                    /Interceptação|INTERCEPTAÇÃO/i,
                ];

                for (const pattern of logPatterns) {
                    if (pattern.test(text)) {
                        console.log("❌ Detectado log do console no texto");
                        return false;
                    }
                }

                // Validar palavras-chave jurídicas
                const legalKeywords = [
                    /\b(sentença|decisão|despacho|acórdão)\b/i,
                    /\b(processo|requerente|requerido|autor|réu)\b/i,
                    /\b(tribunal|juiz|desembargador|ministro)\b/i,
                    /\b(petição|inicial|contestação|recurso)\b/i,
                    /\b(dispositivo|fundamentação|relatório)\b/i,
                    /\b(artigo|lei|código|norma)\b/i,
                    /\b(julgo|decreto|determino|defiro|indefiro)\b/i,
                ];

                let keywordCount = 0;
                for (const keyword of legalKeywords) {
                    if (keyword.test(text)) {
                        keywordCount++;
                    }
                }

                return keywordCount >= 2; // Pelo menos 2 palavras-chave jurídicas
            }

            // Função auxiliar: Limpar texto extraído
            function cleanExtractedText(text) {
                return text
                    .replace(/[\u200B-\u200D\uFEFF]/g, "") // Remove zero-width chars
                    .replace(/[\u00A0]/g, " ") // Replace non-breaking space
                    .replace(/[\u2000-\u200A]/g, " ") // Replace unicode spaces
                    .replace(/[\u2028\u2029]/g, "\n") // Replace line/paragraph separators
                    .replace(/\s+/g, " ") // Normalize multiple spaces
                    .trim();
            }

            // 🔧 FUNÇÃO ALTERNATIVA PARA PDF (SEM PDF.JS EXTERNO - CSP SAFE)
            async function loadPDFJS() {
                return new Promise((resolve, reject) => {
                    // ❌ CSP não permite carregar PDF.js externo
                    // ✅ SOLUÇÃO: Usar estratégias nativas do navegador

                    console.log("📦 Usando estratégias nativas (CSP safe)...");

                    // ✅ ESTRATÉGIA 1: Verificar se o texto já está no clipboard
                    checkClipboardForPDFText()
                        .then((clipboardText) => {
                            if (clipboardText && clipboardText.length > 500) {
                                console.log(
                                    "✅ Texto encontrado no clipboard, usando essa estratégia"
                                );
                                resolve({
                                    type: "clipboard",
                                    text: clipboardText,
                                });
                                return;
                            }

                            // ✅ ESTRATÉGIA 2: Instruir usuário para seleção manual
                            console.log(
                                "🎯 Estratégia de seleção manual ativada"
                            );

                            // Aguardar um pouco e verificar novamente o clipboard
                            setTimeout(async () => {
                                try {
                                    const newClipboardText =
                                        await checkClipboardForPDFText();
                                    if (
                                        newClipboardText &&
                                        newClipboardText.length > 500
                                    ) {
                                        resolve({
                                            type: "clipboard-delayed",
                                            text: newClipboardText,
                                        });
                                    } else {
                                        resolve({
                                            type: "manual-instruction",
                                            instructions: [
                                                "1. Selecione todo o texto do PDF (Ctrl+A)",
                                                "2. Copie o texto (Ctrl+C)",
                                                "3. Clique novamente no botão eProbe",
                                            ],
                                        });
                                    }
                                } catch (error) {
                                    resolve({
                                        type: "fallback",
                                        message:
                                            "Use seleção manual (Ctrl+A, Ctrl+C)",
                                    });
                                }
                            }, 2000);
                        })
                        .catch((error) => {
                            console.log(
                                "⚠️ Erro ao verificar clipboard:",
                                error
                            );
                            resolve({
                                type: "fallback",
                                message: "Use seleção manual (Ctrl+A, Ctrl+C)",
                            });
                        });
                });
            }

            // Aguardar documento carregar completamente
            function waitForDocumentLoad() {
                return new Promise((resolve) => {
                    if (document.readyState === "complete") {
                        resolve();
                    } else {
                        window.addEventListener("load", resolve);
                    }
                });
            }

            // Copiar para clipboard - usando expressão de função
            const copyToClipboard = async function (text) {
                try {
                    await navigator.clipboard.writeText(text);
                    log(" Texto copiado para clipboard");
                    showNotification(
                        "Texto copiado para clipboard!",
                        "success"
                    );
                    return true;
                } catch (error) {
                    log(" Erro ao copiar:", error);
                    showNotification("Erro ao copiar texto", "error");
                    return false;
                }
            };

            // Limpar caracteres invisíveis que podem causar problemas no clipboard
            function cleanInvisibleChars(text) {
                return text
                    .replace(/[\u200B-\u200D\uFEFF]/g, "") // Remove zero-width chars
                    .replace(/[\u00A0]/g, " ") // Replace non-breaking space with regular space
                    .replace(/[\u2000-\u200A]/g, " ") // Replace various unicode spaces
                    .replace(/[\u2028\u2029]/g, "\n") // Replace line/paragraph separators
                    .trim();
            }

            // Copiar texto para clipboard com prefixo para IA
            async function copyToClipboardWithPrefix(texto) {
                try {
                    const prefixo = `Faça um resumo extremamente sucinto do documento, em formato de apontamentos diretos (bullet points), para constar na capa do processo digital. Indique: tipo de ação, partes, pedido(s) do autor, decisão (improcedente/procedente/parcialmente procedente), fundamentos centrais, condenação (custas/honorários se houver) Seja objetivo e direto, sem redação em texto corrido. 
                
                DOCUMENTO:`;

                    const textoLimpo = cleanInvisibleChars(texto);

                    // ✅ VERIFICAR SE O TEXTO JÁ CONTÉM O PREFIXO
                    let textoCompleto;
                    if (
                        textoLimpo.includes(
                            "Faça um resumo extremamente sucinto"
                        ) ||
                        textoLimpo.includes("DOCUMENTO:")
                    ) {
                        console.log(
                            "⚠️ Texto já contém prefixo, usando apenas o texto limpo"
                        );
                        textoCompleto = textoLimpo;
                    } else {
                        console.log("✅ Adicionando prefixo ao texto");
                        textoCompleto = cleanInvisibleChars(
                            prefixo + textoLimpo
                        );
                    }

                    log(" Debug - Texto que será copiado:");
                    log(" Tamanho:", textoCompleto.length, "caracteres");
                    log(
                        " Prévia (primeiros 200 chars):",
                        textoCompleto.substring(0, 200)
                    );
                    log(
                        " Final (últimos 200 chars):",
                        textoCompleto.substring(textoCompleto.length - 200)
                    );

                    await navigator.clipboard.writeText(textoCompleto);

                    // Verificar se realmente foi copiado
                    setTimeout(async () => {
                        try {
                            const clipboardContent =
                                await navigator.clipboard.readText();
                            log(
                                " Verificação: Texto no clipboard:",
                                clipboardContent.length,
                                "caracteres"
                            );
                            log(
                                " Conteúdo real no clipboard:",
                                clipboardContent.substring(0, 200)
                            );

                            if (clipboardContent === textoCompleto) {
                                log(" Clipboard confirmado: Texto correto!");
                            } else {
                                log(
                                    " ERRO: Texto no clipboard é diferente do enviado!"
                                );
                                log(" Debug diferença:");
                                log(
                                    " Esperado:",
                                    textoCompleto.length,
                                    "caracteres"
                                );
                                log(
                                    " Real:",
                                    clipboardContent.length,
                                    "caracteres"
                                );
                                log(
                                    " Diferença:",
                                    Math.abs(
                                        clipboardContent.length -
                                            textoCompleto.length
                                    ),
                                    "caracteres"
                                );

                                // Verificar se é apenas uma diferença de caracteres invisíveis
                                const textoLimpo = textoCompleto.replace(
                                    /[\u200B-\u200D\uFEFF]/g,
                                    ""
                                );
                                const clipboardLimpo = clipboardContent.replace(
                                    /[\u200B-\u200D\uFEFF]/g,
                                    ""
                                );

                                if (textoLimpo === clipboardLimpo) {
                                    log(
                                        " Clipboard OK (apenas caracteres invisíveis diferentes)"
                                    );
                                } else {
                                    log(" Clipboard realmente diferente");
                                    // Encontrar primeiro caractere diferente
                                    for (
                                        let i = 0;
                                        i <
                                        Math.min(
                                            textoCompleto.length,
                                            clipboardContent.length
                                        );
                                        i++
                                    ) {
                                        if (
                                            textoCompleto[i] !==
                                            clipboardContent[i]
                                        ) {
                                            log(
                                                ` Primeira diferença na posição ${i}:`
                                            );
                                            log(
                                                `Esperado: "${textoCompleto.substring(
                                                    i - 5,
                                                    i + 5
                                                )}"`
                                            );
                                            log(
                                                `Real: "${clipboardContent.substring(
                                                    i - 5,
                                                    i + 5
                                                )}"`
                                            );
                                            break;
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            log(" Não foi possível verificar o clipboard:", e);
                        }
                    }, 100);

                    log(
                        ` Texto copiado com prefixo (${textoCompleto.length} caracteres)`
                    );
                    showNotification(
                        ` Texto copiado com prefixo!\n${textoCompleto.length} caracteres prontos para IA`,
                        "success"
                    );
                    return true;
                } catch (error) {
                    log(" Erro ao copiar texto com prefixo:", error);
                    showNotification(" Erro ao copiar texto", "error");
                    return false;
                }
            }

            // Função genérica para abrir IA com texto e prompt específico
            async function openAIWithText(aiName, url, texto) {
                try {
                    log(`🚀 Abrindo ${aiName} para análise manual...`);

                    // Preparar o prompt específico para análise judicial
                    const prompt = `Você é um assistente especializado em resumir documentos judiciais de forma extremamente objetiva e sucinta para capas de processos digitais. Sempre responda em bullet points diretos.

    Faça um resumo extremamente sucinto do documento, em formato de apontamentos diretos (bullet points), para constar na capa do processo digital. Indique: tipo de ação, partes, pedido(s) do autor, decisão (improcedente/procedente/parcialmente procedente), fundamentos centrais, condenação (custas/honorários se houver). Seja objetivo e direto, sem redação em texto corrido.

    DOCUMENTO:
    ${texto}`;

                    // Copiar para área de transferência
                    await navigator.clipboard.writeText(prompt);

                    log(
                        `✅ Texto preparado para ${aiName} (${prompt.length} caracteres)`
                    );

                    // Abrir IA em nova aba
                    window.open(url, "_blank");

                    showNotification(
                        `${aiName} aberto!\n\nO prompt com o documento está na área de transferência.\nCole no ${aiName} (Ctrl+V) para análise.`,
                        "success"
                    );

                    log(`✅ ${aiName} aberto com sucesso em nova aba`);
                    return true;
                } catch (error) {
                    log(`❌ Erro ao abrir ${aiName}:`, error);
                    showNotification(`❌ Erro ao abrir ${aiName}`, "error");
                    return false;
                }
            }

            // Modal para seleção de IA
            async function showAISelectionModal(texto) {
                return new Promise((resolve) => {
                    // Remover modal existente se houver
                    const existingModal =
                        document.getElementById("ai-selection-modal");
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Criar overlay do modal
                    const overlay = document.createElement("div");
                    overlay.id = "ai-selection-modal";
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        z-index: 10002;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        font-family: "Roboto", -apple-system, system-ui, sans-serif;
                    `;

                    // Criar conteúdo do modal
                    const modal = document.createElement("div");
                    modal.style.cssText = `
                        background: #134377;
                        border-radius: 12px;
                        padding: 32px;
                        max-width: 520px;
                        width: 90%;
                        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.4);
                        border: 1px solid rgba(82, 82, 82, 0.3);
                    `;

                    modal.innerHTML = `
                        <div style="text-align: center; margin-bottom: 24px;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 8px;">
                                <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="white">
                                    <path d="M335-160q-16.3 0-30.65-8.5Q290-177 282-190l-73-132h61l39.64 80H398v-24h-72.06l-40.15-80H194l-58-105q-3.8-6-5.9-13.5-2.1-7.5-2.1-15.72 0-4.78 8-29.78l60.31-104H289l39-80h72v-24h-86.67L274-638h-63l71-132q7.57-13.86 22.06-21.93Q318.54-800 335-800h70q25.1 0 42.55 17.45Q465-765.1 465-740v154h-53l-36 24h89v136h-97l-39.94-80H240l-26 24h98l40.47 80H465v182q0 25.1-17.45 42.55Q430.1-160 405-160h-70Zm214 0q-25.1 0-42.55-17.45Q489-194.9 489-220v-182h119l40-80h93l-21-24h-89.06L591-426H489v-136h95l-36-24h-59v-154q0-25.1 17.45-42.55Q523.9-800 549-800h76q16.3 0 30.65 8.5Q670-783 678-770l72 130h-62.51L647-718h-87v24h71.74l39.96 82H765l59 102q3.8 6.33 5.9 14.17Q832-488 832-480q0 5-8 29l-57 105h-94.79l-40.15 80H560v24h87.36L687-322h63l-73 132q-8 13-22.35 21.5Q640.3-160 624-160h-75Z"/>
                                </svg>
                                <h2 style="color: white; margin: 0; font-size: 24px; font-weight: 600;">
                                    Escolha sua IA
                                </h2>
                            </div>
                            <p style="color: rgb(203 213 225); margin: 0; font-size: 16px;">
                                Selecione qual IA deseja usar para análise do documento
                            </p>
                        </div>

                        <div style="display: grid; gap: 12px; margin-bottom: 24px;">
                            <button id="ai-chatgpt" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                                    <path d="M21.55 10.004a5.416 5.416 0 00-.478-4.501c-1.217-2.09-3.662-3.166-6.05-2.66A5.59 5.59 0 0010.831 1C8.39.995 6.224 2.546 5.473 4.838A5.553 5.553 0 001.76 7.496a5.487 5.487 0 00.691 6.5 5.416 5.416 0 00.477 4.502c1.217 2.09 3.662 3.165 6.05 2.66A5.586 5.586 0 0013.168 23c2.443.006 4.61-1.546 5.361-3.84a5.553 5.553 0 003.715-2.66 5.488 5.488 0 00-.693-6.497v.001zm-8.381 11.558a4.199 4.199 0 01-2.675-.954c.034-.018.093-.05.132-.074l4.44-2.53a.71.71 0 00.364-.623v-6.176l1.877 1.069c.02.01.033.029.036.05v5.115c-.003 2.274-1.87 4.118-4.174 4.123zM4.192 17.78a4.059 4.059 0 01-.498-2.763c.032.02.09.055.131.078l4.44 2.53c.225.13.504.13.73 0l5.42-3.088v2.138a.068.068 0 01-.027.057L9.9 19.288c-1.999 1.136-4.552.46-5.707-1.51h-.001zM3.023 8.216A4.15 4.15 0 015.198 6.41l-.002.151v5.06a.711.711 0 00.364.624l5.42 3.087-1.876 1.07a.067.067 0 01-.063.005l-4.489-2.559c-1.995-1.14-2.679-3.658-1.53-5.63h.001zm15.417 3.54l-5.42-3.088L14.896 7.6a.067.067 0 01.063-.006l4.489 2.557c1.998 1.14 2.683 3.662 1.529 5.633a4.163 4.163 0 01-2.174 1.807V12.38a.71.71 0 00-.363-.623zm1.867-2.773a6.04 6.04 0 00-.132-.078l-4.44-2.53a.731.731 0 00-.729 0l-5.42 3.088V7.325a.068.068 0 01.027-.057L14.1 4.713c2-1.137 4.555-.46 5.707 1.513.487.833.664 1.809.499 2.757h.001zm-11.741 3.81l-1.877-1.068a.065.065 0 01-.036-.051V6.559c.001-2.277 1.873-4.122 4.181-4.12.976 0 1.92.338 2.671.954-.034.018-.092.05-.131.073l-4.44 2.53a.71.71 0 00-.365.623l-.003 6.173v.002zm1.02-2.168L12 9.25l2.414 1.375v2.75L12 14.75l-2.415-1.375v-2.75z"/>
                                </svg>
                                <span>ChatGPT</span>
                            </button>

                            <button id="ai-claude" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="#D97757">
                                    <path d="M4.709 15.955l4.72-2.647.08-.23-.08-.128H9.2l-.79-.048-2.698-.073-2.339-.097-2.266-.122-.571-.121L0 11.784l.055-.352.48-.321.686.06 1.52.103 2.278.158 1.652.097 2.449.255h.389l.055-.157-.134-.098-.103-.097-2.358-1.596-2.552-1.688-1.336-.972-.724-.491-.364-.462-.158-1.008.656-.722.881.06.225.061.893.686 1.908 1.476 2.491 1.833.365.304.145-.103.019-.073-.164-.274-1.355-2.446-1.446-2.49-.644-1.032-.17-.619a2.97 2.97 0 01-.104-.729L6.283.134 6.696 0l.996.134.42.364.62 1.414 1.002 2.229 1.555 3.03.456.898.243.832.091.255h.158V9.01l.128-1.706.237-2.095.23-2.695.08-.76.376-.91.747-.492.584.28.48.685-.067.444-.286 1.851-.559 2.903-.364 1.942h.212l.243-.242.985-1.306 1.652-2.064.73-.82.85-.904.547-.431h1.033l.76 1.129-.34 1.166-1.064 1.347-.881 1.142-1.264 1.7-.79 1.36.073.11.188-.02 2.856-.606 1.543-.28 1.841-.315.833.388.091.395-.328.807-1.969.486-2.309.462-3.439.813-.042.03.049.061 1.549.146.662.036h1.622l3.02.225.79.522.474.638-.079.485-1.215.62-1.64-.389-3.829-.91-1.312-.329h-.182v.11l1.093 1.068 2.006 1.81 2.509 2.33.127.578-.322.455-.34-.049-2.205-1.657-.851-.747-1.926-1.62h-.128v.17l.444.649 2.345 3.521.122 1.08-.17.353-.608.213-.668-.122-1.374-1.925-1.415-2.167-1.143-1.943-.14.08-.674 7.254-.316.37-.729.28-.607-.461-.322-.747.322-1.476.389-1.924.315-1.53.286-1.9.17-.632-.012-.042-.14.018-1.434 1.967-2.18 2.945-1.726 1.845-.414.164-.717-.37.067-.662.401-.589 2.388-3.036 1.44-1.882.93-1.086-.006-.158h-.055L4.132 18.56l-1.13.146-.487-.456.061-.746.231-.243 1.908-1.312-.006.006z"/>
                                </svg>
                                <span>Claude</span>
                            </button>

                            <button id="ai-gemini" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 24 24">
                                    <defs>
                                        <linearGradient gradientUnits="userSpaceOnUse" id="gemini-fill-0" x1="7" x2="11" y1="15.5" y2="12">
                                            <stop stop-color="#08B962"/>
                                            <stop offset="1" stop-color="#08B962" stop-opacity="0"/>
                                        </linearGradient>
                                        <linearGradient gradientUnits="userSpaceOnUse" id="gemini-fill-1" x1="8" x2="11.5" y1="5.5" y2="11">
                                            <stop stop-color="#F94543"/>
                                            <stop offset="1" stop-color="#F94543" stop-opacity="0"/>
                                        </linearGradient>
                                        <linearGradient gradientUnits="userSpaceOnUse" id="gemini-fill-2" x1="3.5" x2="17.5" y1="13.5" y2="12">
                                            <stop stop-color="#FABC12"/>
                                            <stop offset=".46" stop-color="#FABC12" stop-opacity="0"/>
                                        </linearGradient>
                                    </defs>
                                    <path d="M20.616 10.835a14.147 14.147 0 01-4.45-3.001 14.111 14.111 0 01-3.678-6.452.503.503 0 00-.975 0 14.134 14.134 0 01-3.679 6.452 14.155 14.155 0 01-4.45 3.001c-.65.28-1.318.505-2.002.678a.502.502 0 000 .975c.684.172 1.35.397 2.002.677a14.147 14.147 0 014.45 3.001 14.112 14.112 0 013.679 6.453.502.502 0 00.975 0c.172-.685.397-1.351.677-2.003a14.145 14.145 0 013.001-4.45 14.113 14.113 0 016.453-3.678.503.503 0 000-.975 13.245 13.245 0 01-2.003-.678z" fill="#3186FF"/>
                                    <path d="M20.616 10.835a14.147 14.147 0 01-4.45-3.001 14.111 14.111 0 01-3.678-6.452.503.503 0 00-.975 0 14.134 14.134 0 01-3.679 6.452 14.155 14.155 0 01-4.45 3.001c-.65.28-1.318.505-2.002.678a.502.502 0 000 .975c.684.172 1.35.397 2.002.677a14.147 14.147 0 014.45 3.001 14.112 14.112 0 013.679 6.453.502.502 0 00.975 0c.172-.685.397-1.351.677-2.003a14.145 14.145 0 013.001-4.45 14.113 14.113 0 016.453-3.678.503.503 0 000-.975 13.245 13.245 0 01-2.003-.678z" fill="url(#gemini-fill-0)"/>
                                    <path d="M20.616 10.835a14.147 14.147 0 01-4.45-3.001 14.111 14.111 0 01-3.678-6.452.503.503 0 00-.975 0 14.134 14.134 0 01-3.679 6.452 14.155 14.155 0 01-4.45 3.001c-.65.28-1.318.505-2.002.678a.502.502 0 000 .975c.684.172 1.35.397 2.002.677a14.147 14.147 0 014.45 3.001 14.112 14.112 0 013.679 6.453.502.502 0 00.975 0c.172-.685.397-1.351.677-2.003a14.145 14.145 0 013.001-4.45 14.113 14.113 0 016.453-3.678.503.503 0 000-.975 13.245 13.245 0 01-2.003-.678z" fill="url(#gemini-fill-1)"/>
                                    <path d="M20.616 10.835a14.147 14.147 0 01-4.45-3.001 14.111 14.111 0 01-3.678-6.452.503.503 0 00-.975 0 14.134 14.134 0 01-3.679 6.452 14.155 14.155 0 01-4.45 3.001c-.65.28-1.318.505-2.002.678a.502.502 0 000 .975c.684.172 1.35.397 2.002.677a14.147 14.147 0 014.45 3.001 14.112 14.112 0 013.679 6.453.502.502 0 00.975 0c.172-.685.397-1.351.677-2.003a14.145 14.145 0 013.001-4.45 14.113 14.113 0 016.453-3.678.503.503 0 000-.975 13.245 13.245 0 01-2.003-.678z" fill="url(#gemini-fill-2)"/>
                                </svg>
                                <span>Gemini</span>
                            </button>

                            <button id="ai-perplexity" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="#22B8CD">
                                    <path d="M19.785 0v7.272H22.5V17.62h-2.935V24l-7.037-6.194v6.145h-1.091v-6.152L4.392 24v-6.465H1.5V7.188h2.884V0l7.053 6.494V.19h1.09v6.49L19.786 0zm-7.257 9.044v7.319l5.946 5.234V14.44l-5.946-5.397zm-1.099-.08l-5.946 5.398v7.235l5.946-5.234V8.965zm8.136 7.58h1.844V8.349H13.46l6.105 5.54v2.655zm-8.982-8.28H2.59v8.195h1.8v-2.576l6.192-5.62zM5.475 2.476v4.71h5.115l-5.115-4.71zm13.219 0l-5.115 4.71h5.115v-4.71z"/>
                                </svg>
                                <span>Perplexity</span>
                            </button>

                            <button id="ai-copilot" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 24 24">
                                    <defs>
                                        <radialGradient cx="85.44%" cy="100.653%" fx="85.44%" fy="100.653%" gradientTransform="scale(-.8553 -1) rotate(50.927 2.041 -1.946)" id="copilot-fill-0" r="105.116%">
                                            <stop offset="9.6%" stop-color="#00AEFF"/>
                                            <stop offset="77.3%" stop-color="#2253CE"/>
                                            <stop offset="100%" stop-color="#0736C4"/>
                                        </radialGradient>
                                        <radialGradient cx="18.143%" cy="32.928%" fx="18.143%" fy="32.928%" gradientTransform="scale(.8897 1) rotate(52.069 .193 .352)" id="copilot-fill-1" r="95.612%">
                                            <stop offset="0%" stop-color="#FFB657"/>
                                            <stop offset="63.4%" stop-color="#FF5F3D"/>
                                            <stop offset="92.3%" stop-color="#C02B3C"/>
                                        </radialGradient>
                                        <radialGradient cx="82.987%" cy="-9.792%" fx="82.987%" fy="-9.792%" gradientTransform="scale(-1 -.9441) rotate(-70.872 .142 1.17)" id="copilot-fill-4" r="140.622%">
                                            <stop offset="6.6%" stop-color="#8C48FF"/>
                                            <stop offset="50%" stop-color="#F2598A"/>
                                            <stop offset="89.6%" stop-color="#FFB152"/>
                                        </radialGradient>
                                        <linearGradient id="copilot-fill-2" x1="39.465%" x2="46.884%" y1="12.117%" y2="103.774%">
                                            <stop offset="15.6%" stop-color="#0D91E1"/>
                                            <stop offset="48.7%" stop-color="#52B471"/>
                                            <stop offset="65.2%" stop-color="#98BD42"/>
                                            <stop offset="93.7%" stop-color="#FFC800"/>
                                        </linearGradient>
                                        <linearGradient id="copilot-fill-3" x1="45.949%" x2="50%" y1="0%" y2="100%">
                                            <stop offset="0%" stop-color="#3DCBFF"/>
                                            <stop offset="24.7%" stop-color="#0588F7" stop-opacity="0"/>
                                        </linearGradient>
                                        <linearGradient id="copilot-fill-5" x1="83.507%" x2="83.453%" y1="-6.106%" y2="21.131%">
                                            <stop offset="5.8%" stop-color="#F8ADFA"/>
                                            <stop offset="70.8%" stop-color="#A86EDD" stop-opacity="0"/>
                                        </linearGradient>
                                    </defs>
                                    <path d="M17.533 1.829A2.528 2.528 0 0015.11 0h-.737a2.531 2.531 0 00-2.484 2.087l-1.263 6.937.314-1.08a2.528 2.528 0 012.424-1.833h4.284l1.797.706 1.731-.706h-.505a2.528 2.528 0 01-2.423-1.829l-.715-2.453z" fill="url(#copilot-fill-0)" transform="translate(0 1)"/>
                                    <path d="M6.726 20.16A2.528 2.528 0 009.152 22h1.566c1.37 0 2.49-1.1 2.525-2.48l.17-6.69-.357 1.228a2.528 2.528 0 01-2.423 1.83h-4.32l-1.54-.842-1.667.843h.497c1.124 0 2.113.75 2.426 1.84l.697 2.432z" fill="url(#copilot-fill-1)" transform="translate(0 1)"/>
                                    <path d="M15 0H6.252c-2.5 0-4 3.331-5 6.662-1.184 3.947-2.734 9.225 1.75 9.225H6.78c1.13 0 2.12-.753 2.43-1.847.657-2.317 1.809-6.359 2.713-9.436.46-1.563.842-2.906 1.43-3.742A1.97 1.97 0 0115 0" fill="url(#copilot-fill-2)" transform="translate(0 1)"/>
                                    <path d="M15 0H6.252c-2.5 0-4 3.331-5 6.662-1.184 3.947-2.734 9.225 1.75 9.225H6.78c1.13 0 2.12-.753 2.43-1.847.657-2.317 1.809-6.359 2.713-9.436.46-1.563.842-2.906 1.43-3.742A1.97 1.97 0 0115 0" fill="url(#copilot-fill-3)" transform="translate(0 1)"/>
                                    <path d="M9 22h8.749c2.5 0 4-3.332 5-6.663 1.184-3.948 2.734-9.227-1.75-9.227H17.22c-1.129 0-2.12.754-2.43 1.848a1149.2 1149.2 0 01-2.713 9.437c-.46 1.564-.842 2.907-1.43 3.743A1.97 1.97 0 019 22" fill="url(#copilot-fill-4)" transform="translate(0 1)"/>
                                    <path d="M9 22h8.749c2.5 0 4-3.332 5-6.663 1.184-3.948 2.734-9.227-1.75-9.227H17.22c-1.129 0-2.12.754-2.43 1.848a1149.2 1149.2 0 01-2.713 9.437c-.46 1.564-.842 2.907-1.43 3.743A1.97 1.97 0 019 22" fill="url(#copilot-fill-5)" transform="translate(0 1)"/>
                                </svg>
                                <span>Copilot</span>
                            </button>

                            <button id="ai-deepseek" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="#4D6BFE">
                                    <path d="M23.748 4.482c-.254-.124-.364.113-.512.234-.051.039-.094.09-.137.136-.372.397-.806.657-1.373.626-.829-.046-1.537.214-2.163.848-.133-.782-.575-1.248-1.247-1.548-.352-.156-.708-.311-.955-.65-.172-.241-.219-.51-.305-.774-.055-.16-.11-.323-.293-.35-.2-.031-.278.136-.356.276-.313.572-.434 1.202-.422 1.84.027 1.436.633 2.58 1.838 3.393.137.093.172.187.129.323-.082.28-.18.552-.266.833-.055.179-.137.217-.329.14a5.526 5.526 0 01-1.736-1.18c-.857-.828-1.631-1.742-2.597-2.458a11.365 11.365 0 00-.689-.471c-.985-.957.13-1.743.388-1.836.27-.098.093-.432-.779-.428-.872.004-1.67.295-2.687.684a3.055 3.055 0 01-.465.137 9.597 9.597 0 00-2.883-.102c-1.885.21-3.39 1.102-4.497 2.623C.082 8.606-.231 10.684.152 12.85c.403 2.284 1.569 4.175 3.36 5.653 1.858 1.533 3.997 2.284 6.438 2.14 1.482-.085 3.133-.284 4.994-1.86.47.234.962.327 1.78.397.63.059 1.236-.03 1.705-.128.735-.156.684-.837.419-.961-2.155-1.004-1.682-.595-2.113-.926 1.096-1.296 2.746-2.642 3.392-7.003.05-.347.007-.565 0-.845-.004-.17.035-.237.23-.256a4.173 4.173 0 001.545-.475c1.396-.763 1.96-2.015 2.093-3.517.02-.23-.004-.467-.247-.588zM11.581 18c-2.089-1.642-3.102-2.183-3.52-2.16-.392.024-.321.471-.235.763.09.288.207.486.371.739.114.167.192.416-.113.603-.673.416-1.842-.14-1.897-.167-1.361-.802-2.5-1.86-3.301-3.307-.774-1.393-1.224-2.887-1.298-4.482-.02-.386.093-.522.477-.592a4.696 4.696 0 011.529-.039c2.132.312 3.946 1.265 5.468 2.774.868.86 1.525 1.887 2.202 2.891.72 1.066 1.494 2.082 2.48 2.914.348.292.625.514.891.677-.802.09-2.14.11-3.054-.614zm1-6.44a.306.306 0 01.415-.287.302.302 0 01.2.288.306.306 0 01-.31.307.303.303 0 01-.304-.308zm3.11 1.596c-.2.081-.399.151-.59.16a1.245 1.245 0 01-.798-.254c-.274-.23-.47-.358-.552-.758a1.73 1.73 0 01.016-.588c.07-.327-.008-.537-.239-.727-.187-.156-.426-.199-.688-.199a.559.559 0 01-.254-.078c-.11-.054-.2-.19-.114-.358.028-.054.16-.186.192-.21.356-.202.767-.136 1.146.016.352.144.618.408 1.001.782.391.451.462.576.685.914.176.265.336.537.445.848.067.195-.019.354-.25.452z"/>
                                </svg>
                                <span>Deepseek</span>
                            </button>
                        </div>

                        <div style="display: flex; justify-content: center; gap: 12px;">
                            <button id="cancel-ai" style="
                                padding: 12px 24px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 1px solid rgba(255, 255, 255, 0.2);
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                font-size: 14px;
                                transition: all 0.2s ease;
                            ">
                                Cancelar
                            </button>
                        </div>
                    `;

                    // Adicionar CSS hover via JavaScript
                    const style = document.createElement("style");
                    style.textContent = `
                        .ai-option:hover {
                            background: rgba(255, 255, 255, 0.2) !important;
                            border-color: rgba(255, 255, 255, 0.3) !important;
                            transform: translateY(-1px);
                        }
                        #cancel-ai:hover {
                            background: rgba(255, 255, 255, 0.2) !important;
                        }
                    `;
                    document.head.appendChild(style);

                    // Adicionar eventos aos botões
                    modal
                        .querySelector("#ai-chatgpt")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                openAIWithText(
                                    "ChatGPT",
                                    "https://chat.openai.com/",
                                    texto
                                )
                            );
                        });

                    modal
                        .querySelector("#ai-claude")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                openAIWithText(
                                    "Claude",
                                    "https://claude.ai/",
                                    texto
                                )
                            );
                        });

                    modal
                        .querySelector("#ai-gemini")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                openAIWithText(
                                    "Gemini",
                                    "https://gemini.google.com/",
                                    texto
                                )
                            );
                        });

                    modal
                        .querySelector("#ai-perplexity")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                openAIWithText(
                                    "Perplexity",
                                    "https://www.perplexity.ai/",
                                    texto
                                )
                            );
                        });

                    modal
                        .querySelector("#ai-copilot")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                openAIWithText(
                                    "Copilot",
                                    "https://copilot.cloud.microsoft/",
                                    texto
                                )
                            );
                        });

                    modal
                        .querySelector("#ai-deepseek")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                openAIWithText(
                                    "Deepseek",
                                    "https://chat.deepseek.com/",
                                    texto
                                )
                            );
                        });

                    modal
                        .querySelector("#cancel-ai")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(false);
                        });

                    // Fechar ao clicar no overlay
                    overlay.addEventListener("click", (e) => {
                        if (e.target === overlay) {
                            overlay.remove();
                            style.remove();
                            resolve(false);
                        }
                    });

                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);
                });
            }

            // Abrir Copilot com texto e prompt específico para análise judicial (mantida para compatibilidade)
            async function openCopilotWithText(texto) {
                return openAIWithText(
                    "Copilot",
                    "https://copilot.cloud.microsoft/",
                    texto
                );
            }

            // Enviar texto diretamente para Perplexity usando API - usando expressão de função
            const sendToPerplexity = async function (texto) {
                const requestId = Date.now().toString();

                try {
                    debugApiCall(requestId, "INÍCIO", {
                        textoLength: texto.length,
                    });
                    log(" Enviando texto para Perplexity via API...");
                    showNotification("Enviando para Perplexity...", "info");

                    const apiKey = await getStoredApiKey();
                    if (!apiKey) {
                        debugApiCall(
                            requestId,
                            "ERRO",
                            "API key não encontrada"
                        );
                        showNotification(" Erro ao obter chave API", "error");
                        return false;
                    }

                    const prompt = `Faça um resumo extremamente sucinto do documento, em formato de apontamentos diretos (bullet points), para constar na capa do processo digital. Indique: tipo de ação, partes, pedido(s) do autor, decisão (improcedente/procedente/parcialmente procedente), fundamentos centrais, condenação (custas/honorários se houver). Seja objetivo e direto, sem redação em texto corrido. DOCUMENTO: ${texto}`;

                    const requestBody = {
                        model: "sonar",
                        messages: [
                            {
                                role: "system",
                                content:
                                    "Você é um assistente especializado em resumir documentos judiciais de forma extremamente objetiva e sucinta para capas de processos digitais. Sempre responda em bullet points diretos.",
                            },
                            {
                                role: "user",
                                content: prompt,
                            },
                        ],
                        max_tokens: 1200,
                        temperature: 0.1,
                        top_p: 0.9,
                    };

                    debugApiCall(requestId, "REQUEST", {
                        url: "https://api.perplexity.ai/chat/completions",
                        model: requestBody.model,
                        promptLength: prompt.length,
                        maxTokens: requestBody.max_tokens,
                    });

                    const response = await fetch(
                        "https://api.perplexity.ai/chat/completions",
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                Authorization: `Bearer ${apiKey}`,
                                "User-Agent": "eProbe-Extension/1.0",
                            },
                            body: JSON.stringify(requestBody),
                        }
                    );

                    const responseHeaders = Object.fromEntries(
                        response.headers.entries()
                    );
                    debugApiCall(requestId, "RESPONSE_HEADERS", {
                        status: response.status,
                        statusText: response.statusText,
                        headers: responseHeaders,
                        requestId: responseHeaders["x-request-id"] || "N/A",
                        rateLimit: {
                            remaining:
                                responseHeaders[
                                    "x-ratelimit-remaining-requests"
                                ],
                            resetRequests:
                                responseHeaders["x-ratelimit-reset-requests"],
                            remainingTokens:
                                responseHeaders["x-ratelimit-remaining-tokens"],
                            resetTokens:
                                responseHeaders["x-ratelimit-reset-tokens"],
                        },
                    });

                    if (!response.ok) {
                        const errorData = await response.text();
                        let errorJson = null;

                        try {
                            errorJson = JSON.parse(errorData);
                        } catch (e) {
                            log(" Resposta de erro não é JSON válido");
                        }

                        debugApiCall(requestId, "ERROR_DETAILS", {
                            status: response.status,
                            statusText: response.statusText,
                            errorText: errorData,
                            errorJson: errorJson,
                            headers: responseHeaders,
                        });

                        if (response.status === 401) {
                            const errorMsg =
                                errorJson?.error?.message ||
                                "Chave API inválida";
                            log(" Erro 401:", errorMsg);
                            showNotification(
                                ` ${errorMsg}. Configure uma nova chave API do Perplexity.`,
                                "error"
                            );
                            await removeStoredApiKey();
                            return false;
                        } else if (response.status === 429) {
                            const rateLimitType =
                                errorJson?.error?.type || "rate_limit_exceeded";
                            const retryAfter = responseHeaders["retry-after"];

                            log(" Rate limit:", {
                                type: rateLimitType,
                                retryAfter,
                            });

                            if (rateLimitType === "insufficient_quota") {
                                showNotification(
                                    " Cota da API Perplexity esgotada. Verifique seus créditos em perplexity.ai/settings/api",
                                    "error"
                                );
                            } else {
                                showNotification(
                                    ` Limite de requests atingido. Aguarde ${
                                        retryAfter || "alguns minutos"
                                    } antes de tentar novamente.`,
                                    "warning"
                                );
                            }
                            return false;
                        } else if (response.status === 403) {
                            const errorMsg =
                                errorJson?.error?.message || "Acesso negado";
                            log(" Erro 403:", errorMsg);
                            showNotification(
                                ` ${errorMsg}. Usando método manual...`,
                                "warning"
                            );
                            return await fallbackToManual(texto);
                        } else if (response.status >= 500) {
                            log(
                                " Erro do servidor Perplexity:",
                                response.status
                            );
                            showNotification(
                                ` Erro do servidor Perplexity (${response.status}). Usando método manual...`,
                                "warning"
                            );
                            return await fallbackToManual(texto);
                        } else {
                            const errorMsg =
                                errorJson?.error?.message ||
                                `Erro ${response.status}`;
                            log(" Erro desconhecido:", errorMsg);
                            showNotification(
                                ` ${errorMsg}. Usando método manual...`,
                                "warning"
                            );
                            return await fallbackToManual(texto);
                        }
                    }

                    const data = await response.json();

                    debugApiCall(requestId, "SUCCESS", {
                        responseId: responseHeaders["x-request-id"],
                        model: data.model,
                        usage: data.usage,
                        finishReason: data.choices?.[0]?.finish_reason,
                        responseLength:
                            data.choices?.[0]?.message?.content?.length,
                    });

                    const resumo = data.choices[0].message.content;

                    showNotification("Resumo gerado com sucesso!", "success");

                    await copyToClipboard(resumo);

                    showNotification(
                        " Resumo pronto!\n\nO resumo do documento está na sua área de transferência.",
                        "success"
                    );

                    return true;
                } catch (error) {
                    debugApiCall(requestId, "EXCEPTION", {
                        errorName: error.name,
                        errorMessage: error.message,
                        errorStack: error.stack,
                    });

                    log(" Erro ao enviar para Perplexity:", error);
                    showNotification(
                        " Erro de conexão na API. Usando método manual...",
                        "warning"
                    );

                    return await fallbackToManual(texto);
                }
            };

            // Função auxiliar para fallback manual
            async function fallbackToManual(texto) {
                log(" Executando fallback para método manual");
                const copied = await copyToClipboardWithPrefix(texto);
                if (copied) {
                    showNotification(
                        " Texto copiado! Cole em Perplexity ou outra IA (Ctrl+V)",
                        "info"
                    );
                } else {
                    log(" Falha ao copiar texto no fallback");
                    showNotification(" Falha ao copiar texto", "error");
                }
                return false;
            }

            // Gerenciar chave API
            async function getStoredApiKey() {
                let apiKey = localStorage.getItem("perplexity_api_key");

                if (!apiKey) {
                    // Chave codificada em Base64 para ofuscação básica
                    const encodedKey =
                        "cHBseC1LUEFHYXhYZVZ4Yk1wUWJ5QzNCNmpZUERPd1luSk1ka3MxcUR6YmF1N2s3c05nbUo=";
                    apiKey = atob(encodedKey);
                    localStorage.setItem("perplexity_api_key", apiKey);
                    log(" API key do Perplexity configurada automaticamente");
                }

                return apiKey;
            }

            async function storeApiKey(apiKey) {
                if (!apiKey || !apiKey.startsWith("pplx-")) {
                    throw new Error(
                        'Chave API inválida. Deve começar com "pplx-"'
                    );
                }
                localStorage.setItem("perplexity_api_key", apiKey);
                log(" Chave API do Perplexity armazenada com sucesso");
            }

            async function removeStoredApiKey() {
                localStorage.removeItem("perplexity_api_key");
                log(" Chave API do Perplexity removida");
            }

            async function validateApiKey(apiKey) {
                if (!apiKey) return false;
                if (!apiKey.startsWith("pplx-")) return false;
                if (apiKey.length < 40) return false;
                return true;
            }

            // Menu de opções
            function showOptionsMenu(x, y) {
                const existing = document.getElementById(
                    "documento-relevante-options-menu"
                );
                if (existing) {
                    existing.remove();
                    return;
                }

                // Verificar se há botão flutuante e ajustar posição se necessário
                const floatingButton =
                    document.getElementById("sent1-auto-button");
                const isFloatingButtonVisible =
                    floatingButton && floatingButton.style.display !== "none";

                // Calcular posição para evitar sair da tela
                const menuWidth = 200;
                const menuHeight = 400; // Estimativa
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;

                // Se o menu vai aparecer perto do botão flutuante, ajustar posição
                if (
                    isFloatingButtonVisible &&
                    x > screenWidth - 220 &&
                    y < 200
                ) {
                    // Mover menu para a esquerda do botão flutuante
                    x = screenWidth - 240;
                }

                // Ajustar X se o menu sair da tela pela direita
                if (x + menuWidth > screenWidth) {
                    x = screenWidth - menuWidth - 20;
                }

                // Ajustar Y se o menu sair da tela por baixo
                if (y + menuHeight > screenHeight) {
                    y = screenHeight - menuHeight - 20;
                }

                // Garantir que não saia pela esquerda ou topo
                x = Math.max(10, x);
                y = Math.max(10, y);

                const menu = document.createElement("ul");
                menu.id = "documento-relevante-options-menu";
                menu.className = "eprobe-menu";
                menu.setAttribute("role", "menu");
                menu.style.cssText = `
                        position: fixed !important;
                        right: 20px !important;
                        top: 154px !important;
                        z-index: 10001;
                        min-width: 200px;
                        border-radius: 8px;
                        border: 1px solid rgb(19 67 119);
                        background: #134377;
                        padding: 6px;
                        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
                        font-family: "Roboto", -apple-system, system-ui, sans-serif;
                        `;

                const pageType = detectPageType();

                log(" Debug showOptionsMenu - pageType detectado:", pageType);
                log(" Debug showOptionsMenu - Posição do menu:", { x, y });

                if (pageType === "lista_documentos") {
                    // Verificar quantos documentos existem para customizar o menu
                    const documentosRelevantes = findDocumentosRelevantes();
                    const documentCount = documentosRelevantes.length;

                    let menuTitle = "Processar Documentos";
                    let buttonColor = "#134377";
                    let titleIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-cpu-icon lucide-cpu"><path d="M12 20v2"/><path d="M12 2v2"/><path d="M17 20v2"/><path d="M17 2v2"/><path d="M2 12h2"/><path d="M2 17h2"/><path d="M2 7h2"/><path d="M20 12h2"/><path d="M20 17h2"/><path d="M20 7h2"/><path d="M7 20v2"/><path d="M7 2v2"/><rect x="4" y="4" width="16" height="16" rx="2"/><rect x="8" y="8" width="8" height="8" rx="1"/></svg>`;

                    if (documentCount === 0) {
                        menuTitle = "Nenhum Documento";
                        buttonColor = "#ef4444";
                        titleIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 6-12 12"/><path d="m6 6 12 12"/></svg>`;
                    } else if (documentCount === 1) {
                        const doc = documentosRelevantes[0];
                        menuTitle = `1 ${doc.tipo.descricao} Encontrada`;
                    } else {
                        menuTitle = `${documentCount} Documentos Encontrados`;
                        buttonColor = "#134377";
                    }

                    menu.innerHTML = `
                        <li role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px; font-weight: 600; border-bottom: 1px solid rgb(148 163 184); margin-bottom: 6px;">
                        ${titleIcon}
                        ${menuTitle}
                        </li>
                        <li id="open-documento-btn" role="menuitem" style="cursor: ${
                            documentCount === 0 ? "not-allowed" : "pointer"
                        }; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px; ${
                        documentCount === 0 ? "opacity: 0.5;" : ""
                    }" ${documentCount === 0 ? 'data-disabled="true"' : ""}>
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="${buttonColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                        <polyline points="14,2 14,8 20,8"/>
                        <line x1="16" y1="13" x2="8" y2="13"/>
                        <line x1="16" y1="17" x2="8" y2="17"/>
                        <polyline points="10,9 9,9 8,9"/>
                        </svg>
                        ${
                            documentCount === 0
                                ? "Nenhum documento encontrado"
                                : documentCount === 1
                                ? `Processar ${documentosRelevantes[0].tipo.descricao}`
                                : `Escolher entre ${documentCount} documentos`
                        }
                        </li>
                        `;

                    const openBtn = menu.querySelector("#open-documento-btn");
                    if (documentCount > 0) {
                        openBtn.classList.add("eprobe-open-button");
                        openBtn.addEventListener("click", () => {
                            menu.remove();
                            if (documentCount > 1) {
                                showSentenceProcessingOptions();
                            } else {
                                runFullAutomation();
                            }
                        });
                    }
                } else if (
                    pageType === "documento_especifico" ||
                    pageType === "documento_html" ||
                    pageType === "documento_pdf"
                ) {
                    // Menu para páginas de documento específico
                    log(" Mostrando menu para documento específico");
                    menu.innerHTML = `
                                        <li role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px; font-weight: 600; border-bottom: 1px solid rgba(148, 163, 184, 0.3); margin-bottom: 6px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-cpu-icon lucide-cpu"><path d="M12 20v2"/><path d="M12 2v2"/><path d="M17 20v2"/><path d="M17 2v2"/><path d="M2 12h2"/><path d="M2 17h2"/><path d="M2 7h2"/><path d="M20 12h2"/><path d="M20 17h2"/><path d="M20 7h2"/><path d="M7 20v2"/><path d="M7 2v2"/><rect x="4" y="4" width="16" height="16" rx="2"/><rect x="8" y="8" width="8" height="8" rx="1"/></svg>
                                        Processar Documento
                                        </li>
                                        <li id="api-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="#ffffff" stroke="none">
                                        <path d="M19.785 0v7.272H22.5V17.62h-2.935V24l-7.037-6.194v6.145h-1.091v-6.152L4.392 24v-6.465H1.5V7.188h2.884V0l7.053 6.494V.19h1.09v6.49L19.786 0zm-7.257 9.044v7.319l5.946 5.234V14.44l-5.946-5.397zm-1.099-.08l-5.946 5.398v7.235l5.946-5.234V8.965zm8.136 7.58h1.844V8.349H13.46l6.105 5.54v2.655zm-8.982-8.28H2.59v8.195h1.8v-2.576l6.192-5.62zM5.475 2.476v4.71h5.115l-5.115-4.71zm13.219 0l-5.115 4.71h5.115v-4.71z"/>
                                        </svg>
                                        Resumir com Perplexity
                                        </li>
                                        <li id="manual-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" height="16px" viewBox="0 -960 960 960" width="16px" fill="#ffffff">
                                        <path d="M255.7-156.65q-17.7 0-32.79-8.77-15.08-8.76-23.56-23.15l-73.24-132.47h60.91l41.13 81.19h87.68v-24h-71.54l-41-81.19h-91.94L53.83-449.09q-4.28-6.48-6.5-14.25-2.22-7.77-2.22-16.88 0-5.55 8.72-31.69l59.54-103.05h92.98l39.9-81.19h71.58v-24h-85.98l-40.5 81.19h-63.48l71.48-132.47q8.04-15.03 23.27-23.47 15.22-8.45 33.08-8.45h65.93q27.17 0 45.5 18.38 18.33 18.37 18.33 45.21v152.56h-53.72l-36 24h89.72v139.11h-98.2l-40.32-80.71h-87.2l-26 24h97.04l40.98 80.71h113.7v179.85q0 26.84-18.33 45.21-18.33 18.38-45.5 18.38H255.7Zm331.31 0q-36.74 0-62.52-25.93-25.77-25.92-25.77-62.76 0-21.04 9.5-40.05 9.5-19.01 26.5-30.52v-328.18q-17-11.51-26.5-30.52-9.5-19.01-9.5-40.05 0-36.84 26.04-62.76 26.03-25.93 62.81-25.93 36.77 0 62.55 25.93 25.77 25.92 25.77 62.76 0 21.04-9.5 40.05-9.5 19.01-26.5 30.52v48.16l78.35-47.54q2.72-33.4 28-56.26 25.29-22.86 60.8-22.86 36.22 0 62.18 26.04 25.95 26.04 25.95 62.81 0 36.78-25.98 62.55-25.99 25.78-62.69 25.78-9.48 0-17.81-1.26-8.33-1.26-16.2-5.26l-88.05 52.73 99.86 80.55q5.28-1.16 10.68-2.46 5.4-1.3 11.61-1.3 36.96 0 62.77 26.04 25.81 26.03 25.81 62.81 0 36.77-25.9 62.55-25.9 25.77-62.48 25.77-38.16 0-64.62-27.12-26.45-27.12-24.41-65.79l-77.87-61.55v82.49q16 11.21 25.5 30.66 9.5 19.44 9.5 41.21 0 36.84-25.54 62.76-25.54 25.93-62.34 25.93Z"/>
                                        </svg>
                                        Escolher IA
                                        </li>
                                        <li id="config-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/>
                                        <circle cx="12" cy="12" r="3"/>
                                        </svg>
                                        Configurar API
                                        </li>
                                        <li id="test-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="m14.5 9.5 1 1"/>
                                        <path d="m15.5 8.5-4 4"/>
                                        <path d="M3 12a9 9 0 1 0 9-9 9.74 9.74 0 0 0-6.74 2.74L3 8"/>
                                        <path d="M3 3v5h5"/>
                                        <circle cx="10" cy="14" r="2"/>
                                        </svg>
                                        Testar API Key
                                        </li>
                                        <li id="logs-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <rect width="8" height="4" x="8" y="2" rx="1" ry="1"/>
                                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                                        <line x1="9" y1="9" x2="15" y2="9"/>
                                        <line x1="9" y1="13" x2="15" y2="13"/>
                                        <line x1="9" y1="17" x2="13" y2="17"/>
                                        </svg>
                                        Ver Logs de Erro
                                        </li>
                                    `;

                    // Adicionar eventos de hover e click para todos os botões
                    const menuItems = menu.querySelectorAll("li[id]");
                    menuItems.forEach((item) => {
                        item.addEventListener(
                            "mouseenter",
                            () => {
                                item.style.backgroundColor =
                                    "rgba(148, 163, 184, 0.1)";
                            },
                            { passive: true }
                        );
                        item.addEventListener(
                            "mouseleave",
                            () => {
                                item.style.backgroundColor = "transparent";
                            },
                            { passive: true }
                        );
                    });

                    menu.querySelector("#api-btn").addEventListener(
                        "click",
                        async () => {
                            menu.remove();
                            const texto = await autoExtractText();
                            if (texto) {
                                await sendToPerplexity(texto);
                            }
                        }
                    );

                    menu.querySelector("#manual-btn").addEventListener(
                        "click",
                        async () => {
                            menu.remove();
                            const texto = await autoExtractText();
                            if (texto) {
                                log("📝 Abrindo modal de seleção de IA...");
                                const success = await showAISelectionModal(
                                    texto
                                );
                                if (!success) {
                                    log(
                                        "❌ Usuário cancelou ou erro ao abrir IA"
                                    );
                                    // Fallback: copiar com prefixo tradicional
                                    const copied =
                                        await copyToClipboardWithPrefix(texto);
                                    if (copied) {
                                        showNotification(
                                            "📋 Texto copiado! Cole em qualquer IA (Ctrl+V)",
                                            "success"
                                        );
                                    }
                                }
                            } else {
                                log(
                                    "❌ Não foi possível extrair texto do documento"
                                );
                                showNotification(
                                    "❌ Erro ao extrair texto do documento",
                                    "error"
                                );
                            }
                        }
                    );

                    menu.querySelector("#config-btn").addEventListener(
                        "click",
                        async () => {
                            menu.remove();
                            await showApiKeyConfig();
                        }
                    );

                    menu.querySelector("#test-btn").addEventListener(
                        "click",
                        async () => {
                            menu.remove();
                            await testApiKey();
                        }
                    );

                    menu.querySelector("#logs-btn").addEventListener(
                        "click",
                        () => {
                            menu.remove();
                            showErrorLogs();
                        }
                    );
                } else {
                    // Página não reconhecida, mas vamos verificar se há documentos
                    const pageHTML = document.documentElement.outerHTML;
                    const hasDocumentHtml = pageHTML.includes(
                        "acessar_documento&id"
                    );
                    const hasDocumentPdf = pageHTML.includes(
                        "acessar_documento&amp"
                    );

                    log(" Página não reconhecida, verificando documentos:", {
                        hasDocumentHtml: hasDocumentHtml,
                        hasDocumentPdf: hasDocumentPdf,
                    });

                    if (hasDocumentHtml || hasDocumentPdf) {
                        // Há documentos, mostrar menu como se fosse documento específico
                        log(
                            " Há documentos, mostrando menu de documento específico"
                        );
                        menu.innerHTML = `
                            <li role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px; font-weight: 600; border-bottom: 1px solid rgba(148, 163, 184, 0.3); margin-bottom: 6px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 8V4H8"/>
                            <rect width="16" height="12" x="4" y="8" rx="2"/>
                            <path d="M2 14h2"/>
                            <path d="M20 14h2"/>
                            <path d="M15 13v2"/>
                            <path d="M9 13v2"/>
                            </svg>
                            Processar Documento
                            </li>
                            <li id="api-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="#ffffff" stroke="none">
                            <path d="M19.785 0v7.272H22.5V17.62h-2.935V24l-7.037-6.194v6.145h-1.091v-6.152L4.392 24v-6.465H1.5V7.188h2.884V0l7.053 6.494V.19h1.09v6.49L19.786 0zm-7.257 9.044v7.319l5.946 5.234V14.44l-5.946-5.397zm-1.099-.08l-5.946 5.398v7.235l5.946-5.234V8.965zm8.136 7.58h1.844V8.349H13.46l6.105 5.54v2.655zm-8.982-8.28H2.59v8.195h1.8v-2.576l6.192-5.62zM5.475 2.476v4.71h5.115l-5.115-4.71zm13.219 0l-5.115 4.71h5.115v-4.71z"/>
                            </svg>
                            Resumo Perplexity
                            </li>
                            <li id="manual-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                            <svg xmlns="http://www.w3.org/2000/svg" height="16px" viewBox="0 -960 960 960" width="16px" fill="#ffffff">
                            <path d="M255.7-156.65q-17.7 0-32.79-8.77-15.08-8.76-23.56-23.15l-73.24-132.47h60.91l41.13 81.19h87.68v-24h-71.54l-41-81.19h-91.94L53.83-449.09q-4.28-6.48-6.5-14.25-2.22-7.77-2.22-16.88 0-5.55 8.72-31.69l59.54-103.05h92.98l39.9-81.19h71.58v-24h-85.98l-40.5 81.19h-63.48l71.48-132.47q8.04-15.03 23.27-23.47 15.22-8.45 33.08-8.45h65.93q27.17 0 45.5 18.38 18.33 18.37 18.33 45.21v152.56h-53.72l-36 24h89.72v139.11h-98.2l-40.32-80.71h-87.2l-26 24h97.04l40.98 80.71h113.7v179.85q0 26.84-18.33 45.21-18.33 18.38-45.5 18.38H255.7Zm331.31 0q-36.74 0-62.52-25.93-25.77-25.92-25.77-62.76 0-21.04 9.5-40.05 9.5-19.01 26.5-30.52v-328.18q-17-11.51-26.5-30.52-9.5-19.01-9.5-40.05 0-36.84 26.04-62.76 26.03-25.93 62.81-25.93 36.77 0 62.55 25.93 25.77 25.92 25.77 62.76 0 21.04-9.5 40.05-9.5 19.01-26.5 30.52v48.16l78.35-47.54q2.72-33.4 28-56.26 25.29-22.86 60.8-22.86 36.22 0 62.18 26.04 25.95 26.04 25.95 62.81 0 36.78-25.98 62.55-25.99 25.78-62.69 25.78-9.48 0-17.81-1.26-8.33-1.26-16.2-5.26l-88.05 52.73 99.86 80.55q5.28-1.16 10.68-2.46 5.4-1.3 11.61-1.3 36.96 0 62.77 26.04 25.81 26.03 25.81 62.81 0 36.77-25.9 62.55-25.9 25.77-62.48 25.77-38.16 0-64.62-27.12-26.45-27.12-24.41-65.79l-77.87-61.55v82.49q16 11.21 25.5 30.66 9.5 19.44 9.5 41.21 0 36.84-25.54 62.76-25.54 25.93-62.34 25.93Z"/>
                            </svg>
                            Escolher IA
                            </li>
                            <li id="config-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l-.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/>
                            <circle cx="12" cy="12" r="3"/>
                            </svg>
                            Configurar API
                            </li>
                            <li id="test-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="m14.5 9.5 1 1"/>
                            <path d="m15.5 8.5-4 4"/>
                            <path d="M3 12a9 9 0 1 0 9-9 9.74 9.74 0 0 0-6.74 2.74L3 8"/>
                            <path d="M3 3v5h5"/>
                            <circle cx="10" cy="14" r="2"/>
                            </svg>
                            Testar API Key
                            </li>
                            <li id="logs-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect width="8" height="4" x="8" y="2" rx="1" ry="1"/>
                            <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                            <line x1="9" y1="9" x2="15" y2="9"/>
                            <line x1="9" y1="13" x2="15" y2="13"/>
                            <line x1="9" y1="17" x2="13" y2="17"/>
                            </svg>
                            Ver Logs de Erro
                            </li>
                            `;

                        // Adicionar eventos de hover e click para todos os botões
                        const menuItems = menu.querySelectorAll("li[id]");
                        menuItems.forEach((item) => {
                            item.addEventListener(
                                "mouseenter",
                                () => {
                                    item.style.backgroundColor =
                                        "rgba(148, 163, 184, 0.1)";
                                },
                                { passive: true }
                            );
                            item.addEventListener(
                                "mouseleave",
                                () => {
                                    item.style.backgroundColor = "transparent";
                                },
                                { passive: true }
                            );
                        });

                        menu.querySelector("#api-btn").addEventListener(
                            "click",
                            async () => {
                                menu.remove();
                                const texto = await autoExtractText();
                                if (texto) {
                                    await sendToPerplexity(texto);
                                }
                            }
                        );

                        menu.querySelector("#manual-btn").addEventListener(
                            "click",
                            async () => {
                                menu.remove();
                                const texto = await autoExtractText();
                                if (texto) {
                                    log("📝 Abrindo modal de seleção de IA...");
                                    const success = await showAISelectionModal(
                                        texto
                                    );
                                    if (!success) {
                                        log(
                                            "❌ Usuário cancelou ou erro ao abrir IA"
                                        );
                                        // Fallback: copiar com prefixo tradicional
                                        const copied =
                                            await copyToClipboardWithPrefix(
                                                texto
                                            );
                                        if (copied) {
                                            showNotification(
                                                "📋 Texto copiado! Cole em qualquer IA (Ctrl+V)",
                                                "success"
                                            );
                                        }
                                    }
                                } else {
                                    log(
                                        "❌ Não foi possível extrair texto do documento"
                                    );
                                    showNotification(
                                        "❌ Erro ao extrair texto do documento",
                                        "error"
                                    );
                                }
                            }
                        );

                        menu.querySelector("#config-btn").addEventListener(
                            "click",
                            async () => {
                                menu.remove();
                                await showApiKeyConfig();
                            }
                        );

                        menu.querySelector("#test-btn").addEventListener(
                            "click",
                            async () => {
                                menu.remove();
                                await testApiKey();
                            }
                        );

                        menu.querySelector("#logs-btn").addEventListener(
                            "click",
                            () => {
                                menu.remove();
                                showErrorLogs();
                            }
                        );
                    } else {
                        // Não há documentos, mostrar mensagem de erro
                        log(" Não há documentos, não criando menu");
                        return;
                    }
                }

                document.body.appendChild(menu);

                // Verificar e prevenir sobreposições após um pequeno delay
                setTimeout(() => {
                    preventElementOverlap();
                }, 100);

                document.addEventListener("click", function closeMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener("click", closeMenu);
                    }
                });
            }

            // Opções de processamento quando há múltiplos documentos
            function showDocumentProcessingOptions() {
                const documentosRelevantes = findDocumentosRelevantes();

                if (documentosRelevantes.length === 0) {
                    showNotification(
                        "❌ Nenhum documento relevante encontrado",
                        "error"
                    );
                    return;
                }

                const existing = document.getElementById(
                    "documento-relevante-selection-modal"
                );
                if (existing) {
                    existing.remove();
                }

                const overlay = document.createElement("div");
                overlay.id = "documento-relevante-selection-modal";
                overlay.className = "eprobe-modal";
                overlay.style.cssText = `
            position: fixed !important;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: "Roboto", -apple-system, system-ui, sans-serif;
        `;

                const modal = document.createElement("div");
                modal.style.cssText = `
            background: #1e293b;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            border: 1px solid #334155;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            color: #f8fafc;
        `;

                const title = document.createElement("h2");
                title.style.cssText = `
            margin: 0 0 20px 0;
            color: #3b82f6;
            font-size: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        `;
                title.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                <polyline points="14,2 14,8 20,8"/>
            </svg>
            Escolher Documento (${documentosRelevantes.length} encontrados)
        `;

                const subtitle = document.createElement("p");
                subtitle.style.cssText = `
            margin: 0 0 20px 0;
            color: #94a3b8;
            font-size: 14px;
            line-height: 1.5;
        `;
                subtitle.textContent =
                    "Selecione o documento que deseja processar:";

                const list = document.createElement("div");
                list.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        `;

                documentosRelevantes.forEach((doc, index) => {
                    const item = document.createElement("div");
                    item.style.cssText = `
                border: 1px solid #475569;
                border-radius: 8px;
                padding: 16px;
                cursor: pointer;
                transition: all 0.2s ease;
                background: #334155;
            `;

                    item.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="color: ${doc.tipo.cor}; font-size: 18px;">
                        ${doc.tipo.icone}
                    </div>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; color: #f8fafc; margin-bottom: 4px;">
                            ${doc.tipo.descricao}
                        </div>
                        <div style="font-size: 12px; color: #94a3b8;">
                            ${doc.nome}
                        </div>
                    </div>
                    <div style="color: #3b82f6;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9,18 15,12 9,6"/>
                        </svg>
                    </div>
                </div>
            `;

                    item.addEventListener(
                        "mouseenter",
                        () => {
                            item.style.backgroundColor = "#475569";
                            item.style.borderColor = "#3b82f6";
                        },
                        { passive: true }
                    );

                    item.addEventListener(
                        "mouseleave",
                        () => {
                            item.style.backgroundColor = "#334155";
                            item.style.borderColor = "#475569";
                        },
                        { passive: true }
                    );

                    item.addEventListener("click", () => {
                        overlay.remove();
                        autoOpenSpecificDocument(doc);
                    });

                    list.appendChild(item);
                });

                const buttons = document.createElement("div");
                buttons.style.cssText = `
            display: flex;
            justify-content: space-between;
            gap: 12px;
        `;

                const cancelBtn = document.createElement("button");
                cancelBtn.style.cssText = `
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s ease;
        `;
                cancelBtn.textContent = "Cancelar";
                cancelBtn.classList.add("eprobe-cancel-button");
                cancelBtn.addEventListener("click", () => {
                    overlay.remove();
                });

                const processAllBtn = document.createElement("button");
                processAllBtn.style.cssText = `
            background: #059669;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s ease;
        `;
                processAllBtn.textContent = "Processar Primeiro";
                processAllBtn.classList.add("eprobe-process-button");
                processAllBtn.addEventListener("click", () => {
                    overlay.remove();
                    autoOpenSpecificDocument(documentosRelevantes[0]);
                });

                buttons.appendChild(cancelBtn);
                buttons.appendChild(processAllBtn);

                modal.appendChild(title);
                modal.appendChild(subtitle);
                modal.appendChild(list);
                modal.appendChild(buttons);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);

                overlay.addEventListener("click", (e) => {
                    if (e.target === overlay) {
                        overlay.remove();
                    }
                });
            }

            // Abrir documento específico
            async function autoOpenSpecificDocument(documento) {
                log("🔗 Abrindo documento específico:", documento);

                try {
                    showNotification("📄 Abrindo documento...", "info");

                    const link = documento.elemento.querySelector("a");
                    if (!link) {
                        log("❌ Link não encontrado no documento");
                        showNotification(
                            "❌ Erro: Link do documento não encontrado",
                            "error"
                        );
                        return false;
                    }

                    const url = link.href;
                    if (!url) {
                        log("❌ URL não encontrada no link");
                        showNotification(
                            "❌ Erro: URL do documento não encontrada",
                            "error"
                        );
                        return false;
                    }

                    log("🌐 URL do documento:", url);

                    const newTab = window.open(url, "_blank");
                    if (newTab) {
                        log("✅ Documento aberto em nova aba");
                        showNotification(
                            "✅ Documento aberto! Execute a extensão novamente na nova aba",
                            "success"
                        );
                        return true;
                    } else {
                        log("❌ Falha ao abrir nova aba - popup bloqueado?");
                        showNotification(
                            "❌ Não foi possível abrir o documento. Verifique se popups estão bloqueados.",
                            "error"
                        );
                        return false;
                    }
                } catch (error) {
                    log("❌ Erro ao abrir documento específico:", error);
                    showNotification(
                        "❌ Erro ao abrir documento: " + error.message,
                        "error"
                    );
                    return false;
                }
            }

            // Automação completa - usando expressão de função para evitar problemas de escopo
            const runFullAutomation = async function () {
                if (isAutomationActive) {
                    log(" Automação já está ativa");
                    return;
                }

                isAutomationActive = true;
                log(" Iniciando automação completa...");

                try {
                    const pageType = detectPageType();

                    if (pageType === "lista_documentos") {
                        const opened = await autoOpenDocumentoRelevante();
                        if (opened) {
                            showNotification(
                                " Documento aberto! Aguarde carregar e execute novamente na nova aba",
                                "success"
                            );
                        }
                    } else if (pageType === "documento_especifico") {
                        const texto = await autoExtractText();
                        if (texto) {
                            const apiSent = await sendToPerplexity(texto);

                            if (!apiSent) {
                                log(
                                    " API falhou, usando método de clipboard como fallback"
                                );
                                showNotification(
                                    " Tentando método alternativo...",
                                    "warning"
                                );

                                const copied = await copyToClipboardWithPrefix(
                                    texto
                                );
                                if (copied) {
                                    showNotification(
                                        " Texto copiado! Cole em Perplexity ou outra IA (Ctrl+V)\n\nO texto já inclui o prefixo de instrução para IA",
                                        "success"
                                    );
                                }
                            }
                        }
                    } else {
                        showNotification(
                            " Página não reconhecida. Use na página do processo ou documento",
                            "error"
                        );
                    }
                } catch (error) {
                    log(" Erro na automação:", error);
                    showNotification(
                        " Erro na automação: " + error.message,
                        "error"
                    );
                } finally {
                    isAutomationActive = false;
                }
            };

            // Função para prevenir sobreposição de elementos da interface
            function preventElementOverlap() {
                const floatingButton =
                    document.getElementById("sent1-auto-button");
                const notification = document.getElementById(
                    "documento-relevante-notification"
                );
                const optionsMenu = document.getElementById(
                    "documento-relevante-options-menu"
                );

                if (
                    !floatingButton ||
                    floatingButton.style.display === "none"
                ) {
                    return; // Botão flutuante não está visível
                }

                // Verificar sobreposição com notificação
                if (notification) {
                    const buttonRect = floatingButton.getBoundingClientRect();
                    const notificationRect =
                        notification.getBoundingClientRect();

                    // Se há sobreposição, mover notificação
                    if (
                        buttonRect.left < notificationRect.right + 10 &&
                        buttonRect.top < notificationRect.bottom + 10 &&
                        buttonRect.bottom > notificationRect.top - 10
                    ) {
                        log(
                            "🔧 Ajustando posição da notificação para evitar sobreposição"
                        );
                        notification.style.right = "240px"; // Mover mais à esquerda
                    }
                }

                // Verificar sobreposição com menu de opções
                if (optionsMenu) {
                    const buttonRect = floatingButton.getBoundingClientRect();
                    const menuRect = optionsMenu.getBoundingClientRect();

                    // Se há sobreposição, mover menu
                    if (
                        buttonRect.left < menuRect.right + 10 &&
                        buttonRect.top < menuRect.bottom + 10 &&
                        buttonRect.bottom > menuRect.top - 10
                    ) {
                        log(
                            "🔧 Ajustando posição do menu para evitar sobreposição"
                        );
                        const newLeft = Math.max(
                            10,
                            buttonRect.left - menuRect.width - 10
                        );
                        optionsMenu.style.left = newLeft + "px";
                    }
                }
            }

            // ✅ REMOVIDO: setupInterfaceObserver duplicada - agora está no escopo global
            // A função foi movida para o escopo global para estar disponível em toda a extensão

            // Sistema de notificações
            function showNotification(message, type = "info") {
                // Remover notificação anterior se existir
                const existing = document.getElementById(
                    "documento-relevante-notification"
                );
                if (existing) {
                    existing.remove();
                }

                // Verificar se existe botão flutuante para ajustar posição
                const floatingButton =
                    document.getElementById("sent1-auto-button");
                const isFloatingButtonVisible =
                    floatingButton &&
                    floatingButton.style.display !== "none" &&
                    floatingButton.offsetParent !== null; // Verifica se está realmente visível

                // Posição dinâmica baseada na presença do botão flutuante
                let notificationTop = "20px";
                let notificationRight = "20px";

                if (isFloatingButtonVisible) {
                    // Se há botão flutuante, calcular posição para evitar sobreposição
                    const buttonRect = floatingButton.getBoundingClientRect();
                    const windowWidth = window.innerWidth;

                    // Se há espaço à esquerda do botão, colocar a notificação lá
                    if (buttonRect.left > 300) {
                        notificationRight =
                            windowWidth - buttonRect.left + 10 + "px";
                    } else {
                        // Se não há espaço, colocar acima ou abaixo do botão
                        if (buttonRect.top > 100) {
                            notificationTop = buttonRect.top - 80 + "px";
                            notificationRight = "20px";
                        } else {
                            notificationTop = buttonRect.bottom + 10 + "px";
                            notificationRight = "20px";
                        }
                    }
                }

                const notification = document.createElement("div");
                notification.id = "documento-relevante-notification";
                notification.className = "eprobe-notification";
                notification.style.cssText = `
                    position: fixed !important;
                    top: ${notificationTop};
                    right: ${notificationRight};
                    background: ${
                        type === "error"
                            ? "#dc3545"
                            : type === "warning"
                            ? "#ffc107"
                            : type === "success"
                            ? "#134377"
                            : "#134377"
                    };
                    color: white;
                    padding: 15px 20px;
                    border-radius: 5px;
                    font-weight: bold;
                    z-index: 10000;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    max-width: 280px;
                    font-size: 14px;
                    line-height: 1.4;
                    `;
                // Verificar se deve mostrar spinner
                if (message.includes("Enviando para Perplexity")) {
                    notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="position: relative; width: 24px; height: 24px;">
                        <div style="width: 24px; height: 24px; border-top: 3px solid rgba(255,255,255,0.3); border-bottom: 3px solid rgba(255,255,255,0.3); border-radius: 50%; position: absolute; top: 0; left: 0;"></div>
                        <div style="width: 24px; height: 24px; border-top: 3px solid white; border-bottom: 3px solid white; border-radius: 50%; position: absolute; top: 0; left: 0; animation: spin 1s linear infinite;"></div>
                    </div>
                    <span>${message}</span>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
                } else {
                    notification.textContent = message;
                }

                document.body.appendChild(notification);

                // Verificar e prevenir sobreposições após um pequeno delay
                setTimeout(() => {
                    preventElementOverlap();
                }, 100);

                // Remover após 5 segundos
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 5000);
            }

            // Verificar se a página deve mostrar o botão integrado (REMOVIDA - usar a versão melhorada)
            // Função movida para cima para evitar duplicação

            // Criar botão de automação integrado na página
            function createAutomationButton() {
                log(" Tentando criar botão integrado...");

                // Verificar se já existe (verificar todos os IDs possíveis)
                if (
                    document.getElementById(
                        "documento-relevante-auto-button"
                    ) ||
                    document.getElementById("sent1-auto-button")
                ) {
                    log(" Botão já existe, pulando criação");
                    return;
                }

                // CRITÉRIO ESPECÍFICO: Verificar se a página tem o título exato
                let shouldShowIntegrated = false;
                try {
                    if (typeof shouldShowIntegratedButton === "function") {
                        shouldShowIntegrated = shouldShowIntegratedButton();
                    }
                } catch (e) {
                    console.warn(
                        "⚠️ Erro ao verificar shouldShowIntegratedButton:",
                        e.message
                    );
                }

                if (!shouldShowIntegrated) {
                    log(
                        " Página não possui o título correto para botão integrado, verificando critério para botão flutuante..."
                    );
                    // Se não tem o título correto mas deve mostrar o botão flutuante, criar botão flutuante
                    let shouldShowFloating = false;
                    try {
                        if (typeof shouldShowFloatingButton === "function") {
                            shouldShowFloating = shouldShowFloatingButton();
                        }
                    } catch (e) {
                        console.warn(
                            "⚠️ Erro ao verificar shouldShowFloatingButton:",
                            e.message
                        );
                    }

                    if (shouldShowFloating) {
                        createFloatingButton();
                    } else {
                        log(" Página não atende critérios para nenhum botão");
                    }
                    return;
                }

                // Buscar container principal para integração
                const targetInfo = findTargetContainer();

                if (!targetInfo) {
                    log(
                        " Container alvo não encontrado, usando posição fixa como fallback"
                    );
                    createFloatingButton();
                    return;
                }

                // Extrair informações do container
                const targetContainer = targetInfo.container || targetInfo;
                const insertMethod = targetInfo.insertMethod || "append";
                const referenceElement = targetInfo.referenceElement;

                log(" Container encontrado, criando botão integrado...");
                const button = criarInfraButtonPrimary(
                    "documento-relevante-auto-button",
                    `
 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 3px !important; vertical-align: middle;">
 <rect width="18" height="18" x="3" y="3" rx="2"/>
 <path d="m9 8 6 4-6 4Z"/>
 </svg>
 Resumir Documento
 `
                );

                // Adicionar espaçamento quando posicionado ao lado do PDPJ
                if (insertMethod === "beforePDPJ") {
                    button.style.marginRight = "15px";
                }

                // Adicionar evento de click
                button.addEventListener("click", async (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    log(" Botão integrado clicado!");
                    log(" Debug: Botão Resumir Documento clicado");

                    // Adicionar feedback visual
                    button.style.transform = "scale(0.95)";
                    setTimeout(() => {
                        button.style.transform = "";
                    }, 150);

                    const pageType = detectPageType();
                    log(" Tipo de página detectado:", pageType);

                    if (pageType === "lista_documentos") {
                        showNotification(" Abrindo documento...", "info");
                        await runFullAutomation();
                    } else if (pageType === "documento_especifico") {
                        const rect = button.getBoundingClientRect();
                        showOptionsMenu(rect.left, rect.bottom);
                    } else {
                        showNotification(" Página não reconhecida", "error");
                    }
                });

                // Inserir no container usando o método apropriado
                if (insertMethod === "beforeDownload" && referenceElement) {
                    try {
                        log(
                            " Inserindo botão antes do Download Completo na barra de comandos..."
                        );
                        log(
                            " Reference element (Download button):",
                            referenceElement
                        );
                        log(" Container (form):", targetContainer);

                        // Criar um wrapper para melhor alinhamento na barra de comandos
                        const buttonWrapper = document.createElement("span");
                        buttonWrapper.style.cssText = "display: inline-block;";
                        buttonWrapper.appendChild(button);

                        // Inserir o wrapper antes do botão Download Completo
                        referenceElement.insertAdjacentElement(
                            "beforebegin",
                            buttonWrapper
                        );

                        log(
                            " Botão inserido com sucesso antes do Download Completo"
                        );
                        log(
                            " Posição final do botão:",
                            button.parentElement.parentElement
                        );
                    } catch (error) {
                        log(
                            " Erro ao inserir antes do Download Completo, usando fallback:",
                            error
                        );
                        // Fallback: inserir no início do container
                        targetContainer.insertBefore(
                            button,
                            targetContainer.firstChild
                        );
                        log(
                            " Botão inserido no início do container (fallback)"
                        );
                    }
                } else if (insertMethod === "prepend") {
                    // Inserir no início do container
                    const firstChild = targetContainer.firstChild;
                    if (firstChild) {
                        targetContainer.insertBefore(button, firstChild);
                    } else {
                        targetContainer.appendChild(button);
                    }
                    log(" Botão inserido no início do container");
                } else if (insertMethod === "beforePDPJ" && referenceElement) {
                    try {
                        // Estratégia 1: Inserir diretamente ao lado esquerdo da imagem usando insertAdjacentElement
                        log(
                            " Tentando posicionar ao lado esquerdo da imagem PDPJ..."
                        );
                        log(" Reference element:", referenceElement);
                        log(
                            " Reference element tagName:",
                            referenceElement.tagName
                        );
                        log(
                            " Reference element parent:",
                            referenceElement.parentElement
                        );

                        // Usar insertAdjacentElement para posicionar exatamente ao lado esquerdo
                        referenceElement.insertAdjacentElement(
                            "beforebegin",
                            button
                        );

                        // Verificação final: garantir que o botão não está dentro de um link
                        const buttonParent = button.parentElement;
                        const isInsideLink = button.closest("a") !== null;

                        if (isInsideLink) {
                            log(
                                " PROBLEMA: Botão foi inserido dentro de um link!"
                            );
                            log(" Tentando mover para fora do link...");

                            // Encontrar o link pai
                            const linkElement = button.closest("a");
                            const linkContainer = linkElement.parentElement;

                            // Remover botão do local atual
                            button.remove();

                            // Inserir antes do link
                            linkContainer.insertBefore(button, linkElement);
                            log(" Botão movido para fora do link");
                        }

                        log(" Botão inserido ao lado esquerdo da imagem PDPJ");
                        log(" Posição final do botão:", button.parentElement);
                        log(
                            " Botão está dentro de link?",
                            button.closest("a") !== null ? "SIM" : "NÃO"
                        );
                    } catch (error) {
                        log(
                            " Erro ao inserir ao lado da imagem PDPJ, tentando estratégias alternativas:",
                            error
                        );

                        try {
                            // Estratégia 2: Verificar se a imagem é realmente filha direta do container
                            if (
                                Array.from(targetContainer.children).includes(
                                    referenceElement
                                )
                            ) {
                                // Inserir antes da imagem PDPJ (ao lado esquerdo)
                                targetContainer.insertBefore(
                                    button,
                                    referenceElement
                                );
                                log(" Botão inserido antes da imagem PDPJ");
                            } else {
                                // Estratégia 3: A imagem não é filha direta, usar o pai direto da imagem
                                const directParent =
                                    referenceElement.parentElement;
                                if (
                                    directParent &&
                                    Array.from(directParent.children).includes(
                                        referenceElement
                                    )
                                ) {
                                    directParent.insertBefore(
                                        button,
                                        referenceElement
                                    );
                                    log(
                                        " Botão inserido antes da imagem PDPJ (no pai direto)"
                                    );
                                } else {
                                    // Estratégia 4: Fallback - adicionar no final do container encontrado
                                    targetContainer.appendChild(button);
                                    log(
                                        " Botão adicionado ao container (fallback)"
                                    );
                                }
                            }
                        } catch (secondError) {
                            log(
                                " Erro na segunda tentativa, usando fallback final:",
                                secondError
                            );
                            // Fallback final: adicionar no final do container
                            targetContainer.appendChild(button);
                            log(
                                " Botão adicionado ao container (fallback final)"
                            );
                        }
                    }
                } else {
                    // Método padrão - adicionar ao final do container
                    targetContainer.appendChild(button);
                    log(
                        " Botão integrado adicionado ao container:",
                        targetContainer
                    );
                }
            }

            // Função para encontrar o container alvo na página
            function findTargetContainer() {
                // Prioridade 1: Buscar o botão "Download Completo" na barra de comandos superior do eProc
                const commandBar = document.getElementById(
                    "divInfraBarraComandosSuperior"
                );
                if (commandBar) {
                    log(" Barra de comandos superior encontrada:", commandBar);

                    // Procurar pelo formulário que contém o botão "Download Completo"
                    const processForm =
                        commandBar.querySelector("#frmProcessoLista");
                    if (processForm) {
                        log(" Formulário do processo encontrado:", processForm);

                        // Buscar o botão "Download Completo" por diferentes estratégias
                        const downloadSelectors = [
                            'button[id*="btnDownloadCompleto"]',
                            'input[id*="btnDownloadCompleto"]',
                            'button[aria-label*="Download Completo"]',
                            'input[aria-label*="Download Completo"]',
                            'button[value*="Download Completo"]',
                            'input[value*="Download Completo"]',
                            'button[title*="Download Completo"]',
                            'input[title*="Download Completo"]',
                            'button:contains("Download Completo")',
                            '*[onclick*="download_completo"]',
                            '*[onclick*="downloadCompleto"]',
                            '*[onclick*="download"]',
                        ];

                        let downloadButton = null;

                        // Primeiro tentar seletores diretos
                        for (const selector of downloadSelectors) {
                            if (selector.includes(":contains(")) continue; // Pular seletores que não funcionam com querySelector
                            downloadButton =
                                processForm.querySelector(selector);
                            if (downloadButton) {
                                log(
                                    ` Botão Download Completo encontrado com seletor: ${selector}`,
                                    downloadButton
                                );
                                break;
                            }
                        }

                        // Se não encontrou, buscar por texto nos botões
                        if (!downloadButton) {
                            log(
                                " Buscando botão Download Completo por texto..."
                            );
                            const allButtons = processForm.querySelectorAll(
                                'button, input[type="submit"], input[type="button"]'
                            );
                            for (const btn of allButtons) {
                                const text =
                                    btn.textContent ||
                                    btn.value ||
                                    btn.getAttribute("aria-label") ||
                                    "";
                                if (
                                    text.toLowerCase().includes("download") &&
                                    text.toLowerCase().includes("completo")
                                ) {
                                    downloadButton = btn;
                                    log(
                                        " Botão Download Completo encontrado por texto:",
                                        downloadButton
                                    );
                                    break;
                                }
                            }
                        }

                        if (downloadButton) {
                            log(
                                " Inserindo antes do botão Download Completo na barra de comandos"
                            );
                            return {
                                container: processForm,
                                insertMethod: "beforeDownload",
                                referenceElement: downloadButton,
                            };
                        } else {
                            // Se não encontrou o botão Download, inserir no início do formulário
                            log(
                                " Botão Download Completo não encontrado, inserindo no início do formulário"
                            );
                            return {
                                container: processForm,
                                insertMethod: "prepend",
                            };
                        }
                    } else {
                        // Se não encontrou o formulário, buscar diretamente na barra de comandos
                        log(
                            " Formulário não encontrado, buscando Download Completo diretamente na barra..."
                        );

                        const downloadSelectors = [
                            'button[id*="btnDownloadCompleto"]',
                            'input[id*="btnDownloadCompleto"]',
                            'button[aria-label*="Download Completo"]',
                            'input[aria-label*="Download Completo"]',
                            'button[value*="Download Completo"]',
                            'input[value*="Download Completo"]',
                        ];

                        let downloadButton = null;
                        for (const selector of downloadSelectors) {
                            downloadButton = commandBar.querySelector(selector);
                            if (downloadButton) {
                                log(
                                    ` Botão Download encontrado na barra: ${selector}`,
                                    downloadButton
                                );
                                return {
                                    container: commandBar,
                                    insertMethod: "beforeDownload",
                                    referenceElement: downloadButton,
                                };
                            }
                        }

                        // Buscar por texto nos botões da barra
                        const allButtons = commandBar.querySelectorAll(
                            'button, input[type="submit"], input[type="button"]'
                        );
                        for (const btn of allButtons) {
                            const text =
                                btn.textContent ||
                                btn.value ||
                                btn.getAttribute("aria-label") ||
                                "";
                            if (
                                text.toLowerCase().includes("download") &&
                                text.toLowerCase().includes("completo")
                            ) {
                                log(
                                    " Botão Download encontrado por texto na barra:",
                                    btn
                                );
                                return {
                                    container: commandBar,
                                    insertMethod: "beforeDownload",
                                    referenceElement: btn,
                                };
                            }
                        }

                        // Se não encontrou nada, inserir na barra de comandos
                        log(
                            " Botão Download não encontrado, inserindo na barra de comandos"
                        );
                        return {
                            container: commandBar,
                            insertMethod: "prepend",
                        };
                    }
                }

                // Prioridade 2: Buscar pela imagem PDPJ e posicionar ao lado esquerdo (fallback)
                const pdpjImage = document.querySelector(
                    'img[src*="pdpj-logotipo_3.png"], img[src*="pdpj-logotipo"]'
                );
                if (pdpjImage) {
                    log(
                        " Imagem PDPJ encontrada, buscando container pai adequado"
                    );

                    // Verificar se a imagem está dentro de um link <a>
                    const linkParent = pdpjImage.closest("a");
                    if (linkParent) {
                        log("Imagem PDPJ está dentro de um link:", linkParent);
                        log(
                            "Link src/href:",
                            linkParent.href || linkParent.getAttribute("href")
                        );
                        const linkContainer = linkParent.parentElement;
                        if (linkContainer) {
                            log("Container do link:", linkContainer);
                            return {
                                container: linkContainer,
                                insertMethod: "beforePDPJ",
                                referenceElement: linkParent, // Usar o link como referência, não a imagem
                            };
                        }
                    }

                    // Primeiro tentar o pai direto da imagem se não estiver em um link
                    const directParent = pdpjImage.parentElement;
                    if (directParent) {
                        log(" Usando pai direto da imagem PDPJ:", directParent);
                        return {
                            container: directParent,
                            insertMethod: "beforePDPJ",
                            referenceElement: pdpjImage,
                        };
                    }

                    // Buscar o container pai que permite inserir o botão ao lado esquerdo
                    let parent = pdpjImage.parentElement;
                    while (parent && parent !== document.body) {
                        const styles = window.getComputedStyle(parent);

                        // Verificar se é um container que permita posicionamento (SEM verificação d-flex)
                        if (
                            styles.display === "flex" ||
                            parent.classList.contains("header") ||
                            parent.tagName === "HEADER"
                        ) {
                            log(
                                " Container de header encontrado para PDPJ:",
                                parent
                            );

                            // Retornar um objeto especial indicando posicionamento próximo à imagem PDPJ
                            return {
                                container: parent,
                                insertMethod: "beforePDPJ",
                                referenceElement: pdpjImage,
                            };
                        }
                        parent = parent.parentElement;
                    }

                    // Se não encontrou container flex, usar o pai direto da imagem como fallback
                    log(" Usando container pai direto da imagem PDPJ");
                    return {
                        container: pdpjImage.parentElement,
                        insertMethod: "beforePDPJ",
                        referenceElement: pdpjImage,
                    };
                }

                // Prioridade 2: REMOVIDO - Não buscar na navbar para evitar interferências
                // A navbar agora é gerenciada exclusivamente por gerenciarNavbarEprobe()
                log(
                    "ℹ️ BUTTON: Pulando busca na navbar para evitar interferências"
                );

                // Prioridade 3: Lista atualizada de seletores com foco no eProc (SEM elementos d-flex que podem interferir na navbar)
                const containerSelectors = [
                    "#divInfraBarraComandosSuperior", // Barra de comandos superior do eProc
                    ".infraBarraComandos", // Barra de comandos geral do eProc
                    "#frmProcessoLista", // Formulário da lista de processos
                    ".toolbar",
                    ".action-bar",
                    ".header-actions",
                    "#barraComandos",
                    ".infra-barra-comandos",
                ];

                for (const selector of containerSelectors) {
                    const container = document.querySelector(selector);
                    if (container) {
                        log(` Container encontrado com seletor: ${selector}`);
                        return { container: container, insertMethod: "append" };
                    }
                }

                // Fallback: buscar containers específicos (SEM d-flex que pode interferir na navbar)
                const fallbackSelectors = [
                    'div[class*="toolbar"]',
                    'div[class*="header"]',
                    'div[class*="action"]',
                ];

                for (const selector of fallbackSelectors) {
                    const containers = document.querySelectorAll(selector);
                    for (const container of containers) {
                        // Verificar se o container está visível e tem tamanho adequado
                        const rect = container.getBoundingClientRect();
                        if (
                            rect.width > 200 &&
                            rect.height > 20 &&
                            rect.top < 300
                        ) {
                            log(` Container fallback encontrado: ${selector}`);
                            return {
                                container: container,
                                insertMethod: "append",
                            };
                        }
                    }
                }

                log(" Nenhum container adequado encontrado");
                return null;
            }

            // Função para mostrar menu básico de debug quando a página não é reconhecida
            function showBasicDebugMenu(button) {
                log("🛠️ DEBUG MENU: Criando menu básico de debug");

                const rect = button.getBoundingClientRect();
                const menu = document.createElement("div");
                menu.id = "eprobe-debug-menu";
                menu.style.cssText = `
                    position: fixed !important;
                    left: ${rect.left - 200}px;
                    top: ${rect.bottom + 10}px;
                    z-index: 10002;
                    background: rgb(19, 67, 119);
                    border: 1px solid rgb(19, 67, 119);
                    border-radius: 8px;
                    padding: 12px;
                    min-width: 250px;
                    color: white;
                    font-family: "Roboto", sans-serif;
                    font-size: 14px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                `;

                const pageType = detectPageType();
                const url = window.location.href;

                menu.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid rgb(19, 67, 119); padding-bottom: 8px;">
                        🛠️ eProbe Debug Menu
                    </div>
                    <div style="font-size: 12px; margin-bottom: 8px;">
                        <strong>Página:</strong> ${
                            pageType || "não reconhecida"
                        }
                    </div>
                    <div style="font-size: 12px; margin-bottom: 12px; word-break: break-all;">
                        <strong>URL:</strong> ${url.substring(0, 60)}...
                    </div>
                    <button id="debug-extract-text" style="width: 100%; margin-bottom: 6px; background: rgb(19, 67, 119); color: white; border: none; padding: 8px; border-radius: 4px; cursor: pointer;">
                        📄 Extrair Texto da Página
                    </button>
                    <button id="debug-show-api-config" style="width: 100%; margin-bottom: 6px; background: rgb(19, 67, 119); color: white; border: none; padding: 8px; border-radius: 4px; cursor: pointer;">
                        🔑 Configurar API Perplexity
                    </button>
                    <button id="debug-close" style="width: 100%; background: #6c757d; color: white; border: none; padding: 8px; border-radius: 4px; cursor: pointer;">
                        ❌ Fechar
                    </button>
                `;

                document.body.appendChild(menu);

                // Event listeners
                menu.querySelector("#debug-extract-text").addEventListener(
                    "click",
                    async () => {
                        menu.remove();
                        try {
                            const texto = await autoExtractText();
                            if (texto) {
                                await copyToClipboardWithPrefix(texto);
                                showNotification(
                                    "📄 Texto extraído e copiado! Cole no Perplexity (Ctrl+V)",
                                    "success"
                                );
                            } else {
                                showNotification(
                                    "❌ Não foi possível extrair texto desta página",
                                    "error"
                                );
                            }
                        } catch (error) {
                            console.error("Erro ao extrair texto:", error);
                            showNotification(
                                "❌ Erro ao extrair texto: " + error.message,
                                "error"
                            );
                        }
                    }
                );

                menu.querySelector("#debug-show-api-config").addEventListener(
                    "click",
                    () => {
                        menu.remove();
                        showApiKeyConfig();
                    }
                );

                menu.querySelector("#debug-close").addEventListener(
                    "click",
                    () => {
                        menu.remove();
                    }
                );

                // Fechar ao clicar fora
                setTimeout(() => {
                    document.addEventListener(
                        "click",
                        function closeDebugMenu(e) {
                            if (!menu.contains(e.target)) {
                                menu.remove();
                                document.removeEventListener(
                                    "click",
                                    closeDebugMenu
                                );
                            }
                        }
                    );
                }, 100);

                log("✅ DEBUG MENU: Menu de debug criado");
            }

            // Função auxiliar para getBoundingClientRect com fallback
            window.getCachedBoundingRect = function (element) {
                try {
                    if (
                        !element ||
                        typeof element.getBoundingClientRect !== "function"
                    ) {
                        console.warn(
                            "⚠️ getCachedBoundingRect: Elemento inválido",
                            element
                        );
                        return {
                            left: 0,
                            top: 0,
                            right: 0,
                            bottom: 0,
                            width: 0,
                            height: 0,
                        };
                    }
                    return element.getBoundingClientRect();
                } catch (error) {
                    console.error(
                        "❌ getCachedBoundingRect: Erro ao obter coordenadas",
                        error
                    );
                    return {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0,
                        width: 0,
                        height: 0,
                    };
                }
            };

            // Função de fallback para criar botão flutuante (caso container não seja encontrado)
            function createFloatingButton() {
                log("🎯 FLOATING BUTTON: Iniciando criação do botão flutuante");

                // Verificar se já existe um botão
                if (document.getElementById("sent1-auto-button")) {
                    log(
                        "⚠️ FLOATING BUTTON: Botão flutuante já existe, cancelando criação"
                    );
                    return;
                }

                // Verificar se a página é válida para mostrar o botão
                const shouldShow = shouldShowFloatingButton();
                log("🔍 FLOATING BUTTON: Verificação de critérios:", {
                    shouldShow: shouldShow,
                    url: window.location.href,
                });

                if (!shouldShow) {
                    log(
                        "❌ FLOATING BUTTON: Página não atende critérios para o botão flutuante, cancelando criação"
                    );
                    return;
                }

                log("✅ FLOATING BUTTON: Criando botão flutuante...");
                const button = document.createElement("button");
                button.id = "sent1-auto-button";
                button.className = "eprobe-button";
                button.innerHTML = `
 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 3px !important; vertical-align: middle;">
 <rect width="18" height="18" x="3" y="3" rx="2"/>
 <path d="m9 8 6 4-6 4Z"/>
 </svg>
 Resumir Documento
 `;

                // FORÇAR aplicação do margin-right no SVG após criação
                setTimeout(() => {
                    const svg = button.querySelector("svg");
                    if (svg) {
                        svg.style.marginRight = "4px";
                        svg.style.setProperty(
                            "margin-right",
                            "4px",
                            "important"
                        );
                        log("✅ FLOATING BUTTON: Margin-right aplicado ao SVG");
                    }
                }, 100);

                // Usar estilo customizado próprio para o botão flutuante
                button.style.cssText = `
 position: fixed !important;
 top: 120px;
 right: 20px;
 z-index: 99999;
 background-color: #134377;
 border: 1px solid #134377;
 color: white;
 padding: 8px 16px;
 border-radius: 4px;
 font-family: "Roboto", -apple-system, system-ui, sans-serif;
 font-size: 14px;
 font-weight: normal;
 cursor: pointer;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 text-decoration: none;
 white-space: nowrap;
 box-shadow: 0 2px 4px rgba(0,0,0,0.2);
 transition: background-color 0.2s ease;
 `;

                // ⚡ OTIMIZAÇÃO PERFORMANCE: CSS hover em vez de event listeners
                button.style.cssText += `
                transition: background-color 0.2s ease;
            `;
                button.classList.add("eprobe-button-hover");

                button.addEventListener("blur", () => {
                    button.style.backgroundColor = "#134377";
                    button.style.borderColor = "#134377";
                });

                button.addEventListener("click", async (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    log("🎯 FLOATING BUTTON: Botão flutuante clicado!");
                    log("🔍 FLOATING BUTTON: Debug do click");

                    // Adicionar feedback visual
                    button.style.transform = "scale(0.95)";
                    setTimeout(() => {
                        button.style.transform = "";
                    }, 150);

                    const pageType = detectPageType();
                    log(
                        "📄 FLOATING BUTTON: Tipo de página detectado:",
                        pageType
                    );

                    try {
                        // Lógica específica para o botão flutuante
                        if (pageType === "lista_documentos") {
                            showNotification("🚀 Abrindo documento...", "info");
                            await runFullAutomation();
                        } else if (
                            pageType === "documento_especifico" ||
                            pageType === "documento_html" ||
                            pageType === "documento_pdf"
                        ) {
                            // Página de documento específico - mostrar menu de opções
                            log("📋 FLOATING BUTTON: Mostrando menu de opções");

                            // Usar getBoundingClientRect diretamente em vez de getCachedBoundingRect
                            const rect = button.getBoundingClientRect();
                            log("📐 FLOATING BUTTON: Coordenadas do botão:", {
                                left: rect.left,
                                bottom: rect.bottom,
                                top: rect.top,
                                right: rect.right,
                            });

                            showOptionsMenu(rect.left, rect.bottom);
                        } else {
                            // Para o botão flutuante, verificar se há documento na página
                            const pageHTML = document.documentElement.outerHTML;
                            const hasDocumentHtml = pageHTML.includes(
                                "acessar_documento&id"
                            );
                            const hasDocumentPdf = pageHTML.includes(
                                "acessar_documento&amp"
                            );

                            log(
                                "🔍 FLOATING BUTTON: Verificação de documento:",
                                {
                                    hasDocumentHtml: hasDocumentHtml,
                                    hasDocumentPdf: hasDocumentPdf,
                                    url: window.location.href,
                                }
                            );

                            if (hasDocumentHtml || hasDocumentPdf) {
                                // Há documento, mas a página não foi reconhecida - tratar como documento específico
                                log(
                                    "📄 FLOATING BUTTON: Documento encontrado - mostrando menu"
                                );

                                const rect = button.getBoundingClientRect();
                                showOptionsMenu(rect.left, rect.bottom);
                            } else {
                                // Página não reconhecida - mostrar menu de debug
                                log(
                                    "❓ FLOATING BUTTON: Página não reconhecida - mostrando menu de debug"
                                );
                                showBasicDebugMenu(button);
                            }
                        }
                    } catch (error) {
                        console.error(
                            "❌ FLOATING BUTTON: Erro ao processar click:",
                            error
                        );
                        showNotification("❌ Erro ao processar ação", "error");
                    }
                });

                document.body.appendChild(button);
                log("✅ FLOATING BUTTON: Botão flutuante adicionado ao DOM");

                // Verificar se o botão foi realmente adicionado
                setTimeout(() => {
                    const addedButton =
                        document.getElementById("sent1-auto-button");
                    if (addedButton) {
                        const computedStyle =
                            window.getComputedStyle(addedButton);
                        log("🔍 FLOATING BUTTON: Status após adição:", {
                            existe: true,
                            display: computedStyle.display,
                            visibility: computedStyle.visibility,
                            position: computedStyle.position,
                            zIndex: computedStyle.zIndex,
                            top: addedButton.style.top,
                            right: addedButton.style.right,
                            backgroundColor: computedStyle.backgroundColor,
                        });

                        // Testar se o botão responde a eventos
                        addedButton.addEventListener(
                            "mouseover",
                            () => {
                                log("🖱️ FLOATING BUTTON: Mouse over detectado");
                            },
                            { once: true }
                        );
                    } else {
                        console.error(
                            "❌ FLOATING BUTTON: Botão não encontrado após adição ao DOM!"
                        );
                    }
                }, 100);

                // Verificar e prevenir sobreposições após um pequeno delay
                setTimeout(() => {
                    preventElementOverlap();
                }, 100);
            }

            // Debug: verificar se o botão foi criado
            function debugButtonStatus() {
                setTimeout(() => {
                    const button = document.getElementById("sent1-auto-button");
                    const integratedButton = document.getElementById(
                        "documento-relevante-auto-button"
                    );

                    log("=== DEBUG STATUS DO BOTÃO ===");
                    log("Página atual:", window.location.href);
                    log("Tipo de página detectado:", detectPageType());
                    log("Página é válida para botão:", isValidPageForButton());

                    if (button) {
                        log(" Botão SENT1 encontrado:", button);
                        const isFloating = button.style.position === "fixed";
                        log(
                            " Tipo de botão:",
                            isFloating ? "Flutuante" : "Integrado"
                        );

                        if (isFloating) {
                            log(" Posição do botão flutuante:", {
                                top: button.style.top,
                                right: button.style.right,
                                zIndex: button.style.zIndex,
                                display: getComputedStyle(button).display,
                                visibility: getComputedStyle(button).visibility,
                            });
                        } else {
                            log(" Informações do botão integrado:", {
                                parentElement: button.parentElement?.tagName,
                                parentClass: button.parentElement?.className,
                                display: getComputedStyle(button).display,
                                visibility: getComputedStyle(button).visibility,
                            });
                        }
                    } else if (integratedButton) {
                        log(" Botão integrado encontrado:", integratedButton);
                    } else {
                        log(" NENHUM BOTÃO ENCONTRADO!");
                        log(" Tentando criar botão agora...");

                        // Tentar criar botão imediatamente no debug
                        try {
                            if (
                                typeof shouldShowIntegratedButton ===
                                    "function" &&
                                shouldShowIntegratedButton()
                            ) {
                                log(
                                    " Página atende critérios para botão integrado - tentando criar..."
                                );
                                createAutomationButton();
                            } else if (
                                typeof shouldShowFloatingButton ===
                                    "function" &&
                                shouldShowFloatingButton()
                            ) {
                                log(
                                    " Página atende critérios para botão flutuante - tentando criar..."
                                );
                                createFloatingButton();
                            } else {
                                log(
                                    " Página não atende critérios para nenhum botão"
                                );
                            }
                        } catch (e) {
                            console.warn(
                                "⚠️ Erro ao verificar critérios do botão:",
                                e.message
                            );
                        }
                    }
                    log("=== FIM DEBUG STATUS ===");
                }, 2000);
            }

            // Debug avançado da API com logging estruturado
            function debugApiCall(requestId, phase, data) {
                if (!debugMode) return;

                const timestamp = new Date().toISOString();
                const phaseColors = {
                    INÍCIO: "",
                    REQUEST: "",
                    RESPONSE_HEADERS: "",
                    SUCCESS: "",
                    ERROR_DETAILS: "",
                    EXCEPTION: "",
                    TEST_START: "",
                    TEST_RESPONSE: "",
                    TEST_SUCCESS: "",
                    TEST_ERROR: "",
                };

                const icon = phaseColors[phase] || "";

                console.group(
                    `${icon} API Debug [ID: ${requestId}] - ${phase}`
                );
                log(" Timestamp:", timestamp);

                if (phase === "REQUEST") {
                    log(" URL:", data.url);
                    log(" Model:", data.model);
                    log(" Prompt Length:", data.promptLength);
                    log(" Max Tokens:", data.maxTokens);
                } else if (phase === "RESPONSE_HEADERS") {
                    log("  Status:", data.status, data.statusText);
                    log(" Request ID:", data.requestId);
                    if (data.rateLimit) {
                        log(" Rate Limits:");
                        console.table(data.rateLimit);
                    }
                } else if (phase === "SUCCESS") {
                    log(" Response ID:", data.responseId);
                    log(" Model Used:", data.model);
                    log(" Usage:", data.usage);
                    log("🏁 Finish Reason:", data.choices?.[0]?.finish_reason);
                    log(
                        " Response Length:",
                        data.choices?.[0]?.message?.content?.length
                    );
                } else if (phase === "ERROR_DETAILS") {
                    log(" Status:", data.status, data.statusText);
                    logError(" Error Text:", data.errorText);
                    if (data.errorJson) {
                        logError(" Error JSON:", data.errorJson);
                    }
                } else if (phase === "EXCEPTION") {
                    logError(" Error Name:", data.errorName);
                    logError(" Error Message:", data.errorMessage);
                    logError("📚 Stack Trace:", data.errorStack);
                } else if (phase === "TEST_SUCCESS") {
                    log(" Total Models:", data.totalModels);
                    log(" GPT Models:", data.gptModels);
                    log("🏢 Organization:", data.organization);
                    log(" Has GPT-4:", data.hasGpt4);
                } else {
                    log(" Data:", data);
                }

                console.groupEnd();

                // Salvar logs críticos no localStorage para debug posterior
                if (phase === "ERROR_DETAILS" || phase === "EXCEPTION") {
                    const errorLogs = JSON.parse(
                        localStorage.getItem("eprobe_error_logs") || "[]"
                    );
                    errorLogs.push({
                        requestId,
                        phase,
                        timestamp,
                        data,
                    });

                    // Manter apenas os últimos 10 logs de erro
                    if (errorLogs.length > 10) {
                        errorLogs.splice(0, errorLogs.length - 10);
                    }

                    localStorage.setItem(
                        "eprobe_error_logs",
                        JSON.stringify(errorLogs)
                    );
                }
            }

            // Verificar status da API key com informações detalhadas
            async function testApiKey() {
                try {
                    const apiKey = await getStoredApiKey();
                    if (!apiKey) {
                        showNotification(
                            " Nenhuma API key configurada",
                            "error"
                        );
                        return false;
                    }

                    log(" Testando API key...");

                    const testId = Date.now().toString();
                    debugApiCall(testId, "TEST_START", {
                        keyPreview: apiKey.substring(0, 10) + "...",
                    });

                    const response = await fetch(
                        "https://api.perplexity.ai/chat/completions",
                        {
                            method: "POST",
                            headers: {
                                Authorization: `Bearer ${apiKey}`,
                                "Content-Type": "application/json",
                                "User-Agent": "eProbe-Extension/1.0",
                            },
                            body: JSON.stringify({
                                model: "sonar",
                                messages: [
                                    {
                                        role: "user",
                                        content: "Teste de conexão",
                                    },
                                ],
                                max_tokens: 10,
                            }),
                        }
                    );

                    const responseHeaders = Object.fromEntries(
                        response.headers.entries()
                    );

                    debugApiCall(testId, "TEST_RESPONSE", {
                        status: response.status,
                        headers: responseHeaders,
                        requestId: responseHeaders["x-request-id"] || "N/A",
                    });

                    if (response.ok) {
                        const data = await response.json();

                        log(
                            " API key válida! Modelo usado:",
                            data.model || "sonar"
                        );

                        debugApiCall(testId, "TEST_SUCCESS", {
                            model: data.model,
                            usage: data.usage,
                            responseContent:
                                data.choices?.[0]?.message?.content,
                        });

                        showNotification(
                            ` API key válida!\nModelo: ${
                                data.model || "sonar"
                            }`,
                            "success"
                        );
                        return true;
                    } else {
                        const errorData = await response.text();
                        let errorJson = null;

                        try {
                            errorJson = JSON.parse(errorData);
                        } catch (e) {
                            log(" Erro de resposta não é JSON válido");
                        }

                        debugApiCall(testId, "TEST_ERROR", {
                            status: response.status,
                            errorText: errorData,
                            errorJson: errorJson,
                        });

                        if (response.status === 401) {
                            const errorMsg =
                                errorJson?.error?.message ||
                                "API key inválida ou expirada";
                            showNotification(` ${errorMsg}`, "error");
                            await removeStoredApiKey();
                        } else if (response.status === 429) {
                            const rateLimitType =
                                errorJson?.error?.type || "rate_limit_exceeded";

                            if (rateLimitType === "insufficient_quota") {
                                showNotification(
                                    " Cota da API Perplexity esgotada. Verifique em perplexity.ai/settings/api",
                                    "error"
                                );
                                await removeStoredApiKey();
                            } else {
                                showNotification(
                                    ` Rate limit atingido no teste da API`,
                                    "warning"
                                );
                            }
                        } else if (response.status === 403) {
                            showNotification(
                                " Acesso negado. Verifique créditos da conta",
                                "error"
                            );
                        } else {
                            const errorMsg =
                                errorJson?.error?.message ||
                                `Erro ${response.status}`;
                            showNotification(` ${errorMsg}`, "error");
                        }
                        return false;
                    }
                } catch (error) {
                    log(" Erro de conexão no teste:", error);
                    showNotification(
                        " Erro de conexão com Perplexity",
                        "error"
                    );
                    return false;
                }
            }

            // Mostrar modal para seleção de múltiplos documentos relevantes
            function showDocumentSelectionModal(documentosRelevantes) {
                log(
                    " DEBUG MODAL: Recebido documentosRelevantes:",
                    documentosRelevantes
                );
                log(" DEBUG MODAL: Detalhes de cada documento:");
                documentosRelevantes.forEach((doc, i) => {
                    log(` DOC${i + 1}:`, {
                        eventoDescricao: doc.eventoDescricao,
                        seqEvento: doc.seqEvento,
                        tipoDocumento: doc.tipoDocumento,
                        eventoData: doc.eventoData,
                    });
                });

                // 📅 ORDENAÇÃO DECRESCENTE POR DATA DE ASSINATURA (mais novo em cima, mais antigo embaixo)
                const documentosOrdenados = [...documentosRelevantes].sort(
                    (a, b) => {
                        // Função auxiliar para converter data brasileira DD/MM/YYYY para Date
                        const parseDataBrasileira = (dataStr) => {
                            if (!dataStr || typeof dataStr !== "string")
                                return null;

                            // Extrair data no formato DD/MM/YYYY ou DD/MM/YY
                            const match = dataStr.match(
                                /(\d{1,2})\/(\d{1,2})\/(\d{2,4})/
                            );
                            if (!match) return null;

                            let [, dia, mes, ano] = match;

                            // Se ano tem apenas 2 dígitos, assumir 20XX
                            if (ano.length === 2) {
                                ano = "20" + ano;
                            }

                            // Criar objeto Date (mês é 0-indexado)
                            return new Date(
                                parseInt(ano),
                                parseInt(mes) - 1,
                                parseInt(dia)
                            );
                        };

                        const dataA = parseDataBrasileira(a.eventoData);
                        const dataB = parseDataBrasileira(b.eventoData);

                        // Se ambas as datas são válidas, ordenar por data (mais recente primeiro)
                        if (dataA && dataB) {
                            return dataB.getTime() - dataA.getTime();
                        }

                        // Se apenas uma data é válida, colocar a válida primeiro
                        if (dataA && !dataB) return -1;
                        if (!dataA && dataB) return 1;

                        // Se nenhuma data é válida, manter ordem original por seqEvento
                        const seqA = parseInt(a.seqEvento) || 0;
                        const seqB = parseInt(b.seqEvento) || 0;
                        return seqB - seqA; // Ordem decrescente por sequência
                    }
                );

                log(
                    "🔄 ORDENAÇÃO: Documentos ordenados por data (mais novo → mais antigo):"
                );
                documentosOrdenados.forEach((doc, i) => {
                    log(
                        `  ${i + 1}. ${doc.eventoDescricao} - ${
                            doc.eventoData || "Sem data"
                        } (Evento ${doc.seqEvento})`
                    );
                });

                // Usar array ordenado para o resto da função
                documentosRelevantes = documentosOrdenados;

                return new Promise((resolve) => {
                    // Remover modal anterior se existir
                    const existing = document.getElementById(
                        "document-selection-modal"
                    );
                    if (existing) {
                        existing.remove();
                    }

                    const modal = document.createElement("div");
                    modal.id = "document-selection-modal";
                    modal.style.cssText = `
                        position: fixed !important;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.8);
                        z-index: 100010;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        backdrop-filter: blur(4px);
                        `;

                    let documentOptions = "";
                    documentosRelevantes.forEach((documento, index) => {
                        const seqEvento = documento.seqEvento
                            ? `Evento ${documento.seqEvento}`
                            : `Documento ${index + 1}`;
                        const tamanhoInfo = documento.tamanho
                            ? ` (${documento.tamanho})`
                            : "";
                        const tipoInfo =
                            documento.tipoDocumento ||
                            TIPOS_DOCUMENTO_RELEVANTE[documento.tipo]
                                ?.descricao ||
                            "DOCUMENTO";
                        const eventoDesc =
                            documento.eventoDescricao || "Documento";

                        log(` DEBUG OPTION ${index + 1}:`, {
                            seqEvento,
                            tipoInfo,
                            eventoDesc,
                            tamanhoInfo,
                            eventoMagistrado: documento.eventoMagistrado, // Debug magistrado
                            magistradoInfo: documento.magistradoInfo, // ✅ NOVO: Debug magistradoInfo estruturado
                            magistradoInfoTipo: documento.magistradoInfo?.tipo, // ✅ Debug específico do tipo
                            magistradoInfoNome: documento.magistradoInfo?.nome, // ✅ Debug específico do nome
                            magistradoInfoVara: documento.magistradoInfo?.vara, // ✅ Debug específico da vara
                            original_eventoDescricao: documento.eventoDescricao,
                        });

                        documentOptions += `
                                <div style="margin-bottom: 12px; padding: 16px; border: 1px solid rgba(82, 82, 82, 0.3); border-radius: 8px; background: rgb(32, 39, 51); cursor: pointer; transition: all 0.2s ease; color: rgb(243, 246, 249);" 
                                class="document-option" data-index="${index}">
                                <div style="font-weight: 600; color: rgb(243, 246, 249); margin-bottom: 8px; display: flex; align-items: center; gap: 8px; font-size: 14px;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; color: rgb(133, 190, 255);">
                                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                                <polyline points="14,2 14,8 20,8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                                <polyline points="10,9 9,9 8,9"/>
                                </svg>
                                ${tipoInfo} - ${seqEvento}
                                </div>
                                <div style="font-size: 12px; color: rgb(136, 152, 181); margin-bottom: 6px; font-weight: 500; display: flex; align-items: center; gap: 8px;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
                                <rect width="8" height="4" x="8" y="2" rx="1" ry="1"/>
                                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                                </svg>
                                ${eventoDesc}
                                </div>
                                <div style="font-size: 12px; color: rgb(136, 152, 181); display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
                                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                                </svg>
                                Documento: ${documento.texto}${tamanhoInfo}
                                </div>${
                                    // ✅ DEBUG: Log direto no modal para diagnosticar
                                    console.log(
                                        `🔍 MODAL DEBUG ${index}: magistradoInfo =`,
                                        documento.magistradoInfo,
                                        `eventoMagistrado =`,
                                        documento.eventoMagistrado
                                    ) ||
                                    // ✅ CONDIÇÃO FLEXÍVEL: Aceitar qualquer magistradoInfo com nome
                                    (documento.magistradoInfo &&
                                        documento.magistradoInfo.nome)
                                        ? `
                                <div style="font-size: 12px; color: rgb(136, 152, 181); opacity: 0.9; display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
                                <path d="M11.5 15H7a4 4 0 0 0-4 4v2"/>
                                <path d="M21.378 16.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a .5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/>
                                <circle cx="10" cy="7" r="4"/>
                                </svg>
                                ${
                                    documento.magistradoInfo.tipo?.toLowerCase() ===
                                    "magistrado"
                                        ? "Magistrado(a)"
                                        : documento.magistradoInfo.tipo?.toLowerCase() ===
                                          "advogado"
                                        ? "Advogado(a)"
                                        : "Usuário"
                                }: ${documento.magistradoInfo.nome}
                                </div>${
                                    // Mostrar vara apenas se existir
                                    documento.magistradoInfo.vara
                                        ? `
            <div style="font-size: 12px; color: rgb(136, 152, 181); opacity: 0.9; display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
            <path d="M10 18v-7"/>
            <path d="M11.12 2.198a2 2 0 0 1 1.76.006l7.866 3.847c.476.233.31.949-.22.949H3.474c-.53 0-.695-.716-.22-.949z"/>
            <path d="M14 18v-7"/>
            <path d="M18 18v-7"/>
            <path d="M3 22h18"/>
            <path d="M6 18v-7"/>
            </svg>
            ${documento.magistradoInfo.vara}
            </div>`
                                        : ""
                                }`
                                        : // FALLBACK: Se não há dados estruturados mas há eventoMagistrado simples
                                        documento.eventoMagistrado
                                        ? `
            <div style="font-size: 12px; color: rgb(136, 152, 181); opacity: 0.9; display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
            <path d="M11.5 15H7a4 4 0 0 0-4 4v2"/>
            <path d="M21.378 16.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/>
            <circle cx="10" cy="7" r="4"/>
            </svg>
            ${documento.eventoMagistrado}
            </div>`
                                        : ""
                                }${
                            documento.eventoData
                                ? `
            <div style="font-size: 12px; color: rgb(136, 152, 181); opacity: 0.9; display: flex; align-items: center; gap: 8px;">
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
            <path d="M15.707 21.293a1 1 0 0 1-1.414 0l-1.586-1.586a1 1 0 0 1 0-1.414l5.586-5.586a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 1 0 1.414z"/>
            <path d="m18 13-1.375-6.874a1 1 0 0 0-.746-.776L3.235 2.028a1 1 0 0 0-1.207 1.207L5.35 15.879a1 1 0 0 0 .776.746L13 18"/>
            <path d="m2.3 2.3 7.286 7.286"/>
            <circle cx="11" cy="11" r="2"/>
            </svg>
            Assinado em ${documento.eventoData}
            </div>`
                                : ""
                        }
            </div>
            `;
                    });

                    modal.innerHTML = `
                                <div style="background: rgb(19, 67, 119); border-radius: 8px; padding: 24px; max-width: 620px; width: 90%; max-height: 80%; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.5); border: 1px solid rgba(82, 82, 82, 0.3);">
                                <div style="margin-bottom: 20px; text-align: center; border-bottom: 1px solid rgba(82, 82, 82, 0.3); padding-bottom: 16px;">
                                <h2 style="margin: 0; color: rgb(243, 246, 249); font-size: 18px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 10px; letter-spacing: -0.025em;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: rgb(133, 190, 255);">
                                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                                <polyline points="14,2 14,8 20,8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                                <polyline points="10,9 9,9 8,9"/>
                                </svg>
                                Múltiplos Documentos Encontrados
                                </h2>
                                <p style="margin: 8px 0 0 0; color: rgb(243, 246, 249); font-size: 13px; font-weight: 400;">
                                Foram encontrados ${documentosRelevantes.length} documentos relevantes neste processo. Selecione qual deseja processar:
                                </p>
                                </div>
                                
                                <div id="document-options" style="margin-bottom: 20px;">
                                ${documentOptions}
                                </div>

                                <div style="text-align: center; padding-top: 16px; border-top: 1px solid rgba(82, 82, 82, 0.3);">
                                <button id="cancel-selection" style="background: rgb(32, 39, 51); color: rgb(243, 246, 249); border: 1px solid rgba(82, 82, 82, 0.5); padding: 12px 16px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 14px; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s ease; min-height: 44px;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="m18 6-12 12"/>
                                <path d="m6 6 12 12"/>
                                </svg>
                                Cancelar
                                </button>
                                </div>
                                </div>
                                `;

                    document.body.appendChild(modal);

                    // Adicionar eventos de clique nas opções
                    modal
                        .querySelectorAll(".document-option")
                        .forEach((option, index) => {
                            option.addEventListener(
                                "mouseover",
                                () => {
                                    option.style.borderColor =
                                        "rgba(19, 67, 119, 0.6)";
                                    option.style.background = "rgb(47, 52, 61)";
                                    option.style.transform = "translateY(-1px)";
                                    option.style.boxShadow =
                                        "0 4px 12px rgba(19, 67, 119, 0.25)";
                                },
                                { passive: true }
                            );

                            option.addEventListener(
                                "mouseout",
                                () => {
                                    option.style.borderColor =
                                        "rgba(82, 82, 82, 0.3)";
                                    option.style.background = "rgb(32, 39, 51)";
                                    option.style.transform = "translateY(0)";
                                    option.style.boxShadow = "none";
                                },
                                { passive: true }
                            );

                            option.addEventListener("click", () => {
                                const selectedIndex = parseInt(
                                    option.getAttribute("data-index")
                                );
                                const selectedDocument =
                                    documentosRelevantes[selectedIndex];

                                log(
                                    ` Documento selecionado: ${selectedDocument.eventoDescricao} - Evento ${selectedDocument.seqEvento}`
                                );
                                showNotification(
                                    ` Documento selecionado: ${selectedDocument.eventoDescricao}`,
                                    "success"
                                );

                                modal.remove();
                                resolve(selectedDocument);
                            });
                        });

                    // Evento do botão cancelar
                    const cancelBtn = modal.querySelector("#cancel-selection");

                    // Adicionar hover vermelho no botão cancelar
                    cancelBtn.addEventListener(
                        "mouseenter",
                        () => {
                            cancelBtn.style.backgroundColor = "#91433d";
                            cancelBtn.style.borderColor = "#91433d";
                        },
                        { passive: true }
                    );

                    cancelBtn.addEventListener(
                        "mouseleave",
                        () => {
                            cancelBtn.style.backgroundColor = "rgb(32, 39, 51)";
                            cancelBtn.style.borderColor =
                                "rgba(82, 82, 82, 0.5)";
                        },
                        { passive: true }
                    );

                    cancelBtn.addEventListener("click", () => {
                        modal.remove();
                        resolve(null);
                    });

                    modal.addEventListener("click", (e) => {
                        if (e.target === modal) {
                            modal.remove();
                            resolve(null);
                        }
                    });
                });
            }

            // Interface melhorada para configuração da API key
            async function showApiKeyConfig() {
                const existing = document.getElementById("api-key-config");
                if (existing) {
                    existing.remove();
                    return;
                }

                const currentKey = localStorage.getItem("perplexity_api_key");

                const modal = document.createElement("div");
                modal.id = "api-key-config";
                modal.className = "eprobe-modal";
                modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 100001;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
            `;

                modal.innerHTML = `
            <div style="background: #134377; border-radius: 12px; padding: 32px; max-width: 560px; width: 90%; box-shadow: 0 12px 40px rgba(0,0,0,0.6); border: 1px solid rgba(255, 255, 255, 0.1);">
            <div style="margin-bottom: 24px; text-align: center; border-bottom: 1px solid rgba(255, 255, 255, 0.15); padding-bottom: 20px;">
            <h2 style="margin: 0; color: rgb(255, 255, 255); font-size: 20px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 12px; letter-spacing: -0.025em;">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgb(133, 190, 255)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="16" r="1"/>
            <rect x="3" y="10" width="18" height="12" rx="2"/>
            <path d="M7 10V7a5 5 0 0 1 10 0v3"/>
            </svg>
            Configurar API Key do Perplexity
            </h2>
            </div>
            
            <div style="margin-bottom: 24px; padding: 20px; background: rgba(32, 39, 51, 0.6); border-radius: 10px; font-size: 14px; line-height: 1.6; color: rgb(255, 255, 255); border: 1px solid rgba(255, 255, 255, 0.1);">
            <div style="margin-bottom: 12px;">
            <strong style="color: rgb(133, 190, 255); font-size: 15px;">Como obter sua API Key do Perplexity:</strong>
            </div>
            <div style="padding-left: 8px; color: rgb(226, 232, 240);">
            <div style="margin-bottom: 8px;">1. Acesse: <a href="https://www.perplexity.ai/settings/api" target="_blank" style="color: rgb(133, 190, 255); text-decoration: underline; font-weight: 500;">www.perplexity.ai/settings/api</a></div>
            <div style="margin-bottom: 8px;">2. Faça login na sua conta Perplexity</div>
            <div style="margin-bottom: 8px;">3. Clique em "Generate" para criar uma nova chave</div>
            <div>4. Copie a chave e cole abaixo</div>
            </div>
            </div>

            <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: rgb(255, 255, 255); font-size: 14px;">API Key:</label>
            <input type="password" id="api-key-input" placeholder="pplx-..." style="width: 100%; padding: 12px 16px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; font-family: 'Roboto', monospace, sans-serif; background: rgba(32, 39, 51, 0.5); color: rgb(255, 255, 255); font-size: 14px; transition: all 0.2s ease; box-sizing: border-box;" value="${
                currentKey || ""
            }" />
            </div>

            <div style="margin-bottom: 24px; padding: 16px; background: rgba(251, 191, 36, 0.15); border: 1px solid rgba(251, 191, 36, 0.4); border-radius: 10px; font-size: 13px; display: flex; align-items: flex-start; gap: 12px; color: rgb(254, 240, 138);">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
            <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
            <path d="M12 9v4"/>
            <path d="m12 17 .01 0"/>
            </svg>
            <span style="line-height: 1.5;"><strong>Privacidade:</strong> Sua API Key é armazenada apenas localmente no seu navegador e não é compartilhada.</span>
            </div>

            <div style="text-align: center; display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
            <button id="save-key" style="background: rgb(133, 190, 255); color: #134377; border: 1px solid rgb(133, 190, 255); padding: 14px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s ease; min-width: 140px; justify-content: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="20,6 9,17 4,12"/>
            </svg>
            Salvar e Testar
            </button>
            <button id="remove-key" style="background: rgb(145, 67, 61); color: white; border: 1px solid rgb(145, 67, 61); padding: 14px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s ease; min-width: 120px; justify-content: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="3,6 5,6 21,6"/>
            <path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"/>
            </svg>
            Remover
            </button>
            <button id="cancel-config" style="background: rgba(255, 255, 255, 0.1); color: rgb(255, 255, 255); border: 1px solid rgba(255, 255, 255, 0.2); padding: 14px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s ease; min-width: 100px; justify-content: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="m18 6-12 12"/>
            <path d="m6 6 12 12"/>
            </svg>
            Cancelar
            </button>
            </div>
            </div>
            `;

                document.body.appendChild(modal);

                const input = modal.querySelector("#api-key-input");
                const saveBtn = modal.querySelector("#save-key");
                const removeBtn = modal.querySelector("#remove-key");
                const cancelBtn = modal.querySelector("#cancel-config");

                // Adicionar eventos de focus/blur para o input
                input.addEventListener("focus", () => {
                    input.style.borderColor = "rgb(19, 67, 119)";
                    input.style.boxShadow = "0 0 0 3px rgba(19, 67, 119, 0.1)";
                });

                input.addEventListener("blur", () => {
                    input.style.borderColor = "rgba(82, 82, 82, 0.5)";
                    input.style.boxShadow = "none";
                });

                input.focus();

                saveBtn.addEventListener("click", async () => {
                    const newKey = input.value.trim();

                    if (!newKey) {
                        showNotification("Digite uma API key", "error");
                        return;
                    }

                    if (!(await validateApiKey(newKey))) {
                        showNotification(
                            "API key inválida. Deve começar com 'pplx-'",
                            "error"
                        );
                        return;
                    }

                    try {
                        await storeApiKey(newKey);
                        modal.remove();

                        showNotification("Testando API key...", "info");

                        const isValid = await testApiKey();
                        if (isValid) {
                            showNotification(
                                "API key configurada e validada!",
                                "success"
                            );
                        } else {
                            showNotification(
                                "API key salva, mas pode não estar funcionando",
                                "warning"
                            );
                        }
                    } catch (error) {
                        showNotification(`Erro: ${error.message}`, "error");
                    }
                });

                removeBtn.addEventListener("click", async () => {
                    await removeStoredApiKey();
                    modal.remove();
                    showNotification("API key removida!", "info");
                });

                // Adicionar eventos de hover para os botões
                saveBtn.addEventListener(
                    "mouseenter",
                    () => {
                        saveBtn.style.backgroundColor = "rgb(107, 170, 255)";
                        saveBtn.style.color = "#134377";
                        saveBtn.style.transform = "translateY(-1px)";
                    },
                    { passive: true }
                );

                saveBtn.addEventListener(
                    "mouseleave",
                    () => {
                        saveBtn.style.backgroundColor = "rgb(133, 190, 255)";
                        saveBtn.style.color = "#134377";
                        saveBtn.style.transform = "translateY(0)";
                    },
                    { passive: true }
                );

                removeBtn.addEventListener(
                    "mouseenter",
                    () => {
                        removeBtn.style.backgroundColor = "rgb(120, 55, 50)";
                        removeBtn.style.transform = "translateY(-1px)";
                    },
                    { passive: true }
                );

                removeBtn.addEventListener(
                    "mouseleave",
                    () => {
                        removeBtn.style.backgroundColor = "rgb(145, 67, 61)";
                        removeBtn.style.transform = "translateY(0)";
                    },
                    { passive: true }
                );

                // Adicionar hover para o botão cancelar
                cancelBtn.addEventListener(
                    "mouseenter",
                    () => {
                        cancelBtn.style.backgroundColor =
                            "rgba(255, 255, 255, 0.15)";
                        cancelBtn.style.borderColor =
                            "rgba(255, 255, 255, 0.3)";
                        cancelBtn.style.transform = "translateY(-1px)";
                    },
                    { passive: true }
                );

                cancelBtn.addEventListener(
                    "mouseleave",
                    () => {
                        cancelBtn.style.backgroundColor =
                            "rgba(255, 255, 255, 0.1)";
                        cancelBtn.style.borderColor =
                            "rgba(255, 255, 255, 0.2)";
                        cancelBtn.style.transform = "translateY(0)";
                    },
                    { passive: true }
                );

                cancelBtn.addEventListener("click", () => {
                    modal.remove();
                });

                modal.addEventListener("click", (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });

                input.addEventListener("keypress", (e) => {
                    if (e.key === "Enter") {
                        saveBtn.click();
                    }
                });
            }

            // Função para visualizar logs de erro
            function showErrorLogs() {
                const logs = JSON.parse(
                    localStorage.getItem("eprobe_error_logs") || "[]"
                );

                if (logs.length === 0) {
                    showNotification("Nenhum log de erro encontrado", "info");
                    return;
                }

                const modal = document.createElement("div");
                modal.className = "eprobe-modal";
                modal.style.cssText = `
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background: rgba(0,0,0,0.8);
 z-index: 100002;
 display: flex;
 align-items: center;
 justify-content: center;
 backdrop-filter: blur(4px);
 `;

                modal.innerHTML = `
 <div style="background: rgb(19, 67, 119); border-radius: 8px; padding: 24px; max-width: 80%; max-height: 80%; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.5); border: 1px solid rgba(82, 82, 82, 0.3);">
 <div style="margin-bottom: 20px; text-align: center; border-bottom: 1px solid rgba(82, 82, 82, 0.3); padding-bottom: 16px;">
 <h2 style="margin: 0; color: rgb(243, 246, 249); font-size: 18px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 10px; letter-spacing: -0.025em;">
 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: rgb(19, 67, 119);">
 <circle cx="11" cy="11" r="8"/>
 <path d="m21 21-4.35-4.35"/>
 </svg>
 Logs de Erro da API
 </h2>
 <button id="clear-logs" style="background: rgb(220, 38, 38); color: white; border: 1px solid rgb(220, 38, 38); padding: 8px 12px; border-radius: 6px; cursor: pointer; margin-top: 12px; display: inline-flex; align-items: center; gap: 6px; font-size: 12px; font-weight: 500; transition: all 0.2s ease;">
 <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <polyline points="3,6 5,6 21,6"/>
 <path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"/>
 </svg>
 Limpar Logs
 </button>
 </div>
 <div style="font-family: 'Roboto', monospace, sans-serif; font-size: 12px; line-height: 1.4; color: rgb(243, 246, 249);">
 ${logs
     .map(
         (log, i) => `
 <div style="margin-bottom: 16px; padding: 12px; border: 1px solid rgba(82, 82, 82, 0.3); border-radius: 8px; background: rgb(32, 39, 51);">
 <strong style="color: rgb(19, 67, 119);">Log ${i + 1} - ${
             log.timestamp
         }</strong><br>
 <strong style="color: rgb(136, 152, 181);">Request ID:</strong> <span style="color: rgb(243, 246, 249);">${
     log.requestId
 }</span><br>
 <strong style="color: rgb(136, 152, 181);">Phase:</strong> <span style="color: rgb(243, 246, 249);">${
     log.phase
 }</span><br>
 <strong style="color: rgb(136, 152, 181);">Data:</strong><br>
 <pre style="background: rgb(18, 26, 39); padding: 10px; border-radius: 6px; overflow-x: auto; white-space: pre-wrap; color: rgb(243, 246, 249); border: 1px solid rgba(82, 82, 82, 0.2); margin-top: 8px;">${JSON.stringify(
     log.data,
     null,
     2
 )}</pre>
 </div>
 `
     )
     .join("")}
 </div>
 <div style="text-align: center; margin-top: 20px; padding-top: 16px; border-top: 1px solid rgba(82, 82, 82, 0.3);">
 <button id="close-logs" style="background: rgb(32, 39, 51); color: rgb(243, 246, 249); border: 1px solid rgba(82, 82, 82, 0.5); padding: 12px 16px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 14px; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s ease;">
 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <path d="m18 6-12 12"/>
 <path d="m6 6 12 12"/>
 </svg>
 Fechar
 </button>
 </div>
 </div>
 `;

                document.body.appendChild(modal);

                modal
                    .querySelector("#close-logs")
                    .addEventListener("click", () => {
                        modal.remove();
                    });

                modal
                    .querySelector("#clear-logs")
                    .addEventListener("click", () => {
                        localStorage.removeItem("eprobe_error_logs");
                        modal.remove();
                        showNotification("Logs de erro limpos", "info");
                    });

                modal.addEventListener("click", (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            // Mostrar informações sobre quota da API
            function showApiQuotaInfo() {
                const modal = document.createElement("div");
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    z-index: 100003;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    `;

                modal.innerHTML = `
                    <div style="background: white; border-radius: 10px; padding: 30px; max-width: 500px; width: 90%; box-shadow: 0 10px 25px rgba(0,0,0,0.3);">
                    <div style="margin-bottom: 20px; text-align: center;">
                    <h2 style="margin: 0; color: #dc3545; font-size: 20px;"> Créditos da API Esgotados</h2>
                    </div>
                    
                    <div style="margin-bottom: 20px; font-size: 14px; line-height: 1.6;">
                    <p><strong>Sua API key do Perplexity não possui créditos suficientes.</strong></p>
                    
                    <p><strong>Para resolver:</strong></p>
                    <ol>
                    <li>Acesse: <a href="https://www.perplexity.ai/settings/api" target="_blank" style="color: #134377;">perplexity.ai/settings/api</a></li>
                    <li>Verifique seus créditos e limites</li>
                    <li>Se necessário, adicione créditos à sua conta</li>
                    <li>Ou aguarde a renovação dos créditos</li>
                    </ol>
                    
                    <p><strong>Alternativa:</strong> Use o método manual que copia o texto para você colar em Perplexity web.</p>
                    </div>

                    <div style="text-align: center;">
                    <button id="open-billing" style="background: #134377; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin-right: 10px; cursor: pointer; font-weight: bold;">
                    Abrir Configurações
                    </button>
                    <button id="config-new-key" style="background: #134377; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin-right: 10px; cursor: pointer; font-weight: bold;">
                    Nova API Key
                    </button>
                    <button id="close-quota-info" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">
                    Fechar
                    </button>
                    </div>
                    </div>
                    `;

                document.body.appendChild(modal);

                modal
                    .querySelector("#open-billing")
                    .addEventListener("click", () => {
                        window.open(
                            "https://www.perplexity.ai/settings/api",
                            "_blank"
                        );
                        modal.remove();
                    });

                modal
                    .querySelector("#config-new-key")
                    .addEventListener("click", () => {
                        modal.remove();
                        showApiKeyConfig();
                    });

                modal
                    .querySelector("#close-quota-info")
                    .addEventListener("click", () => {
                        modal.remove();
                    });

                modal.addEventListener("click", (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            // Mostrar opções de processamento para página de lista com múltiplas sentenças
            async function showSentenceProcessingOptions() {
                const documentosRelevantes = findDocumentosRelevantes();

                if (documentosRelevantes.length === 0) {
                    showNotification("Nenhuma sentença encontrada", "error");
                    return;
                }

                if (documentosRelevantes.length === 1) {
                    // Apenas uma sentença, abrir diretamente
                    await autoOpenDocumentoRelevante();
                    return;
                }

                // Múltiplas sentenças, mostrar opções
                const selectedDocument = await showDocumentSelectionModal(
                    documentosRelevantes
                );

                if (!selectedDocument) {
                    return; // Usuário cancelou
                }

                // Perguntar o que fazer com o documento selecionado
                const processChoice = await showDocumentProcessingModal();

                if (processChoice) {
                    // Abrir o documento selecionado
                    log(
                        " Abrindo documento selecionado:",
                        selectedDocument.href
                    );
                    showNotification(
                        " Abrindo documento selecionado...",
                        "info"
                    );
                    window.open(selectedDocument.href, "_blank");
                } else {
                    // Processar diretamente via API (funcionalidade experimental)
                    showNotification(
                        " Processamento direto via API ainda não implementado. Abrindo documento...",
                        "warning"
                    );
                    window.open(selectedDocument.href, "_blank");
                }
            }

            // Debug completo da estrutura HTML ao redor do link SENT1
            function debugEventStructure(linkElement) {
                log(" === DEBUG ESTRUTURA HTML ===");

                // 1. Informações sobre o próprio link
                log(" Link SENT1:");
                log(` Texto: "${linkElement.textContent.trim()}"`);
                log(` Classes: "${linkElement.className}"`);
                log(` Atributos:`, {
                    href: linkElement.getAttribute("href"),
                    onclick: linkElement.getAttribute("onclick"),
                    onmouseover: linkElement.getAttribute("onmouseover"),
                    "data-nome": linkElement.getAttribute("data-nome"),
                    "data-id": linkElement.getAttribute("data-id"),
                });

                // 2. Analisar a linha (tr) que contém o link
                const currentRow = linkElement.closest("tr");
                if (currentRow) {
                    log(" Linha atual (TR):");
                    log(` Classes da linha: "${currentRow.className}"`);

                    const cells = currentRow.querySelectorAll("td");
                    log(` Total de células: ${cells.length}`);

                    cells.forEach((cell, index) => {
                        const text = cell.textContent.trim();
                        log(
                            ` Célula ${index}: "${text}" (classes: "${cell.className}")`
                        );

                        // Verificar se tem elementos filhos interessantes
                        const labels = cell.querySelectorAll("label");
                        const spans = cell.querySelectorAll("span");
                        const divs = cell.querySelectorAll("div");

                        if (labels.length > 0) {
                            labels.forEach((label, i) => {
                                log(
                                    ` Label ${i}: "${label.textContent.trim()}" (classes: "${
                                        label.className
                                    }")`
                                );
                            });
                        }
                        if (spans.length > 0) {
                            spans.forEach((span, i) => {
                                log(
                                    ` Span ${i}: "${span.textContent.trim()}" (classes: "${
                                        span.className
                                    }")`
                                );
                            });
                        }
                        if (divs.length > 0) {
                            divs.forEach((div, i) => {
                                log(
                                    ` Div ${i}: "${div.textContent.trim()}" (classes: "${
                                        div.className
                                    }")`
                                );
                            });
                        }
                    });
                }

                // 3. Analisar linhas anteriores
                log(" Linhas anteriores:");
                let prevRow = currentRow?.previousElementSibling;
                let rowCount = 0;
                while (prevRow && rowCount < 3) {
                    rowCount++;
                    const prevCells = prevRow.querySelectorAll("td");
                    log(
                        ` Linha anterior ${rowCount}: ${prevCells.length} células`
                    );

                    prevCells.forEach((cell, index) => {
                        const text = cell.textContent.trim();
                        if (text.length > 10) {
                            log(
                                ` Célula ${index}: "${text.substring(
                                    0,
                                    100
                                )}..."`
                            );
                        }
                    });

                    prevRow = prevRow.previousElementSibling;
                }

                // 4. Analisar a tabela completa
                const table = linkElement.closest("table");
                if (table) {
                    log(" Tabela:");
                    log(` Classes da tabela: "${table.className}"`);
                    log(` ID da tabela: "${table.id}"`);

                    // Procurar por cabeçalhos
                    const headers = table.querySelectorAll("th");
                    if (headers.length > 0) {
                        log(" Cabeçalhos encontrados:");
                        headers.forEach((header, index) => {
                            log(
                                ` Header ${index}: "${header.textContent.trim()}"`
                            );
                        });
                    }
                }

                log(" === FIM DEBUG ESTRUTURA ===");
            }

            // Função aprimorada para encontrar descrição do evento
            function findEventDescription(linkElement) {
                const strategies = [
                    () => findEventDescriptionInSameRow(linkElement),
                    () => findEventDescriptionInPreviousRows(linkElement),
                    () => findEventDescriptionByTextPattern(linkElement),
                    () => findEventDescriptionInTableStructure(linkElement),
                    () => findEventDescriptionByProximity(linkElement),
                ];

                for (let i = 0; i < strategies.length; i++) {
                    try {
                        log(`Executando estratégia ${i + 1} para descrição...`);
                        const result = strategies[i]();
                        if (result && result.trim().length > 3) {
                            log(`Estratégia ${i + 1} bem-sucedida:`, result);
                            return result.trim();
                        }
                    } catch (e) {
                        log(`Erro na estratégia ${i + 1}:`, e);
                    }
                }

                log("Nenhuma estratégia encontrou descrição válida");
                return "";
            }

            // Estratégia 1: Buscar na mesma linha do link
            function findEventDescriptionInSameRow(linkElement) {
                const currentRow = linkElement.closest("tr");
                if (!currentRow) return "";

                log("Buscando na linha atual...");

                // Buscar por seletores conhecidos
                const selectors = [
                    "td.infraEventoDescricao",
                    "label.infraEventoDescricao",
                    "td[class*='evento'][class*='descricao']",
                    "td[class*='Evento'][class*='Descricao']",
                ];

                for (const selector of selectors) {
                    const element = currentRow.querySelector(selector);
                    if (element) {
                        const text = element.textContent.trim();
                        if (text && !text.toLowerCase().includes("sent")) {
                            log(`Encontrado via seletor ${selector}:`, text);
                            return text;
                        }
                    }
                }

                return "";
            }

            // Estratégia 2: Buscar em linhas anteriores (evento pode estar em linha separada)
            function findEventDescriptionInPreviousRows(linkElement) {
                const currentRow = linkElement.closest("tr");
                if (!currentRow) return "";

                log("Buscando em linhas anteriores...");

                let previousRow = currentRow.previousElementSibling;
                let attempts = 0;

                while (previousRow && attempts < 10) {
                    attempts++;

                    // Verificar se esta linha contém descrição de evento
                    const eventDescSelectors = [
                        "td.infraEventoDescricao",
                        "label.infraEventoDescricao",
                        "td[class*='evento']",
                        "td[class*='Evento']",
                    ];

                    for (const selector of eventDescSelectors) {
                        const element = previousRow.querySelector(selector);
                        if (element) {
                            const text = element.textContent.trim();
                            if (
                                text &&
                                text.length > 5 &&
                                !text.toLowerCase().includes("sent")
                            ) {
                                log(
                                    `Encontrado em linha anterior (${attempts}):`,
                                    text
                                );
                                return text;
                            }
                        }
                    }

                    previousRow = previousRow.previousElementSibling;
                }

                return "";
            }

            // Estratégia 3: Buscar por padrões de texto típicos de descrição de evento
            function findEventDescriptionByTextPattern(linkElement) {
                const currentRow = linkElement.closest("tr");
                if (!currentRow) return "";

                log("Buscando por padrões de texto...");

                // Expandir busca para linhas próximas
                const rowsToCheck = [];

                // Adicionar linha atual
                rowsToCheck.push(currentRow);

                // Adicionar linhas anteriores
                let prevRow = currentRow.previousElementSibling;
                for (let i = 0; i < 5 && prevRow; i++) {
                    rowsToCheck.unshift(prevRow);
                    prevRow = prevRow.previousElementSibling;
                }

                // Adicionar linhas posteriores
                let nextRow = currentRow.nextElementSibling;
                for (let i = 0; i < 2 && nextRow; i++) {
                    rowsToCheck.push(nextRow);
                    nextRow = nextRow.nextElementSibling;
                }

                // Padrões que indicam descrição de evento judicial
                const eventPatterns = [
                    /julgamento/i,
                    /decisão/i,
                    /sentença/i,
                    /prolação/i,
                    /publicação/i,
                    /audiência/i,
                    /despacho/i,
                    /determinação/i,
                    /intimação/i,
                    /citação/i,
                    /distribuição/i,
                    /remessa/i,
                    /devolução/i,
                    /conclusão/i,
                ];

                for (const row of rowsToCheck) {
                    const cells = row.querySelectorAll("td");
                    for (const cell of cells) {
                        const text = cell.textContent.trim();

                        // Verificar se o texto tem tamanho razoável e contém padrões de evento
                        if (text.length > 10 && text.length < 200) {
                            for (const pattern of eventPatterns) {
                                if (
                                    pattern.test(text) &&
                                    !text.toLowerCase().includes("sent1")
                                ) {
                                    log(
                                        `Encontrado por padrão "${pattern}":`,
                                        text
                                    );
                                    return text;
                                }
                            }
                        }
                    }
                }

                return "";
            }

            // Estratégia 4: Analisar estrutura da tabela para encontrar coluna de descrição
            function findEventDescriptionInTableStructure(linkElement) {
                const table = linkElement.closest("table");
                if (!table) return "";

                log("Analisando estrutura da tabela...");

                const currentRow = linkElement.closest("tr");
                const linkCellIndex = Array.from(currentRow.cells).findIndex(
                    (cell) => cell.contains(linkElement)
                );

                // Buscar na mesma linha, mas em células que podem conter descrição
                for (let i = 0; i < currentRow.cells.length; i++) {
                    if (i === linkCellIndex) continue; // Pular célula do link

                    const cell = currentRow.cells[i];
                    const text = cell.textContent.trim();

                    // Verificar se parece uma descrição (texto médio, não apenas números/datas)
                    if (text.length > 15 && text.length < 150) {
                        // Verificar se não é apenas data, números ou links
                        if (
                            !/^\d+[\d\/\-\s]*$/.test(text) &&
                            !text.toLowerCase().includes("sent") &&
                            !/^https?:\/\//.test(text)
                        ) {
                            log(
                                `Encontrado na estrutura da tabela (célula ${i}):`,
                                text
                            );
                            return text;
                        }
                    }
                }

                return "";
            }

            // Estratégia 5: Buscar por proximidade usando XPath-like logic
            function findEventDescriptionByProximity(linkElement) {
                log("Buscando por proximidade...");

                // Buscar elementos próximos que podem conter descrição
                const parent =
                    linkElement.closest("td") || linkElement.closest("tr");
                if (!parent) return "";

                // Buscar em elementos irmãos
                const siblings = parent.parentElement
                    ? Array.from(parent.parentElement.children)
                    : [];

                for (const sibling of siblings) {
                    if (sibling === parent) continue;

                    const text = sibling.textContent.trim();
                    if (
                        text.length > 20 &&
                        text.length < 200 &&
                        !text.toLowerCase().includes("sent") &&
                        !/^\d+[\d\/\-\s]*$/.test(text)
                    ) {
                        // Verificar se contém palavras típicas de processo judicial
                        if (
                            /julgamento|decisão|sentença|audiência|despacho|intimação|publicação|prolação/i.test(
                                text
                            )
                        ) {
                            log(`Encontrado por proximidade:`, text);
                            return text;
                        }
                    }
                }

                return "";
            }

            // Observador de mudanças na página - VERSÃO ULTRA-ROBUSTA
            function setupPageObserver() {
                let lastUrl = window.location.href;
                let isProcessing = false;
                let processingTimeout = null;

                // Observador super otimizado com debouncing
                const observer = new MutationObserver((mutations) => {
                    // Throttling aprimorado: cancelar timeout anterior se existir
                    if (processingTimeout) {
                        clearTimeout(processingTimeout);
                    }

                    if (isProcessing) return;
                    isProcessing = true;

                    // Usar requestIdleCallback se disponível, senão requestAnimationFrame
                    const scheduleWork = (callback) => {
                        if (window.requestIdleCallback) {
                            requestIdleCallback(callback, { timeout: 100 });
                        } else {
                            requestAnimationFrame(callback);
                        }
                    };

                    scheduleWork(() => {
                        const currentUrl = window.location.href;

                        // Verificar se a URL mudou (navegação SPA)
                        if (currentUrl !== lastUrl) {
                            log("🌐 NAVEGAÇÃO: URL mudou para:", currentUrl);
                            lastUrl = currentUrl;

                            // Reset contador de tentativas para nova página
                            buttonCreationAttempts = 0;

                            // Garantir que o botão existe após navegação
                            setTimeout(() => {
                                ensureButtonExists();
                            }, 300);
                        }

                        // Verificar se botão foi removido com delay otimizado
                        processingTimeout = setTimeout(() => {
                            // Usar sistema robusto para verificar e criar botão
                            ensureButtonExists();

                            // Reset processing flag
                            isProcessing = false;
                            processingTimeout = null;
                        }, 400);
                    });
                });

                // Configurar observador com configuração ultra-otimizada
                observer.observe(document.body, {
                    childList: true,
                    subtree: false, // Evitar observação profunda
                    attributes: false, // Não observar mudanças de atributos
                    characterData: false, // Não observar mudanças de texto
                    attributeOldValue: false,
                    characterDataOldValue: false,
                });

                log(
                    "✅ PAGE OBSERVER: Configurado com sistema robusto de botão"
                );
            }

            // Inicialização
            // Inicialização - REABILITADA criação de botões com proteção da navbar
            function init() {
                log(" Iniciando content script automatizado");
                log(" Resumir Documento: Script iniciado");

                // Configurar observador de página (VERSÃO REABILITADA - criação de botões segura)
                setupPageObserver();

                log(
                    "ℹ️ INIT: Criação automática de botões REABILITADA de forma segura"
                );

                // Criar botão inicial com sistema robusto
                setTimeout(() => {
                    ensureButtonExists();
                }, 400);

                // Segunda tentativa (caso a primeira falhe)
                setTimeout(() => {
                    ensureButtonExists();
                }, 1000);

                // Terceira tentativa (para páginas que demoram para carregar)
                setTimeout(() => {
                    ensureButtonExists();
                }, 2000);

                // ✅ VERIFICAÇÃO: Evitar loop infinito - só detectar se não foi processado
                processoAtual = obterNumeroProcesso(); // Obter processo atual antes das verificações
                if (processoAtual && processoJaFoiProcessado(processoAtual)) {
                    log(
                        `🔐 SKIP: Processo ${processoAtual} já foi processado nesta sessão`
                    );
                    return;
                }

                // Detecção de data da sessão otimizada
                setTimeout(() => {
                    if (
                        !processoAtual ||
                        !processoJaFoiProcessado(processoAtual)
                    ) {
                        log(
                            "🔍 Tentando detectar data da sessão automaticamente..."
                        );
                        if (
                            window.SENT1_AUTO &&
                            window.SENT1_AUTO.detectarCardSessaoSimplificado
                        ) {
                            window.SENT1_AUTO.detectarCardSessaoSimplificado();
                        }
                    }
                }, 500); // Reduzido de 800ms para 500ms

                // Segunda tentativa de detecção otimizada
                setTimeout(() => {
                    if (
                        !hasDataSessaoPautado() &&
                        (!processoAtual ||
                            !processoJaFoiProcessado(processoAtual))
                    ) {
                        log(
                            "🔍 Segunda tentativa de detecção da data da sessão..."
                        );
                        if (
                            window.SENT1_AUTO &&
                            window.SENT1_AUTO.detectarCardSessaoSimplificado
                        ) {
                            window.SENT1_AUTO.detectarCardSessaoSimplificado();
                        }
                    }
                }, 1500); // Reduzido de 2000ms para 1500ms

                // ️ INTEGRAÇÃO AUTOMÁTICA DESABILITADA - Prevenindo logout por excesso de requisições
                setTimeout(async () => {
                    if (hasDataSessaoPautado()) {
                        log(
                            "ℹ️ CRUZAMENTO: Modo automático desabilitado para prevenir logout"
                        );
                        log(
                            "💡 Use window.SENT1_AUTO.cruzarDadosDataSessao() para busca manual"
                        );
                    }
                }, 6000);

                // ⚠️ TENTATIVA FINAL TAMBÉM DESABILITADA
                setTimeout(async () => {
                    if (
                        hasDataSessaoPautado() &&
                        !hasDadosCompletosSessionJulgamento()
                    ) {
                        log(
                            "ℹ️ CRUZAMENTO: Tentativa final desabilitada - use modo manual"
                        );
                        log(
                            "🔧 Execute: window.SENT1_AUTO.debugPaginaSessoes() para investigar"
                        );
                    }
                }, 10000);

                // 📋 DETECÇÃO E PROCESSAMENTO DA PÁGINA DE LOCALIZADORES (MANTIDA - não interfere na navbar)
                setTimeout(() => {
                    detectarPaginaLocalizadores();
                }, 1000);
            }

            // Função de debug para verificar status dos localizadores
            function debugLocalizadores() {
                const currentUrl = window.location.href;
                const isLocalizadoresPage = currentUrl.includes(
                    "acao=usuario_tipo_monitoramento_localizador_listar"
                );
                const tabela = document.querySelector(
                    'table.infraTable[summary*="Localizadores"]'
                );
                const toolbar = document.getElementById(
                    "eprobe-separadores-toolbar"
                );

                console.log("🐛 DEBUG LOCALIZADORES:", {
                    url: currentUrl,
                    isLocalizadoresPage: isLocalizadoresPage,
                    tabelaEncontrada: !!tabela,
                    toolbarCriado: !!toolbar,
                    urlPattern:
                        "acao=usuario_tipo_monitoramento_localizador_listar",
                    numeroLinhas: tabela
                        ? tabela.querySelectorAll(
                              "tbody tr:not(.eprobe-divisor-linha)"
                          ).length
                        : 0,
                });

                if (!isLocalizadoresPage) {
                    console.log("⚠️ Não está na página de localizadores");
                } else {
                    console.log("✅ Está na página de localizadores");
                    if (tabela) {
                        console.log(
                            "✅ Tabela encontrada - forçando reprocessamento"
                        );
                        // Forçar re-processamento
                        processarTabelaLocalizadores();
                    } else {
                        console.log("❌ Tabela não encontrada");
                    }
                }

                return {
                    isLocalizadoresPage,
                    tabelaEncontrada: !!tabela,
                    toolbarCriado: !!toolbar,
                };
            }

            // 🧪 Função de teste específica para separadores
            function testarSeparadoresHover() {
                log(
                    "🧪 TESTE SEPARADORES: Iniciando teste do hover dos botões..."
                );

                const separadores = document.querySelectorAll(
                    ".eprobe-container-hover"
                );
                log(
                    `📊 SEPARADORES: Encontrados ${separadores.length} separadores`
                );

                separadores.forEach((separador, index) => {
                    const botaoRemover = separador.querySelector(
                        ".eprobe-remove-button"
                    );
                    const titulo = separador.querySelector(
                        'span[contentEditable="true"]'
                    );

                    log(`🔍 SEPARADOR ${index + 1}:`, {
                        temBotao: !!botaoRemover,
                        temTitulo: !!titulo,
                        tituloTexto: titulo?.textContent,
                        botaoOpacidade: botaoRemover?.style.opacity,
                        botaoOpacidadeComputada: botaoRemover
                            ? window.getComputedStyle(botaoRemover).opacity
                            : "N/A",
                        posicionamento: {
                            position: botaoRemover?.style.position,
                            marginLeft: botaoRemover?.style.marginLeft,
                            display: botaoRemover?.style.display,
                        },
                    });
                });

                // Simular hover no primeiro separador para teste
                if (separadores.length > 0) {
                    const primeiroSeparador = separadores[0];
                    log("✨ TESTE: Simulando hover no primeiro separador...");

                    // Trigger mouseenter event
                    const event = new MouseEvent("mouseenter", {
                        bubbles: true,
                    });
                    primeiroSeparador.dispatchEvent(event);

                    setTimeout(() => {
                        const botao = primeiroSeparador.querySelector(
                            ".eprobe-remove-button"
                        );
                        log(
                            `📊 APÓS HOVER: Botão opacidade inline = ${
                                botao?.style.opacity || "não definido"
                            }`
                        );
                        log(
                            `📊 APÓS HOVER: Botão opacidade computada = ${
                                botao
                                    ? window.getComputedStyle(botao).opacity
                                    : "N/A"
                            }`
                        );

                        // Trigger mouseleave para voltar ao normal
                        const leaveEvent = new MouseEvent("mouseleave", {
                            bubbles: true,
                        });
                        primeiroSeparador.dispatchEvent(leaveEvent);
                    }, 100);
                }

                return separadores.length;
            }

            // 🔧 Função para forçar correção da visibilidade dos botões de remover
            function corrigirVisibilidadeBotoes() {
                log("🔧 CORREÇÃO: Forçando visibilidade correta dos botões...");

                const botoes = document.querySelectorAll(
                    ".eprobe-remove-button"
                );
                botoes.forEach((botao, index) => {
                    // Remover qualquer opacity inline que possa estar conflitando
                    botao.style.removeProperty("opacity");

                    log(`🔧 BOTÃO ${index + 1}: Opacity inline removida`);
                    log(
                        `   Opacity computada atual: ${
                            window.getComputedStyle(botao).opacity
                        }`
                    );
                });

                return botoes.length;
            }

            // 🎨 FUNÇÕES REUTILIZÁVEIS DE INTERFACE

            // Função para criar botão com estilo eProc elegante e discreto
            function criarBotaoEleganteeProc(id, className = "col-auto mr-2") {
                const botao = document.createElement("div");
                botao.id = id;
                botao.className = className;

                // Estilo base elegante (inspirado no eprobe-data-sessao)
                botao.style.cssText = `
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            border: 1px solid #d1d5db;
            padding: 8px 12px;
            border-radius: 4px;
            background-color: #f8fafc;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
            cursor: pointer;
            white-space: nowrap;
            max-width: fit-content;
        `;

                // Adicionar efeitos hover discretos e elegantes
                botao.addEventListener(
                    "mouseenter",
                    function () {
                        this.style.backgroundColor = "#fafbfc";
                        this.style.borderColor = "#e2e8f0";
                        this.style.boxShadow =
                            "0 2px 4px 0 rgba(0, 0, 0, 0.04)";
                    },
                    { passive: true }
                );

                botao.addEventListener(
                    "mouseleave",
                    function () {
                        this.style.backgroundColor = "#f8fafc";
                        this.style.borderColor = "#d1d5db";
                        this.style.boxShadow =
                            "0 1px 2px 0 rgba(0, 0, 0, 0.05)";
                    },
                    { passive: true }
                );

                return botao;
            }

            // Função específica para criar botão branco capa do processo (alias mais descritivo)
            function botaoBrancoCapaProcesso(id, className = "col-auto mr-2") {
                return criarBotaoEleganteeProc(id, className);
            }

            // Função para criar botão infraButton btn-primary com estilo eProc
            function criarInfraButtonPrimary(id, innerHTML) {
                const button = document.createElement("button");
                button.id = id;
                button.className = "infraButton btn-primary";
                button.style.marginRight = "3px !important";

                // Conteúdo do botão (HTML interno)
                if (innerHTML) {
                    button.innerHTML = innerHTML;
                }

                // 🎯 SOLUÇÃO: Verificar tema ativo antes de aplicar cor
                let temaCor = "#134377"; // Cor padrão azul eProbe

                try {
                    // Tentar pegar tema salvo do localStorage
                    const temaSalvo = localStorage.getItem(
                        "eprobe_tema_botoes_eproc"
                    );
                    if (temaSalvo && TEMAS_BOTOES_EPROC[temaSalvo]) {
                        temaCor = TEMAS_BOTOES_EPROC[temaSalvo].backgroundColor;
                        log(
                            `🎨 BOTÃO: Usando cor do tema ${temaSalvo}: ${temaCor}`
                        );
                    }
                } catch (e) {
                    log(
                        "⚠️ BOTÃO: Erro ao verificar tema salvo, usando azul padrão"
                    );
                }

                // Aplicar cor baseada no tema ativo
                button.style.backgroundColor = temaCor;
                button.style.borderColor = temaCor;

                // FORÇAR aplicação do margin-right no SVG
                setTimeout(() => {
                    const svg = button.querySelector("svg");
                    if (svg) {
                        svg.style.marginRight = "4px";
                        svg.style.setProperty(
                            "margin-right",
                            "4px",
                            "important"
                        );
                        log(
                            "✅ FUNÇÃO CENTRAL: Margin-right aplicado automaticamente ao SVG:",
                            svg.style.marginRight
                        );
                    }
                }, 50);

                // 🎯 EVENTOS HOVER DINÂMICOS baseados na cor do tema
                const corHover =
                    temaCor === "#134377" ? "rgb(19, 67, 119)" : temaCor; // Se azul, usar hover mais escuro

                // Adicionar eventos para hover, focus e blur (otimizados para performance)
                button.addEventListener(
                    "mouseenter",
                    () => {
                        button.style.backgroundColor = corHover;
                        button.style.borderColor = corHover;
                    },
                    { passive: true }
                );

                button.addEventListener(
                    "mouseleave",
                    () => {
                        button.style.backgroundColor = temaCor;
                        button.style.borderColor = temaCor;
                    },
                    { passive: true }
                );

                button.addEventListener("focus", () => {
                    button.style.backgroundColor = corHover;
                    button.style.borderColor = corHover;
                });

                button.addEventListener("blur", () => {
                    button.style.backgroundColor = temaCor;
                    button.style.borderColor = temaCor;
                });

                return button;
            }

            // Função específica para criar botão azul eProc (alias mais descritivo)
            function botaoAzuleProc(id, innerHTML) {
                return criarInfraButtonPrimary(id, innerHTML);
            }

            // FUNÇÃO REMOVIDA: detectarDataSessaoExperimental - substituída por detectarCardSessaoSimplificado ÚNICA

            // Inicializar - VERSÃO SEGURA (sem interferência na navbar)
            init();

            // Função de teste Material Base Layout
            function testarMaterialBaseLayout() {
                try {
                    // Buscar elementos com IDs específicos das minutas
                    const minutasIds = [
                        "conteudoInternoMinutas_0",
                        "conteudoInternoMinutas_1",
                        "conteudoInternoMinutas_2",
                        "conteudoInternoMinutas_3",
                    ];

                    log("🔍 Procurando elementos de minutas:");
                    let encontrados = 0;
                    minutasIds.forEach((id) => {
                        const element = document.getElementById(id);
                        if (element) {
                            log(`✅ Encontrado: ${id}`, element);
                            log(`   - Display: ${element.style.display}`);
                            log(
                                `   - Visible: ${element.offsetParent !== null}`
                            );
                            encontrados++;
                        } else {
                            logError(`❌ Não encontrado: ${id}`);
                        }
                    });

                    // Buscar elementos com onclick
                    const elementsWithOnclick = document.querySelectorAll(
                        '[onclick*="infraAbrirFecharElementoHTML"]'
                    );
                    log(
                        `📊 Encontrados ${elementsWithOnclick.length} elementos com onclick`
                    );

                    // Buscar containers substituídos
                    const containers =
                        document.querySelectorAll("div[data-expanded]");
                    log(
                        `📊 Encontrados ${containers.length} containers com data-expanded`
                    );

                    // Criar card Material Base - versão segura
                    let card = null;
                    if (
                        typeof window.SENT1_AUTO?.criarCardSessaoMaterial ===
                        "function"
                    ) {
                        card =
                            window.SENT1_AUTO.criarCardSessaoMaterial(
                                dadosTeste
                            );
                    } else if (typeof criarCardSessaoMaterial === "function") {
                        card = criarCardSessaoMaterial(dadosTeste);
                    } else {
                        console.warn(
                            "⚠️ TESTE: criarCardSessaoMaterial não disponível"
                        );
                        return {
                            erro: "Função não disponível",
                            disponivel: false,
                        };
                    }

                    if (!card) {
                        console.warn("⚠️ TESTE: Card não foi criado");
                        return { erro: "Card não criado", disponivel: false };
                    }

                    // Verificar especificações CSS
                    const computedStyle = window.getComputedStyle(card);

                    const especificacoes = {
                        width: computedStyle.width,
                        height: computedStyle.height,
                        background: computedStyle.backgroundColor,
                        border: computedStyle.border,
                        borderRadius: computedStyle.borderRadius,
                        boxShadow: computedStyle.boxShadow,
                        display: computedStyle.display,
                        flexDirection: computedStyle.flexDirection,
                        justifyContent: computedStyle.justifyContent,
                        alignItems: computedStyle.alignItems,
                        padding: computedStyle.padding,
                        gap: computedStyle.gap,
                        position: computedStyle.position,
                    };

                    log("📊 ESPECIFICAÇÕES APLICADAS:", especificacoes);

                    // Verificar se atende aos requisitos
                    const conformidade = {
                        dimensoes:
                            especificacoes.width === "225px" &&
                            especificacoes.height === "80px",
                        background:
                            especificacoes.background.includes(
                                "254, 247, 255"
                            ) || especificacoes.background === "#FEF7FF",
                        borderRadius: especificacoes.borderRadius === "12px",
                        flexLayout:
                            especificacoes.display === "flex" &&
                            especificacoes.flexDirection === "column",
                        centralizado:
                            especificacoes.justifyContent === "center" &&
                            especificacoes.alignItems === "center",
                        padding: especificacoes.padding === "10px",
                        gap: especificacoes.gap === "10px",
                    };

                    log("✅ CONFORMIDADE MATERIAL BASE:", conformidade);

                    // Verificar áreas do card
                    const iconArea = card.querySelector(".eprobe-icon-area");
                    const headerArea = card.querySelector(
                        ".eprobe-header-area"
                    );
                    const subheadArea = card.querySelector(
                        ".eprobe-subhead-area"
                    );
                    const dataArea = card.querySelector(".eprobe-data-area");

                    const areas = {
                        icone: !!iconArea,
                        header: !!headerArea ? headerArea.textContent : null,
                        subhead: !!subheadArea ? subheadArea.textContent : null,
                        data: !!dataArea ? dataArea.textContent : null,
                    };

                    log("📐 ÁREAS DO CARD:", areas);

                    return {
                        sucesso: true,
                        layout: "Material Base CSS",
                        especificacoes: especificacoes,
                        conformidade: conformidade,
                        areas: areas,
                        verificacao: {
                            dimensoesCorretas: conformidade.dimensoes,
                            layoutFlexCorreto: conformidade.flexLayout,
                            estilizacaoCorreta:
                                conformidade.background &&
                                conformidade.borderRadius,
                            areasPresentes: Object.values(areas).every(Boolean),
                        },
                    };
                } catch (error) {
                    console.error("❌ ERRO no teste Material Base:", error);
                    return {
                        sucesso: false,
                        erro: error.message,
                    };
                }
            }
            // 🧪 FUNÇÃO DE TESTE XPATH + MATERIAL DESIGN (movida para namespace principal)
            // 🧪 FUNÇÕES DE TESTE SIMPLIFICADO (movidas para namespace principal)
            // 🎨 FUNÇÕES DE ÍCONES (movidas para namespace principal)
            // 🔍 FUNÇÕES DE DIAGNÓSTICO (movidas para namespace principal)
            // 🔧 FUNÇÕES DE DEBUG PARA BOTÃO (movidas para namespace principal)
            // 🌐 FUNÇÕES GLOBAIS PARA DADOS DE SESSÃO (movidas para namespace principal)
            // 🧪 FUNÇÕES DE TESTE (movidas para namespace principal)
            // 🧪 FUNÇÃO DE TESTE PARA CORREÇÃO DO CARD DE SESSÃO (movida para namespace principal)
            // 🚀 FUNÇÃO PARA FORÇAR CRIAÇÃO DE CARD SEM VALIDAÇÕES (movida para namespace principal)
            // 🧪 FUNÇÃO PARA TESTE DE CARD FIGMA EXATO (movida para namespace principal)
            // 🧪 FUNÇÃO DE TESTE PARA ERRO SWITCH RELEVANCIA (movida para namespace principal)
            // 🔧 FUNÇÕES DE DIAGNÓSTICO DE ÍCONES CSS (movidas para namespace principal)
            // 🩺 FUNÇÃO DE DIAGNÓSTICO COMPLETO DO CARD DE SESSÃO (movida para namespace principal)
            // 🔥 FUNÇÕES DE CONTROLE DE PERFORMANCE ULTRA (movidas para namespace principal)
            // 📋 NAMESPACE ESPECÍFICO PARA LOCALIZADORES (movido para namespace principal)
            // ======== TODAS AS FUNÇÕES FORAM MOVIDAS PARA O NAMESPACE PRINCIPAL ========

            // 🧪 EXPOR FUNÇÕES DE TESTE NO NAMESPACE (movidas para namespace principal)

            // ✅ EXPOSIÇÃO GLOBAL DAS FUNÇÕES DE LOCALIZADORES
            // Expor as funções de localizadores globalmente para uso no namespace
            window.detectarPaginaLocalizadores = detectarPaginaLocalizadores;
            window.processarTabelaLocalizadores = processarTabelaLocalizadores;
            window.destacarLocalizadoresUrgentes =
                destacarLocalizadoresUrgentes;

            // ========================================
            // VARIÁVEIS GLOBAIS PARA DADOS DE SESSÃO
            // ========================================

            // ========================================
            // FUNÇÕES GLOBAIS PARA GERENCIAMENTO DOS DADOS
            // ========================================

            /**
             * 🔧 SETUP INTERFACE OBSERVER - Monitora mudanças na interface (OTIMIZADO)
             * Observer unificado com debounce para melhor performance
             */
            function setupInterfaceObserver() {
                log(
                    "🔍 OBSERVER: Configurando observer de interface otimizado"
                );

                // Debounce para evitar múltiplas execuções
                let debounceTimer = null;
                const debounceDelay = 50;

                // Observer otimizado para detectar mudanças nos elementos da interface
                const observer = new MutationObserver((mutations) => {
                    let shouldCheckOverlap = false;
                    let shouldCheckLembretes = false;

                    // Processar mutações de forma mais eficiente
                    for (const mutation of mutations) {
                        // Se elementos foram adicionados ou removidos
                        if (mutation.type === "childList") {
                            for (const node of mutation.addedNodes) {
                                if (node.nodeType === Node.ELEMENT_NODE) {
                                    const id = node.id;
                                    if (
                                        id === "sent1-auto-button" ||
                                        id ===
                                            "documento-relevante-notification" ||
                                        id ===
                                            "documento-relevante-options-menu"
                                    ) {
                                        shouldCheckOverlap = true;
                                    }

                                    // Verificar se é um div.divLembrete
                                    if (
                                        node.classList &&
                                        node.classList.contains("divLembrete")
                                    ) {
                                        shouldCheckLembretes = true;
                                    }

                                    // Verificar elementos filhos também
                                    const lembreteElements =
                                        node.querySelectorAll &&
                                        node.querySelectorAll(
                                            "div.divLembrete"
                                        );
                                    if (
                                        lembreteElements &&
                                        lembreteElements.length > 0
                                    ) {
                                        shouldCheckLembretes = true;
                                    }

                                    if (
                                        shouldCheckOverlap &&
                                        shouldCheckLembretes
                                    )
                                        break;
                                }
                            }
                        }

                        // Se atributos de estilo mudaram
                        if (
                            mutation.type === "attributes" &&
                            mutation.attributeName === "style" &&
                            mutation.target.id &&
                            (mutation.target.id === "sent1-auto-button" ||
                                mutation.target.id ===
                                    "documento-relevante-notification" ||
                                mutation.target.id ===
                                    "documento-relevante-options-menu")
                        ) {
                            shouldCheckOverlap = true;
                        }

                        // Early exit se já encontrou o que precisa
                        if (shouldCheckOverlap && shouldCheckLembretes) break;
                    }

                    // Debounce da verificação de overlap
                    if (
                        shouldCheckOverlap &&
                        typeof preventElementOverlap === "function"
                    ) {
                        if (debounceTimer) clearTimeout(debounceTimer);
                        debounceTimer = setTimeout(
                            preventElementOverlap,
                            debounceDelay
                        );
                    }

                    // Debounce da estilização de lembretes
                    if (
                        shouldCheckLembretes &&
                        typeof estilizarTodosDivLembrete === "function"
                    ) {
                        if (debounceTimer) clearTimeout(debounceTimer);
                        debounceTimer = setTimeout(() => {
                            // ⚡ APLICAÇÃO IMEDIATA - SEM FLASH
                            aplicarEstilizacaoImediataLembretes();

                            const resultado = estilizarTodosDivLembrete();
                            log(
                                "🔄 OBSERVER: Lembretes re-estilizados após mudança no DOM",
                                resultado
                            );

                            // ✨ NOVO: Aplicar também substituição de ícones de lembretes
                            if (
                                typeof substituirIconesLembretes ===
                                    "function" &&
                                isCapaProcessoPage()
                            ) {
                                const iconesSubstituidos =
                                    substituirIconesLembretes();
                                if (iconesSubstituidos > 0) {
                                    log(
                                        `🔄 OBSERVER: ${iconesSubstituidos} ícones de lembretes substituídos após mudança no DOM`
                                    );
                                }
                            } else if (
                                typeof substituirIconesLembretes === "function"
                            ) {
                                log(
                                    "⛔ OBSERVER: Personalização de ícones restrita - página atual não é capa do processo"
                                );
                            }
                        }, debounceDelay + 100); // Pequeno delay adicional para lembretes
                    }
                });

                // Observar mudanças no body
                observer.observe(document.body, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ["style"],
                });

                logCritical(
                    "✅ OBSERVER: Interface observer configurado com sucesso"
                );
                return observer;
            }

            // ========================================
            // 🔍 FUNÇÕES DE DIAGNÓSTICO E CORREÇÃO AUTOMÁTICA
            // ========================================

            /**
             * Diagnóstico completo do estado atual da extensão
             * Verifica se todas as funcionalidades estão operando corretamente
             */
            function diagnosticarCompleto() {
                log(
                    "🔍 DIAGNÓSTICO: Iniciando diagnóstico completo do sistema"
                );

                const diagnostico = {
                    timestamp: new Date().toISOString(),
                    url: window.location.href,
                    pageType: detectPageType(),
                    dadosSessao: {
                        hasDataSessao: hasDataSessaoPautado(),
                        dataSessao: dataSessaoPautado,
                        processoComData: processoComDataSessao,
                        dadosCompletos: hasDadosCompletosSessionJulgamento(),
                    },
                    elementos: {
                        botaoIntegrado: !!document.getElementById(
                            "documento-relevante-auto-button"
                        ),
                        botaoFlutuante:
                            !!document.getElementById("sent1-auto-button"),
                        navbar: !!document.querySelector(".navbar"),
                        minutas: !!document.querySelector("#conteudoMinutas"),
                    },
                    performance: {
                        tentativasCruzamento: tentativasCruzamento,
                        cacheValido: cacheValidoAte > Date.now(),
                        processosProcessados: processosJaProcessados.size,
                        modoUltraPerformance: MODO_ULTRA_PERFORMANCE,
                    },
                    apis: {
                        perplexityKey:
                            !!localStorage.getItem("perplexity_api_key"),
                        requisicoesDesabilitadas:
                            REQUISICOES_AUTOMATICAS_DESABILITADAS,
                    },
                };

                log("📊 DIAGNÓSTICO COMPLETO:", diagnostico);

                // Verificar problemas comuns
                const problemas = [];

                if (
                    !diagnostico.elementos.botaoIntegrado &&
                    !diagnostico.elementos.botaoFlutuante
                ) {
                    problemas.push("Nenhum botão da extensão encontrado");
                }

                if (
                    diagnostico.dadosSessao.hasDataSessao &&
                    !diagnostico.dadosSessao.dadosCompletos
                ) {
                    problemas.push(
                        "Data de sessão detectada mas dados completos não obtidos"
                    );
                }

                if (
                    diagnostico.performance.tentativasCruzamento >=
                    MAX_TENTATIVAS_CRUZAMENTO
                ) {
                    problemas.push(
                        "Máximo de tentativas de cruzamento atingido"
                    );
                }

                if (!diagnostico.apis.perplexityKey) {
                    problemas.push("API key do Perplexity não configurada");
                }

                if (problemas.length > 0) {
                    console.warn("⚠️ PROBLEMAS IDENTIFICADOS:", problemas);
                } else {
                    log("✅ DIAGNÓSTICO: Sistema funcionando corretamente");
                }

                return {
                    ...diagnostico,
                    problemas: problemas,
                    status: problemas.length === 0 ? "OK" : "ATENÇÃO",
                };
            }

            /**
             * Função de correção automática para problemas detectados
             * Tenta resolver os problemas mais comuns automaticamente
             */
            function corrigirProblemas() {
                log("🔧 CORREÇÃO: Iniciando correção automática de problemas");

                const resultadoCorrecao = {
                    timestamp: new Date().toLocaleString("pt-BR"),
                    acoes: [],
                };

                // 1. Tentar criar botão se não existir
                const botaoJaExiste =
                    document.getElementById("eprobe-btn") ||
                    document.getElementById(
                        "documento-relevante-auto-button"
                    ) ||
                    document.getElementById("sent1-auto-button");

                if (!botaoJaExiste) {
                    log("🔘 Criando botão Resumir Documento...");
                    try {
                        ensureButtonExists();
                        const botaoCriado =
                            document.getElementById("eprobe-btn") ||
                            document.getElementById(
                                "documento-relevante-auto-button"
                            ) ||
                            document.getElementById("sent1-auto-button");

                        resultadoCorrecao.acoes.push({
                            acao: "Criação de botão",
                            status: "Tentativa executada",
                            sucesso: botaoCriado !== null,
                            idCriado: botaoCriado ? botaoCriado.id : null,
                        });
                    } catch (error) {
                        console.error("❌ Erro ao criar botão:", error);
                        resultadoCorrecao.acoes.push({
                            acao: "Criação de botão",
                            status: "Erro",
                            erro: error.message,
                        });
                    }
                }

                // 2. Tentar aplicar substituição de ícones
                if (
                    document.querySelectorAll("[data-eprobe-icon-replaced]")
                        .length === 0
                ) {
                    log("🎨 Aplicando substituição de ícones...");
                    try {
                        substituirIconesFieldsetAcoes();
                        resultadoCorrecao.acoes.push({
                            acao: "Substituição de ícones",
                            status: "Executada",
                            quantidade: document.querySelectorAll(
                                "[data-eprobe-icon-replaced]"
                            ).length,
                        });
                    } catch (error) {
                        console.error("❌ Erro ao substituir ícones:", error);
                        resultadoCorrecao.acoes.push({
                            acao: "Substituição de ícones",
                            status: "Erro",
                            erro: error.message,
                        });
                    }
                }

                // 3. Forçar detecção de data da sessão se necessário
                if (!hasDataSessaoPautado()) {
                    log("📅 Forçando detecção de data da sessão...");
                    try {
                        const dataDetectada =
                            window.SENT1_AUTO &&
                            window.SENT1_AUTO.detectarCardSessaoSimplificado
                                ? window.SENT1_AUTO.detectarCardSessaoSimplificado()
                                : null;
                        resultadoCorrecao.acoes.push({
                            acao: "Detecção de data da sessão",
                            status: "Executada",
                            sucesso: dataDetectada !== null,
                            valor: dataDetectada,
                        });
                    } catch (error) {
                        console.error(
                            "❌ Erro ao detectar data da sessão:",
                            error
                        );
                        resultadoCorrecao.acoes.push({
                            acao: "Detecção de data da sessão",
                            status: "Erro",
                            erro: error.message,
                        });
                    }
                }

                log("🔧 CORREÇÃO COMPLETA:", resultadoCorrecao);
                return resultadoCorrecao;
            }

            /**
             * 🔧 FUNÇÃO CRÍTICA: Corrigir pointer-events de botões do eProc
             * Garante que botões importantes como LegNovaMinuta sejam clicáveis
             */
            function corrigirPointerEventsBotoes() {
                console.log(
                    "🔧 CORREÇÃO: Iniciando correção de pointer-events em botões críticos..."
                );

                const correcoesAplicadas = [];

                // 1. Corrigir especificamente o botão LegNovaMinuta
                const botaoLegNovaMinuta = document.querySelector(
                    "#LegNovaMinuta button"
                );
                if (botaoLegNovaMinuta) {
                    // Corrigir o botão e todos os seus elementos filhos
                    botaoLegNovaMinuta.style.setProperty(
                        "pointer-events",
                        "auto",
                        "important"
                    );
                    const spansDoBotao =
                        botaoLegNovaMinuta.querySelectorAll("span");
                    spansDoBotao.forEach((span) => {
                        span.style.setProperty(
                            "pointer-events",
                            "auto",
                            "important"
                        );
                    });
                    const iconesDoBotao = botaoLegNovaMinuta.querySelectorAll(
                        "svg, img, [data-eprobe-icon-replaced]"
                    );
                    iconesDoBotao.forEach((icone) => {
                        icone.style.setProperty(
                            "pointer-events",
                            "auto",
                            "important"
                        );
                    });
                    correcoesAplicadas.push("LegNovaMinuta button");
                    console.log("✅ CORREÇÃO: Botão LegNovaMinuta corrigido");
                }

                // 2. Corrigir todos os botões com classe infraLegendObrigatorio
                const botoesInfraLegend = document.querySelectorAll(
                    ".infraLegendObrigatorio button"
                );
                botoesInfraLegend.forEach((botao, index) => {
                    botao.style.setProperty(
                        "pointer-events",
                        "auto",
                        "important"
                    );
                    const spans = botao.querySelectorAll("span");
                    spans.forEach((span) => {
                        span.style.setProperty(
                            "pointer-events",
                            "auto",
                            "important"
                        );
                    });
                    const icones = botao.querySelectorAll(
                        "svg, img, [data-eprobe-icon-replaced]"
                    );
                    icones.forEach((icone) => {
                        icone.style.setProperty(
                            "pointer-events",
                            "auto",
                            "important"
                        );
                    });
                    correcoesAplicadas.push(
                        `infraLegendObrigatorio button ${index + 1}`
                    );
                });

                // 3. Corrigir especificamente ícones de estrela protegidos
                const iconesEstrelaProtegidos = document.querySelectorAll(
                    'img[data-eprobe-protected="true"]'
                );
                iconesEstrelaProtegidos.forEach((icone, index) => {
                    icone.style.setProperty(
                        "pointer-events",
                        "auto",
                        "important"
                    );
                    const parentLink = icone.closest("a");
                    if (parentLink) {
                        parentLink.style.setProperty(
                            "pointer-events",
                            "auto",
                            "important"
                        );
                    }
                    correcoesAplicadas.push(
                        `Ícone estrela protegido ${index + 1}`
                    );
                });

                // 4. Corrigir botões btn-link que podem estar bloqueados
                const botoesBtnLink =
                    document.querySelectorAll("button.btn-link");
                botoesBtnLink.forEach((botao, index) => {
                    botao.style.setProperty(
                        "pointer-events",
                        "auto",
                        "important"
                    );
                    const spans = botao.querySelectorAll("span");
                    spans.forEach((span) => {
                        span.style.setProperty(
                            "pointer-events",
                            "auto",
                            "important"
                        );
                    });
                    const icones = botao.querySelectorAll(
                        "svg, img, [data-eprobe-icon-replaced]"
                    );
                    icones.forEach((icone) => {
                        icone.style.setProperty(
                            "pointer-events",
                            "auto",
                            "important"
                        );
                    });
                });

                console.log(
                    `✅ CORREÇÃO: ${correcoesAplicadas.length} correções aplicadas:`,
                    correcoesAplicadas
                );

                return {
                    status: "sucesso",
                    correcoesAplicadas: correcoesAplicadas.length,
                    detalhes: correcoesAplicadas,
                };
            }

            /**
             *  NOVA VERSÃO ROBUSTA: switchRelevanciaDocumento sem dependências problemáticas
             */
            function corrigirSwitchRelevanciaDocumentoRobusta() {
                console.log(
                    "🚀 CORREÇÃO ROBUSTA: Iniciando substituição completa da função switchRelevanciaDocumento..."
                );

                const correcoesAplicadas = [];

                // 🔧 IMPLEMENTAÇÃO ROBUSTA COMPLETA da switchRelevanciaDocumento
                function switchRelevanciaDocumentoRobusta(
                    idEvento,
                    relevancia,
                    tipo,
                    urlAjax
                ) {
                    try {
                        console.log(
                            "🚀 FUNÇÃO ROBUSTA: switchRelevanciaDocumento chamada:",
                            {
                                idEvento,
                                relevancia,
                                tipo,
                                urlAjax,
                            }
                        );

                        // Validação básica dos parâmetros
                        if (!idEvento || !urlAjax) {
                            console.error("❌ PARÂMETROS INVÁLIDOS:", {
                                idEvento,
                                urlAjax,
                            });
                            return false;
                        }

                        // Construir URL da requisição AJAX de forma segura
                        let fullUrl = urlAjax;
                        const separator =
                            fullUrl.indexOf("?") === -1 ? "?" : "&";
                        fullUrl += `${separator}idEvento=${encodeURIComponent(
                            idEvento
                        )}&relevancia=${encodeURIComponent(
                            relevancia
                        )}&tipo=${encodeURIComponent(tipo || "")}`;

                        console.log("🌐 REQUISIÇÃO AJAX ROBUSTA:", fullUrl);

                        // Executar requisição AJAX com tratamento completo de erros
                        const xhr = new XMLHttpRequest();
                        xhr.open("GET", fullUrl, true);

                        xhr.onreadystatechange = function () {
                            if (xhr.readyState === 4) {
                                if (xhr.status === 200) {
                                    console.log(
                                        "✅ AJAX SUCESSO:",
                                        xhr.responseText
                                    );

                                    // Atualizar ícone visualmente
                                    setTimeout(() => {
                                        atualizarIconeEstrelaVisualRobusta(
                                            idEvento,
                                            relevancia
                                        );
                                    }, 100);

                                    // Verificar se precisa recarregar (comportamento padrão do eProc)
                                    if (
                                        xhr.responseText &&
                                        xhr.responseText
                                            .toLowerCase()
                                            .includes("reload")
                                    ) {
                                        console.log(
                                            "🔄 RECARREGANDO PÁGINA conforme resposta do servidor"
                                        );
                                        setTimeout(
                                            () => window.location.reload(),
                                            500
                                        );
                                    }
                                } else {
                                    console.error(
                                        "❌ AJAX ERRO:",
                                        xhr.status,
                                        xhr.statusText
                                    );
                                }
                            }
                        };

                        xhr.onerror = function () {
                            console.error("❌ AJAX ERRO DE REDE");
                        };

                        xhr.timeout = 10000; // 10 segundos de timeout
                        xhr.ontimeout = function () {
                            console.error("❌ AJAX TIMEOUT");
                        };

                        xhr.send();
                        return true;
                    } catch (error) {
                        console.error(
                            "❌ ERRO CRÍTICO na função robusta:",
                            error
                        );
                        return false;
                    }
                }

                // Função auxiliar para atualizar ícone visualmente (versão robusta)
                function atualizarIconeEstrelaVisualRobusta(
                    idEvento,
                    relevancia
                ) {
                    try {
                        console.log(
                            `🌟 ATUALIZANDO ÍCONES: Evento ${idEvento}, Relevância ${relevancia}`
                        );

                        // Procurar ícones de estrela por múltiplos seletores
                        const seletores = [
                            `img[onclick*="switchRelevanciaDocumento('${idEvento}'"]`,
                            `a[onclick*="switchRelevanciaDocumento('${idEvento}'"]`,
                            `img[onclick*='switchRelevanciaDocumento("${idEvento}"']`,
                            `a[onclick*='switchRelevanciaDocumento("${idEvento}"']`,
                            `img[src*="estrela"]`,
                            `img[src*="Estrela"]`,
                        ];

                        let iconesAtualizados = 0;

                        for (const seletor of seletores) {
                            const elementos =
                                document.querySelectorAll(seletor);
                            elementos.forEach((elemento, index) => {
                                try {
                                    // Verificar se este elemento pertence ao evento correto
                                    const pertenceAoEvento =
                                        verificarSeElementoPertenceAoEventoRobusta(
                                            elemento,
                                            idEvento
                                        );

                                    if (pertenceAoEvento) {
                                        if (elemento.tagName === "IMG") {
                                            // Atualizar src da imagem
                                            const srcAtual = elemento.src;
                                            let novoSrc;

                                            if (
                                                relevancia === "S" ||
                                                relevancia === "1"
                                            ) {
                                                // Marcar como relevante (estrela acesa)
                                                novoSrc = srcAtual
                                                    .replace(
                                                        /estrela[_\-]?off/gi,
                                                        "estrela_on"
                                                    )
                                                    .replace(
                                                        /estrela[_\-]?apagada/gi,
                                                        "estrela_acesa"
                                                    )
                                                    .replace(
                                                        /EstrelaApagada/gi,
                                                        "EstrelaAcesa"
                                                    );
                                            } else {
                                                // Marcar como não relevante (estrela apagada)
                                                novoSrc = srcAtual
                                                    .replace(
                                                        /estrela[_\-]?on/gi,
                                                        "estrela_off"
                                                    )
                                                    .replace(
                                                        /estrela[_\-]?acesa/gi,
                                                        "estrela_apagada"
                                                    )
                                                    .replace(
                                                        /EstrelaAcesa/gi,
                                                        "EstrelaApagada"
                                                    );
                                            }

                                            if (novoSrc !== srcAtual) {
                                                elemento.src = novoSrc;
                                                iconesAtualizados++;
                                                console.log(
                                                    `✅ Ícone ${index} atualizado: ${srcAtual} → ${novoSrc}`
                                                );
                                            }
                                        }

                                        // Atualizar atributos de acessibilidade
                                        const textoRelevancia =
                                            relevancia === "S" ||
                                            relevancia === "1"
                                                ? "Relevante"
                                                : "Não relevante";
                                        elemento.title = textoRelevancia;
                                        elemento.alt = textoRelevancia;
                                    }
                                } catch (iconError) {
                                    console.warn(
                                        `⚠️ Erro ao atualizar ícone ${index}:`,
                                        iconError
                                    );
                                }
                            });
                        }

                        console.log(
                            `🎯 RESULTADO: ${iconesAtualizados} ícones atualizados para evento ${idEvento}`
                        );
                    } catch (error) {
                        console.error(
                            "❌ ERRO ao atualizar ícones visuais:",
                            error
                        );
                    }
                }

                // Função para verificar se um elemento pertence ao evento específico (versão robusta)
                function verificarSeElementoPertenceAoEventoRobusta(
                    elemento,
                    idEvento
                ) {
                    try {
                        // Método 1: Verificar onclick do próprio elemento
                        const onclick = elemento.getAttribute("onclick");
                        if (onclick && onclick.includes(idEvento)) {
                            console.log(
                                `🎯 MATCH: Elemento pertence ao evento ${idEvento} (onclick)`
                            );
                            return true;
                        }

                        // Método 2: Procurar no container pai por referência ao evento
                        const container = elemento.closest(
                            'tr, .evento, [id*="evento"], .infraLinha'
                        );
                        if (container) {
                            // Verificar se o ID do evento aparece no texto ou atributos do container
                            if (
                                container.textContent.includes(idEvento) ||
                                container.innerHTML.includes(idEvento) ||
                                container.getAttribute("id")?.includes(idEvento)
                            ) {
                                console.log(
                                    `🎯 MATCH: Elemento pertence ao evento ${idEvento} (container)`
                                );
                                return true;
                            }
                        }

                        // Método 3: Verificar elementos irmãos
                        const parent = elemento.parentElement;
                        if (
                            parent &&
                            (parent.textContent.includes(idEvento) ||
                                parent.innerHTML.includes(idEvento))
                        ) {
                            console.log(
                                `🎯 MATCH: Elemento pertence ao evento ${idEvento} (parent)`
                            );
                            return true;
                        }

                        return false;
                    } catch (error) {
                        console.warn("⚠️ Erro ao verificar evento:", error);
                        return false;
                    }
                }

                // 🔄 SUBSTITUIR COMPLETAMENTE a função original
                const funcaoOriginal = window.switchRelevanciaDocumento;
                window.switchRelevanciaDocumento =
                    switchRelevanciaDocumentoRobusta;

                if (funcaoOriginal) {
                    console.log(
                        "🔄 SUBSTITUIÇÃO COMPLETA: Função original substituída por versão robusta"
                    );
                    correcoesAplicadas.push(
                        "Função original completamente substituída por versão robusta"
                    );
                } else {
                    console.log(
                        "🆕 CRIAÇÃO: Função switchRelevanciaDocumento robusta criada do zero"
                    );
                    correcoesAplicadas.push("Função robusta criada do zero");
                }

                // 🛡️ PROTEÇÃO: Observar e re-aplicar se a função for sobrescrita
                let reprotecaoAttempts = 0;
                const maxReprotecaoAttempts = 5;

                const observerReprotecao = new MutationObserver(() => {
                    if (
                        window.switchRelevanciaDocumento !==
                            switchRelevanciaDocumentoRobusta &&
                        reprotecaoAttempts < maxReprotecaoAttempts
                    ) {
                        reprotecaoAttempts++;
                        console.log(
                            `🔄 REPROTECÇÃO ${reprotecaoAttempts}: Re-aplicando função robusta...`
                        );
                        window.switchRelevanciaDocumento =
                            switchRelevanciaDocumentoRobusta;
                        correcoesAplicadas.push(
                            `Re-proteção aplicada (tentativa ${reprotecaoAttempts})`
                        );
                    }
                });

                observerReprotecao.observe(document.body, {
                    childList: true,
                    subtree: true,
                });

                // Parar observer após 30 segundos para evitar overhead
                setTimeout(() => {
                    observerReprotecao.disconnect();
                    console.log(
                        "🛑 Observer de re-proteção desativado após 30 segundos"
                    );
                }, 30000);

                // 🔧 CORRIGIR links onclick existentes para usar nossa função robusta
                setTimeout(() => {
                    const linksEstrela = document.querySelectorAll(
                        'a[onclick*="switchRelevanciaDocumento"], img[onclick*="switchRelevanciaDocumento"]'
                    );
                    console.log(
                        `🔗 CORREÇÃO: Encontrados ${linksEstrela.length} links com switchRelevanciaDocumento`
                    );

                    linksEstrela.forEach((link, index) => {
                        try {
                            // Pular links já protegidos pela nossa extensão
                            if (
                                link.classList?.contains(
                                    "eprobe-icon-protected"
                                ) ||
                                link.dataset?.eprobeProtected === "true"
                            ) {
                                console.log(
                                    `🛡️ PROTEÇÃO: Link ${index} já protegido pelo eProbe, mantendo...`
                                );
                                return;
                            }

                            const onclickOriginal =
                                link.getAttribute("onclick");
                            if (
                                onclickOriginal &&
                                onclickOriginal.includes(
                                    "switchRelevanciaDocumento"
                                )
                            ) {
                                // Garantir que usa a função global robusta
                                const novoOnclick = onclickOriginal.replace(
                                    /switchRelevanciaDocumento\(/g,
                                    "window.switchRelevanciaDocumento("
                                );

                                if (novoOnclick !== onclickOriginal) {
                                    link.setAttribute("onclick", novoOnclick);
                                    link.classList.add(
                                        "eprobe-link-corrigido-robusta"
                                    );
                                    console.log(
                                        `✅ LINK ${index} CORRIGIDO: onclick atualizado para versão robusta`
                                    );
                                    correcoesAplicadas.push(
                                        `Link onclick corrigido robustamente (${index})`
                                    );
                                }
                            }
                        } catch (linkError) {
                            console.warn(
                                `⚠️ Erro ao corrigir link ${index}:`,
                                linkError
                            );
                        }
                    });
                }, 500);

                console.log(
                    `✅ CORREÇÃO ROBUSTA COMPLETA: ${correcoesAplicadas.length} correções aplicadas:`,
                    correcoesAplicadas
                );

                return {
                    status: "sucesso_robusta",
                    correcoesAplicadas: correcoesAplicadas.length,
                    detalhes: correcoesAplicadas,
                    funcaoOriginal: funcaoOriginal ? "substituída" : "criada",
                };
            }

            /**
             * 🔧 FUNÇÃO CRÍTICA: Corrigir problemas com switchRelevanciaDocumento do eProc
             * Garante que a função de marcar/desmarcar eventos como relevantes funcione
             */
            function corrigirSwitchRelevanciaDocumento() {
                console.log(
                    "🔧 CORREÇÃO: Iniciando correção da função switchRelevanciaDocumento..."
                );

                const correcoesAplicadas = [];

                // 1. Interceptar e corrigir erros na função switchRelevanciaDocumento
                if (typeof window.switchRelevanciaDocumento === "function") {
                    const originalFunction = window.switchRelevanciaDocumento;

                    window.switchRelevanciaDocumento = function (...args) {
                        try {
                            console.log(
                                "🔍 INTERCEPTAÇÃO: switchRelevanciaDocumento chamada com args:",
                                args
                            );
                            return originalFunction.apply(this, args);
                        } catch (error) {
                            console.error(
                                "❌ ERRO interceptado em switchRelevanciaDocumento:",
                                error
                            );

                            // Tentar recuperar e executar manualmente se possível
                            if (args.length >= 4) {
                                const [idEvento, relevancia, tipo, urlAjax] =
                                    args;
                                console.log("🔧 TENTATIVA DE RECUPERAÇÃO:", {
                                    idEvento,
                                    relevancia,
                                    tipo,
                                    urlAjax,
                                });

                                // Fazer chamada AJAX manual se possível
                                if (urlAjax && typeof urlAjax === "string") {
                                    try {
                                        const xhr = new XMLHttpRequest();
                                        const fullUrl =
                                            urlAjax +
                                            "&idEvento=" +
                                            idEvento +
                                            "&relevancia=" +
                                            relevancia +
                                            "&tipo=" +
                                            tipo;

                                        xhr.open("GET", fullUrl, true);
                                        xhr.onreadystatechange = function () {
                                            if (
                                                xhr.readyState === 4 &&
                                                xhr.status === 200
                                            ) {
                                                console.log(
                                                    "✅ RECUPERAÇÃO: Requisição AJAX manual executada com sucesso"
                                                );
                                                // Atualizar visualmente o ícone
                                                atualizarIconeEstrela(
                                                    idEvento,
                                                    relevancia
                                                );
                                            }
                                        };
                                        xhr.send();

                                        correcoesAplicadas.push(
                                            "Requisição AJAX manual executada"
                                        );
                                        return true;
                                    } catch (ajaxError) {
                                        console.error(
                                            "❌ ERRO na recuperação AJAX:",
                                            ajaxError
                                        );
                                    }
                                }
                            }

                            // Se não conseguiu recuperar, mostrar erro amigável
                            alert(
                                "Erro ao alterar relevância do evento. Tente recarregar a página."
                            );
                            return false;
                        }
                    };

                    correcoesAplicadas.push(
                        "Função switchRelevanciaDocumento interceptada"
                    );
                    console.log(
                        "✅ CORREÇÃO: switchRelevanciaDocumento interceptada com proteção"
                    );
                }

                // 2. Função auxiliar para atualizar visualmente os ícones de estrela
                function atualizarIconeEstrela(idEvento, relevancia) {
                    // Procurar o ícone relacionado ao evento
                    const iconesEstrela = document.querySelectorAll(
                        'img[src*="Estrela"], img[data-eprobe-protected="true"]'
                    );

                    iconesEstrela.forEach((icone) => {
                        // Verificar se o ícone pertence ao evento correto (por contexto ou id)
                        const eventoContainer = icone.closest(
                            'tr, .evento, [id*="evento"]'
                        );
                        if (
                            eventoContainer &&
                            eventoContainer.textContent.includes(idEvento)
                        ) {
                            if (relevancia === "1") {
                                // Mudar para estrela acesa
                                if (icone.src.includes("EstrelaApagada")) {
                                    icone.src = icone.src.replace(
                                        "EstrelaApagada",
                                        "EstrelaAcesa"
                                    );
                                    icone.alt = "Evento relevante";
                                    icone.title = "Relevante";
                                }
                            } else {
                                // Mudar para estrela apagada
                                if (icone.src.includes("EstrelaAcesa")) {
                                    icone.src = icone.src.replace(
                                        "EstrelaAcesa",
                                        "EstrelaApagada"
                                    );
                                    icone.alt = "Evento normal";
                                    icone.title = "Marcar como relevante";
                                }
                            }
                        }
                    });
                }

                console.log(
                    `✅ CORREÇÃO: ${correcoesAplicadas.length} correções aplicadas para switchRelevanciaDocumento:`,
                    correcoesAplicadas
                );

                return {
                    status: "sucesso",
                    correcoesAplicadas: correcoesAplicadas.length,
                    detalhes: correcoesAplicadas,
                };
            }

            /**
             * DESABILITADO: Força a reaplicação dos ícones em caso de falha
             * Esta função pode estar interferindo com os ícones de estrela do eProc
             */
            function forcarReaplicacaoIcones() {
                // ⛔ RESTRIÇÃO: Só personalizar ícones na página de capa do processo
                if (!isCapaProcessoPage()) {
                    log(
                        "⛔ ÍCONES: Forçar reaplicação de ícones restrito apenas à página de capa do processo - URL atual não permitida"
                    );
                    log("📍 URL atual:", window.location.href);
                    return {
                        fieldsetAcoes: 0,
                        ferramentas: 0,
                        erros: [],
                        bloqueado: true,
                        motivo: "url_nao_permitida",
                    };
                }

                log("🔄 ÍCONES: Forçando reaplicação de ícones...");

                // Remover marcações existentes
                const iconesJaSubstituidos = document.querySelectorAll(
                    "[data-eprobe-icon-replaced]"
                );
                iconesJaSubstituidos.forEach((icone) => {
                    icone.removeAttribute("data-eprobe-icon-replaced");
                    icone.removeAttribute("data-original-text");
                });

                let resultados = {
                    fieldsetAcoes: 0,
                    ferramentas: 0,
                    erros: [],
                };

                // Executar substituição no fieldset de ações
                try {
                    const fieldsetAcoes = document.querySelector(
                        "#fldAcoes.infraFieldset"
                    );
                    if (fieldsetAcoes) {
                        log("🎨 Reaplicando ícones no fieldset de ações...");
                        substituirIconesFieldsetAcoes();
                        // Adicionar substituição global
                        substituirIconesGlobalmente();
                        // ✨ NOVO: Adicionar substituição de ícones de lembretes
                        if (typeof substituirIconesLembretes === "function") {
                            substituirIconesLembretes();
                        }
                        resultados.fieldsetAcoes = document.querySelectorAll(
                            "#fldAcoes [data-eprobe-icon-replaced]"
                        ).length;
                    }
                } catch (error) {
                    console.error("❌ Erro na reaplicação do fieldset:", error);
                    resultados.erros.push(`Fieldset: ${error.message}`);
                }

                // Executar substituição nas ferramentas
                try {
                    log("🛠️ Reaplicando ícones das ferramentas...");
                    if (typeof substituirIconesFerramentas === "function") {
                        const sucessoFerramentas =
                            substituirIconesFerramentas();
                        // Executar também a substituição global
                        substituirIconesGlobalmente();
                        // ✨ NOVO: Executar substituição específica de ícones de lembretes
                        if (typeof substituirIconesLembretes === "function") {
                            substituirIconesLembretes();
                            log("✅ ÍCONES: Ícones de lembretes aplicados");
                        }
                        if (sucessoFerramentas) {
                            // Contar ícones de ferramentas substituídos (subtrair os de fieldset)
                            const totalIcones = document.querySelectorAll(
                                "[data-eprobe-icon-replaced]"
                            ).length;
                            const iconesFieldset = document.querySelectorAll(
                                "#fldAcoes [data-eprobe-icon-replaced]"
                            ).length;
                            resultados.ferramentas =
                                totalIcones - iconesFieldset;
                            log(
                                `✅ ÍCONES: ${resultados.ferramentas} ícones de ferramentas aplicados`
                            );
                        } else {
                            resultados.ferramentas = 0;
                            log(
                                "⚠️ ÍCONES: Nenhum ícone de ferramenta foi substituído"
                            );
                        }
                    } else {
                        console.warn(
                            "⚠️ ÍCONES: Função substituirIconesFerramentas não está disponível"
                        );
                        resultados.erros.push(
                            "Função substituirIconesFerramentas não encontrada"
                        );
                    }
                } catch (error) {
                    console.error(
                        "❌ Erro na reaplicação das ferramentas:",
                        error
                    );
                    resultados.erros.push(`Ferramentas: ${error.message}`);
                    resultados.ferramentas = 0;
                }

                log("✅ ÍCONES: Reaplicação concluída:", resultados);
                return resultados;
            }

            /**
             * Inicializa o sistema de substituição de ícones
             * Função principal que coordena toda a substituição
             */
            function inicializarSubstituicaoIcones() {
                // ⛔ RESTRIÇÃO: Só personalizar ícones na página de capa do processo
                if (!isCapaProcessoPage()) {
                    log(
                        "⛔ ÍCONES: Sistema de personalização de ícones restrito apenas à página de capa do processo - URL atual não permitida"
                    );
                    log("📍 URL atual:", window.location.href);
                    return {
                        timestamp: new Date().toLocaleString("pt-BR"),
                        execucoes: [],
                        totalSubstituicoes: 0,
                        bloqueado: true,
                        motivo: "url_nao_permitida",
                    };
                }

                log("🎨 ÍCONES: Inicializando sistema de substituição...");

                if (MODO_ULTRA_PERFORMANCE) {
                    log(
                        "⚠️ ÍCONES: Modo ultra-performance ativo - substituição bloqueada"
                    );
                    return false;
                }

                const resultados = {
                    timestamp: new Date().toLocaleString("pt-BR"),
                    execucoes: [],
                    totalSubstituicoes: 0,
                };

                // 1. Substituir ícones do fieldset de ações
                try {
                    const antes = document.querySelectorAll(
                        "[data-eprobe-icon-replaced]"
                    ).length;
                    substituirIconesFieldsetAcoes();
                    const depois = document.querySelectorAll(
                        "[data-eprobe-icon-replaced]"
                    ).length;
                    const substituicoes = depois - antes;

                    resultados.execucoes.push({
                        tipo: "Fieldset Ações",
                        substituicoes: substituicoes,
                        sucesso: true,
                    });
                    resultados.totalSubstituicoes += substituicoes;
                } catch (error) {
                    console.error(
                        "❌ Erro na substituição do fieldset:",
                        error
                    );
                    resultados.execucoes.push({
                        tipo: "Fieldset Ações",
                        substituicoes: 0,
                        sucesso: false,
                        erro: error.message,
                    });
                }

                // 2. Substituir ícones das ferramentas
                try {
                    if (typeof substituirIconesFerramentas === "function") {
                        const antes = document.querySelectorAll(
                            "[data-eprobe-icon-replaced]"
                        ).length;
                        substituirIconesFerramentas();
                        // ✨ NOVO: Aplicar também ícones de lembretes aqui
                        if (typeof substituirIconesLembretes === "function") {
                            substituirIconesLembretes();
                        }
                        const depois = document.querySelectorAll(
                            "[data-eprobe-icon-replaced]"
                        ).length;
                        const substituicoes = depois - antes;

                        resultados.execucoes.push({
                            tipo: "Ferramentas",
                            substituicoes: substituicoes,
                            sucesso: true,
                        });
                        resultados.totalSubstituicoes += substituicoes;
                    }
                } catch (error) {
                    console.error(
                        "❌ Erro na substituição de ferramentas:",
                        error
                    );
                    resultados.execucoes.push({
                        tipo: "Ferramentas",
                        substituicoes: 0,
                        sucesso: false,
                        erro: error.message,
                    });
                }

                log("🎨 ÍCONES: Inicialização concluída:", resultados);

                // 📏 CORREÇÃO FINAL: Aplicar correção de alinhamento em divListaRecursosMinuta
                try {
                    if (
                        typeof corrigirAlinhamentoRecursosMinuta === "function"
                    ) {
                        setTimeout(() => {
                            const correcaoAlinhamento =
                                corrigirAlinhamentoRecursosMinuta();
                            if (
                                correcaoAlinhamento.encontrado &&
                                correcaoAlinhamento.iconesCorrigidos > 0
                            ) {
                                log(
                                    `📏 ÍCONES: Alinhamento corrigido em divListaRecursosMinuta - ${correcaoAlinhamento.iconesCorrigidos} ícones processados`
                                );
                            }
                        }, 100); // Pequeno delay para garantir que os ícones foram renderizados
                    }
                } catch (error) {
                    console.warn(
                        "⚠️ ÍCONES: Erro na correção de alinhamento:",
                        error
                    );
                }

                return resultados;
            }

            /**
             * Diagnóstico específico para problemas com ícones CSS
             * Analisa o estado atual dos ícones na página
             */
            function diagnosticarIconesCSS() {
                log("🔍 DIAGNÓSTICO: Analisando estado dos ícones CSS...");

                const diagnostico = {
                    timestamp: new Date().toLocaleString("pt-BR"),
                    url: window.location.href,
                    fieldsetAcoes: null,
                    iconesGIF: 0,
                    iconesSVG: 0,
                    iconesSubstituidos: 0,
                    problemas: [],
                    recomendacoes: [],
                };

                // Analisar fieldset de ações
                const fieldsetAcoes = document.querySelector(
                    "#fldAcoes.infraFieldset"
                );
                if (fieldsetAcoes) {
                    diagnostico.fieldsetAcoes = {
                        encontrado: true,
                        children: fieldsetAcoes.children.length,
                        links: fieldsetAcoes.querySelectorAll("a").length,
                    };

                    // Contar tipos de ícones
                    const iconesGIF =
                        fieldsetAcoes.querySelectorAll('img[src*=".gif"]');
                    const iconesSVG =
                        fieldsetAcoes.querySelectorAll("svg.lucide");
                    const iconesSubstituidos = fieldsetAcoes.querySelectorAll(
                        "[data-eprobe-icon-replaced]"
                    );

                    diagnostico.iconesGIF = iconesGIF.length;
                    diagnostico.iconesSVG = iconesSVG.length;
                    diagnostico.iconesSubstituidos = iconesSubstituidos.length;

                    // Identificar problemas
                    if (iconesGIF.length > 0 && iconesSVG.length === 0) {
                        diagnostico.problemas.push(
                            "Ícones GIF não foram substituídos por SVG"
                        );
                        diagnostico.recomendacoes.push(
                            "Execute window.SENT1_AUTO.forcarReaplicacaoIcones()"
                        );
                    }

                    if (
                        iconesSubstituidos.length === 0 &&
                        iconesGIF.length > 0
                    ) {
                        diagnostico.problemas.push(
                            "Nenhum ícone foi marcado como substituído"
                        );
                        diagnostico.recomendacoes.push(
                            "Execute window.SENT1_AUTO.inicializarSubstituicaoIcones()"
                        );
                    }
                } else {
                    diagnostico.fieldsetAcoes = { encontrado: false };
                    diagnostico.problemas.push(
                        "Fieldset #fldAcoes não encontrado"
                    );
                    diagnostico.recomendacoes.push(
                        "Verifique se está na página correta do eProc"
                    );
                }

                // Verificar se modo ultra-performance está bloqueando
                if (MODO_ULTRA_PERFORMANCE) {
                    diagnostico.problemas.push(
                        "Modo ultra-performance ativo bloqueando substituições"
                    );
                    diagnostico.recomendacoes.push(
                        "Execute window.SENT1_AUTO.desativarModoUltraPerformance()"
                    );
                }

                log("🔍 DIAGNÓSTICO COMPLETO:", diagnostico);
                return diagnostico;
            }

            // ========================================
            // FUNÇÕES GLOBAIS PARA GERENCIAMENTO DOS DADOS
            // ========================================

            /**
             * Função global para obter o tipo de julgamento
             * @returns {string|null} - Tipo do julgamento (ex: "Mérito", "Embargos de Declaração")
             */
            function getTipoJulgamentoProcessoPautado() {
                return TipoJulgamentoProcessoPautado;
            }

            /**
             * Função global para definir o tipo de julgamento
             * @param {string} tipo - Tipo do julgamento
             */
            function setTipoJulgamentoProcessoPautado(tipo) {
                TipoJulgamentoProcessoPautado = tipo;
                log("📋 TIPO: Tipo de julgamento definido:", tipo);
            }

            /**
             * Função global para obter o status do julgamento
             * @returns {string|null} - Status do julgamento (ex: "Julgado em Pauta", "Retirado em Pauta")
             */
            function getStatusJulgamento() {
                return StatusJulgamento;
            }

            /**
             * Função global para definir o status do julgamento
             * @param {string} status - Status do julgamento
             */
            function setStatusJulgamento(status) {
                StatusJulgamento = status;
                log("📊 STATUS: Status de julgamento definido:", status);
            }

            /**
             * Função global para obter a data da sessão
             * @returns {string|null} - Data da sessão (ex: "10/04/2025")
             */
            function getDataSessao() {
                return DataSessao;
            }

            /**
             * Função global para definir a data da sessão
             * @param {string} data - Data da sessão
             */
            function setDataSessao(data) {
                DataSessao = data;
                log("📅 DATA: Data da sessão definida:", data);
            }

            /**
             * Função para resetar todos os dados globais da sessão
             */
            function resetDadosGlobaisSessao() {
                TipoJulgamentoProcessoPautado = null;
                StatusJulgamento = null;
                DataSessao = null;
                log(
                    "🔄 RESET: Todos os dados globais da sessão foram resetados"
                );
            }

            /**
             * Função para mostrar todos os dados globais da sessão
             */
            function showDadosGlobaisSessao() {
                log("📊 DADOS GLOBAIS DA SESSÃO:");
                log("   Tipo de Julgamento:", TipoJulgamentoProcessoPautado);
                log("   Status do Julgamento:", StatusJulgamento);
                log("   Data da Sessão:", DataSessao);

                return {
                    tipoJulgamento: TipoJulgamentoProcessoPautado,
                    statusJulgamento: StatusJulgamento,
                    dataSessao: DataSessao,
                };
            }

            // ❌ FUNÇÃO REMOVIDA: detectarStatusSessao()
            // ✅ USE AGORA: detectarSessoesUnificado()

            /**
             * Retorna o texto do card baseado no status da sessão
             * @param {Object} statusSessao - Objeto com informações do status
             * @returns {string} - Texto para exibir no card
             */
            function obterTextoCardPorStatus(statusSessao) {
                if (!statusSessao) {
                    return "Processo Pautado"; // Fallback padrão
                }

                switch (statusSessao.status) {
                    case "Incluído":
                        return "Processo Pautado";
                    case "Julgado":
                        return "Processo Julgado";
                    case "Retirado":
                        return "Processo retirado de pauta";
                    default:
                        return "Processo Pautado";
                }
            }

            /**
             * Retorna a cor do card baseado no status da sessão
             * @param {Object} statusSessao - Objeto com informações do status
             * @returns {string} - Cor em formato hex
             */
            function obterCorCardPorStatus(statusSessao) {
                if (!statusSessao) {
                    return "#3b82f6"; // Azul padrão
                }

                switch (statusSessao.status) {
                    case "Incluído":
                        return "#3b82f6"; // Azul para pautado
                    case "Julgado":
                        return "#16a34a"; // Verde para julgado
                    case "Retirado":
                        return "#dc2626"; // Vermelho para retirado
                    default:
                        return "#3b82f6";
                }
            }

            // FUNÇÃO REMOVIDA: detectarDataSessaoComStatus - substituída por detectarCardSessaoSimplificado ÚNICA

            // Funções auxiliares para gerenciar status de sessão
            function getStatusSessao() {
                return dataSessaoPautado?.statusSessao || null;
            }

            function hasStatusSessao() {
                return (
                    dataSessaoPautado?.statusSessao !== null &&
                    dataSessaoPautado?.statusSessao !== undefined
                );
            }

            function resetStatusSessao() {
                if (dataSessaoPautado) {
                    delete dataSessaoPautado.statusSessao;
                }
                log("🔄 STATUS: Status da sessão resetado");
            }

            function showStatusSessaoInfo() {
                const status = getStatusSessao();
                if (status) {
                    const info = `📋 STATUS DA SESSÃO DETECTADO:
                
    Status: ${status.status}
    Descrição: ${status.descricao}
    Tipo do Processo: ${status.tipoProcesso}
    Data: ${status.data.dataFormatada}
    Órgão: ${traduzirSiglaOrgao(status.orgao)}
    Texto Completo: ${status.textoCompleto}`;

                    log(info);
                    alert(info);
                    return status;
                } else {
                    const msg =
                        "❌ Nenhum status de sessão foi detectado ainda.";
                    log(msg);
                    alert(msg);
                    return null;
                }
            }

            // ========================================
            // FUNÇÕES DE TESTE E DEBUG PARA STATUS DE SESSÃO
            // ========================================

            /**
             * Testa o sistema completo de detecção de status de sessão
             * @returns {Object} - Resultado do teste com informações detalhadas
             */
            function testarSistemaStatusSessao() {
                log("🧪 TESTE: Iniciando teste completo do sistema de status");

                try {
                    // 1. Verificar se há data de sessão detectada
                    const temDataSessao = hasDataSessaoPautado();
                    log(
                        `📊 Data de sessão detectada: ${
                            temDataSessao ? "SIM" : "NÃO"
                        }`
                    );

                    if (temDataSessao) {
                        const dadosSessao = getDataSessaoPautado();
                        log(`📅 Data: ${dadosSessao.dataFormatada}`);
                    }

                    // 2. Testar detecção de status
                    const statusDetectado = detectarStatusSessao();
                    log(
                        `🎯 Status detectado: ${
                            statusDetectado ? "SIM" : "NÃO"
                        }`
                    );

                    if (statusDetectado) {
                        log(`📋 Status: ${statusDetectado.status}`);
                        log(`📝 Descrição: ${statusDetectado.descricao}`);
                        log(`📅 Data: ${statusDetectado.data.dataFormatada}`);
                        log(
                            `🏛️ Órgão: ${traduzirSiglaOrgao(
                                statusDetectado.orgao
                            )}`
                        );
                    }

                    // 3. Testar funções de texto e cor
                    const textoCard = obterTextoCardPorStatus(statusDetectado);
                    const corCard = obterCorCardPorStatus(statusDetectado);

                    log(`🎨 Texto do card: "${textoCard}"`);
                    log(`🎨 Cor do card: ${corCard}`);

                    // 4. Verificar interface
                    const cardExiste =
                        document.getElementById("eprobe-data-sessao");
                    log(`🖼️ Card na interface: ${cardExiste ? "SIM" : "NÃO"}`);

                    const resultado = {
                        temDataSessao,
                        statusDetectado,
                        textoCard,
                        corCard,
                        cardExiste: !!cardExiste,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };

                    log("✅ TESTE: Sistema testado com sucesso!");
                    return resultado;
                } catch (error) {
                    console.error("❌ TESTE: Erro durante o teste:", error);
                    return {
                        erro: error.message,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };
                }
            }

            /**
             * Debug dos padrões de busca para status de sessão
             * Mostra quais padrões estão encontrando matches no texto da página
             */
            function debugPadroesStatusSessao() {
                log("🔍 DEBUG: Analisando padrões de status de sessão");

                try {
                    // Obter texto completo da página
                    const textoCompleto = document.body.innerText;
                    log(
                        `📄 Texto da página: ${textoCompleto.length} caracteres`
                    );

                    // Padrões a serem testados
                    const padroes = [
                        {
                            nome: "Incluído em Pauta",
                            regex: /([A-Za-zÀ-ÿ\s]+(?:Interno|Declaração|Mérito|Preliminar|Cautelar|Retratação))\s*\(Incluído em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi,
                            status: "Pautado",
                        },
                        {
                            nome: "Incluído em Mesa",
                            regex: /([A-Za-zÀ-ÿ\s]+(?:Interno|Declaração|Mérito|Preliminar|Cautelar|Retratação))\s*\(Incluído em Mesa em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi,
                            status: "Pautado",
                        },
                        {
                            nome: "Julgado em Pauta",
                            regex: /([A-Za-zÀ-ÿ\s]+(?:Interno|Declaração|Mérito|Preliminar|Cautelar))\s*\(Julgado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi,
                            status: "Julgado",
                        },
                        {
                            nome: "Retirado em Pauta",
                            regex: /([A-Za-zÀ-ÿ\s]+(?:Interno|Declaração|Mérito|Preliminar|Cautelar))\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi,
                            status: "Retirado",
                        },
                    ];

                    let encontrados = 0;

                    // Testar cada padrão
                    padroes.forEach((padrao, index) => {
                        log(
                            `\n🔍 Testando padrão ${index + 1}: ${padrao.nome}`
                        );

                        // Resetar regex
                        padrao.regex.lastIndex = 0;

                        const matches = textoCompleto.match(padrao.regex);

                        if (matches && matches.length > 0) {
                            encontrados++;
                            log(
                                `✅ MATCH ENCONTRADO! (${
                                    matches.length
                                } ocorrência${matches.length > 1 ? "s" : ""})`
                            );

                            matches.forEach((match, i) => {
                                log(`   ${i + 1}. "${match}"`);
                            });

                            // Tentar extrair detalhes do primeiro match
                            padrao.regex.lastIndex = 0;
                            const detalhes = padrao.regex.exec(textoCompleto);
                            if (detalhes) {
                                log(`   📋 Tipo: ${detalhes[1]?.trim()}`);
                                log(`   📅 Data: ${detalhes[2]}`);
                                log(`   🏛️ Órgão: ${detalhes[3]}`);
                            }
                        } else {
                            logError(`❌ Nenhum match encontrado`);
                        }
                    });

                    log(
                        `\n📊 RESUMO: ${encontrados} ${
                            encontrados === 1
                                ? "padrão encontrado"
                                : "padrões encontrados"
                        }`
                    );

                    // Buscar por texto relacionado a sessão
                    const termosRelacionados = [
                        "Incluído em Pauta",
                        "Julgado em Pauta",
                        "Retirado em Pauta",
                        "sessão",
                        "julgamento",
                        "pauta",
                    ];

                    log("\n🔍 Buscando termos relacionados:");
                    termosRelacionados.forEach((termo) => {
                        const regex = new RegExp(termo, "gi");
                        const matches = textoCompleto.match(regex);
                        log(
                            `   "${termo}": ${
                                matches ? matches.length : 0
                            } ocorrência${
                                matches && matches.length !== 1 ? "s" : ""
                            }`
                        );
                    });

                    return {
                        totalPadroes: padroes.length,
                        padroesEncontrados: encontrados,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };
                } catch (error) {
                    console.error(
                        "❌ DEBUG: Erro durante debug dos padrões:",
                        error
                    );
                    return { erro: error.message };
                }
            }

            /**
             * Força a detecção de um status específico (para testes)
             * @param {string} tipoStatus - "pautado", "julgado" ou "retirado"
             * @returns {Object|null} - Objeto com status forçado ou null se inválido
             */
            function forcarStatusSessao(tipoStatus = "pautado") {
                log(`🚀 FORÇA: Forçando status "${tipoStatus}"`);

                try {
                    const statusValidos = {
                        pautado: {
                            status: "Pautado",
                            descricao: "Processo Pautado",
                            cor: "#134377",
                        },
                        julgado: {
                            status: "Julgado",
                            descricao: "Processo Julgado",
                            cor: "#16a34a",
                        },
                        retirado: {
                            status: "Retirado",
                            descricao: "Processo Retirado de Pauta",
                            cor: "#dc2626",
                        },
                    };

                    const tipoLower = tipoStatus.toLowerCase();

                    if (!statusValidos[tipoLower]) {
                        console.error(
                            `❌ FORÇA: Status "${tipoStatus}" inválido. Use: pautado, julgado ou retirado`
                        );
                        return null;
                    }

                    const config = statusValidos[tipoLower];
                    const dataAtual = new Date();
                    const dataFormatada = dataAtual.toLocaleDateString("pt-BR");

                    // Criar objeto de status forçado
                    const statusForcado = {
                        status: config.status,
                        descricao: config.descricao,
                        tipoProcesso: "Teste Forçado",
                        data: {
                            dataFormatada: dataFormatada,
                            dataObject: dataAtual,
                        },
                        orgao: "TESTE",
                        textoCompleto: `Teste Forçado (${config.status} em Pauta em ${dataFormatada} - TESTE)`,
                        forcado: true,
                    };

                    log(
                        `✅ FORÇA: Status "${config.status}" criado artificialmente`
                    );
                    log(`📅 Data: ${dataFormatada}`);
                    log(`🎨 Cor: ${config.cor}`);

                    // Testar funções relacionadas
                    const textoCard = obterTextoCardPorStatus(statusForcado);
                    const corCard = obterCorCardPorStatus(statusForcado);

                    log(`🎨 Texto do card: "${textoCard}"`);
                    log(`🎨 Cor do card: ${corCard}`);

                    // Opcionalmente atualizar a interface se houver data de sessão
                    if (hasDataSessaoPautado()) {
                        log("🖼️ Atualizando interface com status forçado...");

                        // Salvar dados temporariamente
                        const dadosOriginais = dataSessaoPautado;

                        // Aplicar status forçado
                        if (dataSessaoPautado) {
                            dataSessaoPautado.statusSessao = statusForcado;
                        }

                        // Tentar atualizar interface
                        const sucesso = atualizarDataSessaoNaInterface();
                        log(
                            `🖼️ Interface atualizada: ${
                                sucesso ? "SIM" : "NÃO"
                            }`
                        );

                        // Restaurar dados originais após 5 segundos
                        setTimeout(() => {
                            dataSessaoPautado = dadosOriginais;
                            log("🔄 FORÇA: Dados originais restaurados");
                        }, 5000);
                    }

                    return statusForcado;
                } catch (error) {
                    console.error("❌ FORÇA: Erro ao forçar status:", error);
                    return null;
                }
            }

            /**
             * Força uma nova detecção de status e atualização do card
             */
            function forcarAtualizacaoStatus() {
                log("🔄 FORÇA: Forçando atualização do status da sessão");

                try {
                    // 1. Re-detectar status
                    const novoStatus = detectarStatusSessao();
                    log("🔍 Novo status detectado:", novoStatus);

                    // 2. Atualizar dados se há sessão
                    if (hasDataSessaoPautado() && novoStatus) {
                        dataSessaoPautado.statusSessao = novoStatus;
                        log("✅ Status atualizado nos dados da sessão");
                    }

                    // 3. Forçar atualização da interface
                    const cardExistente =
                        document.getElementById("eprobe-data-sessao");
                    if (cardExistente) {
                        log("🗑️ Removendo card existente");
                        cardExistente.remove();
                    }

                    // 4. Re-inserir com novo status
                    setTimeout(() => {
                        const sucesso = inserirDataSessaoNaInterface();
                        if (sucesso) {
                            log("✅ Card atualizado com novo status");
                        } else {
                            logError("❌ Falha ao re-inserir card");
                        }
                    }, 100);

                    return novoStatus;
                } catch (error) {
                    console.error(
                        "❌ Erro ao forçar atualização de status:",
                        error
                    );
                    return null;
                }
            }

            /**
             * Testa especificamente o caso "Retirado em Pauta"
             */
            function testarCasoRetirado() {
                log("🧪 TESTE: Testando caso específico 'Retirado em Pauta'");

                // Texto de exemplo do usuário
                const textoExemplo =
                    "Mérito (Retirado em Pauta em 10/04/2025 - CAMPUB5)";
                log(`📝 Texto de exemplo: "${textoExemplo}"`);

                // Testar regex específico
                const regexRetirado =
                    /([A-Za-zÀ-ÿ\s]+(?:Interno|Declaração|Mérito|Preliminar|Cautelar))\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi;

                const match = textoExemplo.match(regexRetirado);
                log("🔍 Match resultado:", match);

                if (match) {
                    regexRetirado.lastIndex = 0;
                    const detalhes = regexRetirado.exec(textoExemplo);
                    log("📋 Detalhes extraídos:", detalhes);

                    if (detalhes) {
                        const resultado = {
                            tipo: detalhes[1]?.trim(),
                            data: detalhes[2],
                            orgao: detalhes[3],
                            status: "Retirado",
                            descricao: "Processo Retirado de Pauta",
                        };

                        log("✅ RESULTADO:", resultado);

                        // Testar cores e textos
                        const textoCard = obterTextoCardPorStatus({
                            status: "Retirado",
                        });
                        const corCard = obterCorCardPorStatus({
                            status: "Retirado",
                        });

                        log(`🎨 Texto do card: "${textoCard}"`);
                        log(`🎨 Cor do card: ${corCard}`);

                        return resultado;
                    }
                } else {
                    logError(
                        "❌ FALHA: Regex não funcionou com o texto de exemplo"
                    );
                }

                // Buscar na seção específica das minutas
                log("🔍 Procurando na seção de minutas...");
                const minutasElement = document.getElementById("fldMinutas");
                if (minutasElement) {
                    const textoMinutas =
                        minutasElement.innerText ||
                        minutasElement.textContent ||
                        "";
                    log(
                        `📝 Texto das minutas encontrado (${textoMinutas.length} chars):`,
                        textoMinutas.substring(0, 200) + "..."
                    );

                    const matchMinutas = textoMinutas.match(regexRetirado);
                    if (matchMinutas) {
                        log(
                            "✅ Padrão 'Retirado' encontrado nas minutas:",
                            matchMinutas
                        );

                        // Simular detecção correta
                        regexRetirado.lastIndex = 0;
                        const detalhesMinutas =
                            regexRetirado.exec(textoMinutas);
                        if (detalhesMinutas) {
                            const resultadoMinutas = {
                                tipo: detalhesMinutas[1]?.trim(),
                                data: detalhesMinutas[2],
                                orgao: detalhesMinutas[3],
                                status: "Retirado",
                                descricao: "Processo Retirado de Pauta",
                            };
                            log("✅ RESULTADO DAS MINUTAS:", resultadoMinutas);
                            return resultadoMinutas;
                        }
                    } else {
                        logError(
                            "❌ Padrão 'Retirado' não encontrado nas minutas"
                        );

                        // Verificar padrões mais simples
                        if (/retirado/i.test(textoMinutas)) {
                            logError(
                                "⚠️ Palavra 'retirado' encontrada nas minutas"
                            );
                            log(
                                "📝 Contexto:",
                                textoMinutas.match(/(.{0,50}retirado.{0,50})/gi)
                            );
                        }
                    }
                } else {
                    logError("❌ Elemento #fldMinutas não encontrado");
                }

                // Verificar em toda a página como fallback
                log("🔍 Testando na página completa...");
                const textoCompleto = document.body.innerText;
                const matchPagina = textoCompleto.match(regexRetirado);

                if (matchPagina) {
                    log("✅ Encontrado padrão 'Retirado' na página");
                } else {
                    logError("❌ Padrão 'Retirado' não encontrado na página");

                    // Verificar se há pelo menos a palavra "retirado"
                    if (/retirado/i.test(textoCompleto)) {
                        log(
                            "⚠️ Palavra 'retirado' encontrada, mas não no padrão esperado"
                        );
                        const contextosRetirado = textoCompleto.match(
                            /(.{0,80}retirado.{0,80})/gi
                        );
                        if (contextosRetirado) {
                            log(
                                "📝 Contextos encontrados:",
                                contextosRetirado.slice(0, 3)
                            );
                        }
                    } else {
                        logError(
                            "❌ Palavra 'retirado' não encontrada na página"
                        );
                    }
                }

                return null;
            }

            /**
             * Debug completo do status da sessão
             */
            function debugStatusCompleto() {
                log("🧪 DEBUG STATUS COMPLETO: Verificando detecção de status");

                // 1. Verificar estado atual
                log("📊 ESTADO ATUAL:");
                log("   Data sessão pautado:", dataSessaoPautado);
                log("   Processo atual:", processoAtual);
                log("   Processo com data:", processoComDataSessao);

                // 2. Executar detecção de status
                log("🔍 EXECUTANDO DETECÇÃO:");
                const statusDetectado = detectarStatusSessao();
                log("   Status detectado:", statusDetectado);

                // 3. Verificar status armazenado
                log("💾 STATUS ARMAZENADO:");
                const statusArmazenado = getStatusSessao();
                log("   Status via getStatusSessao():", statusArmazenado);

                // 4. Verificar texto na página
                const textoCompleto = document.body.innerText;
                log("📝 VERIFICAÇÕES DE TEXTO:");

                // Procurar por diferentes padrões
                const padroes = [
                    { nome: "Retirado", regex: /retirado\s+em\s+pauta/i },
                    { nome: "Julgado", regex: /julgado\s+em\s+pauta/i },
                    { nome: "Incluído", regex: /incluído\s+em\s+pauta/i },
                ];

                padroes.forEach((padrao) => {
                    const encontrado = textoCompleto.match(padrao.regex);
                    if (encontrado) {
                        log(`   ✅ ${padrao.nome}: "${encontrado[0]}"`);
                    } else {
                        logError(`   ❌ ${padrao.nome}: não encontrado`);
                    }
                });

                // 5. Simular chamada da interface
                log("🎨 SIMULAÇÃO INTERFACE:");
                const textoCard = obterTextoCardPorStatus(statusArmazenado);
                const corCard = obterCorCardPorStatus(statusArmazenado);
                log(`   Texto do card: "${textoCard}"`);
                log(`   Cor do card: ${corCard}`);

                return {
                    statusDetectado,
                    statusArmazenado,
                    textoCard,
                    corCard,
                    temTextoRetirado: /retirado\s+em\s+pauta/i.test(
                        textoCompleto
                    ),
                };
            }

            /**
             * Debug do padrão específico "Retirado"
             */
            function debugPadraoRetirado() {
                log(
                    "🧪 DEBUG RETIRADO: Testando detecção de padrão 'Retirado em Pauta'"
                );

                // Texto de exemplo fornecido pelo usuário
                const textoTeste =
                    "Mérito (Retirado em Pauta em 10/04/2025 - CAMPUB5)";
                log(`📝 Texto de teste: "${textoTeste}"`);

                // Testar o padrão regex específico
                const padraoRetirado =
                    /([A-Za-zÀ-ÿ\s]+(?:Interno|Declaração|Mérito|Preliminar|Cautelar))\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi;

                const match = textoTeste.match(padraoRetirado);
                log("🔍 Match resultado:", match);

                if (match) {
                    // Resetar lastIndex para nova busca
                    padraoRetirado.lastIndex = 0;
                    const detalhes = padraoRetirado.exec(textoTeste);
                    log("📋 Detalhes extraídos:", detalhes);

                    if (detalhes) {
                        log("✅ SUCESSO:");
                        log(`   Tipo: ${detalhes[1]?.trim()}`);
                        log(`   Data: ${detalhes[2]}`);
                        log(`   Órgão: ${detalhes[3]}`);
                        log(`   Texto completo: ${detalhes[0]}`);
                    }
                } else {
                    logError("❌ FALHA: Padrão não encontrou match");
                }

                // Testar também com o texto completo da página atual
                const textoCompleto = document.body.innerText;
                log("🔍 Testando na página atual...");

                const matchPagina = textoCompleto.match(padraoRetirado);
                if (matchPagina) {
                    log("✅ Encontrado na página:", matchPagina);
                } else {
                    logError("❌ Não encontrado na página atual");
                }

                // Procurar por qualquer texto similar
                const buscaRetirado = /retirado\s+em\s+pauta/i;
                const encontrouRetirado = textoCompleto.match(buscaRetirado);
                if (encontrouRetirado) {
                    log("🔍 Texto 'retirado em pauta' encontrado na página");
                } else {
                    log(
                        "❌ Texto 'retirado em pauta' NÃO encontrado na página"
                    );
                }
            }

            /**
             * Função para procurar texto específico "Retirado em Pauta" em toda a página
             */
            function encontrarTextoRetirado() {
                log(
                    "🔍 BUSCA: Procurando texto 'Retirado em Pauta' em toda a página"
                );

                // 1. Buscar em elementos específicos primeiro
                const seletores = [
                    "#fldMinutas",
                    "#divInfraAreaProcesso",
                    "#conteudoMinutas",
                    ".infraEventoDescricao",
                    "[id*='minutas']",
                    "[class*='minutas']",
                ];

                seletores.forEach((seletor) => {
                    const elemento = document.querySelector(seletor);
                    if (elemento) {
                        const texto =
                            elemento.innerText || elemento.textContent || "";
                        if (/retirado\s+em\s+pauta/i.test(texto)) {
                            log(
                                `✅ ENCONTRADO em ${seletor}:`,
                                texto.substring(0, 200)
                            );

                            // Buscar o padrão específico
                            const regex =
                                /([A-Za-zÀ-ÿ\s]+(?:Interno|Declaração|Mérito|Preliminar|Cautelar))\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi;
                            const match = texto.match(regex);
                            if (match) {
                                log(
                                    `🎯 PADRÃO ENCONTRADO em ${seletor}:`,
                                    match
                                );
                            }
                        } else {
                            logError(`❌ Não encontrado em ${seletor}`);
                        }
                    } else {
                        logError(`❌ Elemento ${seletor} não existe`);
                    }
                });

                // 2. Buscar em toda a página
                const textoCompleto = document.body.innerText;
                const matches = textoCompleto.match(
                    /(.{0,100}retirado\s+em\s+pauta.{0,100})/gi
                );
                if (matches) {
                    log("🔍 CONTEXTOS 'Retirado em Pauta' na página:");
                    matches.forEach((match, index) => {
                        log(`   ${index + 1}: ${match}`);
                    });
                } else {
                    log(
                        "❌ Texto 'Retirado em Pauta' não encontrado na página"
                    );
                }

                // 3. Testar regex completo na página
                const regexCompleto =
                    /([A-Za-zÀ-ÿ\s]+(?:Interno|Declaração|Mérito|Preliminar|Cautelar))\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi;
                const matchCompleto = textoCompleto.match(regexCompleto);
                if (matchCompleto) {
                    log("✅ REGEX COMPLETO funcionou:", matchCompleto);
                } else {
                    logError("❌ REGEX COMPLETO não encontrou nada");
                }

                return {
                    encontrouTexto: matches ? true : false,
                    contextos: matches || [],
                    matchRegex: matchCompleto || [],
                };
            }

            /**
             * Força uma re-detecção completa com logging detalhado
             */
            function forcarDeteccaoCompleta() {
                log("🔄 FORÇA: Iniciando detecção completa com debug");

                // 1. Procurar texto primeiro
                encontrarTextoRetirado();

                // 2. Executar detecção normal
                const statusDetectado = detectarStatusSessao();
                log("🎯 Status detectado:", statusDetectado);

                // 3. Forçar atualização se necessário
                if (statusDetectado) {
                    // Atualizar dados globais
                    if (hasDataSessaoPautado()) {
                        dataSessaoPautado.statusSessao = statusDetectado;
                        log("✅ Dados globais atualizados");
                    }

                    // Re-inserir interface
                    forcarAtualizacaoStatus();
                } else {
                    log(
                        "❌ Nenhum status detectado - verifique se a página contém dados de sessão"
                    );
                }

                return statusDetectado;
            }

            // ========================================
            // ❌ SEÇÃO COMENTADA: FUNÇÕES DUPLICADAS DE PDF
            // ========================================
            // ✅ Nossa implementação principal está nas linhas 8061-8175
            // ❌ Estas funções eram parte do sistema antigo complexo

            /*
        **
         * ESTRATÉGIA 1: Extrair texto via seleção automática
         *
        async function tryExtractTextViaSelection(pdfElement) {
            try {
                log("  Tentando extração via seleção automática...");

                // Focar no elemento PDF
                pdfElement.focus();
                await new Promise((resolve) => setTimeout(resolve, 500));

                // Simular Ctrl+A para selecionar todo o texto
                const selectAllEvent = new KeyboardEvent("keydown", {
                    key: "a",
                    code: "KeyA",
                    ctrlKey: true,
                    metaKey: false,
                    bubbles: true,
                    cancelable: true,
                });

                pdfElement.dispatchEvent(selectAllEvent);
                await new Promise((resolve) => setTimeout(resolve, 1000));

                // Tentar obter texto selecionado
                const selectedText = window.getSelection().toString();
                if (selectedText && selectedText.length > 50) {
                    log(" Texto obtido via getSelection()");
                    return selectedText;
                }

                // Simular Ctrl+C para copiar
                const copyEvent = new KeyboardEvent("keydown", {
                    key: "c",
                    code: "KeyC",
                    ctrlKey: true,
                    metaKey: false,
                    bubbles: true,
                    cancelable: true,
                });

                pdfElement.dispatchEvent(copyEvent);
                await new Promise((resolve) => setTimeout(resolve, 500));

                // Tentar ler do clipboard
                try {
                    const clipboardText = await navigator.clipboard.readText();
                    if (clipboardText && clipboardText.length > 50) {
                        log(" Texto obtido via clipboard após Ctrl+C");
                        return clipboardText;
                    }
                } catch (clipError) {
                    log(" Acesso negado ao clipboard");
                }

                return null;
            } catch (error) {
                log(` Erro na seleção automática: ${error.message}`);
                return null;
            }
        }

        /**
         * ESTRATÉGIA 2: Extrair texto via PDF.js
         */
            async function tryExtractTextViaPdfJs(pdfElement) {
                try {
                    log("📚 Tentando extração via PDF.js...");

                    const pdfUrl = pdfElement.src;
                    if (
                        !pdfUrl ||
                        pdfUrl.startsWith("blob:") ||
                        pdfUrl.startsWith("data:")
                    ) {
                        log(" URL do PDF não é adequada para PDF.js");
                        return null;
                    }

                    // Carregar PDF.js se necessário
                    if (typeof pdfjsLib === "undefined") {
                        log("📦 Carregando PDF.js...");
                        await loadPdfJsLibrary();
                    }

                    log(`  Processando PDF: ${pdfUrl}`);
                    const pdf = await pdfjsLib.getDocument(pdfUrl).promise;
                    let fullText = "";

                    // Extrair texto de todas as páginas (limitado a 10 páginas para performance)
                    const numPages = Math.min(pdf.numPages, 10);
                    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                        const page = await pdf.getPage(pageNum);
                        const textContent = await page.getTextContent();

                        const pageText = textContent.items
                            .filter(
                                (item) => item.str && item.str.trim().length > 0
                            )
                            .map((item) => item.str)
                            .join(" ");

                        if (pageText.trim()) {
                            fullText += pageText + "\n\n";
                        }

                        // Mostrar progresso
                        if (numPages > 1) {
                            showNotification(
                                ` Processando página ${pageNum}/${numPages}...`,
                                "info"
                            );
                        }
                    }

                    if (fullText.trim().length > 50) {
                        log(
                            ` PDF.js extraiu ${fullText.length} caracteres de ${numPages} páginas`
                        );
                        return fullText.trim();
                    }

                    return null;
                } catch (error) {
                    log(` Erro no PDF.js: ${error.message}`);
                    return null;
                }
            }

            /**
             * ❌ ESTRATÉGIA DESABILITADA: Fetch direto do PDF (violava políticas do eProc)
             */
            async function tryExtractTextViaFetch(pdfElement) {
                console.log(
                    "❌ FETCH PDF DESABILITADO: Esta função foi desabilitada por violação às políticas do eProc"
                );
                return null; // Sempre retorna null
            }

            /**
             * ESTRATÉGIA 4: Extrair via clipboard com comandos específicos
             */
            async function tryExtractTextViaClipboard(pdfElement) {
                try {
                    log(" Tentando extração via clipboard...");

                    // Limpar clipboard primeiro
                    try {
                        await navigator.clipboard.writeText("");
                    } catch (e) {
                        log(" Não foi possível limpar clipboard");
                    }

                    // Focar e tentar diferentes combinações de teclas
                    pdfElement.focus();
                    await new Promise((resolve) => setTimeout(resolve, 500));

                    // Tentar Ctrl+A seguido de Ctrl+C
                    document.execCommand("selectAll");
                    await new Promise((resolve) => setTimeout(resolve, 300));
                    document.execCommand("copy");
                    await new Promise((resolve) => setTimeout(resolve, 500));

                    // Verificar clipboard
                    try {
                        const clipboardText =
                            await navigator.clipboard.readText();
                        if (clipboardText && clipboardText.trim().length > 50) {
                            log(" Texto obtido via execCommand");
                            return clipboardText.trim();
                        }
                    } catch (clipError) {
                        log(" Acesso negado ao clipboard após execCommand");
                    }

                    return null;
                } catch (error) {
                    log(` Erro na extração via clipboard: ${error.message}`);
                    return null;
                }
            }

            /**
             * Carrega a biblioteca PDF.js dinamicamente
             */
            async function loadPdfJsLibrary() {
                if (typeof pdfjsLib !== "undefined") {
                    return;
                }

                log("📦 Carregando PDF.js...");

                // Carregar PDF.js da CDN
                const script = document.createElement("script");
                script.src =
                    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
                document.head.appendChild(script);

                await new Promise((resolve, reject) => {
                    script.onload = () => {
                        log(" PDF.js carregado com sucesso");
                        // Configurar worker
                        if (typeof pdfjsLib !== "undefined") {
                            pdfjsLib.GlobalWorkerOptions.workerSrc =
                                "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
                        }
                        resolve();
                    };
                    script.onerror = () => {
                        log(" Erro ao carregar PDF.js");
                        reject(new Error("Falha ao carregar PDF.js"));
                    };
                });

                // Aguardar inicialização
                await new Promise((resolve) => setTimeout(resolve, 1000));
            }

            /**
             * Limpa e normaliza texto extraído de PDF
             */
            function cleanExtractedText(text) {
                return text
                    .replace(/\r\n/g, "\n") // Normalizar quebras de linha
                    .replace(/\r/g, "\n") // Normalizar quebras de linha
                    .replace(/\n{3,}/g, "\n\n") // Reduzir quebras de linha excessivas
                    .replace(/\s+/g, " ") // Normalizar espaços múltiplos
                    .replace(/([.!?])\s*([A-ZÁÊÇ])/g, "$1\n\n$2") // Quebrar em parágrafos
                    .trim();
            }

            /**
             * Trata erros na extração de texto e oferece soluções
             */
            async function handleTextExtractionError(error, pdfElement) {
                const pdfUrl = pdfElement?.src || "";

                log(" Tentativas diretas falharam, oferecendo alternativas");

                showNotification(
                    " Extração automática não foi possível!\n\n" +
                        "Métodos alternativos:\n" +
                        "1. Selecione o texto manualmente no PDF (Ctrl+A, Ctrl+C)\n" +
                        "2. Baixe o PDF e use Perplexity/Claude com upload\n" +
                        "3. Use ferramenta de conversão PDF para texto\n\n" +
                        " Alguns PDFs têm proteções que impedem extração automática.",
                    "warning"
                );

                // Tentar iniciar download automático como fallback
                await tryAutoDownloadPDF(pdfUrl);

                return null;
            }

            /**
             * Tenta extrair texto direto do PDF usando APIs nativas
             */
            async function tryExtractDirectPdfText(pdfElement) {
                try {
                    log(" Tentando extração direta de texto do PDF...");

                    // Verificar se é um PDF embedado do Chrome
                    if (
                        pdfElement.type === "application/pdf" ||
                        pdfElement.type === "application/x-google-chrome-pdf"
                    ) {
                        // Tentar selecionar tudo no PDF e copiar
                        pdfElement.focus();

                        // Simular Ctrl+A para selecionar todo o texto
                        const selectAllEvent = new KeyboardEvent("keydown", {
                            key: "a",
                            ctrlKey: true,
                            bubbles: true,
                        });
                        pdfElement.dispatchEvent(selectAllEvent);

                        await new Promise((resolve) =>
                            setTimeout(resolve, 500)
                        );

                        // Tentar ler da clipboard se possível
                        try {
                            if (
                                navigator.clipboard &&
                                navigator.clipboard.readText
                            ) {
                                const clipboardText =
                                    await navigator.clipboard.readText();
                                if (
                                    clipboardText &&
                                    clipboardText.length > 100
                                ) {
                                    log(" Texto extraído via clipboard");
                                    return clipboardText;
                                }
                            }
                        } catch (clipboardError) {
                            log(" Acesso ao clipboard negado");
                        }
                    }

                    // Tentar outras abordagens para PDFs
                    const pdfUrl = pdfElement.src;
                    if (pdfUrl && !pdfUrl.startsWith("blob:")) {
                        // Tentar carregar PDF.js se disponível
                        if (typeof pdfjsLib !== "undefined") {
                            log("📚 Tentando PDF.js para extração...");
                            const pdf = await pdfjsLib.getDocument(pdfUrl)
                                .promise;
                            const page = await pdf.getPage(1);
                            const textContent = await page.getTextContent();

                            const text = textContent.items
                                .map((item) => item.str)
                                .join(" ");
                            if (text.length > 100) {
                                log(" Texto extraído via PDF.js");
                                return text;
                            }
                        }
                    }

                    return null;
                } catch (error) {
                    log(` Extração direta falhou: ${error.message}`);
                    return null;
                }
            }

            /**
             * Captura imagem do PDF para OCR usando múltiplas estratégias
             */
            async function captureImageForOCR(pdfElement) {
                try {
                    showNotification("  Capturando imagem do PDF...", "info");

                    // Método 1: html2canvas (mais confiável)
                    const canvasFromHtml2Canvas = await tryHtml2Canvas(
                        pdfElement
                    );
                    if (canvasFromHtml2Canvas) {
                        log(" Captura via html2canvas bem-sucedida");
                        return canvasFromHtml2Canvas;
                    }

                    // Método 2: Canvas nativo
                    log(" Tentando captura via canvas nativo...");
                    const canvasNativo = await tryNativeCanvas(pdfElement);
                    if (canvasNativo) {
                        log(" Captura via canvas nativo bem-sucedida");
                        return canvasNativo;
                    }

                    // Método 3: Usar screenshot da viewport
                    log(" Tentando captura da viewport...");
                    const viewportCanvas = await tryViewportCapture(pdfElement);
                    if (viewportCanvas) {
                        log(" Captura da viewport bem-sucedida");
                        return viewportCanvas;
                    }

                    throw new Error("Todos os métodos de captura falharam");
                } catch (error) {
                    log(` Erro na captura de imagem: ${error.message}`);
                    return null;
                }
            }

            /**
             * Tenta download automático do PDF
             */
            async function tryAutoDownloadPDF(pdfUrl) {
                if (
                    !pdfUrl ||
                    pdfUrl.startsWith("blob:") ||
                    pdfUrl.startsWith("chrome-extension:")
                ) {
                    return;
                }

                try {
                    log(" Tentando download automático do PDF...");
                    const link = document.createElement("a");
                    link.href = pdfUrl;
                    link.download = "documento-eproc.pdf";
                    link.style.display = "none";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    showNotification(
                        "Download iniciado! Use o arquivo com Perplexity/Claude.",
                        "info"
                    );
                } catch (downloadError) {
                    log(
                        ` Download automático falhou: ${downloadError.message}`
                    );
                }
            }

            // Modal customizado para opções de preview
            function showPreviewOptionsModal() {
                return new Promise((resolve) => {
                    const overlay = document.createElement("div");
                    overlay.className = "help-modal-overlay";
                    overlay.innerHTML = `
 <div class="help-modal" style="max-width: 420px;">
 <div class="help-modal-header">
 <h2 style="font-size:1.1rem;display:flex;align-items:center;gap:8px;">
 <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:1.2em;height:1.2em;">
 <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/>
 <circle cx="12" cy="12" r="3"/>
 </svg>
 Texto Extraído
 </h2>
 <button class="help-close-btn" aria-label="Fechar">
 <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 6-12 12" /><path d="m6 6 12 12" /></svg>
 </button>
 </div>
 <div class="help-modal-content" style="padding:24px 20px 20px 20px;">
 <div style="margin-bottom:18px;display:flex;align-items:center;gap:8px;">
 <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:1.1em;height:1.1em;color:#134377;"><polyline points="20 6 9 17 4 12" /></svg>
 <span style="color:rgb(var(--color-text-main));font-size:1rem;">Texto extraído com sucesso!</span>
 </div>
 <p style="color:rgb(var(--color-text-muted));margin-bottom:20px;line-height:1.5;">Deseja visualizar o preview do texto antes de copiar?</p>
 <div style="display:flex;gap:12px;justify-content:flex-end;">
 <button class="btn primary" id="preview-yes-btn" style="min-width:100px;">Ver Preview</button>
 <button class="btn" id="preview-no-btn" style="min-width:120px;">Copiar Direto</button>
 </div>
 </div>
 </div>
 `;
                    document.body.appendChild(overlay);
                    const close = (result) => {
                        document.body.removeChild(overlay);
                        resolve(result);
                    };
                    overlay.querySelector(".help-close-btn").onclick = () =>
                        close(false);
                    overlay.querySelector("#preview-yes-btn").onclick = () =>
                        close(true);
                    overlay.querySelector("#preview-no-btn").onclick = () =>
                        close(false);
                    overlay.addEventListener("click", (e) => {
                        if (e.target === overlay) close(false);
                    });
                });
            }

            // Modal customizado para opções de processamento de documento
            function showDocumentProcessingModal() {
                return new Promise((resolve) => {
                    const overlay = document.createElement("div");
                    overlay.className = "help-modal-overlay";
                    overlay.innerHTML = `
                        <div class="help-modal" style="max-width: 450px;">
                        <div class="help-modal-header">
                        <h2 style="font-size:1.1rem;display:flex;align-items:center;gap:8px;">
                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:1.2em;height:1.2em;">
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                        <polyline points="14,2 14,8 20,8"/>
                        <line x1="16" y1="13" x2="8" y2="13"/>
                        <line x1="16" y1="17" x2="8" y2="17"/>
                        <polyline points="10,9 9,9 8,9"/>
                        </svg>
                        Documento Selecionado
                        </h2>
                        <button class="help-close-btn" aria-label="Fechar">
                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 6-12 12" /><path d="m6 6 12 12" /></svg>
                        </button>
                        </div>
                        <div class="help-modal-content" style="padding:24px 20px 20px 20px;">
                        <p style="color:rgb(var(--color-text-main));margin-bottom:20px;line-height:1.5;">Como deseja processar o documento selecionado?</p>
                        <div style="margin-bottom:20px;">
                        <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px;padding:12px;border-radius:8px;background:rgb(var(--color-background-alt3));">
                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:1.2em;height:1.2em;color:#134377;flex-shrink:0;">
                        <path d="M15 3h6v6"/>
                        <path d="M10 14 21 3"/>
                        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
                        </svg>
                        <div>
                        <div style="color:rgb(var(--color-text-main));font-weight:500;margin-bottom:4px;">Processamento Manual</div>
                        <div style="color:rgb(var(--color-text-muted));font-size:0.9rem;">Abre o documento em nova aba para extração manual</div>
                        </div>
                        </div>
                        <div style="display:flex;align-items:center;gap:12px;padding:12px;border-radius:8px;background:rgb(var(--color-background-alt3));">
                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:1.2em;height:1.2em;color:#f59e0b;flex-shrink:0;">
                        <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                        <line x1="12" y1="19" x2="12" y2="22"/>
                        <line x1="8" y1="22" x2="16" y2="22"/>
                        </svg>
                        <div>
                        <div style="color:rgb(var(--color-text-main));font-weight:500;margin-bottom:4px;">Processamento via API</div>
                        <div style="color:rgb(var(--color-text-muted));font-size:0.9rem;">Tenta processar diretamente (experimental)</div>
                        </div>
                        </div>
                        </div>
                        <div style="display:flex;gap:12px;justify-content:flex-end;">
                        <button class="btn primary" id="process-manual-btn" style="min-width:120px;">Manual</button>
                        <button class="btn" id="process-api-btn" style="min-width:100px;">Via API</button>
                        </div>
                        </div>
                        </div>
                        `;
                    document.body.appendChild(overlay);
                    const close = (result) => {
                        document.body.removeChild(overlay);
                        resolve(result);
                    };
                    overlay.querySelector(".help-close-btn").onclick = () =>
                        close(true);
                    overlay.querySelector("#process-manual-btn").onclick = () =>
                        close(true);
                    overlay.querySelector("#process-api-btn").onclick = () =>
                        close(false);
                    overlay.addEventListener("click", (e) => {
                        if (e.target === overlay) close(true);
                    });
                });
            }

            // Formatar informações de magistrado/advogado
            function formatarMagistradoAdvogado(texto) {
                if (!texto || texto.trim().length === 0) {
                    return "";
                }

                let textoLimpo = texto.trim();

                // Remover tags HTML (incluindo <br/> e <br>)
                textoLimpo = textoLimpo.replace(/<br\s*\/?>/gi, "\n");
                textoLimpo = textoLimpo.replace(/<[^>]*>/g, "");

                // Separar em linhas e filtrar conteúdo útil
                const linhas = textoLimpo
                    .split(/\n/)
                    .map((l) => l.trim())
                    .filter((l) => l.length > 0)
                    .filter((l) => !l.match(/^(MAGISTRADO|ADVOGADO)$/i)); // Remover labels extras

                // Detectar se é magistrado ou advogado baseado em palavras-chave
                const isMagistrado =
                    /juiz|juíz|magistrad|vara|gabinete|comarca/i.test(
                        textoLimpo
                    );

                if (isMagistrado) {
                    // Para magistrados: procurar nome da pessoa e informação da vara
                    let nomePessoa = "";
                    let infoVara = "";

                    for (const linha of linhas) {
                        // Se a linha contém palavras típicas de vara/gabinete, é info de vara
                        if (/\d+[ªº]?\s*(vara|gabinete|comarca)/i.test(linha)) {
                            infoVara = linha;
                        }
                        // Se é um nome de pessoa (contém pelo menos 2 palavras com letras)
                        else if (
                            /^[A-ZÁÊÇÕÜÀÁÉÊÍÓÔÚÂÃ\s]{3,}$/i.test(linha) &&
                            linha.split(" ").length >= 2
                        ) {
                            // Capitalizar corretamente o nome (primeira letra maiúscula, resto minúscula)
                            nomePessoa = linha
                                .toLowerCase()
                                .split(" ")
                                .map(
                                    (palavra) =>
                                        palavra.charAt(0).toUpperCase() +
                                        palavra.slice(1)
                                )
                                .join(" ");
                        }
                    }

                    // Se encontrou nome e vara, retornar objeto com ambos
                    if (nomePessoa && infoVara) {
                        return {
                            tipo: "magistrado",
                            nome: `Magistrado(a): ${nomePessoa}`,
                            vara: infoVara,
                        };
                    }
                    // Se só encontrou nome
                    else if (nomePessoa) {
                        return {
                            tipo: "magistrado",
                            nome: `Magistrado(a): ${nomePessoa}`,
                            vara: null,
                        };
                    }
                    // Se só encontrou vara
                    else if (infoVara) {
                        return {
                            tipo: "magistrado",
                            nome: `Magistrado(a): ${infoVara}`,
                            vara: null,
                        };
                    }
                    // Fallback: usar primeira linha útil
                    else if (linhas.length > 0) {
                        const primeiraLinha = linhas[0]
                            .toLowerCase()
                            .split(" ")
                            .map(
                                (palavra) =>
                                    palavra.charAt(0).toUpperCase() +
                                    palavra.slice(1)
                            )
                            .join(" ");
                        return {
                            tipo: "magistrado",
                            nome: `Magistrado(a): ${primeiraLinha}`,
                            vara: null,
                        };
                    }
                } else {
                    // Para advogados: usar a primeira linha que parece um nome
                    let nomeAdvogado =
                        linhas.find(
                            (linha) =>
                                /^[A-ZÁÊÇÕÜÀÁÉÊÍÓÔÚÂÃ\s]{3,}$/i.test(linha) &&
                                linha.split(" ").length >= 2
                        ) || linhas[0];

                    if (nomeAdvogado) {
                        // Capitalizar corretamente o nome do advogado
                        nomeAdvogado = nomeAdvogado
                            .toLowerCase()
                            .split(" ")
                            .map(
                                (palavra) =>
                                    palavra.charAt(0).toUpperCase() +
                                    palavra.slice(1)
                            )
                            .join(" ");
                        return {
                            tipo: "advogado",
                            nome: `Advogado(a): ${nomeAdvogado}`,
                            vara: null,
                        };
                    }
                }

                // Fallback final
                return textoLimpo;
            }

            // ⚠️ NOTA: Observer de interface foi removido desta seção pois setupInterfaceObserver()
            // está definido dentro da IIFE principal e não é acessível aqui.
            // A inicialização do observer já é feita corretamente dentro da IIFE principal.

            // Função auxiliar para validar data brasileira
            // 🔍 IDENTIFICAR PROCESSO - Extrair número do processo atual (COM CACHE ANTI-LOOP)
            // Variáveis já declaradas no topo do arquivo

            function validarDataBrasileira(dataString) {
                log(`📅 VALIDAÇÃO: Validando data "${dataString}"`);

                // Limpar e normalizar a string da data
                const dataLimpa = dataString.trim().replace(/[^\d\/\-\.]/g, "");
                log(`📅 VALIDAÇÃO: Data limpa: "${dataLimpa}"`);

                // Tentar diferentes separadores
                const separadores = ["/", "-", "."];
                let partesData = null;
                let separadorUsado = "";

                for (const sep of separadores) {
                    if (dataLimpa.includes(sep)) {
                        partesData = dataLimpa.split(sep);
                        separadorUsado = sep;
                        break;
                    }
                }

                if (!partesData || partesData.length !== 3) {
                    log(
                        `❌ VALIDAÇÃO: Formato inválido - esperado 3 partes separadas por ${separadores.join(
                            ", "
                        )}`
                    );
                    return null;
                }

                // Assumir formato brasileiro: DD/MM/AAAA
                const dia = parseInt(partesData[0], 10);
                const mes = parseInt(partesData[1], 10);
                const ano = parseInt(partesData[2], 10);

                log(
                    `📅 VALIDAÇÃO: Partes extraídas - Dia: ${dia}, Mês: ${mes}, Ano: ${ano}`
                );

                // Validações básicas
                if (isNaN(dia) || isNaN(mes) || isNaN(ano)) {
                    logError("❌ VALIDAÇÃO: Partes não são números válidos");
                    return null;
                }

                if (dia < 1 || dia > 31) {
                    log(
                        `❌ VALIDAÇÃO: Dia inválido: ${dia} (deve estar entre 1 e 31)`
                    );
                    return null;
                }

                if (mes < 1 || mes > 12) {
                    log(
                        `❌ VALIDAÇÃO: Mês inválido: ${mes} (deve estar entre 1 e 12)`
                    );
                    return null;
                }

                if (ano < 2020 || ano > 2030) {
                    log(
                        `❌ VALIDAÇÃO: Ano inválido: ${ano} (deve estar entre 2020 e 2030)`
                    );
                    return null;
                }

                // Criar objeto Date para validação mais rigorosa
                const dataObj = new Date(ano, mes - 1, dia); // mes-1 porque Date usa 0-based months

                if (
                    dataObj.getFullYear() !== ano ||
                    dataObj.getMonth() !== mes - 1 ||
                    dataObj.getDate() !== dia
                ) {
                    log(
                        `❌ VALIDAÇÃO: Data inexistente no calendário: ${dia}/${mes}/${ano}`
                    );
                    return null;
                }

                log(
                    `✅ VALIDAÇÃO: Data válida confirmada: ${dia}/${mes}/${ano}`
                );

                // Criar objeto de retorno com informações estruturadas
                const dataValidada = {
                    dataOriginal: dataString,
                    dataFormatada: `${dia.toString().padStart(2, "0")}/${mes
                        .toString()
                        .padStart(2, "0")}/${ano}`,
                    dia: dia,
                    mes: mes,
                    ano: ano,
                    timestamp: dataObj.getTime(),
                    dataObj: dataObj,
                };

                logCritical(
                    `✅ VALIDAÇÃO: Objeto de data criado:`,
                    dataValidada
                );
                return dataValidada;
            }

            // FUNÇÃO REMOVIDA: detectarDataSessao - substituída por detectarCardSessaoSimplificado ÚNICA

            // 🔍 FUNÇÃO PARA VERIFICAR STATUS DOS CONTROLES
            function statusControlesRequisicao() {
                const agora = Date.now();
                const info = {
                    tentativasRealizadas: tentativasCruzamento,
                    tentativasRestantes:
                        MAX_TENTATIVAS_CRUZAMENTO - tentativasCruzamento,
                    emAndamento: cruzamentoEmAndamento,
                    proximaTentativaEm: Math.max(
                        0,
                        (DELAY_ENTRE_TENTATIVAS -
                            (agora - ultimaTentativaCruzamento)) /
                            1000
                    ),
                    temCache: !!cacheResultadoSessoes,
                    cacheValidoPor: Math.max(
                        0,
                        (cacheValidoAte - agora) / 1000
                    ),
                };

                log("📊 STATUS DOS CONTROLES:", info);
                return info;
            }

            function showDataSessaoPautadoInfo() {
                if (hasDataSessaoPautado()) {
                    const info = `Clique para mais informações`;

                    log(info);
                    alert(info);
                    return dataSessaoPautado;
                } else {
                    const msg =
                        "❌ Nenhuma data da sessão foi detectada ainda.";
                    log(msg);
                    alert(msg);
                    return null;
                }
            }

            // Função para remover data da sessão da interface
            // VERSÃO MATERIAL DESIGN - Remove apenas cards Material Design
            function removerDataSessaoDaInterface() {
                log("🗑️ REMOVER: Removendo cards Material Design da interface");

                return removerCardMaterialDesign();
            }

            // Função para atualizar data da sessão na interface
            // VERSÃO SIMPLIFICADA - Usa sistema XPath direto
            function atualizarDataSessaoNaInterface() {
                log("🔄 ATUALIZAR: Usando sistema XPath simplificado...");

                // Remover cards antigos
                removerDataSessaoDaInterface();

                // Usar sistema simplificado
                return window.SENT1_AUTO &&
                    window.SENT1_AUTO.detectarCardSessaoSimplificado
                    ? window.SENT1_AUTO.detectarCardSessaoSimplificado()
                    : null;
            }

            // 🚨 FUNÇÃO PARA FORÇAR INSERÇÃO DO CARD MESMO PARA PROCESSOS PROCESSADOS
            function forcarInsercaoCardSemValidacao() {
                log("🚨 FORÇA: Forçando inserção do card sem validações");

                // 1. Verificar se há data detectada
                if (!hasDataSessaoPautado()) {
                    logError(
                        "❌ FORÇA: Nenhuma data detectada - tentando detectar"
                    );

                    // Forçar detecção mesmo para processo já processado
                    const processoAnterior = processoAtual;
                    const jaProcessadoAnterior = processoAnterior
                        ? processosJaProcessados.has(processoAnterior)
                        : false;

                    if (jaProcessadoAnterior) {
                        log(
                            "🔄 FORÇA: Removendo processo da lista de processados temporariamente"
                        );
                        processosJaProcessados.delete(processoAnterior);
                    }

                    // Detectar data
                    const dataDetectada =
                        window.SENT1_AUTO &&
                        window.SENT1_AUTO.detectarCardSessaoSimplificado
                            ? window.SENT1_AUTO.detectarCardSessaoSimplificado()
                            : null;

                    if (!dataDetectada) {
                        logError("❌ FORÇA: Falha na detecção da data");
                        if (jaProcessadoAnterior) {
                            processosJaProcessados.add(processoAnterior);
                        }
                        return false;
                    }
                }

                // 2. Remover card existente
                const cardExistente =
                    document.getElementById("eprobe-data-sessao");
                if (cardExistente) {
                    cardExistente.remove();
                    log("🗑️ FORÇA: Card existente removido");
                }

                // 3. Forçar inserção
                log("🎯 FORÇA: Tentando inserir card...");
                const sucesso = inserirDataSessaoNaInterface();

                if (sucesso) {
                    log("✅ FORÇA: Card inserido com sucesso!");
                    return true;
                } else {
                    logError("❌ FORÇA: Falha na inserção do card");
                    return false;
                }
            }

            // ========================================
            // ❌ SEÇÃO REMOVIDA: FUNÇÕES DE CRUZAMENTO DE DADOS DE SESSÃO
            // ✅ SUBSTITUÍDO POR: detectarSessoesUnificado() - busca específica no DOM
            // ========================================

            /**
             * Busca dados das sessões de julgamento no eProc
             * @param {string} hash - Hash da página de sessões (opcional)
             * @returns {Promise<Array>} - Array com dados das sessões
             */
            async function buscarDadosSessoes(hash = null) {
                log("🔍 SESSÕES: Iniciando busca de dados das sessões");

                // 🛡️ VERIFICAR CACHE PRIMEIRO
                const agora = Date.now();
                if (cacheResultadoSessoes && agora < cacheValidoAte) {
                    log(
                        "📦 SESSÕES: Usando dados do cache (evitando nova requisição)"
                    );
                    return cacheResultadoSessoes;
                }

                // 🛡️ VERIFICAR SE JÁ ESTÁ EM ANDAMENTO
                if (cruzamentoEmAndamento) {
                    log("⏳ SESSÕES: Busca já em andamento, aguardando...");
                    return [];
                }

                // 🛡️ VERIFICAR LIMITE DE TENTATIVAS
                if (tentativasCruzamento >= MAX_TENTATIVAS_CRUZAMENTO) {
                    log(
                        `🚫 SESSÕES: Limite de ${MAX_TENTATIVAS_CRUZAMENTO} tentativas atingido`
                    );
                    log(
                        "💡 SESSÕES: Use window.SENT1_AUTO.debugPaginaSessoes() para debug manual"
                    );
                    return [];
                }

                // 🛡️ VERIFICAR DELAY ENTRE TENTATIVAS
                if (
                    agora - ultimaTentativaCruzamento <
                    DELAY_ENTRE_TENTATIVAS
                ) {
                    const tempoRestante = Math.ceil(
                        (DELAY_ENTRE_TENTATIVAS -
                            (agora - ultimaTentativaCruzamento)) /
                            1000
                    );
                    log(
                        `⏰ SESSÕES: Aguardando ${tempoRestante}s antes da próxima tentativa`
                    );
                    return [];
                }

                try {
                    // Marcar início da busca
                    cruzamentoEmAndamento = true;
                    tentativasCruzamento++;
                    ultimaTentativaCruzamento = agora;

                    log(
                        `🔄 SESSÕES: Tentativa ${tentativasCruzamento}/${MAX_TENTATIVAS_CRUZAMENTO}`
                    );

                    // Construir URL da página de sessões
                    const baseUrl = window.location.origin;
                    const urlSessoes = hash
                        ? `${baseUrl}/eproc/controlador.php?acao=sessao_julgamento_listar&hash=${hash}`
                        : `${baseUrl}/eproc/controlador.php?acao=sessao_julgamento_listar`;

                    log(`🌐 SESSÕES: Buscando URL: ${urlSessoes}`);

                    // Fazer fetch da página
                    const response = await fetch(urlSessoes, {
                        credentials: "same-origin",
                        headers: {
                            Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                        },
                    });

                    if (!response.ok) {
                        throw new Error(
                            `HTTP ${response.status}: ${response.statusText}`
                        );
                    }

                    const htmlContent = await response.text();
                    logCritical("✅ SESSÕES: Página carregada com sucesso");

                    // Fazer parse dos dados
                    const dadosSessoes = await parsearDadosSessoes(htmlContent);
                    log(
                        `📊 SESSÕES: ${dadosSessoes.length} sessões encontradas`
                    );

                    // 📦 ARMAZENAR NO CACHE
                    if (dadosSessoes.length > 0) {
                        cacheResultadoSessoes = dadosSessoes;
                        cacheValidoAte = agora + CACHE_DURATION;
                        log(
                            "📦 SESSÕES: Resultado armazenado no cache por 5 minutos"
                        );
                    }

                    return dadosSessoes;
                } catch (error) {
                    console.error(
                        `❌ SESSÕES: Erro ao buscar dados: ${error.message}`
                    );
                    return [];
                } finally {
                    // Sempre limpar flag de andamento
                    cruzamentoEmAndamento = false;
                }
            }

            /**
             * Faz parse dos dados das sessões do HTML
             * @param {string} htmlContent - Conteúdo HTML da página
             * @returns {Array} - Array com dados estruturados das sessões
             */
            async function parsearDadosSessoes(htmlContent) {
                log("🔍 PARSE: Iniciando parse dos dados das sessões");

                try {
                    // Criar parser DOM
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(
                        htmlContent,
                        "text/html"
                    );

                    // 🔍 DEBUG: Verificar estrutura da página
                    log("📋 PARSE DEBUG: Analisando estrutura da página...");

                    // Verificar se a página foi carregada corretamente
                    const title =
                        doc.querySelector("title")?.textContent || "sem título";
                    log(`📋 PARSE DEBUG: Título da página: "${title}"`);

                    // Verificar se há redirecionamento para login
                    if (
                        title.toLowerCase().includes("login") ||
                        title.toLowerCase().includes("acesso")
                    ) {
                        log(
                            "❌ PARSE DEBUG: Página de login detectada - sessão expirada"
                        );
                        return [];
                    }

                    // Buscar diferentes seletores possíveis para a tabela
                    const seletoresTabela = [
                        "#divInfraAreaTelaD .table-responsive table.table",
                        "#divInfraAreaTelaD table.table",
                        ".table-responsive table.table",
                        "table.table",
                        "#divInfraAreaTelaD table",
                        ".table-responsive table",
                        "table",
                        "#frmLista table",
                        "#divInfraAreaTelaE table",
                    ];

                    let tabela = null;
                    let seletorUsado = "";

                    for (const seletor of seletoresTabela) {
                        tabela = doc.querySelector(seletor);
                        if (tabela) {
                            seletorUsado = seletor;
                            log(
                                `✅ PARSE DEBUG: Tabela encontrada com seletor: "${seletor}"`
                            );
                            break;
                        }
                    }

                    if (!tabela) {
                        // Debug mais detalhado se não encontrar tabela
                        log(
                            "🔍 PARSE DEBUG: Nenhuma tabela encontrada, analisando estrutura..."
                        );

                        // Verificar elementos principais
                        const divInfraAreaTelaD =
                            doc.querySelector("#divInfraAreaTelaD");
                        const tableResponsive =
                            doc.querySelector(".table-responsive");
                        const allTables = doc.querySelectorAll("table");
                        const allDivs = doc.querySelectorAll("div[id*='Area']");

                        log(
                            `📋 PARSE DEBUG: #divInfraAreaTelaD encontrado: ${!!divInfraAreaTelaD}`
                        );
                        log(
                            `📋 PARSE DEBUG: .table-responsive encontrado: ${!!tableResponsive}`
                        );
                        log(
                            `📋 PARSE DEBUG: Total de tabelas: ${allTables.length}`
                        );
                        log(
                            `📋 PARSE DEBUG: Divs com 'Area' no ID: ${allDivs.length}`
                        );

                        // Listar todas as tabelas encontradas
                        allTables.forEach((table, index) => {
                            const tableId = table.id || "sem-id";
                            const tableClass = table.className || "sem-class";
                            const rowCount =
                                table.querySelectorAll("tr").length;
                            log(
                                `📋 PARSE DEBUG: Tabela ${
                                    index + 1
                                }: id="${tableId}", class="${tableClass}", linhas=${rowCount}`
                            );
                        });

                        // Listar divs com Area no ID
                        allDivs.forEach((div, index) => {
                            log(
                                `📋 PARSE DEBUG: Div ${index + 1}: id="${
                                    div.id
                                }", class="${div.className}"`
                            );
                        });

                        // Verificar se há erro específico na página
                        const errorElements = doc.querySelectorAll(
                            ".alert-danger, .error, .erro, [class*='erro'], [class*='error']"
                        );
                        if (errorElements.length > 0) {
                            log(
                                "❌ PARSE DEBUG: Elementos de erro encontrados:"
                            );
                            errorElements.forEach((error, index) => {
                                log(
                                    `📋 PARSE DEBUG: Erro ${
                                        index + 1
                                    }: "${error.textContent.trim()}"`
                                );
                            });
                        }

                        log(
                            "❌ PARSE: Tabela de sessões não encontrada em nenhum seletor"
                        );
                        return [];
                    }

                    // Buscar todas as linhas de dados (tbody > tr)
                    const linhasSessoes = tabela.querySelectorAll(
                        'tbody tr[id^="tr_"]'
                    );
                    log(`📋 PARSE: ${linhasSessoes.length} linhas encontradas`);

                    const sessoes = [];

                    for (const linha of linhasSessoes) {
                        try {
                            const sessao = await extrairDadosLinhaSessao(linha);
                            if (sessao) {
                                sessoes.push(sessao);
                            }
                        } catch (error) {
                            console.warn(
                                `⚠️ PARSE: Erro ao processar linha: ${error.message}`
                            );
                        }
                    }

                    log(
                        `✅ PARSE: ${sessoes.length} sessões processadas com sucesso`
                    );
                    return sessoes;
                } catch (error) {
                    console.error(`❌ PARSE: Erro no parse: ${error.message}`);
                    return [];
                }
            }

            /**
             * Extrai dados de uma linha específica da tabela de sessões
             * @param {Element} linha - Elemento tr da linha
             * @returns {Object|null} - Objeto com dados da sessão ou null
             */
            async function extrairDadosLinhaSessao(linha) {
                try {
                    const id = linha.getAttribute("id");
                    const colunas = linha.querySelectorAll("td");

                    if (colunas.length < 8) {
                        console.warn(
                            `⚠️ LINHA: Linha ${id} tem ${colunas.length} colunas, esperado >= 8`
                        );
                        return null;
                    }

                    // Extrair dados conforme a estrutura HTML fornecida
                    const orgaoJulgador = colunas[1]?.textContent?.trim() || "";
                    const dataHoraSessao =
                        colunas[2]?.textContent?.trim() || "";
                    const tipoSessao = colunas[3]?.textContent?.trim() || "";
                    const localSessao = colunas[4]?.textContent?.trim() || "";
                    const dataLimitePauta =
                        colunas[5]?.textContent?.trim() || "";
                    const dataLimiteMesa =
                        colunas[6]?.textContent?.trim() || "";
                    const dataLimiteMinutas =
                        colunas[7]?.textContent?.trim() || "";
                    const statusSessao = colunas[8]?.textContent?.trim() || "";

                    // Extrair só a data da string "03/06/2025 14:00"
                    const dataMatch = dataHoraSessao.match(
                        /(\d{1,2}\/\d{1,2}\/\d{4})/
                    );
                    const dataSessao = dataMatch ? dataMatch[1] : "";

                    // Extrair só o horário
                    const horaMatch = dataHoraSessao.match(/(\d{1,2}:\d{2})/);
                    const horaSessao = horaMatch ? horaMatch[1] : "";

                    const sessao = {
                        id: id,
                        orgaoJulgador: orgaoJulgador,
                        dataSessao: dataSessao,
                        horaSessao: horaSessao,
                        dataHoraCompleta: dataHoraSessao,
                        tipoSessao: tipoSessao,
                        localSessao: localSessao,
                        dataLimitePauta: dataLimitePauta,
                        dataLimiteMesa: dataLimiteMesa,
                        dataLimiteMinutas: dataLimiteMinutas,
                        statusSessao: statusSessao,
                        // Dados adicionais
                        dataDetectada: new Date(),
                        validData: !!dataSessao,
                    };

                    log(
                        `📋 LINHA: Sessão extraída - ${traduzirSiglaOrgao(
                            orgaoJulgador
                        )} em ${dataSessao}`
                    );
                    return sessao;
                } catch (error) {
                    console.error(
                        `❌ LINHA: Erro ao extrair dados: ${error.message}`
                    );
                    return null;
                }
            }

            /**
             * Busca sessão específica por data
             * @param {string} dataProcurada - Data no formato DD/MM/AAAA
             * @param {string} hash - Hash da página (opcional)
             * @returns {Promise<Object|null>} - Dados da sessão encontrada ou null
             */
            async function buscarSessaoPorData(dataProcurada, hash = null) {
                log(`🎯 BUSCA: Procurando sessão para data: ${dataProcurada}`);

                try {
                    // Buscar todas as sessões
                    const sessoes = await buscarDadosSessoes(hash);

                    if (sessoes.length === 0) {
                        return null;
                    }

                    // Procurar sessão com a data específica
                    const sessaoEncontrada = sessoes.find(
                        (sessao) => sessao.dataSessao === dataProcurada
                    );

                    if (sessaoEncontrada) {
                        log(`✅ BUSCA: Sessão encontrada!`);
                        log(
                            `📋 BUSCA: ${traduzirSiglaOrgao(
                                sessaoEncontrada.orgaoJulgador
                            )} - ${sessaoEncontrada.dataHoraCompleta}`
                        );

                        // Armazenar na variável global
                        dadosCompletosSessionJulgamento = sessaoEncontrada;

                        return sessaoEncontrada;
                    } else {
                        // Log das datas disponíveis para debug
                        const datasDisponiveis = sessoes
                            .map((s) => s.dataSessao)
                            .filter((d) => d);
                        log(
                            `📅 BUSCA: Datas disponíveis: ${datasDisponiveis.join(
                                ", "
                            )}`
                        );

                        return null;
                    }
                } catch (error) {
                    console.error(`❌ BUSCA: Erro na busca: ${error.message}`);
                    return null;
                }
            }

            /**
             * Realiza cruzamento automático da data detectada com os dados das sessões
             * @param {string} hash - Hash da página (opcional)
             * @returns {Promise<boolean>} - true se encontrou e cruzou dados
             */
            async function cruzarDadosDataSessao(
                hash = null,
                forcarRequisicao = false
            ) {
                log("🔄 CRUZAMENTO: Iniciando cruzamento de dados da sessão");

                //  VERIFICAR SE REQUISIÇÕES AUTOMÁTICAS ESTÃO DESABILITADAS
                if (REQUISICOES_AUTOMATICAS_DESABILITADAS) {
                    log(
                        "🚫 CRUZAMENTO: Requisições automáticas desabilitadas globalmente"
                    );
                    log(
                        "💡 Para habilitar: window.SENT1_AUTO.habilitarRequisicoes()"
                    );
                    return false;
                }

                // 🔐 VERIFICAÇÃO DUPLA: Processo atual deve estar marcado como processado
                if (!processoAtual) {
                    logError("❌ CRUZAMENTO: Processo atual não identificado");
                    return false;
                }

                if (!processoJaFoiProcessado(processoAtual)) {
                    log(
                        `❌ CRUZAMENTO: Processo ${processoAtual} não foi marcado como processado`
                    );
                    return false;
                }

                if (!hasDataSessaoPautado()) {
                    log(
                        "❌ CRUZAMENTO: Nenhuma data de sessão detectada para cruzar"
                    );
                    return false;
                }

                const dataFormatada = dataSessaoPautado.dataFormatada;
                log(
                    `🎯 CRUZAMENTO: Buscando dados para: ${dataFormatada} (Processo: ${processoAtual})`
                );

                try {
                    const sessaoEncontrada = await buscarSessaoPorData(
                        dataFormatada,
                        hash
                    );

                    if (sessaoEncontrada) {
                        log("✅ CRUZAMENTO: Dados cruzados com sucesso!");

                        // Atualizar interface se estiver sendo exibida
                        setTimeout(() => {
                            atualizarDataSessaoNaInterface();
                        }, 500);

                        return true;
                    } else {
                        logError(
                            "❌ CRUZAMENTO: Não foi possível cruzar os dados"
                        );
                        return false;
                    }
                } catch (error) {
                    console.error(
                        `❌ CRUZAMENTO: Erro no cruzamento: ${error.message}`
                    );
                    return false;
                }
            }

            /**
             * Retorna os dados completos da sessão (se disponíveis)
             * @returns {Object|null} - Dados da sessão ou null
             */
            function getDadosCompletosSessionJulgamento() {
                return dadosCompletosSessionJulgamento;
            }

            /**
             * Verifica se há dados completos da sessão disponíveis
             * @returns {boolean} - true se há dados disponíveis
             */
            function hasDadosCompletosSessionJulgamento() {
                return dadosCompletosSessionJulgamento !== null;
            }

            /**
             * Reseta os dados completos da sessão
             */
            function resetDadosCompletosSessionJulgamento() {
                log("🔄 RESET: Limpando dados completos da sessão");
                dadosCompletosSessionJulgamento = null;
            }

            /**
             * Mostra informações completas da sessão
             */
            function showDadosCompletosSessionJulgamento() {
                if (hasDadosCompletosSessionJulgamento()) {
                    const dados = dadosCompletosSessionJulgamento;
                    const info = `📋 DADOS COMPLETOS DA SESSÃO:

            🏛️ Órgão Julgador: ${traduzirSiglaOrgao(dados.orgaoJulgador)}
            📅 Data da Sessão: ${dados.dataSessao}
            ⏰ Horário: ${dados.horaSessao}
            🖥️ Tipo: ${dados.tipoSessao}
            📍 Local: ${dados.localSessao}
            📋 Status: ${dados.statusSessao}

            📅 Data Limite Pauta: ${dados.dataLimitePauta}
            📅 Data Limite Mesa: ${dados.dataLimiteMesa}
            📅 Data Limite Minutas: ${dados.dataLimiteMinutas}

            🆔 ID: ${dados.id}`;

                    log(info);
                    alert(info);
                    return dados;
                } else {
                    const msg =
                        "❌ Nenhum dado completo de sessão foi encontrado ainda.";
                    log(msg);
                    alert(msg);
                    return null;
                }
            }

            // 🚀 INICIALIZAÇÃO AUTOMÁTICA OTIMIZADA - Carregamento mais rápido
            let inicializacaoExecutada = false; // Prevenir execução dupla

            function inicializarAutomaticamente() {
                if (inicializacaoExecutada) {
                    logError("⚠️ INICIALIZAÇÃO: Já executada, pulando...");
                    return;
                }

                inicializacaoExecutada = true;
                log(
                    "🚀 INICIALIZAÇÃO: Iniciando detecção automática de sessão..."
                );

                // ===== APLICAÇÃO IMEDIATA DE ESTILOS E ELEMENTOS =====
                log(
                    "⚡ INICIALIZAÇÃO: Aplicando estilos e elementos imediatamente..."
                );

                // 0. ⚡ APLICAR ANTI-FLASH CRÍTICO PRIMEIRO
                aplicarAntiFlashIcones();

                // 1. CSS Instantâneo já aplicado no início do arquivo - sem ação necessária
                try {
                    const tema =
                        localStorage.getItem("eprobe_selected_theme") || "blue";
                    log(
                        `✅ INICIALIZAÇÃO: Tema ${tema} usando CSS instantâneo`
                    );
                } catch (error) {
                    console.warn(
                        "⚠️ INICIALIZAÇÃO: Erro ao aplicar tema:",
                        error
                    );
                }

                // 2. Executar aplicação de estilos e elementos imediatamente
                try {
                    // Força aplicação imediata dos estilos CSS críticos
                    const head =
                        document.head ||
                        document.getElementsByTagName("head")[0];
                    if (
                        head &&
                        !document.getElementById("eprobe-instant-performance")
                    ) {
                        const performanceStyles =
                            document.createElement("style");
                        performanceStyles.id = "eprobe-instant-performance";
                        performanceStyles.textContent = `
                    /* Performance instantânea para elementos eProbe */
                    body { opacity: 1 !important; }
                    .navbar { opacity: 1 !important; }
                    
                    /* Garantir que elementos críticos apareçam imediatamente */
                    #navbar.navbar.bg-instancia,
                    .navbar.bg-instancia {
                        opacity: 1 !important;
                        transition: all 0.3s ease !important;
                        display: flex !important; 
                        align-items: center !important;
                    }
                    
                    /* Aplicar estilos SVG Figma instantaneamente */
                    .eprobe-figma-card-svg {
                        display: inline-block !important;
                        margin: 8px 0 !important;
                        position: relative !important;
                    }
                `;
                        head.appendChild(performanceStyles);
                        log(
                            "✅ INICIALIZAÇÃO: Estilos de performance aplicados"
                        );
                    }

                    // Executar gerenciamento da navbar imediatamente
                    if (typeof window.gerenciarNavbarEprobe === "function") {
                        window.gerenciarNavbarEprobe();
                        log(
                            "✅ INICIALIZAÇÃO: Navbar gerenciada imediatamente"
                        );
                    }

                    // Detectar e aplicar card de sessão imediatamente se possível
                    debounceGlobal(
                        () => {
                            if (
                                typeof detectarCardSessaoSimplificado ===
                                "function"
                            ) {
                                detectarCardSessaoSimplificado();
                                log(
                                    "✅ INICIALIZAÇÃO: Detecção de card de sessão iniciada"
                                );
                            }

                            // Aplicar estilização de lembretes
                            if (
                                typeof aplicarEstilizacaoLembretesRobusta ===
                                "function"
                            ) {
                                aplicarEstilizacaoLembretesRobusta();
                                log(
                                    "✅ INICIALIZAÇÃO: Estilização robusta de lembretes iniciada"
                                );
                            }

                            // Aplicar gradientes na capa do processo
                            if (
                                typeof aplicarGradientesCapaProcessoRobusta ===
                                "function"
                            ) {
                                aplicarGradientesCapaProcessoRobusta();
                                log(
                                    "✅ INICIALIZAÇÃO: Gradientes robustos na capa iniciados"
                                );
                            }

                            // Aplicar gradientes nas minutas
                            if (
                                typeof aplicarGradientesLegMinutasRobusta ===
                                "function"
                            ) {
                                aplicarGradientesLegMinutasRobusta();
                                log(
                                    "✅ INICIALIZAÇÃO: Gradientes robustos nas minutas iniciados"
                                );
                            }

                            // ⚡ NOVO: Aplicar estilização IMEDIATA para eliminar flash
                            if (
                                typeof aplicarEstilizacaoImediataLembretes ===
                                "function"
                            ) {
                                aplicarEstilizacaoImediataLembretes();
                            }

                            // ✨ NOVO: Aplicar substituição de ícones de lembretes
                            if (
                                typeof substituirIconesLembretes === "function"
                            ) {
                                substituirIconesLembretes();
                                log(
                                    "✅ INICIALIZAÇÃO: Ícones de lembretes substituídos"
                                );
                            }
                        },
                        "deteccao-card-instantanea",
                        50
                    );
                } catch (error) {
                    console.warn(
                        "⚠️ INICIALIZAÇÃO: Erro ao aplicar estilos:",
                        error
                    );
                }

                // Execução imediata sem delay desnecessário
                try {
                    // 1. Detectar data da sessão de forma não-bloqueante
                    if (!hasDataSessaoPautado()) {
                        log(
                            "🔍 INICIALIZAÇÃO: Tentando detectar data da sessão..."
                        );

                        // 🚨 CORREÇÃO ANTI-LOOP: Não fazer chamadas recursivas
                        log(
                            "ℹ️ INICIALIZAÇÃO: Sistema já inicializado, evitando loops"
                        );
                        return;
                    }

                    // 2. Verificar se há dados para inserir na interface
                    if (hasDataSessaoPautado()) {
                        log(
                            "✅ INICIALIZAÇÃO: Data detectada, inserindo na interface..."
                        );
                        inserirDataSessaoNaInterface();

                        // 3. Cruzamento só se requisições estiverem habilitadas
                        if (!REQUISICOES_AUTOMATICAS_DESABILITADAS) {
                            log(
                                "🔄 INICIALIZAÇÃO: Agendando cruzamento de dados..."
                            );
                            debounceGlobal(
                                () => {
                                    cruzarDadosDataSessao()
                                        .then(() => {
                                            log(
                                                "✅ INICIALIZAÇÃO: Processo completo finalizado!"
                                            );
                                            atualizarDataSessaoNaInterface();
                                        })
                                        .catch((error) => {
                                            console.warn(
                                                "⚠️ INICIALIZAÇÃO: Erro no cruzamento:",
                                                error.message
                                            );
                                        });
                                },
                                "cruzamento-automatico",
                                2000
                            );
                        } else {
                            log(
                                "ℹ️ INICIALIZAÇÃO: Cruzamento automático desabilitado - interface básica pronta"
                            );
                        }
                    } else {
                        log(
                            "ℹ️ INICIALIZAÇÃO: Nenhuma data de sessão detectada nesta página"
                        );
                    }
                } catch (error) {
                    console.error(
                        "❌ INICIALIZAÇÃO: Erro na inicialização automática:",
                        error
                    );
                    inicializacaoExecutada = false; // Permitir retry em caso de erro
                }
            }

            // 🧪 FUNÇÃO DE TESTE - Para validação durante desenvolvimento
            function testarSistemaCompleto() {
                log(
                    "🧪 TESTE: Iniciando teste completo do sistema de sessões..."
                );

                return new Promise(async (resolve) => {
                    try {
                        // 1. Resetar estado
                        log("🔄 TESTE: Resetando estado...");
                        resetDataSessaoPautado();
                        resetDadosCompletosSessionJulgamento();

                        // 2. Testar detecção de data
                        log("🔍 TESTE: Testando detecção de data...");
                        if (
                            window.SENT1_AUTO &&
                            window.SENT1_AUTO.detectarCardSessaoSimplificado
                        ) {
                            window.SENT1_AUTO.detectarCardSessaoSimplificado();
                        }

                        if (hasDataSessaoPautado()) {
                            log("✅ TESTE: Data detectada com sucesso!");
                            showDataSessaoPautadoInfo();

                            // 3. Testar inserção na interface
                            log("🎨 TESTE: Testando inserção na interface...");
                            inserirDataSessaoNaInterface();

                            // 4. Testar cruzamento de dados
                            log("🔄 TESTE: Testando cruzamento de dados...");
                            const resultado = await cruzarDadosDataSessao();

                            if (resultado) {
                                log(
                                    "✅ TESTE: Cruzamento realizado com sucesso!"
                                );
                                showDadosCompletosSessionJulgamento();

                                // 5. Testar atualização da interface
                                log(
                                    "🎨 TESTE: Testando atualização da interface..."
                                );
                                atualizarDataSessaoNaInterface();

                                log(
                                    "🎉 TESTE: Teste completo finalizado com SUCESSO!"
                                );
                                resolve(true);
                            } else {
                                logError(
                                    "⚠️ TESTE: Cruzamento não encontrou dados"
                                );
                                resolve(false);
                            }
                        } else {
                            logError(
                                "❌ TESTE: Nenhuma data de sessão detectada"
                            );
                            resolve(false);
                        }
                    } catch (error) {
                        console.error("❌ TESTE: Erro durante teste:", error);
                        resolve(false);
                    }
                });
            }

            // Adicionar funções ao namespace global para debug (movidas para namespace principal)

            // 🔍 FUNÇÃO DE DEBUG - Para investigar estrutura da página de sessões
            async function debugPaginaSessoes() {
                log("🔍 DEBUG: Iniciando debug da página de sessões...");

                try {
                    const baseUrl = window.location.origin;
                    const urlSessoes = `${baseUrl}/eproc/controlador.php?acao=sessao_julgamento_listar`;

                    log(`🌐 DEBUG: Fazendo fetch para: ${urlSessoes}`);

                    const response = await fetch(urlSessoes, {
                        credentials: "same-origin",
                        headers: {
                            Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                        },
                    });

                    if (!response.ok) {
                        console.error(
                            `❌ DEBUG: Erro HTTP ${response.status}: ${response.statusText}`
                        );
                        return;
                    }

                    const htmlContent = await response.text();
                    log(
                        `✅ DEBUG: Página carregada, tamanho: ${htmlContent.length} caracteres`
                    );

                    // Fazer parse
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(
                        htmlContent,
                        "text/html"
                    );

                    // Debug básico
                    const title =
                        doc.querySelector("title")?.textContent || "sem título";
                    log(`📋 DEBUG: Título: "${title}"`);

                    // Verificar se foi redirecionado para login
                    if (
                        title.toLowerCase().includes("login") ||
                        htmlContent.includes("frmLogin")
                    ) {
                        console.warn(
                            "⚠️ DEBUG: Parece que foi redirecionado para página de login!"
                        );
                        console.warn(
                            "💡 DEBUG: Tente acessar a URL manualmente no navegador primeiro"
                        );
                        return;
                    }

                    // Analisar estrutura
                    const allTables = doc.querySelectorAll("table");
                    log(`📊 DEBUG: ${allTables.length} tabelas encontradas`);

                    allTables.forEach((table, index) => {
                        const id = table.id || "sem-id";
                        const className = table.className || "sem-class";
                        const rows = table.querySelectorAll("tr").length;
                        const hasSessionData =
                            table.innerHTML.includes("Órgão Julgador") ||
                            table.innerHTML.includes("Data da Sessão") ||
                            table.innerHTML.includes("sessao");

                        log(`📋 DEBUG: Tabela ${index + 1}:`);
                        log(`  - ID: "${id}"`);
                        log(`  - Class: "${className}"`);
                        log(`  - Linhas: ${rows}`);
                        log(
                            `  - Parece ter dados de sessão: ${hasSessionData}`
                        );

                        if (hasSessionData && rows > 1) {
                            log(
                                `🎯 DEBUG: Esta tabela parece promissora! Analisando mais...`
                            );

                            // Pegar headers
                            const headers = Array.from(
                                table.querySelectorAll("th, thead td")
                            ).map((th) => th.textContent.trim());
                            log(
                                `📋 DEBUG: Headers: ${JSON.stringify(headers)}`
                            );

                            // Pegar algumas linhas de exemplo
                            const dataRows = table.querySelectorAll("tbody tr");
                            log(`📋 DEBUG: ${dataRows.length} linhas de dados`);

                            Array.from(dataRows)
                                .slice(0, 3)
                                .forEach((row, rowIndex) => {
                                    const cells = Array.from(
                                        row.querySelectorAll("td")
                                    ).map((td) => td.textContent.trim());
                                    log(
                                        `📋 DEBUG: Linha ${
                                            rowIndex + 1
                                        }: ${JSON.stringify(cells)}`
                                    );
                                });
                        }
                    });

                    // Salvar HTML para inspeção manual
                    log(
                        "💾 DEBUG: HTML da página salvo em window.debugPageHTML (use console para inspecionar)"
                    );
                    window.debugPageHTML = htmlContent;

                    log("✅ DEBUG: Análise completa! Verifique os logs acima.");
                } catch (error) {
                    console.error("❌ DEBUG: Erro durante debug:", error);
                }
            }

            // 📨 HANDLER DE MENSAGENS - Para comunicação com o popup
            if (
                typeof chrome !== "undefined" &&
                chrome.runtime &&
                chrome.runtime.onMessage
            ) {
                chrome.runtime.onMessage.addListener(function (
                    request,
                    sender,
                    sendResponse
                ) {
                    log("📨 MENSAGEM: Recebida do popup:", request);

                    if (request.action === "toggleAutoSessionRequests") {
                        const enabled = request.enabled;

                        if (enabled) {
                            log(
                                "🔓 POPUP: Habilitando requisições automáticas de sessão"
                            );
                            REQUISICOES_AUTOMATICAS_DESABILITADAS = false;
                        } else {
                            log(
                                "🔒 POPUP: Desabilitando requisições automáticas de sessão"
                            );
                            REQUISICOES_AUTOMATICAS_DESABILITADAS = true;
                        }

                        log(
                            `⚙️ POPUP: REQUISICOES_AUTOMATICAS_DESABILITADAS = ${REQUISICOES_AUTOMATICAS_DESABILITADAS}`
                        );

                        // Enviar resposta de confirmação
                        sendResponse({
                            success: true,
                            message: enabled
                                ? "Requisições automáticas habilitadas"
                                : "Requisições automáticas desabilitadas",
                            currentState:
                                !REQUISICOES_AUTOMATICAS_DESABILITADAS,
                        });
                    }

                    // Manter o handler para outras mensagens se necessário
                    if (request.action === "toggleSessionDateHighlight") {
                        log(
                            "🎯 POPUP: Toggle para destaque da data da sessão:",
                            request.enabled
                        );

                        // Aqui você pode adicionar a lógica para o destaque da data da sessão
                        // Por enquanto, apenas confirmar recebimento
                        sendResponse({
                            success: true,
                            message: request.enabled
                                ? "Destaque ativado"
                                : "Destaque desativado",
                        });
                    }

                    // Handler para aplicação de temas
                    if (request.action === "applyTheme") {
                        const theme = request.theme;
                        log(
                            "🎨 MAIN: Aplicando tema recebido do popup:",
                            theme
                        );

                        // APLICAR TEMA REALMENTE usando a função correta
                        if (typeof applyThemeStyles === "function") {
                            applyThemeStyles(theme);
                            log("✅ MAIN: Tema aplicado via applyThemeStyles");
                        } else if (
                            typeof window.applyThemeStyles === "function"
                        ) {
                            window.applyThemeStyles(theme);
                            log(
                                "✅ MAIN: Tema aplicado via window.applyThemeStyles"
                            );
                        } else {
                            log(
                                "❌ MAIN: Função applyThemeStyles não encontrada"
                            );
                        }

                        // Resposta de sucesso
                        sendResponse({
                            success: true,
                            message: `Tema ${theme} aplicado com sucesso`,
                        });
                    }

                    // Handler para temas de botões
                    if (request.action === "applyButtonTheme") {
                        const theme = request.theme;
                        log(
                            "💼 MAIN: Aplicando tema de botão recebido do popup:",
                            theme
                        );

                        // Verificar se a função aplicarEstiloBotoesEproc está disponível
                        if (
                            typeof window.aplicarEstiloBotoesEproc ===
                            "function"
                        ) {
                            try {
                                if (theme === "reset") {
                                    // Reset para padrão do sistema
                                    window.resetarBotoesEproc();
                                    sendResponse({
                                        success: true,
                                        message:
                                            "Botões resetados para o padrão do sistema",
                                    });
                                } else {
                                    // Aplicar tema específico
                                    window.aplicarEstiloBotoesEproc(theme);
                                    sendResponse({
                                        success: true,
                                        message: `Tema "${theme}" aplicado aos botões`,
                                    });
                                }
                            } catch (error) {
                                console.error(
                                    "❌ MAIN: Erro ao aplicar tema de botão:",
                                    error
                                );
                                sendResponse({
                                    success: false,
                                    message: `Erro ao aplicar tema: ${error.message}`,
                                });
                            }
                        } else {
                            console.error(
                                "❌ MAIN: Funções de tema de botão não encontradas"
                            );
                            sendResponse({
                                success: false,
                                message:
                                    "Erro: funções de tema de botão não disponíveis",
                            });
                        }
                    }

                    return true; // Indica que a resposta será enviada de forma assíncrona
                });

                log("📨 HANDLER: Listener de mensagens do popup registrado");
            }

            // ===== EXECUÇÃO IMEDIATA - ELIMINAR FLASH TOTAL =====
            // Executar inicialização IMEDIATAMENTE sem aguardar DOM
            log("⚡ INSTANT: Executando inicialização imediata...");

            // ⚡ SUPER ANTI-FLASH: Aplicar imediatamente antes de qualquer coisa
            try {
                aplicarEstilizacaoImediataLembretes();
            } catch (error) {
                console.error(
                    "❌ ANTI-FLASH: Erro na aplicação imediata:",
                    error
                );
            }

            // Executar inicialização IMEDIATAMENTE
            inicializarAutomaticamente();

            // ⚡ MONITOR ULTRARRÁPIDO: Verificação a cada 16ms (60fps) - ULTRA-OTIMIZADO
            let tentativasMonitor = 0;
            const maxTentativasMonitor = 1875; // 30 segundos a 60fps

            const monitorUltraRapido = setInterval(() => {
                try {
                    tentativasMonitor++;

                    // OTIMIZAÇÃO: Verificação ultrarrápida sem logs
                    const lembretesNaoProcessados = document.querySelectorAll(
                        ".lista-lembretes .lembrete:not(.eprobe-lembrete-processado), div.divLembrete:not(.eprobe-lembrete-processado)"
                    );

                    if (lembretesNaoProcessados.length > 0) {
                        // PROCESSAMENTO INSTANTÂNEO: Aplicar estilos diretamente sem função intermediária
                        lembretesNaoProcessados.forEach((elemento) => {
                            const style = elemento.getAttribute("style") || "";
                            let aplicouEstilo = false;

                            // Detecção e aplicação instantânea por cor
                            if (style.includes("#efef8f")) {
                                elemento.style.setProperty(
                                    "background",
                                    "linear-gradient(#F9EFAF, #F7E98D)",
                                    "important"
                                );
                                aplicouEstilo = true;
                            } else if (style.includes("#db8080")) {
                                elemento.style.setProperty(
                                    "background",
                                    "linear-gradient(#FAAFAF, #F78D8D)",
                                    "important"
                                );
                                aplicouEstilo = true;
                            } else if (style.includes("#87adcd")) {
                                elemento.style.setProperty(
                                    "background",
                                    "linear-gradient(#AFCFFA, #8DC0F7)",
                                    "important"
                                );
                                aplicouEstilo = true;
                            } else if (style.includes("#a7eda7")) {
                                elemento.style.setProperty(
                                    "background",
                                    "linear-gradient(#AFFAB6, #8DF792)",
                                    "important"
                                );
                                aplicouEstilo = true;
                            } else if (style.includes("#f5b574")) {
                                elemento.style.setProperty(
                                    "background",
                                    "linear-gradient(#FAD3AF, #F7C68D)",
                                    "important"
                                );
                                aplicouEstilo = true;
                            }

                            if (aplicouEstilo) {
                                // Aplicar estilos base instantaneamente
                                elemento.style.setProperty(
                                    "padding",
                                    "20px",
                                    "important"
                                );
                                elemento.style.setProperty(
                                    "min-width",
                                    "315px",
                                    "important"
                                );
                                elemento.style.setProperty(
                                    "min-height",
                                    "140px",
                                    "important"
                                );
                                elemento.style.setProperty(
                                    "box-shadow",
                                    "0 4px 6px rgba(0, 0, 0, 0.1)",
                                    "important"
                                );
                                elemento.style.setProperty(
                                    "transition",
                                    "box-shadow 0.5s ease",
                                    "important"
                                );
                                elemento.style.setProperty(
                                    "-webkit-font-smoothing",
                                    "subpixel-antialiased",
                                    "important"
                                );
                                elemento.style.setProperty(
                                    "visibility",
                                    "visible",
                                    "important"
                                );
                                elemento.style.setProperty(
                                    "opacity",
                                    "1",
                                    "important"
                                );
                                elemento.classList.add(
                                    "eprobe-lembrete-processado"
                                );
                            }
                        });

                        // Substituição instantânea de ícones
                        substituirIconesLembretesImediato();
                    }

                    // OTIMIZAÇÃO: Verificação de botões ultrarrápida
                    const botoesNaoMarcados = document.querySelectorAll(
                        "div.botaoLerMais:not([data-eprobe-will-replace]):not([data-eprobe-expandir-replaced])"
                    );

                    if (botoesNaoMarcados.length > 0) {
                        botoesNaoMarcados.forEach((botao) => {
                            const texto = (
                                botao.textContent || ""
                            ).toLowerCase();
                            if (
                                texto.includes("ler mais") ||
                                texto.includes("...ler mais")
                            ) {
                                const lembreteParent =
                                    botao.closest(".divLembrete");
                                if (lembreteParent) {
                                    const desLembrete =
                                        lembreteParent.querySelector(
                                            ".desLembrete"
                                        );
                                    if (desLembrete) {
                                        const textoCompleto =
                                            desLembrete.textContent || "";
                                        const temTextoTruncado =
                                            textoCompleto.length > 150 ||
                                            desLembrete.scrollHeight >
                                                desLembrete.clientHeight ||
                                            textoCompleto.includes("...") ||
                                            window.getComputedStyle(desLembrete)
                                                .textOverflow === "ellipsis";

                                        if (temTextoTruncado) {
                                            botao.setAttribute(
                                                "data-eprobe-will-replace",
                                                "true"
                                            );
                                            botao.style.display = "none";
                                            botao.style.visibility = "hidden";
                                        }
                                    }
                                }
                            }
                        });
                    }

                    // OTIMIZAÇÃO: Parar após tempo limite ou estabilidade
                    if (
                        tentativasMonitor >= maxTentativasMonitor ||
                        (tentativasMonitor > 125 &&
                            lembretesNaoProcessados.length === 0 &&
                            botoesNaoMarcados.length === 0)
                    ) {
                        clearInterval(monitorUltraRapido);
                        // Log final apenas (sem logs intermediários para máxima performance)
                        if (tentativasMonitor < maxTentativasMonitor) {
                            log(
                                "⚡ MONITOR ULTRARRÁPIDO: Finalizado - página estável após",
                                tentativasMonitor,
                                "verificações"
                            );
                        }
                    }
                } catch (error) {
                    // Silencioso para máxima performance - sem logs de erro
                }
            }, 16); // 60fps para captura instantânea

            // ⚡ MONITOR SECUNDÁRIO: Backup a cada 100ms para garantir cobertura total
            const monitorBackup = setInterval(() => {
                try {
                    const lembretesNaoProcessados = document.querySelectorAll(
                        ".lista-lembretes .lembrete:not(.eprobe-lembrete-processado), div.divLembrete:not(.eprobe-lembrete-processado)"
                    );
                    if (lembretesNaoProcessados.length > 0) {
                        aplicarEstilizacaoImediataLembretes();
                        substituirIconesLembretesImediato();
                    }
                } catch (error) {
                    // Silencioso
                }
            }, 100);

            // Parar monitores após 10 segundos
            setTimeout(() => {
                clearInterval(monitorBackup);
                log("⚡ MONITORES: Finalizados após timeout de 10 segundos");
            }, 10000);

            // Backup: Executar novamente quando DOM estiver pronto (para reaplicar estilos se necessário)
            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", () => {
                    log("🔄 BACKUP: Reaplicando estilos após DOMContentLoaded");

                    // Aplicar anti-flash novamente
                    try {
                        aplicarEstilizacaoImediataLembretes();
                    } catch (error) {
                        console.error("❌ BACKUP ANTI-FLASH: Erro:", error);
                    }

                    // CSS instantâneo já aplicado - sem necessidade de reaplicação
                    log(
                        "✅ BACKUP: CSS instantâneo já garante aplicação correta"
                    );
                });
            }

            // ##### VERIFICAÇÃO E CORREÇÃO DE ESCOPO DAS FUNÇÕES PRINCIPAIS #####

            // Garantir que as funções principais estejam acessíveis no namespace
            // Esta seção corrige problemas de escopo com expressões de função

            // ========================================
            // 🔧 IMPLEMENTAÇÕES DAS FUNÇÕES FALTANTES
            // ========================================

            /**
     * Função principal de automação completa
        log(`   ID: ${spanElement.id || "sem-id"}`);
        log(`   Tag: ${spanElement.tagName}`);
        log(`   Classe: ${spanElement.className || "sem-classe"}`);

        // Extrair dados do atributo onmouseover
        const onmouseoverAttr = spanElement.getAttribute("onmouseover");

        if (!onmouseoverAttr) {
            logError("❌ XPATH: Atributo onmouseover não encontrado");
            log("   Element HTML:", spanElement.outerHTML);
            return null;
        }

        log("🔍 XPATH: Atributo onmouseover encontrado:");
        log(`   ${onmouseoverAttr}`);

        // Extrair o conteúdo do tooltip (texto dentro das aspas)
        const match = onmouseoverAttr.match(/infraTooltipMostrar\('([^']+)'/);
        if (!match) {
            logError("❌ XPATH: Formato do tooltip não reconhecido");
            log("   Tentando extrair de outras formas...");

            // Tentativa alternativa de extração
            const matchAlternativo = onmouseoverAttr.match(/"([^"]+)"/);
            if (matchAlternativo) {
                log("✅ XPATH: Formato alternativo detectado");
                return processarTooltipContent(matchAlternativo[1]);
            }

            return null;
        }

        return processarTooltipContent(match[1]);
    }

    // Função auxiliar para processar o conteúdo do tooltip
    function processarTooltipContent(tooltipContent) {
        log(`📝 XPATH: Conteúdo do tooltip: ${tooltipContent}`);

        // USAR FUNÇÃO GLOBAL que detecta o formato atualizado
        const resultado = extrairDadosCardSessaoGlobal(tooltipContent);

        if (resultado) {
            log(`✅ XPATH: SUCESSO! Dados extraídos:`);
            log(`   - Status: ${resultado.status}`);
            log(`   - Status Original: ${resultado.statusOriginal}`);
            log(`   - Tipo: ${resultado.tipoProcesso}`);
            log(`   - Data: ${resultado.data}`);
            log(`   - Código: ${resultado.codigo}`);
            log(`   - Total Sessões: ${resultado.totalSessoes}`);

    // ===== HELPERS PARA EVENT LISTENERS PASSIVOS =====

    // ❌ FUNÇÃO REMOVIDA: extrairDadosSessaoCompleto() 
    // ✅ USE AGORA: detectarSessoesUnificado()

        // 🔧 SISTEMA UNIFICADO DE TOOLTIP - Todas as funcionalidades movidas para função única

        /**
         * 🎨 FUNÇÃO DE DEBUG PARA divLembrete - Identifica elementos com background amarelo
         */
            function debugDivLembrete() {
                log(
                    "🔍 DEBUG: Procurando elementos divLembrete com background-color:#efef8f"
                );

                const elementos = document.querySelectorAll(
                    'div.divLembrete[style*="background-color:#efef8f"], div.divLembrete[style*="background-color: #efef8f"]'
                );

                log(
                    `✅ Encontrados ${elementos.length} elementos divLembrete com background amarelo:`
                );

                elementos.forEach((elemento, index) => {
                    log(`📋 divLembrete ${index + 1}:`, {
                        id: elemento.id,
                        classes: elemento.className,
                        style: elemento.getAttribute("style"),
                        conteudo:
                            elemento.textContent.substring(0, 100) + "...",
                    });
                });

                return elementos;
            }

            /**
             * 🔍 FUNÇÃO DE DETECÇÃO INTELIGENTE DE LEMBRETES
             * Detecta automaticamente quais tipos de lembretes existem na página
             */
            function detectarTiposLembretesNaPagina() {
                log("🔍 DETECÇÃO: Analisando tipos de lembretes na página...");

                const tiposDetectados = {
                    divLembrete: 0,
                    listaLembretes: 0,
                    outrosElementos: 0,
                    coresEncontradas: [],
                    elementos: [], // ADICIONADO: Array com todos os elementos encontrados
                    elementosPorCor: {}, // ADICIONADO: Elementos organizados por cor
                };

                // 1. Detectar div.divLembrete
                const divLembretes =
                    document.querySelectorAll("div.divLembrete");
                tiposDetectados.divLembrete = divLembretes.length;

                // 2. Detectar .lista-lembretes .lembrete
                const listaLembretes = document.querySelectorAll(
                    ".lista-lembretes .lembrete"
                );
                tiposDetectados.listaLembretes = listaLembretes.length;

                // 3. Detectar cores de background em qualquer div
                const coresLembrete = [
                    "#efef8f",
                    "#db8080",
                    "#87adcd",
                    "#a7eda7",
                    "#f5b574",
                ];

                coresLembrete.forEach((cor) => {
                    const elementos = document.querySelectorAll(
                        `div[style*="background-color:${cor}"], div[style*="background-color: ${cor}"]`
                    );
                    if (elementos.length > 0) {
                        const nomeCor =
                            cor === "#efef8f"
                                ? "amarelo"
                                : cor === "#db8080"
                                ? "vermelho"
                                : cor === "#87adcd"
                                ? "azul"
                                : cor === "#a7eda7"
                                ? "verde"
                                : "laranja";

                        tiposDetectados.coresEncontradas.push(nomeCor);
                        tiposDetectados.elementosPorCor[nomeCor] =
                            Array.from(elementos);
                        tiposDetectados.elementos.push(
                            ...Array.from(elementos)
                        );
                        tiposDetectados.outrosElementos += elementos.length;
                    }
                });

                log("📊 DETECÇÃO COMPLETA:", tiposDetectados);
                return tiposDetectados;
            }

            /**
             * 🎨 FUNÇÃO DE ESTILIZAÇÃO INTELIGENTE PARA LEMBRETES
             * Detecta automaticamente o tipo de elemento de lembrete na página
             */
            function estilizarDivLembrete() {
                log(
                    "🎨 ESTILIZAÇÃO: Procurando lembretes amarelos em TODOS os seletores..."
                );

                // Seletores múltiplos para diferentes tipos de lembretes
                const seletores = [
                    'div.divLembrete[style*="background-color:#efef8f"]',
                    'div.divLembrete[style*="background-color: #efef8f"]',
                    '.lista-lembretes .lembrete[style*="background-color:#efef8f"]',
                    '.lista-lembretes .lembrete[style*="background-color: #efef8f"]',
                    'div[style*="background-color:#efef8f"]',
                    'div[style*="background-color: #efef8f"]',
                ];

                let elementosEncontrados = [];

                // Tentar cada seletor
                seletores.forEach((seletor, index) => {
                    const elementos = document.querySelectorAll(seletor);
                    if (elementos.length > 0) {
                        log(
                            `✅ ENCONTRADOS ${
                                elementos.length
                            } lembretes amarelos com seletor ${
                                index + 1
                            }: ${seletor}`
                        );
                        elementosEncontrados.push(...elementos);
                    }
                });

                // Remover duplicatas
                elementosEncontrados = [...new Set(elementosEncontrados)];

                if (elementosEncontrados.length === 0) {
                    log(
                        "❌ Nenhum elemento lembrete com background amarelo encontrado"
                    );
                    return false;
                }

                elementosEncontrados.forEach((elemento, index) => {
                    // Aplicar gradiente amarelo
                    elemento.style.background =
                        "linear-gradient( #F9EFAF, #F7E98D)";

                    // Aplicar estilos aprimorados - GARANTINDO MESMO TAMANHO
                    elemento.style.padding = "20px !important";
                    elemento.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
                    elemento.style.transition = "box-shadow 0.5s ease";
                    elemento.style.webkitFontSmoothing = "subpixel-antialiased";

                    // CORREÇÃO: Garantir mesmo tamanho visual de todos os lembretes
                    elemento.style.minWidth = "315px";
                    elemento.style.minHeight = "140px";
                    elemento.style.fontSize = "1rem";
                    elemento.style.lineHeight = "1.5";
                    elemento.style.margin = "0";
                    elemento.style.border = "none";

                    // Marcar como processado para consistência
                    elemento.classList.add("eprobe-lembrete-processado");

                    // Adicionar eventos de hover e focus
                    elemento.addEventListener(
                        "mouseenter",
                        function () {
                            this.style.boxShadow = "0 5px 8px rgba(0,0,0,0.15)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "mouseleave",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "focus",
                        function () {
                            this.style.boxShadow = "0 5px 12px rgba(0,0,0,0.2)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "blur",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true }
                    );

                    log(
                        `✅ Gradiente amarelo aplicado ao lembrete ${
                            index + 1
                        } (ID: ${elemento.id || "sem-id"})`
                    );
                });
                log(
                    `🎨 AMARELO CONCLUÍDO: ${elementosEncontrados.length} elementos estilizados`
                );
                return elementosEncontrados.length;
            }

            /**
             * 🎨 FUNÇÃO DE ESTILIZAÇÃO INTELIGENTE PARA LEMBRETES VERMELHOS
             */
            function estilizarDivLembreteVermelho() {
                log(
                    "🎨 ESTILIZAÇÃO: Procurando lembretes vermelhos em TODOS os seletores..."
                );

                // Seletores múltiplos para diferentes tipos de lembretes
                const seletores = [
                    'div.divLembrete[style*="background-color:#db8080"]',
                    'div.divLembrete[style*="background-color: #db8080"]',
                    '.lista-lembretes .lembrete[style*="background-color:#db8080"]',
                    '.lista-lembretes .lembrete[style*="background-color: #db8080"]',
                    'div[style*="background-color:#db8080"]',
                    'div[style*="background-color: #db8080"]',
                ];

                let elementosEncontrados = [];

                // Tentar cada seletor
                seletores.forEach((seletor, index) => {
                    const elementos = document.querySelectorAll(seletor);
                    if (elementos.length > 0) {
                        log(
                            `✅ ENCONTRADOS ${
                                elementos.length
                            } lembretes vermelhos com seletor ${
                                index + 1
                            }: ${seletor}`
                        );
                        elementosEncontrados.push(...elementos);
                    }
                });

                // Remover duplicatas
                elementosEncontrados = [...new Set(elementosEncontrados)];

                if (elementosEncontrados.length === 0) {
                    log("❌ Nenhum elemento lembrete vermelho encontrado");
                    return false;
                }

                elementosEncontrados.forEach((elemento, index) => {
                    // Aplicar gradiente vermelho
                    elemento.style.background =
                        "linear-gradient( #FAAFAF, #F78D8D)";

                    // Aplicar estilos aprimorados - GARANTINDO MESMO TAMANHO
                    elemento.style.padding = "20px !important";
                    elemento.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
                    elemento.style.transition = "box-shadow 0.5s ease";
                    elemento.style.webkitFontSmoothing = "subpixel-antialiased";

                    // CORREÇÃO: Garantir mesmo tamanho visual de todos os lembretes
                    elemento.style.minWidth = "315px";
                    elemento.style.minHeight = "140px";
                    elemento.style.fontSize = "1rem";
                    elemento.style.lineHeight = "1.5";
                    elemento.style.margin = "0";
                    elemento.style.border = "none";

                    // Marcar como processado para consistência
                    elemento.classList.add("eprobe-lembrete-processado");

                    // Adicionar eventos de hover e focus
                    elemento.addEventListener(
                        "mouseenter",
                        function () {
                            this.style.boxShadow = "0 5px 8px rgba(0,0,0,0.15)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "mouseleave",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "focus",
                        function () {
                            this.style.boxShadow = "0 5px 12px rgba(0,0,0,0.2)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "blur",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true }
                    );

                    log(
                        `✅ Gradiente vermelho aplicado ao divLembrete ${
                            index + 1
                        } (ID: ${elemento.id})`
                    );
                });
                log(
                    `🎨 CONCLUÍDO: ${elementosEncontrados.length} elementos divLembrete vermelhos com gradiente`
                );
                return elementosEncontrados.length;
            }

            /**
             * 🎨 FUNÇÃO DE ESTILIZAÇÃO PARA LEMBRETES AZUIS - Com detecção inteligente
             */
            function estilizarDivLembreteAzul() {
                log(
                    "🎨 ESTILIZAÇÃO AZUL: Aplicando gradiente com detecção inteligente"
                );

                // Múltiplos seletores para diferentes estruturas da página
                const seletores = [
                    'div.divLembrete[style*="background-color:#87adcd"]',
                    'div.divLembrete[style*="background-color: #87adcd"]',
                    '.lista-lembretes div[style*="#87adcd"]',
                    'div[style*="background-color:#87adcd"]',
                    'div[style*="background-color: #87adcd"]',
                ];

                let elementos = [];

                // Tentar cada seletor até encontrar elementos
                for (const seletor of seletores) {
                    elementos = document.querySelectorAll(seletor);
                    if (elementos.length > 0) {
                        log(
                            `✅ AZUL: Encontrados ${elementos.length} elementos com seletor: ${seletor}`
                        );
                        break;
                    }
                }

                if (elementos.length === 0) {
                    log(
                        "❌ AZUL: Nenhum elemento azul encontrado com nenhum dos seletores"
                    );
                    return false;
                }

                elementos.forEach((elemento, index) => {
                    // Aplicar gradiente azul
                    elemento.style.background =
                        "linear-gradient( #AFCFFA, #8DC0F7)";

                    // Aplicar estilos aprimorados - GARANTINDO MESMO TAMANHO
                    elemento.style.padding = "20px !important";
                    elemento.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
                    elemento.style.transition = "box-shadow 0.5s ease";
                    elemento.style.webkitFontSmoothing = "subpixel-antialiased";

                    // CORREÇÃO: Garantir mesmo tamanho visual de todos os lembretes
                    elemento.style.minWidth = "315px";
                    elemento.style.minHeight = "140px";
                    elemento.style.fontSize = "1rem";
                    elemento.style.lineHeight = "1.5";
                    elemento.style.margin = "0";
                    elemento.style.border = "none";

                    // Marcar como processado para consistência
                    elemento.classList.add("eprobe-lembrete-processado");

                    // Adicionar eventos de hover e focus
                    elemento.addEventListener(
                        "mouseenter",
                        function () {
                            this.style.boxShadow = "0 5px 8px rgba(0,0,0,0.15)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "mouseleave",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "focus",
                        function () {
                            this.style.boxShadow = "0 5px 12px rgba(0,0,0,0.2)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "blur",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true }
                    );

                    log(
                        `✅ AZUL: Gradiente aplicado ao elemento ${
                            index + 1
                        } (ID: ${elemento.id})`
                    );
                });

                log(
                    `🎨 AZUL CONCLUÍDO: ${elementos.length} elementos estilizados`
                );
                return elementos.length;
            }

            /**
             * 🎨 FUNÇÃO DE ESTILIZAÇÃO PARA LEMBRETES VERDES - Com detecção inteligente
             */
            function estilizarDivLembreteVerde() {
                log(
                    "🎨 ESTILIZAÇÃO VERDE: Aplicando gradiente com detecção inteligente"
                );

                // Múltiplos seletores para diferentes estruturas da página
                const seletores = [
                    'div.divLembrete[style*="background-color:#a7eda7"]',
                    'div.divLembrete[style*="background-color: #a7eda7"]',
                    '.lista-lembretes div[style*="#a7eda7"]',
                    'div[style*="background-color:#a7eda7"]',
                    'div[style*="background-color: #a7eda7"]',
                ];

                let elementos = [];

                // Tentar cada seletor até encontrar elementos
                for (const seletor of seletores) {
                    elementos = document.querySelectorAll(seletor);
                    if (elementos.length > 0) {
                        log(
                            `✅ VERDE: Encontrados ${elementos.length} elementos com seletor: ${seletor}`
                        );
                        break;
                    }
                }

                if (elementos.length === 0) {
                    log(
                        "❌ VERDE: Nenhum elemento verde encontrado com nenhum dos seletores"
                    );
                    return false;
                }

                elementos.forEach((elemento, index) => {
                    // Aplicar gradiente verde
                    elemento.style.background =
                        "linear-gradient( #AFFAB6, #8DF792)";

                    // Aplicar estilos aprimorados - GARANTINDO MESMO TAMANHO
                    elemento.style.padding = "20px !important";
                    elemento.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
                    elemento.style.transition = "box-shadow 0.5s ease";
                    elemento.style.webkitFontSmoothing = "subpixel-antialiased";

                    // CORREÇÃO: Garantir mesmo tamanho visual de todos os lembretes
                    elemento.style.minWidth = "315px";
                    elemento.style.minHeight = "140px";
                    elemento.style.fontSize = "1rem";
                    elemento.style.lineHeight = "1.5";
                    elemento.style.margin = "0";
                    elemento.style.border = "none";

                    // Marcar como processado para consistência
                    elemento.classList.add("eprobe-lembrete-processado");

                    // Adicionar eventos de hover e focus
                    elemento.addEventListener(
                        "mouseenter",
                        function () {
                            this.style.boxShadow = "0 5px 8px rgba(0,0,0,0.15)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "mouseleave",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "focus",
                        function () {
                            this.style.boxShadow = "0 5px 12px rgba(0,0,0,0.2)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "blur",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true }
                    );

                    log(
                        `✅ VERDE: Gradiente aplicado ao elemento ${
                            index + 1
                        } (ID: ${elemento.id})`
                    );
                });

                log(
                    `🎨 VERDE CONCLUÍDO: ${elementos.length} elementos estilizados`
                );
                return elementos.length;
            }

            /**
             * 🎨 FUNÇÃO DE ESTILIZAÇÃO PARA LEMBRETES LARANJAS - Com detecção inteligente
             */
            function estilizarDivLembreteLaranja() {
                log(
                    "🎨 ESTILIZAÇÃO LARANJA: Aplicando gradiente com detecção inteligente"
                );

                // Múltiplos seletores para diferentes estruturas da página
                const seletores = [
                    'div.divLembrete[style*="background-color:#f5b574"]',
                    'div.divLembrete[style*="background-color: #f5b574"]',
                    '.lista-lembretes div[style*="#f5b574"]',
                    'div[style*="background-color:#f5b574"]',
                    'div[style*="background-color: #f5b574"]',
                ];

                let elementos = [];

                // Tentar cada seletor até encontrar elementos
                for (const seletor of seletores) {
                    elementos = document.querySelectorAll(seletor);
                    if (elementos.length > 0) {
                        log(
                            `✅ LARANJA: Encontrados ${elementos.length} elementos com seletor: ${seletor}`
                        );
                        break;
                    }
                }

                if (elementos.length === 0) {
                    log(
                        "❌ LARANJA: Nenhum elemento laranja encontrado com nenhum dos seletores"
                    );
                    return false;
                }

                elementos.forEach((elemento, index) => {
                    // Aplicar gradiente laranja
                    elemento.style.background =
                        "linear-gradient( #FAD3AF, #F7C68D)";

                    // Aplicar estilos aprimorados - GARANTINDO MESMO TAMANHO DOS OUTROS
                    elemento.style.padding = "20px !important";
                    elemento.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
                    elemento.style.transition = "box-shadow 0.5s ease";
                    elemento.style.webkitFontSmoothing = "subpixel-antialiased";

                    // CORREÇÃO CRÍTICA: Garantir mesmo tamanho visual dos outros lembretes
                    elemento.style.minWidth = "315px";
                    elemento.style.minHeight = "140px";
                    elemento.style.fontSize = "1rem";
                    elemento.style.lineHeight = "1.5";
                    elemento.style.margin = "0";
                    elemento.style.border = "none";

                    // Marcar como processado para consistência
                    elemento.classList.add("eprobe-lembrete-processado");

                    // Adicionar eventos de hover e focus
                    elemento.addEventListener(
                        "mouseenter",
                        function () {
                            this.style.boxShadow = "0 5px 8px rgba(0,0,0,0.15)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "mouseleave",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "focus",
                        function () {
                            this.style.boxShadow = "0 5px 12px rgba(0,0,0,0.2)";
                        },
                        { passive: true }
                    );

                    elemento.addEventListener(
                        "blur",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true }
                    );

                    log(
                        `✅ LARANJA: Gradiente aplicado ao elemento ${
                            index + 1
                        } (ID: ${elemento.id})`
                    );
                });

                log(
                    `🎨 LARANJA CONCLUÍDO: ${elementos.length} elementos estilizados`
                );
                return elementos.length;
            }

            /**
             * 🎨 FUNÇÃO MASTER - Aplica todos os gradientes de uma vez com detecção inteligente
             */
            function estilizarTodosDivLembrete() {
                log(
                    "🎨 MASTER: Iniciando estilização com detecção inteligente..."
                );

                // Primeiro detectar que tipos de lembretes existem
                const deteccao = detectarTiposLembretesNaPagina();

                if (deteccao.coresEncontradas.length === 0) {
                    log(
                        "ℹ️ MASTER: Nenhum lembrete colorido encontrado para estilizar"
                    );
                    return { total: 0, detalhes: {} };
                }

                log(
                    `🎯 MASTER: Cores encontradas: ${deteccao.coresEncontradas.join(
                        ", "
                    )}`
                );

                const resultados = {
                    amarelos: 0,
                    vermelhos: 0,
                    azuis: 0,
                    verdes: 0,
                    laranjas: 0,
                    total: 0,
                    deteccao: deteccao,
                };

                // Aplicar cada cor encontrada
                deteccao.coresEncontradas.forEach((cor) => {
                    try {
                        let sucesso = false;
                        let quantidade = 0;

                        switch (cor) {
                            case "amarelo":
                                sucesso = estilizarDivLembrete();
                                if (sucesso) {
                                    quantidade = document.querySelectorAll(
                                        'div[style*="background-color:#efef8f"], div[style*="background-color: #efef8f"], .lista-lembretes [style*="#efef8f"]'
                                    ).length;
                                    resultados.amarelos = quantidade;
                                }
                                break;
                            case "vermelho":
                                sucesso = estilizarDivLembreteVermelho();
                                if (sucesso) {
                                    quantidade = document.querySelectorAll(
                                        'div[style*="background-color:#db8080"], div[style*="background-color: #db8080"], .lista-lembretes [style*="#db8080"]'
                                    ).length;
                                    resultados.vermelhos = quantidade;
                                }
                                break;
                            case "azul":
                                sucesso = estilizarDivLembreteAzul();
                                if (sucesso) {
                                    quantidade = document.querySelectorAll(
                                        'div[style*="background-color:#87adcd"], div[style*="background-color: #87adcd"], .lista-lembretes [style*="#87adcd"]'
                                    ).length;
                                    resultados.azuis = quantidade;
                                }
                                break;
                            case "verde":
                                sucesso = estilizarDivLembreteVerde();
                                if (sucesso) {
                                    quantidade = document.querySelectorAll(
                                        'div[style*="background-color:#a7eda7"], div[style*="background-color: #a7eda7"], .lista-lembretes [style*="#a7eda7"]'
                                    ).length;
                                    resultados.verdes = quantidade;
                                }
                                break;
                            case "laranja":
                                sucesso = estilizarDivLembreteLaranja();
                                if (sucesso) {
                                    quantidade = document.querySelectorAll(
                                        'div[style*="background-color:#f5b574"], div[style*="background-color: #f5b574"], .lista-lembretes [style*="#f5b574"]'
                                    ).length;
                                    resultados.laranjas = quantidade;
                                }
                                break;
                        }

                        log(
                            `✅ MASTER ${cor}: ${quantidade} lembretes estilizados`
                        );
                    } catch (error) {
                        log(
                            `❌ MASTER: Erro ao estilizar lembretes ${cor}:`,
                            error
                        );
                    }
                });

                resultados.total =
                    resultados.amarelos +
                    resultados.vermelhos +
                    resultados.azuis +
                    resultados.verdes +
                    resultados.laranjas;

                log("🎨 MASTER CONCLUÍDO:", resultados);
                return resultados;
            }

            /**
             * 🔍 FUNÇÃO DE DEBUG MASTER - Verifica todos os divLembrete coloridos
             */
            function debugTodosDivLembrete() {
                log(
                    "🔍 DEBUG MASTER: Analisando todos os divLembrete coloridos"
                );

                const cores = {
                    amarelo: {
                        seletor:
                            'div.divLembrete[style*="background-color:#efef8f"], div.divLembrete[style*="background-color: #efef8f"]',
                        gradiente: "linear-gradient( #F9EFAF, #F7E98D)",
                    },
                    vermelho: {
                        seletor:
                            'div.divLembrete[style*="background-color:#db8080"], div.divLembrete[style*="background-color: #db8080"]',
                        gradiente: "linear-gradient( #FAAFAF, #F78D8D)",
                    },
                    azul: {
                        seletor:
                            'div.divLembrete[style*="background-color:#87adcd"], div.divLembrete[style*="background-color: #87adcd"]',
                        gradiente: "linear-gradient( #AFCFFA, #8DC0F7)",
                    },
                    verde: {
                        seletor:
                            'div.divLembrete[style*="background-color:#a7eda7"], div.divLembrete[style*="background-color: #a7eda7"]',
                        gradiente: "linear-gradient( #AFFAB6, #8DF792)",
                    },
                    laranja: {
                        seletor:
                            'div.divLembrete[style*="background-color:#f5b574"], div.divLembrete[style*="background-color: #f5b574"]',
                        gradiente: "linear-gradient( #FAD3AF, #F7C68D)",
                    },
                };

                const resumo = {
                    totalEncontrados: 0,
                    porCor: {},
                };

                Object.keys(cores).forEach((cor) => {
                    const elementos = document.querySelectorAll(
                        cores[cor].seletor
                    );
                    resumo.porCor[cor] = {
                        quantidade: elementos.length,
                        elementos: Array.from(elementos).map((el) => ({
                            id: el.id,
                            classes: el.className,
                            conteudo: el.textContent.substring(0, 50) + "...",
                        })),
                    };
                    resumo.totalEncontrados += elementos.length;

                    log(
                        `📋 ${cor.toUpperCase()}: ${elementos.length} elementos`
                    );
                });

                log("🔍 DEBUG MASTER RESUMO:", resumo);
                return resumo;
            }

            /**
             * 🔄 FUNÇÃO DE ESTILIZAÇÃO ROBUSTA - Com detecção inteligente e retry automático
             */
            function aplicarEstilizacaoLembretesRobusta() {
                log(
                    "🔄 ESTILIZAÇÃO ROBUSTA: Iniciando com detecção inteligente..."
                );

                // 1. PRIMEIRO: Detectar que tipos de lembretes existem
                const deteccao = detectarTiposLembretesNaPagina();

                if (deteccao.coresEncontradas.length === 0) {
                    log(
                        "ℹ️ ESTILIZAÇÃO ROBUSTA: Nenhum lembrete colorido encontrado na página atual"
                    );
                    return false;
                }

                log(
                    `🎯 ESTILIZAÇÃO ROBUSTA: Encontrados lembretes de ${deteccao.coresEncontradas.length} cores diferentes`
                );

                let tentativas = 0;
                const maxTentativas = 5;
                const intervalTentativas = 1000; // 1 segundo entre tentativas

                const tentarEstilizar = () => {
                    tentativas++;
                    log(
                        `🎯 ESTILIZAÇÃO: Tentativa ${tentativas}/${maxTentativas}`
                    );

                    const resultado = estilizarTodosDivLembrete();
                    const sucesso = resultado.total > 0;

                    if (!sucesso && tentativas < maxTentativas) {
                        log(
                            `⏳ ESTILIZAÇÃO: Aguardando ${intervalTentativas}ms para nova tentativa...`
                        );
                        setTimeout(tentarEstilizar, intervalTentativas);
                    } else if (sucesso) {
                        log(
                            "✅ ESTILIZAÇÃO ROBUSTA: Lembretes estilizados com sucesso!"
                        );
                        log(
                            `📊 RESULTADOS: ${resultado.total} lembretes processados`,
                            resultado
                        );
                    } else {
                        log(
                            "⚠️ ESTILIZAÇÃO ROBUSTA: Não foi possível encontrar lembretes após todas as tentativas"
                        );
                    }
                };

                // Iniciar primeira tentativa
                tentarEstilizar();

                // Também agendar uma verificação após carregamento completo
                if (document.readyState !== "complete") {
                    window.addEventListener("load", () => {
                        setTimeout(() => {
                            log(
                                "🔄 ESTILIZAÇÃO: Verificação pós-carregamento..."
                            );
                            estilizarTodosDivLembrete();
                        }, 500);
                    });
                }
            }

            /**
             * ⚡ APLICAÇÃO IMEDIATA ANTI-FLASH ULTRA-OTIMIZADA - ZERO FLASH GARANTIDO
             * Sistema ultrarrápido que elimina completamente qualquer transformação visual
             */
            function aplicarEstilizacaoImediataLembretes() {
                try {
                    // 🚀 ULTRA-OTIMIZAÇÃO: Execução sem logs para máxima velocidade

                    // 1. DETECÇÃO ULTRARRÁPIDA de lembretes
                    const deteccao = detectarTiposLembretesNaPagina();

                    if (deteccao.coresEncontradas.length === 0) {
                        return false;
                    }

                    // 2. BATCH PROCESSING: Preparar todos os estilos em memória primeiro
                    const styleBatch = new Map();
                    const elementsToProcess = [];

                    deteccao.coresEncontradas.forEach((nomeCor) => {
                        const elementos =
                            deteccao.elementosPorCor[nomeCor] || [];

                        elementos.forEach((elemento) => {
                            if (
                                !elemento.classList.contains(
                                    "eprobe-lembrete-processado"
                                )
                            ) {
                                // Preparar estilos em batch para aplicação simultânea
                                const styleConfig = {
                                    element: elemento,
                                    styles: {},
                                };

                                // Gradientes otimizados por cor
                                switch (nomeCor) {
                                    case "amarelo":
                                        styleConfig.styles.background =
                                            "linear-gradient(#F9EFAF, #F7E98D)";
                                        break;
                                    case "vermelho":
                                        styleConfig.styles.background =
                                            "linear-gradient(#FAAFAF, #F78D8D)";
                                        break;
                                    case "azul":
                                        styleConfig.styles.background =
                                            "linear-gradient(#AFCFFA, #8DC0F7)";
                                        break;
                                    case "verde":
                                        styleConfig.styles.background =
                                            "linear-gradient(#AFFAB6, #8DF792)";
                                        break;
                                    case "laranja":
                                        styleConfig.styles.background =
                                            "linear-gradient(#FAD3AF, #F7C68D)";
                                        break;
                                }

                                // Estilos base ultra-otimizados
                                Object.assign(styleConfig.styles, {
                                    padding: "20px",
                                    boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)",
                                    transition: "box-shadow 0.2s ease",
                                    WebkitFontSmoothing: "subpixel-antialiased",
                                    visibility: "visible",
                                    opacity: "1",
                                });

                                elementsToProcess.push(styleConfig);
                            }
                        });
                    });

                    // 3. APLICAÇÃO SIMULTÂNEA: Aplicar todos os estilos de uma vez
                    // Usar requestAnimationFrame para sincronizar com o browser
                    const applyStylesBatch = () => {
                        elementsToProcess.forEach(({ element, styles }) => {
                            // Aplicação ultrarrápida usando Object.assign para CSSStyleDeclaration
                            Object.entries(styles).forEach(([prop, value]) => {
                                element.style.setProperty(
                                    prop
                                        .replace(/([A-Z])/g, "-$1")
                                        .toLowerCase(),
                                    value,
                                    "important"
                                );
                            });

                            // Marcar como processado instantaneamente
                            element.classList.add("eprobe-lembrete-processado");
                        });

                        // 4. SUBSTITUIÇÃO INSTANTÂNEA de ícones (sem logs)
                        substituirIconesLembretesImediato();

                        // 5. VERIFICAÇÃO FINAL: Garantir visibilidade
                        deteccao.elementos.forEach((elemento) => {
                            if (
                                !elemento.classList.contains(
                                    "eprobe-lembrete-processado"
                                )
                            ) {
                                elemento.classList.add(
                                    "eprobe-lembrete-processado"
                                );
                                elemento.style.setProperty(
                                    "visibility",
                                    "visible",
                                    "important"
                                );
                                elemento.style.setProperty(
                                    "opacity",
                                    "1",
                                    "important"
                                );
                            }
                        });
                    };

                    // Executar IMEDIATAMENTE sem aguardar frame
                    applyStylesBatch();

                    return true;
                } catch (error) {
                    log(
                        "❌ ANTI-FLASH: Erro durante aplicação imediata:",
                        error
                    );

                    // FALLBACK DE EMERGÊNCIA: Tornar todos os lembretes visíveis imediatamente
                    const todosLembretes = document.querySelectorAll(
                        'div.divLembrete, .lista-lembretes .lembrete, div[style*="background-color:#efef8f"], div[style*="background-color:#db8080"], div[style*="background-color:#87adcd"], div[style*="background-color:#a7eda7"], div[style*="background-color:#f5b574"]'
                    );

                    todosLembretes.forEach((elemento) => {
                        elemento.style.setProperty(
                            "visibility",
                            "visible",
                            "important"
                        );
                        elemento.style.setProperty("opacity", "1", "important");
                    });

                    log(
                        `🚨 FALLBACK: ${todosLembretes.length} lembretes restaurados via fallback`
                    );
                    return false;
                }
            }

            /**
             * ⚡ SUBSTITUIÇÃO IMEDIATA DE ÍCONES - SEM LOGS PARA MÁXIMA PERFORMANCE
             * Versão ultra-rápida da substituição de ícones para eliminar flash
             */
            function substituirIconesLembretesImediato() {
                // ⛔ RESTRIÇÃO: Só personalizar ícones na página de capa do processo
                if (!isCapaProcessoPage()) {
                    return false; // Retorno silencioso para não gerar logs excessivos
                }

                try {
                    // 1. Substituir ícones de editar
                    const iconesEditar = document.querySelectorAll(
                        'a[aria-label="Alterar Lembrete"] span.material-icons, a[href*="processo_lembrete_destino_alterar"] span.material-icons'
                    );

                    iconesEditar.forEach((icone) => {
                        if (
                            icone.textContent.trim() === "edit" &&
                            !icone.hasAttribute("data-eprobe-icon-replaced")
                        ) {
                            const svgContainer = document.createElement("span");
                            svgContainer.innerHTML =
                                '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#545454"><path d="m478.61-517.54 41.62 41.62L736.31-692l-41.62-41.62-216.08 216.08ZM218.69-216h41.62l223.77-223.77-41.62-41.62-223.77 223.77V-216Zm320.62-204.69L423.77-536.61l148.31-148.31-43.69-43.69q-3.08-3.08-9.23-3.08-6.16 0-9.24 3.08L320.85-539.54l-37.15-36.38 191.23-189.85q18.69-18.69 45.3-18.69 26.62 0 45.31 18.69l43.69 43.69 54.54-54.53q12.85-12.85 31.11-12.85 18.27 0 31.12 12.85l54.84 54.84q12.85 12.85 11.97 29.85-.89 17-12.73 30.84L539.31-420.69ZM282.23-164H166.69v-115.54l256.7-257.07 115.92 115.92L282.23-164Z"/></svg>';
                            const svg = svgContainer.firstElementChild;
                            if (icone.className) {
                                svg.setAttribute(
                                    "class",
                                    icone.className + " eprobe-substituted-icon"
                                );
                            } else {
                                svg.classList.add(
                                    "material-icons",
                                    "eprobe-substituted-icon"
                                );
                            }
                            svg.setAttribute(
                                "data-eprobe-icon-replaced",
                                "true"
                            );

                            // 📏 DIMENSIONAMENTO ESPECÍFICO: Verificar se está em divListaRecursosMinuta
                            aplicarDimensionamentoRecursosMinuta(svg);

                            icone.parentNode.replaceChild(svg, icone);
                        }
                    });

                    // 2. Substituir ícones de excluir
                    const iconesExcluir = document.querySelectorAll(
                        'a[aria-label="Desativar Lembrete"] span.material-icons, a[onclick*="desativarLembrete"] span.material-icons'
                    );

                    iconesExcluir.forEach((icone) => {
                        if (
                            icone.textContent.trim() === "delete" &&
                            !icone.hasAttribute("data-eprobe-icon-replaced")
                        ) {
                            const svgContainer = document.createElement("span");
                            svgContainer.innerHTML =
                                '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#545454"><path d="M324.31-164q-26.62 0-45.47-18.84Q260-201.69 260-228.31V-696h-48v-52h172v-43.38h192V-748h172v52h-48v467.26q0 27.74-18.65 46.24Q662.7-164 635.69-164H324.31ZM648-696H312v467.69q0 5.39 3.46 8.85t8.85 3.46h311.38q4.62 0 8.46-3.85 3.85-3.84 3.85-8.46V-696ZM400.16-288h51.99v-336h-51.99v336Zm107.69 0h51.99v-336h-51.99v336ZM312-696v480-480Z"/></svg>';
                            const svg = svgContainer.firstElementChild;
                            if (icone.className) {
                                svg.setAttribute(
                                    "class",
                                    icone.className + " eprobe-substituted-icon"
                                );
                            } else {
                                svg.classList.add(
                                    "material-icons",
                                    "eprobe-substituted-icon"
                                );
                            }
                            if (icone.title)
                                svg.setAttribute("title", icone.title);
                            if (icone.getAttribute("alt"))
                                svg.setAttribute(
                                    "alt",
                                    icone.getAttribute("alt")
                                );
                            if (icone.getAttribute("aria-hidden"))
                                svg.setAttribute(
                                    "aria-hidden",
                                    icone.getAttribute("aria-hidden")
                                );
                            svg.setAttribute(
                                "data-eprobe-icon-replaced",
                                "true"
                            );

                            // 📏 DIMENSIONAMENTO ESPECÍFICO: Verificar se está em divListaRecursosMinuta
                            aplicarDimensionamentoRecursosMinuta(svg);

                            icone.parentNode.replaceChild(svg, icone);
                        }
                    });

                    // 3. Substituir botões "Ler mais" por ícone expand_all (apenas quando necessário)
                    let botoesLerMais = Array.from(
                        document.querySelectorAll("div.botaoLerMais")
                    ).filter((botao) => {
                        const texto = (botao.textContent || "").toLowerCase();
                        return (
                            texto.includes("ler mais") ||
                            texto.includes("...ler mais") ||
                            texto.includes("... ler mais")
                        );
                    });

                    botoesLerMais.forEach((botao) => {
                        if (
                            !botao.hasAttribute("data-eprobe-expandir-replaced")
                        ) {
                            const temEventoClick =
                                botao.onclick || botao.getAttribute("onclick");
                            if (!temEventoClick) return;

                            const lembreteParent =
                                botao.closest(".divLembrete");
                            if (!lembreteParent) return;

                            const desLembrete =
                                lembreteParent.querySelector(".desLembrete");
                            if (!desLembrete) return;

                            // Verificar se há truncamento de texto
                            const textoCompleto = desLembrete.textContent || "";
                            const temTextoTruncado =
                                textoCompleto.length > 150 ||
                                desLembrete.scrollHeight >
                                    desLembrete.clientHeight ||
                                textoCompleto.includes("...") ||
                                window.getComputedStyle(desLembrete)
                                    .textOverflow === "ellipsis";

                            if (!temTextoTruncado) return;

                            // Criar container centralizado
                            const container = document.createElement("div");
                            container.style.cssText =
                                "margin-top: 15px; margin-bottom: 25px; display: flex; align-items: center; justify-content: center; cursor: pointer; width: 100%;";
                            container.setAttribute(
                                "data-eprobe-expandir-replaced",
                                "true"
                            );

                            container.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#545454">
                                    <path d="M480-72 230-322l68-70 182 182 182-182 68 70L480-72ZM297-569l-67-71 250-250 250 250-67 71-183-183-183 183Z"/>
                                </svg>
                                <span style="color: #545454; font-size: 14px; font-weight: 500;">Expandir lembrete</span>
                            </div>
                        `;

                            // Copiar eventos
                            if (botao.onclick)
                                container.onclick = botao.onclick;
                            const onclickAttr = botao.getAttribute("onclick");
                            if (onclickAttr)
                                container.setAttribute("onclick", onclickAttr);

                            // Substituir elemento mantendo compatibilidade com eProc
                            try {
                                // Criar backup invisível do botão original para compatibilidade com eProc
                                const botaoBackup = botao.cloneNode(true);
                                botaoBackup.style.display = "none";
                                botaoBackup.style.visibility = "hidden";
                                botaoBackup.style.position = "absolute";
                                botaoBackup.style.top = "-9999px";
                                botaoBackup.setAttribute(
                                    "data-eprobe-backup",
                                    "true"
                                );

                                // Inserir container e backup
                                botao.parentNode.insertBefore(container, botao);
                                botao.parentNode.insertBefore(
                                    botaoBackup,
                                    botao
                                );
                                botao.parentNode.removeChild(botao);
                            } catch (error) {
                                // Silencioso para máxima performance
                            }
                        }
                    });

                    // 4. Marcar lembretes como processados
                    const lembretes = document.querySelectorAll(
                        ".lista-lembretes .lembrete"
                    );
                    lembretes.forEach((lembrete) => {
                        lembrete.classList.add("eprobe-lembrete-processado");
                    });
                } catch (error) {
                    // Silencioso para não afetar performance
                }
            }

            /**
             * 🚀 FUNÇÃO DE CORREÇÃO COMPLETA - Diagnosticar e corrigir tooltip
             * Executa diagnóstico completo e força recriação do tooltip DIRETO NO CARD
             */
            function diagnosticarECorrigirTooltip() {
                log("🚀 DIAGNÓSTICO COMPLETO: Iniciando com tooltip direto...");

                // 1. Verificar se há sessões detectadas
                const sessoesGlobais = window.SENT1_AUTO.todasSessoesDetectadas;
                log("📊 SESSÕES GLOBAIS:", sessoesGlobais);

                // 2. Verificar card atual
                const card = document.getElementById("eprobe-data-sessao");
                if (!card) {
                    logError("❌ DIAGNÓSTICO: Card não encontrado");
                    return false;
                }

                log("✅ DIAGNÓSTICO: Card encontrado");

                // 3. Remover qualquer indicador existente (não precisamos mais)
                const indicadorExistente = card.querySelector(
                    ".eprobe-figma-sessions-indicator"
                );
                if (indicadorExistente) {
                    log(" ️ DIAGNÓSTICO: Removendo indicador antigo...");
                    indicadorExistente.remove();
                }

                // 4. Se não há sessões múltiplas, criar dados de teste
                let sessoesParaTeste = sessoesGlobais;
                if (!sessoesParaTeste || sessoesParaTeste.length <= 1) {
                    log(
                        "⚠️ DIAGNÓSTICO: Criando dados de teste para tooltip..."
                    );
                    sessoesParaTeste = [
                        {
                            status: "Pautado",
                            data: "15/07/2025",
                            dataOriginal: "15/07/2025",
                            orgao: "4CCR",
                            tipoProcesso: "Apelação",
                            prioridade: 1,
                        },
                        {
                            status: "Retirado",
                            data: "10/07/2025",
                            dataOriginal: "10/07/2025",
                            orgao: "4CCR",
                            tipoProcesso: "Apelação",
                            prioridade: 2,
                        },
                        {
                            status: "Julgado",
                            data: "05/07/2025",
                            dataOriginal: "05/07/2025",
                            orgao: "4CCR",
                            tipoProcesso: "Apelação",
                            prioridade: 3,
                        },
                    ];

                    // Armazenar globalmente
                    window.SENT1_AUTO.todasSessoesDetectadas = sessoesParaTeste;
                }

                // 5. Remover tooltip antigo
                const tooltipAntigo = document.getElementById(
                    "eprobe-rich-tooltip"
                );
                if (tooltipAntigo) {
                    tooltipAntigo.remove();
                    log("🗑️ DIAGNÓSTICO: Tooltip antigo removido");
                }

                // 6. Aplicar tooltip DIRETO NO CARD
                log("🎨 DIAGNÓSTICO: Aplicando tooltip direto no card...");
                const resultado = adicionarTooltipDiretoNoCard(
                    card,
                    sessoesParaTeste
                );

                if (resultado && resultado.status === "sucesso") {
                    logCritical(
                        "✅ DIAGNÓSTICO: Tooltip direto aplicado com sucesso!"
                    );
                } else {
                    logError("❌ DIAGNÓSTICO: Falha ao aplicar tooltip direto");
                }

                // 7. Testar após 500ms
                setTimeout(() => {
                    log("🧪 DIAGNÓSTICO: Testando tooltip...");
                    testarTooltipRapido();
                }, 500);

                log("✅ DIAGNÓSTICO COMPLETO: Finalizado com tooltip direto!");
                return true;
            }

            /**
             * Obtém a classe CSS correspondente ao status
             * @param {string} status - Status da sessão
             * @returns {string} - Classe CSS correspondente
             */
            function obterClasseStatusPorTipo(status) {
                const statusLower = (status || "").toLowerCase();

                if (
                    statusLower.includes("pautado") ||
                    statusLower.includes("incluído")
                ) {
                    return "status-pautado";
                } else if (
                    statusLower.includes("julgado") ||
                    statusLower.includes("decidido")
                ) {
                    return "status-julgado";
                } else if (
                    statusLower.includes("retirado") ||
                    statusLower.includes("suspenso")
                ) {
                    return "status-retirado";
                }

                return "status-neutro";
            }

            /**
             * Obtém o ícone correspondente ao status
             * @param {string} status - Status da sessão
             * @returns {string} - HTML do ícone
             */
            function obterIconePorStatus(status) {
                const statusLower = (status || "").toLowerCase();

                if (
                    statusLower.includes("pautado") ||
                    statusLower.includes("incluído")
                ) {
                    return '<span class="material-icons">schedule</span>';
                } else if (
                    statusLower.includes("julgado") ||
                    statusLower.includes("decidido")
                ) {
                    return '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M6 3v12"/><circle cx="6" cy="3" r="3"/><path d="M6 21v-6"/><path d="M15 6a9 9 0 1 0 6 5.3c0.7-1.3 1-2.8 1-4.3 0-1.4-0.3-2.7-0.8-4z"/></svg>';
                } else if (
                    statusLower.includes("retirado") ||
                    statusLower.includes("suspenso")
                ) {
                    return '<span class="material-icons">pause_circle</span>';
                }

                return '<span class="material-icons">info</span>';
            }

            /**
             * Cria um card Material Design usando especificações EXATAS do Figma
             * @param {Object} dadosSessao - Dados da sessão detectada
             * @returns {HTMLElement} - Elemento do card criado
             */
            /**
             * 🎨 CONFIGURAÇÕES DOS CARDS POR STATUS
             * Define cor do ícone e texto do header para cada status
             * @param {string} status - Status da sessão (pode ser null/undefined)
             * @returns {Object} - Configuração com corIcon e statusText
             */
            function obterConfigCardPorStatus(status) {
                // Normalizar status (remover espaços, lowercase)
                const statusNormalizado = (status || "").toLowerCase().trim();

                // Mapeamento completo dos 8 cards conforme especificações Figma
                const configuracoes = {
                    pautado: {
                        corIcon: "#5C85B4",
                        statusText: "Pautado",
                    },
                    retirado: {
                        corIcon: "#CE2D4F",
                        statusText: "Retirado",
                    },
                    vista: {
                        corIcon: "#FFBF46",
                        statusText: "Vista",
                    },
                    julgado: {
                        corIcon: "#3AB795",
                        statusText: "Julgado",
                    },
                    adiado: {
                        corIcon: "#F55D3E",
                        statusText: "Adiado",
                    },
                    adiado935: {
                        corIcon: "#731963",
                        statusText: "Adiado 935",
                    },
                    sobrestado: {
                        corIcon: "#FCB0B3",
                        statusText: "Sobrestado",
                    },
                    diligencia: {
                        corIcon: "#00171F",
                        statusText: "Diligência",
                    },
                };

                // Buscar configuração exata ou fallback para Pautado
                return (
                    configuracoes[statusNormalizado] || configuracoes["pautado"]
                );
            }

            /**
             * 🎨 CARD FIGMA - IMPLEMENTAÇÃO DINÂMICA PARA TODOS OS STATUS
             * Base igual para todos, muda apenas texto do header e cor do ícone
             * @param {Object} dadosSessao - Dados da sessão (obrigatório)
             * @returns {HTMLElement|null} - Elemento do card ou null se erro
             */
            function criarCardMaterialDesign(dadosSessao) {
                // ⚠️ VALIDAÇÃO CRÍTICA: Card só funciona com dados da sessão
                if (!dadosSessao) {
                    log(
                        "❌ CARD FIGMA: Sem dados da sessão - não criando card"
                    );
                    return null;
                }

                try {
                    // Obter configuração baseada no status
                    const config = obterConfigCardPorStatus(dadosSessao.status);
                    log(
                        `🎨 CRIANDO CARD ${config.statusText.toUpperCase()} (${
                            config.corIcon
                        }):`,
                        dadosSessao
                    );

                    // 0. GARANTIR FONTE ROBOTO CARREGADA
                    if (
                        !document.querySelector(
                            'link[href*="fonts.googleapis.com"][href*="Roboto"]'
                        )
                    ) {
                        const linkRoboto = document.createElement("link");
                        linkRoboto.rel = "stylesheet";
                        linkRoboto.href =
                            "https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap";
                        document.head.appendChild(linkRoboto);
                    }

                    // 1. CONTAINER PRINCIPAL - Dimensões exatas: 169x60px conforme suas especificações
                    const cardContainer = document.createElement("div");
                    cardContainer.id = "eprobe-data-sessao";
                    cardContainer.className = "eprobe-figma-card-pautado";
                    cardContainer.style.cssText = `
                width: 190px;
                height: 60px;
                margin: 8px 4px;
                display: inline-block;
                position: relative;
                cursor: pointer;
                transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
                box-shadow: 0px 3px 3px rgba(0, 0, 0, 0.25);
                filter: drop-shadow(0px 4px 4px rgba(0, 0, 0, 0.3));
                border-radius: 9px;
            `;

                    // 2. SVG BASE - Dimensões atualizadas 190x60px para comportar "Conv. em Diligência"
                    const svg = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "svg"
                    );
                    svg.setAttribute("width", "190");
                    svg.setAttribute("height", "60");
                    svg.setAttribute("viewBox", "0 0 190 60");
                    svg.setAttribute("fill", "none");

                    // 3. FUNDO DO CARD - COR EXATA FIGMA
                    const backgroundRect = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "rect"
                    );
                    backgroundRect.setAttribute("x", "0");
                    backgroundRect.setAttribute("y", "0");
                    backgroundRect.setAttribute("width", "190");
                    backgroundRect.setAttribute("height", "60");
                    backgroundRect.setAttribute("rx", "9");
                    backgroundRect.setAttribute("fill", "#FEF7FF");
                    backgroundRect.setAttribute("stroke", "#CAC4D0");
                    backgroundRect.setAttribute("stroke-width", "0.75");

                    // 4. ÍCONE PAUTADO - CALENDÁRIO COM RELÓGIO #5C85B4
                    // Dimensões exatas do Figma: 24.9 x 24.75px
                    const iconGroup = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "g"
                    );

                    // Posição do ícone conforme especificações Figma exatas (ajustada para nova largura)
                    // left: 6.51%, top: 27.65%, dimensões: 24.9 x 24.75px
                    const iconX = Math.round(190 * 0.0651); // 6.51% de 190px = ~12px
                    const iconY = Math.round(60 * 0.2765); // 27.65% de 60px = ~16.6px

                    // Container do ícone com dimensões exatas
                    const iconRect = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "rect"
                    );
                    iconRect.setAttribute("x", iconX);
                    iconRect.setAttribute("y", iconY);
                    iconRect.setAttribute("width", "24.9");
                    iconRect.setAttribute("height", "24.75");
                    iconRect.setAttribute("fill", "none"); // Invisível, apenas para definir área

                    // SVG do calendário com relógio - dimensões 24.9 x 24.75px
                    const iconPath = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "path"
                    );
                    iconPath.setAttribute(
                        "transform",
                        `translate(${iconX}, ${iconY})`
                    );
                    iconPath.setAttribute(
                        "d",
                        "M2.48973 24.1623C1.80506 24.1623 1.21914 23.9317 0.731981 23.4705C0.244824 23.0093 0.00082991 22.4542 0 21.8052V5.3052C0 4.65698 0.243994 4.10227 0.731981 3.64105C1.21997 3.17984 1.80589 2.94884 2.48973 2.94805H3.7346V0.590912H6.22433V2.94805H16.1833V0.590912H18.673V2.94805H19.9179C20.6025 2.94805 21.1889 3.17905 21.6768 3.64105C22.1648 4.10305 22.4084 4.65777 22.4076 5.3052V10.815C22.4076 11.1489 22.2881 11.4291 22.0491 11.6553C21.81 11.8816 21.5146 11.9944 21.1627 11.9936C20.8108 11.9928 20.5154 11.8797 20.2764 11.6542C20.0374 11.4287 19.9179 11.1489 19.9179 10.815V10.0195H2.48973V21.8052H9.70995C10.0627 21.8052 10.3585 21.9183 10.5975 22.1446C10.8366 22.3709 10.9556 22.6506 10.9548 22.9838C10.954 23.3169 10.8345 23.597 10.5963 23.8241C10.3581 24.0512 10.0627 24.1639 9.70995 24.1623H2.48973ZM18.673 25.3409C16.9509 25.3409 15.4832 24.7662 14.2699 23.6167C13.0566 22.4672 12.4495 21.0776 12.4487 19.4481C12.4478 17.8185 13.0549 16.4289 14.2699 15.2794C15.4849 14.1299 16.9526 13.5552 18.673 13.5552C20.3934 13.5552 21.8615 14.1299 23.0773 15.2794C24.2931 16.4289 24.8998 17.8185 24.8973 19.4481C24.8948 21.0776 24.2877 22.4676 23.0761 23.6178C21.8644 24.7681 20.3967 25.3425 18.673 25.3409ZM20.7581 22.2472L21.6295 21.4222L19.2954 19.2123V15.9123H18.0506V19.6838L20.7581 22.2472Z"
                    );
                    iconPath.setAttribute("fill", config.corIcon);
                    iconPath.setAttribute("class", "eprobe-icon-dinamico");

                    iconGroup.appendChild(iconRect);
                    iconGroup.appendChild(iconPath);

                    // 5. TEXTO PRINCIPAL - "Pautado" (Header LP)
                    // Dimensões: 113.92 x 16.06px
                    // Posição: left: 26.04%, top: 23.33%, bottom: 49.9%
                    const textPrincipal = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "text"
                    );
                    // Cálculos atualizados: 26.04% de 190px = ~49.5px, 23.33% de 60px = 14px
                    const headerX = Math.round(190 * 0.2604); // 26.04% = ~49.5px
                    const headerY = Math.round(60 * 0.2333) + 13.5; // 23.33% + font-size para baseline = ~27.5px

                    textPrincipal.setAttribute("x", headerX.toString());
                    textPrincipal.setAttribute("y", headerY.toString());
                    textPrincipal.setAttribute(
                        "font-family",
                        "Roboto, sans-serif"
                    );
                    textPrincipal.setAttribute("font-style", "normal");
                    textPrincipal.setAttribute("font-weight", "500");
                    textPrincipal.setAttribute("font-size", "13.5037px");
                    textPrincipal.setAttribute("line-height", "16");
                    textPrincipal.setAttribute("fill", "#1D1B20");
                    textPrincipal.setAttribute("text-anchor", "start");
                    textPrincipal.setAttribute("class", "eprobe-status-text");
                    textPrincipal.textContent = config.statusText;

                    // 6. SUBTÍTULO - "Sessão: getData()" (Subhead LP)
                    // Dimensões: 103.36 x 15.89px
                    // Posição: left: 26.04%, top: 50.1%, bottom: 24.9%
                    const dataExtraida = getData(dadosSessao);
                    const textData = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "text"
                    );
                    // Cálculos atualizados: 26.04% de 190px = ~49.5px, 50.1% de 60px = 30px
                    const subheadX = Math.round(190 * 0.2604); // 26.04% = ~49.5px
                    const subheadY = Math.round(60 * 0.501) + 11; // 50.1% + font-size para baseline = ~41px

                    textData.setAttribute("x", subheadX.toString());
                    textData.setAttribute("y", subheadY.toString());
                    textData.setAttribute("font-family", "Roboto, sans-serif");
                    textData.setAttribute("font-style", "normal");
                    textData.setAttribute("font-weight", "400");
                    textData.setAttribute("font-size", "11px");
                    textData.setAttribute("line-height", "15");
                    textData.setAttribute("letter-spacing", "0.187552px");
                    textData.setAttribute("fill", "#1D1B20");
                    textData.setAttribute("text-anchor", "start");
                    textData.setAttribute("class", "eprobe-date-text");
                    textData.textContent = `Sessão: ${dataExtraida}`;

                    // 7. MONTAGEM DO SVG
                    svg.appendChild(backgroundRect);
                    svg.appendChild(iconGroup);
                    svg.appendChild(textPrincipal);
                    svg.appendChild(textData);

                    // 8. ADICIONAR AO CONTAINER
                    cardContainer.appendChild(svg);

                    // 8.1. CONFIGURAR TOOLTIP DIRETO NO CARD (SEM INDICADOR)
                    // ✅ CORREÇÃO: Configurar tooltip direto sem necessidade de indicador
                    const sessoesParaTooltip =
                        dadosSessao.todasSessoes ||
                        window.SENT1_AUTO.todasSessoesDetectadas ||
                        (dadosSessao.dataOriginal ? [dadosSessao] : []);

                    log(
                        `🔍 CARD DEBUG: dadosSessao.todasSessoes=${
                            dadosSessao.todasSessoes?.length || 0
                        }, ` +
                            `window.SENT1_AUTO.todasSessoesDetectadas=${
                                window.SENT1_AUTO.todasSessoesDetectadas
                                    ?.length || 0
                            }, ` +
                            `sessoesParaTooltip=${sessoesParaTooltip.length}`
                    );

                    if (sessoesParaTooltip && sessoesParaTooltip.length > 0) {
                        log(
                            `🎯 CARD: ${sessoesParaTooltip.length} sessões detectadas - configurando tooltip direto`
                        );

                        // Configurar tooltip direto no card
                        setTimeout(() => {
                            const resultadoTooltip =
                                adicionarTooltipDiretoNoCard(
                                    cardContainer,
                                    sessoesParaTooltip
                                );
                            if (
                                resultadoTooltip &&
                                resultadoTooltip.status === "sucesso"
                            ) {
                                log(
                                    "✅ CARD: Tooltip direto configurado com sucesso!"
                                );
                            } else {
                                log(
                                    "⚠️ CARD: Falha ao configurar tooltip direto"
                                );
                            }
                        }, 100);
                    } else {
                        log(
                            "ℹ️ CARD: Apenas uma sessão - tooltip simples será aplicado no hover"
                        );
                    }

                    // 8.1. APLICAR ESTILOS CSS ESPECÍFICOS PARA GARANTIR ESPECIFICAÇÕES FIGMA
                    const cardStyle = document.createElement("style");
                    if (!document.getElementById("eprobe-card-figma-styles")) {
                        cardStyle.id = "eprobe-card-figma-styles";
                        cardStyle.textContent = `
                    .eprobe-figma-card-pautado {
                        font-family: 'Roboto', sans-serif !important;
                    }
                    
                    .eprobe-figma-card-pautado text {
                        font-family: 'Roboto', sans-serif !important;
                        shape-rendering: crispEdges;
                        text-rendering: optimizeLegibility;
                        
                    }
                    
                    /* Header LP - Especificações exatas Figma */
                    .eprobe-status-text {
                        font-family: 'Roboto', sans-serif !important;
                        font-style: normal !important;
                        font-weight: 500 !important;
                        font-size: 13.5037px !important;
                        line-height: 16px !important;
                        fill: #1D1B20 !important;
                        font-stretch: 100 !important;
                        text-align: justify !important;
                    }
                    
                    /* Subhead LP - Especificações exatas Figma */
                    .eprobe-date-text {
                        font-family: 'Roboto', sans-serif !important;
                        font-style: normal !important;
                        font-weight: 400 !important;
                        font-size: 11px !important;
                        line-height: 15px !important;
                        letter-spacing: 0.187552px !important;
                        fill: #1D1B20 !important;
                    }
                    
                    /* IconAzul - Especificações Figma */
                    .eprobe-icon-azul {
                        background: #5C85B4 !important;
                        width: 24.9px !important;
                        height: 24.75px !important;
                    }
                `;
                        document.head.appendChild(cardStyle);
                    }

                    // 9. EFEITOS HOVER - MATERIAL DESIGN ELEVATION
                    addPassiveEventListener(cardContainer, "mouseenter", () => {
                        cardContainer.style.transform = "translateY(-2px)";
                        cardContainer.style.boxShadow =
                            "0px 8px 12px 6px rgba(0, 0, 0, 0.15)";
                        cardContainer.style.filter =
                            "drop-shadow(0px 6px 6px rgba(0, 0, 0, 0.35))";
                    });

                    addPassiveEventListener(cardContainer, "mouseleave", () => {
                        cardContainer.style.transform = "translateY(0)";
                        cardContainer.style.boxShadow =
                            "0px 3px 3px rgba(0, 0, 0, 0.25)";
                        cardContainer.style.filter =
                            "drop-shadow(0px 4px 4px rgba(0, 0, 0, 0.3))";
                    });

                    // 10. LOG DE SUCESSO
                    logCritical("✅ CARD PAUTADO CRIADO:", {
                        id: cardContainer.id,
                        status: "Pautado",
                        data: dataExtraida,
                        cor: "#5C85B4",
                    });

                    return cardContainer;
                } catch (error) {
                    console.error("❌ ERRO AO CRIAR CARD PAUTADO:", error);
                    return null;
                }
            }

            /**
             * Aplica estilos únicos para cards SVG do Figma
             */
            function aplicarEstilosSvgFigma() {
                if (document.getElementById("eprobe-figma-svg-styles")) return;

                const styleSvg = document.createElement("style");
                styleSvg.id = "eprobe-figma-svg-styles";
                styleSvg.textContent = `
            .eprobe-figma-card-svg {
                display: inline-block;
                margin: 8px 0;
                position: relative;
            }
            
            .eprobe-figma-svg-container {
                position: relative;
                display: inline-block;
            }
            
            .eprobe-figma-svg-container svg {
                transition: all 0.2s ease;
                display: block;
            }
            
            .eprobe-figma-card-svg:hover .eprobe-figma-svg-container svg {
                transform: translateY(-1px);
                filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
            }
            
            .eprobe-figma-data-overlay {
                position: absolute;
                bottom: 12px;
                left: 24px;
                right: 24px;
                pointer-events: none;
                z-index: 10;
            }
            
            .eprobe-figma-data-text {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 11px;
                font-weight: 500;
                color: #1D1B20;
                opacity: 0.9;
                text-align: left;
                display: block;
                line-height: 1.2;
                background: rgba(255, 255, 255, 0.8);
                padding: 2px 4px;
                border-radius: 4px;
                backdrop-filter: blur(4px);
            }
        `;
                document.head.appendChild(styleSvg);
            }

            /**
             * Obtém configuração específica para cada status baseada nos designs do Figma
             * @param {string} status - Status da sessão
             * @returns {Object} - Configuração do design
             */
            function obterConfigFigmaStatus(status) {
                const configs = {
                    PAUTADO: {
                        cor: "#5C85B4",
                        statusText: "Pautado",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Processo incluído em pauta para julgamento",
                    },
                    RETIRADO: {
                        cor: "#CE2D4F",
                        statusText: "Retirado de Pauta",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Processo retirado de pauta",
                    },
                    VISTA: {
                        cor: "#FFBF46",
                        statusText: "Pedido de Vista",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Pedido de vista apresentado",
                    },
                    JULGADO: {
                        cor: "#3AB795",
                        statusText: "Julgado",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Processo julgado",
                    },
                    ADIADO: {
                        cor: "#F55D3E",
                        statusText: "Adiado",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Julgamento adiado",
                    },
                    ADIADO_935: {
                        cor: "#731963",
                        statusText: "Adiado (art. 935)",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Adiado conforme art. 935",
                    },
                    SOBRESTADO: {
                        cor: "#FCB0B3",
                        statusText: "Sobrestado (art. 942)",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Sobrestado conforme art. 942",
                    },
                    DILIGENCIA: {
                        cor: "#00171F",
                        statusText: "Conv. em Diligência",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                    },
                };

                // Normalizar o status para busca (maiúsculo, remover acentos e caracteres especiais)
                const statusNormalizado = status
                    ? status.toUpperCase().replace(/[^A-Z0-9_]/g, "_")
                    : "PAUTADO";

                // Tentar match exato primeiro
                if (configs[statusNormalizado]) {
                    log(`✅ CONFIG: Status '${statusNormalizado}' encontrado`);
                    return configs[statusNormalizado];
                }

                // Fallback para status similar
                const statusFallback = Object.keys(configs).find((key) =>
                    key.includes(statusNormalizado.split("_")[0])
                );

                if (statusFallback) {
                    log(
                        `⚠️ CONFIG: Usando fallback '${statusFallback}' para '${statusNormalizado}'`
                    );
                    return configs[statusFallback];
                }

                // Fallback final para PAUTADO
                log(
                    `⚠️ CONFIG: Status '${statusNormalizado}' não encontrado, usando PAUTADO`
                );
                return configs.PAUTADO;
            }

            /**
             *  FUNÇÃO DE POSICIONAMENTO INTELIGENTE DO TOOLTIP
             * Calcula a melhor posição para o tooltip considerando:
             * - Bordas da viewport
             * - Posição do elemento de referência
             * - Tamanho do tooltip
             * - Preferências de posicionamento
             * @param {HTMLElement} tooltip - Elemento do tooltip
             * @param {HTMLElement} referencia - Elemento de referência (indicador)
             * @returns {Object} - Coordenadas {left, top} calculadas
             */
            function calcularPosicaoTooltipInteligente(
                tooltip,
                referencia,
                cardElement = null
            ) {
                // Obter dimensões dos elementos
                const refRect = referencia.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();

                // Se temos o card, usar suas dimensões também
                const cardRect = cardElement
                    ? cardElement.getBoundingClientRect()
                    : refRect;

                // Obter dimensões da viewport
                const viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    scrollX: window.scrollX,
                    scrollY: window.scrollY,
                };

                // Margem de segurança das bordas
                const margem = 16;
                const espacamento = 8; // Distância pequena entre indicador e tooltip

                // NOVA ESTRATÉGIA: POSICIONAR PRÓXIMO AO INDICADOR, NÃO AO CARD
                // 1. Posição preferencial: À direita do indicador
                // 2. Se não couber à direita: À esquerda do indicador
                // 3. Se não couber em nenhum lado: Abaixo do indicador

                let left, top;
                let posicao = "direita"; // Padrão

                // TENTAR POSICIONAR À DIREITA DO INDICADOR
                left = refRect.right + espacamento;

                // Verificar se cabe à direita
                if (left + tooltipRect.width > viewport.width - margem) {
                    // Não cabe à direita, tentar à esquerda
                    left = refRect.left - tooltipRect.width - espacamento;
                    posicao = "esquerda";

                    // Verificar se cabe à esquerda
                    if (left < margem) {
                        // Não cabe nem à direita nem à esquerda, posicionar abaixo
                        left =
                            refRect.left +
                            refRect.width / 2 -
                            tooltipRect.width / 2;
                        posicao = "abaixo";

                        // Ajustar horizontalmente se necessário
                        if (left < margem) {
                            left = margem;
                        } else if (
                            left + tooltipRect.width >
                            viewport.width - margem
                        ) {
                            left = viewport.width - tooltipRect.width - margem;
                        }
                    }
                }

                // POSICIONAMENTO VERTICAL
                if (posicao === "abaixo") {
                    // Posicionar abaixo do indicador
                    top = refRect.bottom + espacamento;
                } else {
                    // Posicionar alinhado verticalmente com o indicador (lateral)
                    top =
                        refRect.top +
                        refRect.height / 2 -
                        tooltipRect.height / 2;
                }

                // Verificar se o tooltip não sai da viewport verticalmente
                if (top < margem) {
                    top = margem;
                } else if (
                    top + tooltipRect.height >
                    viewport.height - margem
                ) {
                    if (posicao !== "abaixo") {
                        // Se estava lateral, tentar posicionar acima
                        top = refRect.top - tooltipRect.height - espacamento;
                        if (top < margem) {
                            // Se não couber acima, forçar dentro da viewport
                            top = viewport.height - tooltipRect.height - margem;
                        }
                    } else {
                        // Se estava abaixo, forçar dentro da viewport
                        top = viewport.height - tooltipRect.height - margem;
                    }
                }

                // Garantir que não saia da viewport (valores finais)
                left = Math.max(
                    margem,
                    Math.min(left, viewport.width - tooltipRect.width - margem)
                );
                top = Math.max(
                    margem,
                    Math.min(top, viewport.height - tooltipRect.height - margem)
                );

                log(
                    `📐 TOOLTIP: Posicionado "${posicao}" - left: ${left}, top: ${top}`
                );

                return {
                    left: Math.round(left),
                    top: Math.round(top),
                    position: posicao,
                    cardPosition: posicao, // Para compatibilidade
                };
            }

            /**
             * 🎨 RICH TOOLTIP MATERIAL DESIGN para múltiplas sessões
             * @param {HTMLElement} cardElement - Elemento do card
             * @param {Array} todasSessoes - Array com todas as sessões detectadas
             */
            function adicionarRichTooltipMaterialDesign(
                cardElement,
                todasSessoes
            ) {
                log(
                    "⚠️ DEPRECATED: adicionarRichTooltipMaterialDesign - usando função unificada"
                );
                return adicionarTooltipUnificado(cardElement, todasSessoes);
            }

            /**
             * ❌ FUNÇÃO DUPLICADA DESATIVADA
             * Esta função foi substituída por aplicarTooltipUnificado()
             * Redirecionando para evitar conflitos de tooltip
             */
            function adicionarTooltipDiretoNoCard(
                cardElement,
                todasSessoes = null
            ) {
                console.log(
                    "⚠️ TOOLTIP DUPLICADO: Redirecionando para função unificada..."
                );

                // 🔄 REDIRECIONAR PARA A FUNÇÃO UNIFICADA
                return aplicarTooltipUnificado(cardElement, todasSessoes);
            }

            // ❌ FUNÇÕES DUPLICADAS REMOVIDAS - Use apenas adicionarTooltipDiretoNoCard()
            // Todas as funções de tooltip agora redirecionam para a função ativa adicionarTooltipDiretoNoCard

            /**
             * ✅ FUNÇÃO UNIFICADA DE TOOLTIP - REDIRECIONAMENTO PARA FUNÇÃO ATIVA
             * @param {HTMLElement} cardElement - Elemento do card
             * @param {Array} todasSessoes - Array com todas as sessões
             */
            function adicionarTooltipUnificado(
                cardElement,
                todasSessoes = null
            ) {
                log(
                    "🔄 REDIRECT: adicionarTooltipUnificado → adicionarTooltipDiretoNoCard"
                );
                return adicionarTooltipDiretoNoCard(cardElement, todasSessoes);
            }

            /**
             * ✅ FUNÇÃO TOOLTIP INTERATIVO - REDIRECIONAMENTO PARA FUNÇÃO ATIVA
             * @param {HTMLElement} cardElement - Elemento do card
             * @param {Array} todasSessoes - Array com todas as sessões
             */
            function adicionarTooltipInterativo(cardElement, todasSessoes) {
                log(
                    "🔄 REDIRECT: adicionarTooltipInterativo → adicionarTooltipDiretoNoCard"
                );
                return adicionarTooltipDiretoNoCard(cardElement, todasSessoes);
            }

            /**
             * ✅ FUNÇÃO TOOLTIP SIMPLIFICADO - REDIRECIONAMENTO PARA FUNÇÃO ATIVA
             * @param {HTMLElement} cardElement - Elemento do card
             * @param {Array} todasSessoes - Array com todas as sessões
             */
            function criarTooltipSimplificado(cardElement, todasSessoes) {
                log(
                    "🔄 REDIRECT: criarTooltipSimplificado → adicionarTooltipDiretoNoCard"
                );
                return adicionarTooltipDiretoNoCard(cardElement, todasSessoes);
            }

            /**
             * Retorna ícone SVG apropriado para o status
             * @param {string} status - Status da sessão
             * @returns {string} - SVG do ícone
             */
            function getStatusIcon(status) {
                const icons = {
                    Julgado: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20 6L9 17l-5-5"></path>
            </svg>`,
                    Retirado: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>`,
                    Sobrestado: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>`,
                    "Pedido de Vista": `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>`,
                    Pautado: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12,6 12,12 16,14"></polyline>
            </svg>`,
                    Adiado: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M12 6v6l4 2"></path>
                <path d="M16 8a6 6 0 0 0-12 0"></path>
            </svg>`,
                };

                // Buscar ícone por palavra-chave
                for (const [key, icon] of Object.entries(icons)) {
                    if (
                        status.includes(key) ||
                        key.includes(status.split(" ")[0])
                    ) {
                        return icon;
                    }
                }

                // Ícone padrão
                return `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="16" x2="12" y2="12"></line>
            <line x1="12" y1="8" x2="12.01" y2="8"></line>
        </svg>`;
            }

            /**
             * Cria um item de informação para o card
             * @param {string} label - Rótulo da informação
             * @param {string} valor - Valor da informação
             * @param {string} icone - Nome do ícone Material
             * @returns {HTMLElement} - Elemento do item criado
             */
            function criarItemInformacao(label, valor, icone) {
                const item = document.createElement("div");
                item.className = "eprobe-info-item";

                const iconeEl = document.createElement("span");
                iconeEl.className = "material-icons eprobe-info-icon";
                iconeEl.textContent = icone;

                const textoContainer = document.createElement("div");
                textoContainer.className = "eprobe-info-text";

                const labelEl = document.createElement("div");
                labelEl.className = "eprobe-info-label";
                labelEl.textContent = label;

                const valorEl = document.createElement("div");
                valorEl.className = "eprobe-info-value";
                valorEl.textContent = valor;

                textoContainer.appendChild(labelEl);
                textoContainer.appendChild(valorEl);

                item.appendChild(iconeEl);
                item.appendChild(textoContainer);

                return item;
            }

            /**
             * 🧪 FUNÇÃO DE DEBUG PARA TOOLTIP DIRETO NO CARD
             * Testa o sistema de tooltip com dados simulados diretamente no card
             */
            function debugTooltipUnificado() {
                console.group("🧪 DEBUG: Sistema de Tooltip Direto no Card");

                // Verificar se há card de sessão
                const card = document.getElementById("eprobe-data-sessao");
                if (!card) {
                    console.warn("❌ Card de sessão não encontrado");
                    console.groupEnd();
                    return false;
                }

                console.log("✅ Card encontrado:", card);

                // Remover qualquer indicador existente (não precisamos mais)
                const indicadorExistente = card.querySelector(
                    ".eprobe-figma-sessions-indicator"
                );
                if (indicadorExistente) {
                    console.log("🗑️ Removendo indicador antigo...");
                    indicadorExistente.remove();
                }

                // Criar dados de teste
                const sessoesSimuladas = [
                    {
                        data: "15/01/2025",
                        status: "PAUTADO",
                        statusOriginal: "Incluído em Pauta",
                        codigo: "CIV1",
                        tipoProcesso: "Cível",
                        orgao: "1ª Câmara de Direito Civil",
                        isAtual: true,
                    },
                    {
                        data: "10/01/2025",
                        status: "RETIRADO",
                        statusOriginal: "Retirado de Pauta",
                        codigo: "CIV1",
                        tipoProcesso: "Cível",
                        orgao: "1ª Câmara de Direito Civil",
                        isAtual: false,
                    },
                    {
                        data: "05/01/2025",
                        status: "ADIADO",
                        statusOriginal: "Adiado em Pauta",
                        codigo: "CIV1",
                        tipoProcesso: "Cível",
                        orgao: "1ª Câmara de Direito Civil",
                        isAtual: false,
                    },
                ];

                console.log("📋 Dados simulados:", sessoesSimuladas);

                // Aplicar tooltip direto no card
                console.log("🎨 Aplicando tooltip direto no card...");
                const resultado = adicionarTooltipDiretoNoCard(
                    card,
                    sessoesSimuladas
                );

                if (resultado && resultado.status === "sucesso") {
                    console.log("✅ Tooltip direto aplicado com sucesso!");
                    console.log(
                        "🖱️ Teste: Passe o mouse sobre o card para ver o tooltip"
                    );
                } else {
                    console.error(
                        "❌ Falha ao aplicar tooltip direto:",
                        resultado
                    );
                }

                console.log(
                    "✅ Debug concluído - tooltip configurado diretamente no card"
                );
                console.groupEnd();

                return true;
            }

            /**
             * 🔧 FUNÇÃO NORMALIZADORA - Extrai a data da sessão de qualquer estrutura
             * ÚNICA FUNÇÃO para obter a data da sessão independente da origem dos dados
             * @param {Object|string} dadosSessao - Dados da sessão (qualquer formato)
             * @returns {string} - Data formatada como string (DD/MM/AAAA) ou fallback
             */
            function extrairDataSessaoNormalizada(dadosSessao) {
                // REGRA CRÍTICA: Sempre declarar variáveis antes de usar
                let dataExtraida = null;

                try {
                    // 1. Se dadosSessao é string, retornar diretamente
                    if (typeof dadosSessao === "string") {
                        return dadosSessao;
                    }

                    // 2. Se dadosSessao é null/undefined
                    if (!dadosSessao) {
                        logError(
                            "⚠️ NORMALIZAÇÃO: dadosSessao é null/undefined"
                        );
                        return "Data não disponível";
                    }

                    // 3. Tentar dadosSessao.data (estrutura do detectarCardSessaoSimplificado)
                    if (typeof dadosSessao.data === "string") {
                        dataExtraida = dadosSessao.data;
                        log(
                            `✅ NORMALIZAÇÃO: Usando dadosSessao.data = "${dataExtraida}"`
                        );
                        return dataExtraida;
                    }

                    // 4. Tentar dadosSessao.dataFormatada (estrutura do validarDataBrasileira)
                    if (typeof dadosSessao.dataFormatada === "string") {
                        dataExtraida = dadosSessao.dataFormatada;
                        log(
                            `✅ NORMALIZAÇÃO: Usando dadosSessao.dataFormatada = "${dataExtraida}"`
                        );
                        return dataExtraida;
                    }

                    // 5. Tentar dadosSessao.data.dataFormatada (estrutura aninhada)
                    if (
                        dadosSessao.data &&
                        typeof dadosSessao.data.dataFormatada === "string"
                    ) {
                        dataExtraida = dadosSessao.data.dataFormatada;
                        log(
                            `✅ NORMALIZAÇÃO: Usando dadosSessao.data.dataFormatada = "${dataExtraida}"`
                        );
                        return dataExtraida;
                    }

                    // 6. Fallback: Procurar qualquer propriedade que pareça uma data
                    const propriedadesPossiveis = [
                        "dataOriginal",
                        "dataString",
                        "dataSessao",
                    ];
                    for (const prop of propriedadesPossiveis) {
                        if (
                            dadosSessao[prop] &&
                            typeof dadosSessao[prop] === "string"
                        ) {
                            dataExtraida = dadosSessao[prop];
                            log(
                                `✅ NORMALIZAÇÃO: Usando dadosSessao.${prop} = "${dataExtraida}"`
                            );
                            return dataExtraida;
                        }
                    }

                    // 7. Log para debug se nenhuma propriedade foi encontrada
                    log(
                        "❌ NORMALIZAÇÃO: Nenhuma propriedade de data encontrada"
                    );
                    log("   Estrutura recebida:", Object.keys(dadosSessao));
                    log("   Dados completos:", dadosSessao);

                    return "Data não disponível";
                } catch (error) {
                    console.error(
                        "❌ NORMALIZAÇÃO: Erro ao extrair data:",
                        error
                    );
                    return "Erro na data";
                }
            }

            /**
             * 🎯 FUNÇÃO CURTA - Versão concisa para uso diário
             * @param {Object|string} d - Dados da sessão
             * @returns {string} - Data como string
             */
            function getData(d) {
                return extrairDataSessaoNormalizada(d);
            }

            /**
             * Atualiza o card existente com novos dados
             * VERSÃO CORRIGIDA - Usa função normalizadora para extrair data
             * @param {Object} dadosSessao - Novos dados da sessão
             */
            function atualizarCardMaterialDesign(dadosSessao) {
                const cardExistente =
                    document.getElementById("eprobe-data-sessao");

                // 🔧 CORREÇÃO: Usar função curta para extrair data
                const dataExtraida = getData(dadosSessao);

                log(
                    `📅 MATERIAL: Data normalizada extraída: "${dataExtraida}"`
                );

                if (cardExistente) {
                    log(
                        "🔄 MATERIAL: Card existente encontrado, verificando se precisa atualizar"
                    );

                    // Verificar se os dados realmente mudaram (usar data normalizada)
                    const statusAtual = cardExistente.querySelector(
                        ".eprobe-status-text"
                    )?.textContent;
                    const dataAtual =
                        cardExistente.querySelector(
                            ".eprobe-date-text"
                        )?.textContent;

                    if (
                        statusAtual === dadosSessao?.status &&
                        dataAtual?.includes(dataExtraida)
                    ) {
                        log(
                            "ℹ️ MATERIAL: Card já está atualizado, mantendo estado atual"
                        );
                        materialDesignState.cardAtivo = true;
                        materialDesignState.ultimaDeteccao = dadosSessao;
                        return;
                    }

                    log(
                        "🔄 MATERIAL: Dados mudaram, atualizando card Material Design"
                    );

                    // Remover card antigo apenas se os dados mudaram
                    cardExistente.remove();

                    // USAR A FUNÇÃO INTERNA que retorna elemento DOM
                    const card = criarCardMaterialDesign(dadosSessao);

                    if (card) {
                        inserirCardNaInterface(card);
                        log("✅ MATERIAL: Card atualizado com sucesso!");
                    } else {
                        console.error("❌ MATERIAL: Erro ao atualizar card");
                    }

                    materialDesignState.cardAtivo = true;
                    materialDesignState.ultimaDeteccao = dadosSessao;
                } else {
                    log("🆕 MATERIAL: Criando novo card Material Design");

                    // USAR A FUNÇÃO INTERNA que retorna elemento DOM
                    const card = criarCardMaterialDesign(dadosSessao);

                    if (card) {
                        inserirCardNaInterface(card);
                        log("✅ MATERIAL: Card inserido com sucesso!");
                    } else {
                        console.error(
                            "❌ MATERIAL: Erro ao criar card - função retornou null"
                        );
                    }

                    materialDesignState.cardAtivo = true;
                    materialDesignState.ultimaDeteccao = dadosSessao;
                }
            }

            /**
             * Insere o card na interface ao lado do lblMagistrado na row mt-2
             * VERSÃO CORRIGIDA - Posicionamento específico conforme solicitado
             * @param {HTMLElement} card - Elemento do card a ser inserido
             */
            /**
             * Insere o card fixo ao lado direito do elemento específico
             * POSICIONAMENTO ESPECÍFICO: /html/body/div[2]/div[3]/div[2]/div/div[1]/form[2]/div[3]/div/div/fieldset[1]/div/div[2]/div[3]
             * @param {HTMLElement} card - Elemento do card a ser inserido
             */
            function inserirCardNaInterface(card) {
                log(
                    "🎯 INSERÇÃO: Procurando txtMagistrado para inserir card ao lado DIREITO..."
                );

                try {
                    // Buscar o span do magistrado correto (txtMagistrado)
                    const txtMagistrado =
                        document.getElementById("txtMagistrado");

                    if (txtMagistrado) {
                        log("✅ INSERÇÃO: txtMagistrado encontrado!");
                        log(
                            "📍 INSERÇÃO: Texto do magistrado:",
                            txtMagistrado.textContent
                        );
                        log(
                            "📍 INSERÇÃO: Tag:",
                            txtMagistrado.tagName,
                            "ID:",
                            txtMagistrado.id
                        );

                        // Obter o container pai para posicionamento
                        const containerPai = txtMagistrado.parentElement;
                        if (containerPai) {
                            // Configurar o container pai para flex layout
                            containerPai.style.display = "flex";
                            containerPai.style.alignItems = "center";
                            containerPai.style.gap = "15px";

                            // Configurar o card para posicionamento flexível
                            card.style.position = "static";
                            card.style.flexShrink = "0";
                            card.style.marginLeft = "15px";

                            // Inserir o card DEPOIS do txtMagistrado (lado direito)
                            txtMagistrado.parentNode.insertBefore(
                                card,
                                txtMagistrado.nextSibling
                            );

                            log(
                                "✅ INSERÇÃO: Card posicionado ao lado DIREITO do txtMagistrado"
                            );
                            log(
                                "🎯 INSERÇÃO: Layout flex aplicado com gap de 15px"
                            );
                            return true;
                        } else {
                            log(
                                "⚠️ INSERÇÃO: Container pai do txtMagistrado não encontrado"
                            );
                        }
                    } else {
                        log(
                            "❌ INSERÇÃO: txtMagistrado não encontrado, tentando fallback lblMagistrado..."
                        );

                        // FALLBACK: Buscar lblMagistrado se txtMagistrado não existir
                        const lblMagistrado =
                            document.getElementById("lblMagistrado");

                        if (lblMagistrado) {
                            log(
                                "✅ INSERÇÃO: lblMagistrado encontrado como fallback!"
                            );

                            const containerPai = lblMagistrado.parentElement;
                            if (containerPai) {
                                // Aplicar layout flex
                                containerPai.style.display = "flex";
                                containerPai.style.alignItems = "center";
                                containerPai.style.gap = "15px";

                                // Configurar card
                                card.style.position = "static";
                                card.style.flexShrink = "0";
                                card.style.marginLeft = "15px";

                                // Inserir DEPOIS do label (lado direito)
                                lblMagistrado.parentNode.insertBefore(
                                    card,
                                    lblMagistrado.nextSibling
                                );

                                log(
                                    "✅ INSERÇÃO: Card inserido via fallback ao lado DIREITO do lblMagistrado"
                                );
                                return true;
                            }
                        }

                        // FALLBACK FINAL: XPath para magistrado
                        log(
                            "⚠️ INSERÇÃO: Tentando XPath para encontrar magistrado..."
                        );

                        const xpathMagistrado =
                            "//span[contains(@id, 'Magistrado') or contains(text(), 'ALEXANDRE MORAIS')]";
                        const spanMagistrado = document.evaluate(
                            xpathMagistrado,
                            document,
                            null,
                            XPathResult.FIRST_ORDERED_NODE_TYPE,
                            null
                        ).singleNodeValue;

                        if (spanMagistrado) {
                            log(
                                "✅ INSERÇÃO: Magistrado encontrado via XPath!"
                            );

                            const containerPai = spanMagistrado.parentElement;
                            if (containerPai) {
                                // Aplicar layout flex
                                containerPai.style.display = "flex";
                                containerPai.style.alignItems = "center";
                                containerPai.style.gap = "15px";

                                // Configurar card
                                card.style.position = "static";
                                card.style.flexShrink = "0";
                                card.style.marginLeft = "15px";

                                // Inserir DEPOIS do span (lado direito)
                                spanMagistrado.parentNode.insertBefore(
                                    card,
                                    spanMagistrado.nextSibling
                                );

                                log(
                                    "✅ INSERÇÃO: Card inserido via XPath ao lado DIREITO do magistrado"
                                );
                                return true;
                            }
                        }
                    }
                } catch (error) {
                    log("❌ INSERÇÃO: Erro ao buscar lblMagistrado:", error);
                }

                // FALLBACK FINAL: Posição fixa apenas se não conseguir encontrar o local correto
                log("⚠️ INSERÇÃO: Usando fallback - posição fixa");

                card.style.position = "fixed";
                card.style.top = "200px";
                card.style.right = "30px";
                card.style.zIndex = "9999";
                card.style.maxWidth = "180px";

                document.body.appendChild(card);
                log("✅ INSERÇÃO: Card inserido com fallback");
                return true;
            }

            /**
             * Remove o card Material Design da interface
             */
            function removerCardMaterialDesign() {
                const card = document.getElementById("eprobe-data-sessao");
                if (card) {
                    card.remove();
                    log("🗑️ MATERIAL: Card Material Design removido");

                    // Atualizar estado
                    materialDesignState.cardAtivo = false;
                    materialDesignState.ultimaDeteccao = null;

                    return true;
                }
                return false;
            }

            /**
             * Verifica se o card Material Design está presente na interface
             * @returns {boolean} - True se o card estiver presente
             */
            function cardMaterialDesignPresente() {
                return !!document.getElementById("eprobe-data-sessao");
            }

            // Função auxiliar para configurar tooltip por tipo
            function configurarTooltipPorTipo(dados) {
                try {
                    if (
                        dados.tooltipTipo === "rico" &&
                        dados.tipo === "multiplas_sessoes"
                    ) {
                        log(
                            "🎨 TOOLTIP: Aplicando tooltip rico para múltiplas sessões"
                        );
                        adicionarRichTooltipMaterialDesign();
                    } else if (dados.tooltipTipo === "simples") {
                        log("🎨 TOOLTIP: Aplicando tooltip simples");
                        criarTooltipSimplificado(dados);
                    }
                } catch (error) {
                    console.error(
                        "❌ TOOLTIP: Erro na configuração por tipo:",
                        error
                    );
                }
            }

            // Função para criar card com tooltip integrado
            function criarCardComTooltipIntegrado() {
                try {
                    log("🎯 CARD+TOOLTIP: Iniciando criação integrada...");

                    // 1. DETECTAR E CONFIGURAR DADOS
                    const dadosSessao = detectarEConfigurarTooltipUnificado();

                    if (!dadosSessao) {
                        log(
                            "ℹ️ CARD+TOOLTIP: Sem dados de sessão - não criando card"
                        );
                        return null;
                    }

                    // 2. CRIAR CARD MATERIAL DESIGN
                    const cardCriado = criarCardMaterialDesign(dadosSessao);

                    if (!cardCriado) {
                        logError("❌ CARD+TOOLTIP: Falha na criação do card");
                        return null;
                    }

                    // 3. AGUARDAR E CONFIGURAR TOOLTIP
                    setTimeout(() => {
                        const cardElement = document.querySelector(
                            ".card-material-design"
                        );
                        if (cardElement && dadosSessao.temTooltip) {
                            configurarTooltipPorTipo(dadosSessao);
                            log(
                                "✅ CARD+TOOLTIP: Card e tooltip configurados com sucesso"
                            );
                        } else {
                            log(
                                "⚠️ CARD+TOOLTIP: Card criado mas tooltip não configurado"
                            );
                        }
                    }, 500);

                    return dadosSessao;
                } catch (error) {
                    console.error(
                        "❌ CARD+TOOLTIP: Erro na criação integrada:",
                        error
                    );
                    return null;
                }
            }

            /**
             * Carrega os ícones Material Icons se não estiverem disponíveis
             */
            function carregarMaterialIcons() {
                // Verificar se os ícones já estão carregados
                if (document.querySelector('link[href*="material-icons"]')) {
                    logCritical(
                        "✅ MATERIAL: Ícones Material Icons já carregados"
                    );
                    return Promise.resolve();
                }

                return new Promise((resolve) => {
                    log("🔄 MATERIAL: Carregando ícones Material Icons...");

                    const linkElement = document.createElement("link");
                    linkElement.rel = "stylesheet";
                    linkElement.href =
                        "https://fonts.googleapis.com/icon?family=Material+Icons";

                    linkElement.onload = () => {
                        log(
                            "✅ MATERIAL: Ícones Material Icons carregados com sucesso"
                        );
                        resolve();
                    };

                    linkElement.onerror = () => {
                        console.warn(
                            "⚠️ MATERIAL: Erro ao carregar ícones Material Icons, continuando sem ícones"
                        );
                        resolve();
                    };

                    document.head.appendChild(linkElement);

                    // Resolve após 100ms mesmo se onload não disparar (fallback rápido)
                    setTimeout(resolve, 100);
                });
            }

            /**
             * Inicialização automática do sistema Material Design
             * VERSÃO OTIMIZADA - Sem recriação automática de cards
             */
            async function inicializarMaterialDesign() {
                // 🔥 PERFORMANCE: Pular se modo ultra-performance estiver ativo
                if (MODO_ULTRA_PERFORMANCE) {
                    log(
                        "🔥 PERFORMANCE: Inicialização Material Design PULADA (modo ultra-performance ativo)"
                    );
                    return;
                }

                log(
                    "🚀 MATERIAL: Inicializando sistema Material Design SIMPLIFICADO"
                );

                try {
                    // Aguardar um breve momento para garantir que a página esteja carregada
                    setTimeout(() => {
                        log(
                            "🔍 MATERIAL: Executando detecção de dados (sem criação automática de card)"
                        );

                        // Detectar dados disponíveis, mas NÃO criar card automaticamente
                        const resultado =
                            window.SENT1_AUTO?.detectarCardSessaoSimplificado?.();

                        if (resultado) {
                            log(
                                "✅ MATERIAL: Dados de sessão detectados e salvos (card será exibido apenas se dados forem válidos)"
                            );
                        } else {
                            log(
                                "ℹ️ MATERIAL: Nenhum dado de sessão detectado na página atual"
                            );
                        }
                    }, 500);

                    log(
                        "✅ MATERIAL: Sistema Material Design simplificado inicializado com sucesso"
                    );
                } catch (error) {
                    console.error(
                        "❌ MATERIAL: Erro na inicialização do Material Design:",
                        error
                    );
                }
            }

            /**
             * Aplica o CSS minimalista do Material Design
             */
            function aplicarCSSMaterialDesign() {
                // 🔥 PERFORMANCE: Pular se modo ultra-performance estiver ativo
                if (MODO_ULTRA_PERFORMANCE) {
                    log(
                        "🔥 PERFORMANCE: Aplicação de CSS Material Design PULADA (modo ultra-performance ativo)"
                    );
                    return;
                }

                log("🎨 MATERIAL: Iniciando aplicação do CSS minimalista");

                // Verificar se já foi aplicado
                const styleExistente = document.querySelector(
                    "style[data-eprobe-material-design]"
                );
                if (styleExistente) {
                    log("ℹ️ MATERIAL: CSS já aplicado, pulando aplicação");
                    return;
                }

                const css = `
                    /* eProbe Card Micro Compacto - Tamanho Exato do Conteúdo */
                    .eprobe-material-card-minimal {
                        background: #ffffff;
                        border: 1px solid #e5e7eb;
                        border-radius: 3px;
                        padding: 2px 4px;
                        margin: 1px 0;
                        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        width: fit-content;
                        max-width: none;
                        font-size: 10px;
                        transition: all 0.2s ease;
                        display: inline-block;
                        line-height: 1.1;
                    }
                    
                    .eprobe-material-card-minimal:hover {
                        box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
                    }
                    
                    .eprobe-card-minimal-content {
                        display: flex;
                        flex-direction: column;
                        gap: 1px;
                        white-space: nowrap;
                    }
                    
                    .eprobe-status-row {
                        display: flex;
                        align-items: center;
                        gap: 3px;
                    }
                    
                    .eprobe-date-row {
                        display: flex;
                        align-items: center;
                        gap: 3px;
                    }
                    
                    .eprobe-status-icon,
                    .eprobe-date-icon {
                        width: 12px;
                        height: 12px;
                        flex-shrink: 0;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                    }
                    
                    .eprobe-status-text {
                        font-size: 10px;
                        font-weight: 600;
                        color: #1f2937;
                        line-height: 1.1;
                    }
                    
                    .eprobe-date-label {
                        font-size: 9px;
                        color: #6b7280;
                        font-weight: 500;
                        line-height: 1.1;
                    }
                    
                    .eprobe-date-text {
                        font-size: 10px;
                        color: #374151;
                        font-weight: 600;
                        line-height: 1.1;
                    }
                    
                    /* Ícones SVG micro otimizados */
                    .eprobe-icon-calendar::before {
                        content: "";
                        display: block;
                        width: 12px;
                        height: 12px;
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect width='18' height='18' x='3' y='4' rx='2' ry='2'/%3E%3Cline x1='16' x2='16' y1='2' y2='6'/%3E%3Cline x1='8' x2='8' y1='2' y2='6'/%3E%3Cline x1='3' x2='21' y1='10' y2='10'/%3E%3C/svg%3E");
                        background-repeat: no-repeat;
                        background-size: contain;
                        background-position: center;
                    }
                    
                    .eprobe-icon-check::before {
                        content: "";
                        display: block;
                        width: 12px;
                        height: 12px;
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2310b981' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20,6 9,17 4,12'/%3E%3C/svg%3E");
                        background-repeat: no-repeat;
                        background-size: contain;
                        background-position: center;
                    }
                    
                    .eprobe-icon-alert::before {
                        content: "";
                        display: block;
                        width: 12px;
                        height: 12px;
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23f59e0b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z'/%3E%3Cpath d='M12 9v4'/%3E%3Cpath d='m12 17 .01 0'/%3E%3C/svg%3E");
                        background-repeat: no-repeat;
                        background-size: contain;
                        background-position: center;
                    }
                    
                    .eprobe-icon-info::before {
                        content: "";
                        display: block;
                        width: 12px;
                        height: 12px;
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%233b82f6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='m9 12 2 2 4-4'/%3E%3C/svg%3E");
                        background-repeat: no-repeat;
                        background-size: contain;
                        background-position: center;
                    }
                    
                    /* Cores dos ícones por status */
                    .eprobe-status-icon.status-pautado .eprobe-icon-info::before {
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%233b82f6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='m9 12 2 2 4-4'/%3E%3C/svg%3E");
                    }
                    
                    .eprobe-status-icon.status-julgado .eprobe-icon-check::before {
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2310b981' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20,6 9,17 4,12'/%3E%3C/svg%3E");
                    }
                    
                    .eprobe-status-icon.status-retirado .eprobe-icon-alert::before {
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23f59e0b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z'/%3E%3Cpath d='M12 9v4'/%3E%3Cpath d='m12 17 .01 0'/%3E%3C/svg%3E");
                    }
                    
                    /* Responsividade */
                    @media (max-width: 768px) {
                        .eprobe-material-card-minimal {
                            max-width: 90vw;
                        }
                        
                        .eprobe-card-minimal-content {
                            white-space: normal;
                        }
                    }
                `;

                // Carregar ícones já incluídos no CSS
                const styleElement = document.createElement("style");
                styleElement.setAttribute(
                    "data-eprobe-material-design",
                    "true"
                );
                styleElement.textContent = css;
                document.head.appendChild(styleElement);

                log(
                    "✅ MATERIAL: CSS minimalista aplicado com ícones SVG incluídos"
                );
            }

            // IMPORTANTE: Aplicar CSS imediatamente
            aplicarCSSMaterialDesign();

            /**
             * 🔧 FUNÇÃO DE CORREÇÃO - Forçar recriação completa do card de sessão
             * Seguindo REGRAS CRÍTICAS: SEMPRE declarar variáveis e verificar existência
             */
            function forcarRecriacaoCardSessao() {
                log(
                    "🔧 CORREÇÃO: Forçando recriação completa do card de sessão"
                );

                // REGRA CRÍTICA: Declarar todas as variáveis antes de usar
                let cardExistente = null;
                let dadosSessaoGlobais = null;
                let statusSessao = null;

                try {
                    // Verificar se há dados globais salvos
                    if (
                        typeof window.SENT1_AUTO !== "undefined" &&
                        window.SENT1_AUTO.showDadosGlobaisSessao
                    ) {
                        dadosSessaoGlobais =
                            window.SENT1_AUTO.showDadosGlobaisSessao();
                    }

                    // Obter status atual
                    if (typeof getStatusSessao === "function") {
                        statusSessao = getStatusSessao();
                    }

                    // Dados mínimos para o card
                    const dadosCard = {
                        status: statusSessao?.status || "Pautado",
                        data: {
                            dataFormatada:
                                statusSessao?.data?.dataFormatada ||
                                "29/07/2025",
                        },
                    };

                    log("📋 CORREÇÃO: Dados para o card:", dadosCard);

                    // Remover card existente
                    cardExistente =
                        document.getElementById("eprobe-data-sessao");
                    if (cardExistente) {
                        log("🗑️ CORREÇÃO: Removendo card existente");
                        cardExistente.remove();
                    }

                    // Forçar reaplicação do CSS (apenas em páginas permitidas)
                    if (isCapaProcessoPage()) {
                        forcarReaplicacaoIcones();
                    } else {
                        log(
                            "⛔ CORREÇÃO: Reaplicação de ícones bloqueada - página não é capa do processo"
                        );
                    }

                    // Aguardar um frame para garantir que o CSS foi aplicado
                    requestAnimationFrame(() => {
                        try {
                            // Criar novo card
                            const novoCard =
                                window.SENT1_AUTO.criarCardMaterialDesign(
                                    dadosCard
                                );

                            // Inserir no local correto
                            const targetContainer =
                                encontrarContainerParaCard();
                            if (targetContainer && novoCard) {
                                targetContainer.appendChild(novoCard);
                                log(
                                    "✅ CORREÇÃO: Card recriado e inserido com sucesso"
                                );

                                // Diagnosticar após inserção
                                setTimeout(() => {
                                    diagnosticarIconesCSS();
                                }, 100);
                            } else {
                                log(
                                    "❌ CORREÇÃO: Falha ao encontrar container ou criar card"
                                );
                            }
                        } catch (error) {
                            console.error(
                                "❌ CORREÇÃO: Erro ao recriar card:",
                                error
                            );
                        }
                    });
                } catch (error) {
                    console.error(
                        "❌ CORREÇÃO: Erro geral na recriação:",
                        error
                    );
                }
            }

            /**
             * 🔍 FUNÇÃO AUXILIAR - Encontrar container adequado para o card
             * Seguindo REGRAS CRÍTICAS: SEMPRE retornar valor consistente
             */
            function encontrarContainerParaCard() {
                // REGRA CRÍTICA: Declarar variável antes de usar
                let container = null;

                // Estratégia 1: Tentar encontrar container específico do eProc
                const possiveisContainers = [
                    "#divInfraAreaProcesso",
                    "#conteudoMinutas",
                    "#fldMinutas",
                    ".infraAreaTabela",
                    "body",
                ];

                for (const seletor of possiveisContainers) {
                    container = document.querySelector(seletor);
                    if (container) {
                        log(`✅ CONTAINER: Encontrado container: ${seletor}`);
                        break;
                    }
                }

                // Fallback garantido
                if (!container) {
                    container = document.body;
                    logError("⚠️ CONTAINER: Usando fallback para body");
                }

                return container;
            }

            // 🔧 FUNÇÃO DE CORREÇÃO AUTOMÁTICA SIMPLES (movida para namespace principal)

            // 🎨 SISTEMA GLOBAL DE PERSONALIZAÇÃO DE BOTÕES DO EPROC
            // Funções expostas globalmente para personalizar botões (fora da IIFE)

            // Configurações de temas para botões
            const TEMAS_BOTOES_EPROC = {
                elegante: {
                    backgroundColor:
                        "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
                    color: "#ffffff",
                    border: "1px solid #5a67d8",
                    borderRadius: "8px",
                    boxShadow: "0 4px 15px rgba(102, 126, 234, 0.3)",
                    transition: "all 0.3s ease",
                    hover: {
                        boxShadow: "0 6px 20px rgba(102, 126, 234, 0.4)",
                    },
                    focus: {
                        boxShadow: "0 0 0 3px rgba(102, 126, 234, 0.3)",
                        outline: "none",
                    },
                },
                minimalista: {
                    backgroundColor: "#f8f9fa",
                    color: "#495057",
                    border: "1px solid #dee2e6",
                    borderRadius: "4px",
                    boxShadow: "none",
                    transition: "all 0.2s ease",
                    hover: {
                        backgroundColor: "#e9ecef",
                        borderColor: "#adb5bd",
                    },
                    focus: {
                        borderColor: "#80bdff",
                        boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
                    },
                },
                escuro: {
                    backgroundColor: "#343a40",
                    color: "#ffffff",
                    border: "1px solid #495057",
                    borderRadius: "6px",
                    boxShadow: "0 2px 8px rgba(0, 0, 0, 0.15)",
                    transition: "all 0.3s ease",
                    hover: {
                        backgroundColor: "#495057",
                        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.25)",
                    },
                    focus: {
                        boxShadow: "0 0 0 3px rgba(52, 58, 64, 0.3)",
                    },
                },

                profissional: {
                    backgroundColor: "#007ebd",
                    color: "#ffffff",
                    border: "1px solid #006ba6",
                    borderRadius: "4px",
                    boxShadow: "0 2px 4px rgba(0, 126, 189, 0.2)",
                    transition: "all 0.2s ease",
                    hover: {
                        backgroundColor: "#006ba6",
                        boxShadow: "0 4px 8px rgba(0, 126, 189, 0.3)",
                    },
                    focus: {
                        boxShadow: "0 0 0 3px rgba(0, 126, 189, 0.3)",
                    },
                },
            };

            // Função principal para aplicar estilo personalizado aos botões
            window.aplicarEstiloBotoesEproc = function (
                tema = "elegante",
                opcoes = {}
            ) {
                log(`🎨 BOTÕES: Aplicando tema "${tema}" aos botões do eProc`);

                // Verificar se o tema existe
                if (!TEMAS_BOTOES_EPROC[tema]) {
                    console.warn(
                        `⚠️ BOTÕES: Tema "${tema}" não encontrado. Temas disponíveis:`,
                        Object.keys(TEMAS_BOTOES_EPROC)
                    );
                    tema = "elegante"; // Fallback para tema padrão
                }

                const configuracaoTema = {
                    ...TEMAS_BOTOES_EPROC[tema],
                    ...opcoes,
                };

                // Seletores para todos os tipos de botões do eProc (INCLUINDO botões eProbe - EXCLUINDO pesquisa, navbar, infraLegendObrigatorio, btn-link e btn-sm)
                const seletoresBotoes = [
                    ".bootstrap-styles .btn:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)",
                    ".bootstrap-styles .eproc-button:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)",
                    ".bootstrap-styles .eproc-button-primary:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)",
                    ".bootstrap-styles .infraButton:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)",
                    ".bootstrap-styles .infraButton.btn-primary:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)",
                    ".bootstrap-styles .infraButton.eproc-button-primary:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)",
                    ".bootstrap-styles .infraArvore .infraButton.infraArvoreNoSelecionado:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)",
                    'button[class*="infra"]:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)',
                    'input[type="button"]:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)',
                    'input[type="submit"]:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)',
                    'button[onclick*="abrirVisualizacao"]:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)',
                    'button[onclick*="processo"]:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm)',
                ];

                // Remover estilo anterior se existir
                const estiloAnterior = document.getElementById(
                    "eprobe-estilo-botoes-eproc"
                );
                if (estiloAnterior) {
                    estiloAnterior.remove();
                }

                // Criar novo estilo
                const estiloElemento = document.createElement("style");
                estiloElemento.id = "eprobe-estilo-botoes-eproc";

                // Gerar CSS baseado na configuração do tema
                let css = `
        /* 🎨 eProbe - Estilo Personalizado dos Botões do eProc - Tema: ${tema} */
        
        /* 🎯 SINCRONIZAÇÃO: Elemento txtUnderline do eProc com mesma cor dos botões */
        #txtUnderline {
            color: ${configuracaoTema.color} !important;
        }
        
        /* Estilo base dos botões */
        ${seletoresBotoes.join(", ")} {
            background: ${configuracaoTema.backgroundColor} !important;
            color: ${configuracaoTema.color} !important;
            border: ${configuracaoTema.border} !important;
            border-radius: ${configuracaoTema.borderRadius} !important;
            box-shadow: ${configuracaoTema.boxShadow} !important;
            transition: ${configuracaoTema.transition} !important;
            font-weight: 500 !important;
            cursor: pointer !important;
        }
    `;

                // Adicionar estilos de hover se definidos
                if (configuracaoTema.hover) {
                    const hoverProps = Object.entries(configuracaoTema.hover)
                        .map(
                            ([prop, value]) =>
                                `${prop
                                    .replace(/([A-Z])/g, "-$1")
                                    .toLowerCase()}: ${value} !important;`
                        )
                        .join("\n                ");

                    css += `
        /* Estilo hover */
        ${seletoresBotoes.map((s) => `${s}:hover`).join(", ")} {
            ${hoverProps}
        }
        `;
                }

                // Adicionar estilos de focus se definidos
                if (configuracaoTema.focus) {
                    const focusProps = Object.entries(configuracaoTema.focus)
                        .map(
                            ([prop, value]) =>
                                `${prop
                                    .replace(/([A-Z])/g, "-$1")
                                    .toLowerCase()}: ${value} !important;`
                        )
                        .join("\n                ");

                    css += `
        /* Estilo focus */
        ${seletoresBotoes.map((s) => `${s}:focus`).join(", ")} {
            ${focusProps}
        }
        `;
                }

                // Adicionar estilos para estados ativos
                css += `
        /* Estilo disabled */
        ${seletoresBotoes.map((s) => `${s}:disabled`).join(", ")} {
            opacity: 0.6 !important;
            cursor: not-allowed !important;
            transform: none !important;
        }
                `;

                // Lógica especial para o tema "material" - adicionar pseudo-elementos
                if (tema === "material") {
                    css += `
        /* 🛡️ PROTEÇÃO ANTI-INJEÇÃO EPROC: Bloquear estilos inline para tema Material */
        ${seletoresBotoes.join(", ")} {
            background: inherit !important;
            width: auto !important;
            display: inline-block !important;
        }
        
        /* Tema Material - Pseudo-elementos ::before e ::after */
        ${seletoresBotoes.map((s) => `${s}::before`).join(", ")},
        ${seletoresBotoes.map((s) => `${s}::after`).join(", ")} {
            content: "" !important;
            display: block !important;
            height: 2px !important;
            width: 100% !important;
            position: absolute !important;
            left: 0 !important;
            background: #ada5a5 !important;
            transition: .3s !important;
            z-index: 1 !important;
        }
        
        ${seletoresBotoes.map((s) => `${s}::before`).join(", ")} {
            top: 0 !important;
        }
        
        ${seletoresBotoes.map((s) => `${s}::after`).join(", ")} {
            bottom: 0 !important;
        }
        `;
                }

                // CSS para margin-right do botão - SOLUÇÃO SIMPLES QUE FUNCIONOU
                css += `

            /* 🛡️ EPROBE BUTTONS: Margin-right nos SVGs dos botões personalizados */
            #documento-relevante-auto-button svg { margin-right: 3px !important; }
            .infraButton svg { margin-right: 3px !important; }
            .btn-primary svg { margin-right: 3px !important; }
            .eprobe-button svg { margin-right: 3px !important; }
            
            /* 🛡️ PROTEÇÃO: Garantir espaçamento correto em todos os botões eProbe */
            button[id*="documento-relevante"] svg { margin-right: 3px !important; }
            `;

                // Adicionar proteção específica para botões de pesquisa, navbar E infraLegendObrigatorio
                css +=
                    '\n\n    /* 🎯 REGRA CRÍTICA OBRIGATÓRIA: .d-none.d-md-flex SEMPRE FLEX - ALTA PRIORIDADE */\n    .d-none.d-md-flex,\n    div.d-none.d-md-flex,\n    .navbar .d-none.d-md-flex,\n    #navbar .d-none.d-md-flex,\n    .navbar-nav .d-none.d-md-flex,\n    .navbar-collapse .d-none.d-md-flex {\n        display: flex !important;\n        align-items: center !important;\n        visibility: visible !important;\n        opacity: 1 !important;\n        height: auto !important;\n        width: auto !important;\n    }\n\n    /* 🛡️ PROTEÇÃO: Manter aparência original para elementos excluídos */\n    .btn-pesquisar, .btn-pesquisar-nova-janela, .search-button,\n    button[class*="btn-pesquisar"], .input-group-btn .btn,\n    .btn-pesquisar::before, .btn-pesquisar::after,\n    .btn-pesquisar-nova-janela::before, .btn-pesquisar-nova-janela::after,\n    .search-button::before, .search-button::after,\n    .infraLegendObrigatorio, .infraLegendObrigatorio *,\n    legend.infraLegendObrigatorio, legend.infraLegendObrigatorio * {\n        /* Preservar estilos originais sem resetar tudo */\n    }\n\n    /* 🛡️ INFRALEGEND: Garantir que infraLegendObrigatorio mantenha aparência original (EXCETO legMinutas) */\n    .infraLegendObrigatorio:not(#legMinutas), legend.infraLegendObrigatorio:not(#legMinutas) {\n        background: initial !important;\n        color: initial !important;\n        border: initial !important;\n        border-radius: initial !important;\n        box-shadow: initial !important;\n        transition: initial !important;\n        font-weight: initial !important;\n        cursor: initial !important;\n    }\n\n ';

                estiloElemento.textContent = css;
                document.head.appendChild(estiloElemento);

                // Salvar preferência no localStorage
                try {
                    localStorage.setItem("eprobe_tema_botoes_eproc", tema);
                    localStorage.setItem(
                        "eprobe_opcoes_botoes_eproc",
                        JSON.stringify(opcoes)
                    );
                } catch (error) {
                    console.warn(
                        "⚠️ BOTÕES: Erro ao salvar preferências:",
                        error
                    );
                }

                log(
                    `✅ BOTÕES: Tema "${tema}" aplicado com sucesso a todos os botões do eProc`
                );

                // Retornar informações sobre a aplicação
                return {
                    tema: tema,
                    botoesAfetados: document.querySelectorAll(
                        seletoresBotoes.join(", ")
                    ).length,
                    configuracao: configuracaoTema,
                };
            };

            // Função para restaurar tema salvo
            window.restaurarTemaBotoesEproc = function () {
                try {
                    const temaSalvo = localStorage.getItem(
                        "eprobe_tema_botoes_eproc"
                    );
                    const opcoesSalvas = localStorage.getItem(
                        "eprobe_opcoes_botoes_eproc"
                    );

                    if (temaSalvo) {
                        const opcoes = opcoesSalvas
                            ? JSON.parse(opcoesSalvas)
                            : {};
                        window.aplicarEstiloBotoesEproc(temaSalvo, opcoes);
                        log(
                            `🔄 BOTÕES: Tema salvo "${temaSalvo}" restaurado automaticamente`
                        );
                        return true;
                    }
                } catch (error) {
                    console.warn(
                        "⚠️ BOTÕES: Erro ao restaurar tema salvo:",
                        error
                    );
                }
                return false;
            };

            // Função para resetar estilos para o padrão do eProc
            window.resetarBotoesEproc = function () {
                const estiloPersonalizado = document.getElementById(
                    "eprobe-estilo-botoes-eproc"
                );
                if (estiloPersonalizado) {
                    estiloPersonalizado.remove();
                    localStorage.removeItem("eprobe_tema_botoes_eproc");
                    localStorage.removeItem("eprobe_opcoes_botoes_eproc");
                    log("🔄 BOTÕES: Estilos resetados para o padrão do eProc");
                    return true;
                }
                return false;
            };

            // Função para listar temas disponíveis
            window.listarTemasBotoesEproc = function () {
                log(
                    "🎨 BOTÕES: Temas disponíveis:",
                    Object.keys(TEMAS_BOTOES_EPROC)
                );
                return Object.keys(TEMAS_BOTOES_EPROC);
            };

            // Função para aplicar tema personalizado
            window.criarTemaPersonalizadoBotoes = function (
                nome,
                configuracao
            ) {
                if (!nome || !configuracao) {
                    console.warn(
                        "⚠️ BOTÕES: Nome e configuração são obrigatórios para criar tema personalizado"
                    );
                    return false;
                }

                TEMAS_BOTOES_EPROC[nome] = configuracao;
                log(
                    `✅ BOTÕES: Tema personalizado "${nome}" criado com sucesso`
                );
                return true;
            };

            // Auto-aplicar tema salvo quando a página carregar
            setTimeout(() => {
                if (!window.restaurarTemaBotoesEproc()) {
                    // Se não há tema salvo, aplicar tema padrão elegante
                    // window.aplicarEstiloBotoesEproc('elegante');
                }
            }, 200); // ← REDUZIDO DE 1000ms PARA 200ms

            /**
             * 🎯 NAVBAR SIMPLES: Função otimizada sem complexidades desnecessárias
             */

            window.gerenciarNavbarEprobe = function () {
                if (window.navbarEprobeInicializada) return;
                window.navbarEprobeInicializada = true;

                // Função simplificada para inserir elemento
                function inserir() {
                    const navbar = document.querySelector("nav#navbar");
                    const marketplace = navbar?.querySelector(
                        'a[href*="pdpj/marketplace_redirecionar"]'
                    );

                    if (
                        !marketplace ||
                        document.getElementById("eprobe-navbar-element")
                    ) {
                        return;
                    }

                    const link = document.createElement("a");
                    link.id = "eprobe-navbar-element";
                    link.href = "https://e-probe.vercel.app/";
                    link.target = "_blank";
                    link.style.cssText =
                        "padding: 5px 6px;text-decoration: none;display: flex !important; align-items: center !important;height: 50px";

                    // Verificar se chrome.runtime está disponível (contexto de extensão)
                    if (
                        typeof chrome !== "undefined" &&
                        chrome.runtime &&
                        chrome.runtime.getURL
                    ) {
                        link.innerHTML = `<img src="${chrome.runtime.getURL(
                            "assets/40x.png"
                        )}" style="width:40px;height:40px">`;
                    } else {
                        // Fallback para teste local - usar caminho relativo
                        link.innerHTML = `<img src="assets/40x.png" style="width:40px;height:40px">`;
                    }

                    marketplace.parentNode.insertBefore(link, marketplace);

                    // Aplicar z-index elevado à navbar para ficar acima de outros elementos
                    const navbarWrapper =
                        document.querySelector(
                            ".bootstrap-styles.navbar-wrapper"
                        ) ||
                        document.querySelector("nav#navbar") ||
                        navbar;
                    if (navbarWrapper) {
                        navbarWrapper.style.zIndex = "10000";
                    }
                }

                // Executar quando navbar estiver disponível
                if (document.querySelector("nav#navbar")) {
                    inserir();
                } else {
                    // Observer simples sem overhead
                    const observer = new MutationObserver(() => {
                        if (document.querySelector("nav#navbar")) {
                            inserir();
                            observer.disconnect();
                        }
                    });
                    observer.observe(document.body, {
                        childList: true,
                        subtree: true,
                    });
                }
            };

            // 🚀 EXECUÇÃO IMEDIATA DA NAVBAR - ELIMINAR DELAY
            // Executar gerenciamento da navbar IMEDIATAMENTE (sem timeout)
            if (window.gerenciarNavbarEprobe) {
                log("⚡ NAVBAR: Executando gerenciamento imediato da navbar");
                window.gerenciarNavbarEprobe();
            } else {
                // Se a função ainda não estiver disponível, aguardar pouco e tentar novamente
                setTimeout(() => {
                    if (window.gerenciarNavbarEprobe) {
                        log(
                            "⚡ NAVBAR: Executando gerenciamento da navbar (tentativa 2)"
                        );
                        window.gerenciarNavbarEprobe();
                    }
                }, 50);
            }

            // ============================================
            // PERSONALIZAÇÃO DO CAMPO DE PESQUISA DA NAVBAR
            // ============================================

            /**
             * 🔍 NAVBAR: Personalizar campo de pesquisa de processo
             * Altera o placeholder e aplica estilo quase invisível
             */
            function personalizarCampoPesquisaNavbar() {
                log("🔍 NAVBAR: Personalizando campo de pesquisa...");

                const campoPesquisa = document.querySelector(
                    "#txtNumProcessoPesquisaRapida"
                );

                if (campoPesquisa) {
                    // Alterar o placeholder
                    campoPesquisa.placeholder = "digite o n. do processo";

                    // Aplicar CSS para placeholder quase invisível
                    const style = document.createElement("style");
                    style.id = "eprobe-pesquisa-navbar-style";
                    style.textContent = `
            /* 🔍 PESQUISA NAVBAR: Placeholder quase invisível */
            #txtNumProcessoPesquisaRapida::placeholder {
                color: rgba(255, 255, 255, 1) !important;
                opacity: 0.4 !important;
                font-style: italic !important;
            }
            
            /* Para Firefox */
            #txtNumProcessoPesquisaRapida::-moz-placeholder {
                color: rgba(255, 255, 255, 1) !important;
                opacity: 0.4 !important;
                font-style: italic !important;
            }
            
            /* Para Edge/IE */
            #txtNumProcessoPesquisaRapida::-ms-input-placeholder {
                color: rgba(255, 255, 255, 1) !important;
                opacity: 0.4 !important;
                font-style: italic !important;
            }
        `;

                    // Verificar se o estilo já existe antes de adicionar
                    const estiloExistente = document.getElementById(
                        "eprobe-pesquisa-navbar-style"
                    );
                    if (!estiloExistente) {
                        document.head.appendChild(style);
                    }

                    log(
                        "✅ NAVBAR: Campo de pesquisa personalizado com sucesso"
                    );
                    return true;
                } else {
                    logError("⚠️ NAVBAR: Campo de pesquisa não encontrado");
                    return false;
                }
            }

            /**
             * 🎯 NAVBAR: Monitorar e aplicar personalização do campo de pesquisa
             * Executa com observer para garantir que funcione mesmo com carregamento dinâmico
             */
            function inicializarPersonalizacaoPesquisaNavbar() {
                // Tentar aplicar imediatamente
                if (personalizarCampoPesquisaNavbar()) {
                    return;
                }

                // Se não encontrou, usar observer para aguardar o elemento aparecer
                const observer = new MutationObserver(() => {
                    if (personalizarCampoPesquisaNavbar()) {
                        observer.disconnect();
                    }
                });

                observer.observe(document.body, {
                    childList: true,
                    subtree: true,
                });

                // Timeout de segurança para evitar observer infinito
                setTimeout(() => {
                    observer.disconnect();
                }, 10000);

                // Verificação final do status dos botões após inicialização completa
                setTimeout(() => {
                    log("=== STATUS FINAL DOS BOTÕES ===");
                    const integratedButton = document.getElementById(
                        "documento-relevante-auto-button"
                    );
                    const floatingButton =
                        document.getElementById("sent1-auto-button");

                    log(
                        "Botão integrado:",
                        integratedButton ? "✅ Criado" : "❌ Não encontrado"
                    );
                    log(
                        "Botão flutuante:",
                        floatingButton ? "✅ Criado" : "❌ Não encontrado"
                    );
                    log("URL atual:", window.location.href);

                    // ✅ VERIFICAÇÃO SEGURA das funções
                    let criterioIntegrado = "função não disponível";
                    let criterioFlutuante = "função não disponível";

                    try {
                        if (typeof shouldShowIntegratedButton === "function") {
                            criterioIntegrado = shouldShowIntegratedButton();
                        }
                    } catch (e) {
                        criterioIntegrado = "erro ao executar";
                    }

                    try {
                        if (typeof shouldShowFloatingButton === "function") {
                            criterioFlutuante = shouldShowFloatingButton();
                        }
                    } catch (e) {
                        criterioFlutuante = "erro ao executar";
                    }

                    log("Critério integrado:", criterioIntegrado);
                    log("Critério flutuante:", criterioFlutuante);

                    if (!integratedButton && !floatingButton) {
                        log(
                            "⚠️ ATENÇÃO: Nenhum botão foi criado - tentando uma última vez"
                        );
                        ensureButtonExists();
                    }
                }, 5000);
            }

            // Expor função globalmente para debug
            window.personalizarCampoPesquisaNavbar =
                personalizarCampoPesquisaNavbar;

            // 🎨 SISTEMA DE SUBSTITUIÇÃO DE ÍCONES NO FIELDSET DE AÇÕES

            // Mapeamento de ícones antigos para novos SVGs
            const ICON_REPLACEMENTS = {
                // Árvore
                "arvore documento_listar": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-network-icon lucide-network"><rect x="16" y="16" width="6" height="6" rx="1"/><rect x="2" y="16" width="6" height="6" rx="1"/><rect x="9" y="2" width="6" height="6" rx="1"/><path d="M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3"/><path d="M12 12V8"/></svg>',
                    selector: 'img[alt="arvore documento_listar"]',
                },
                // Cancelar Movimentação
                "processo movimento_desativar_consulta": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>',
                    selector:
                        'img[alt="processo movimento_desativar_consulta"]',
                },
                // Audiência
                "audiencia listar": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-audio-lines-icon lucide-audio-lines"><path d="M2 10v3"/><path d="M6 6v11"/><path d="M10 3v18"/><path d="M14 8v7"/><path d="M18 5v13"/><path d="M22 10v3"/></svg>',
                    selector: 'img[alt="audiencia listar"]',
                },
                // Download Completo
                "selecionar processos_agendar_arquivo_completo": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download-icon lucide-download"><path d="M12 15V3"/><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2 2v-4"/><path d="m7 10 5 5 5-5"/></svg>',
                    selector:
                        'img[alt="selecionar processos_agendar_arquivo_completo"]',
                },
                // Enviar E-mail
                "processo enviar_email_listar": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-at-sign-icon lucide-at-sign"><circle cx="12" cy="12" r="4"/><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8"/></svg>',
                    selector: 'img[alt="processo enviar_email_listar"]',
                },
                // Expedir Carta
                "processo expedir_carta_subform": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail-icon lucide-mail"><path d="m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7"/><rect x="2" y="4" width="20" height="16" rx="2"/></svg>',
                    selector: 'img[alt="processo expedir_carta_subform"]',
                },
                // Gerenciar Situação das Partes
                "gerenciamento partes_situacao_listar": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-user-round-pen-icon lucide-user-round-pen"><path d="M2 21a8 8 0 0 1 10.821-7.487"/><path d="M21.378 16.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/><circle cx="10" cy="8" r="5"/></svg>',
                    selector: 'img[alt="gerenciamento partes_situacao_listar"]',
                },
                // Intimar
                "processo intimacao": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-scroll-text-icon lucide-scroll-text"><path d="M15 12h-5"/><path d="M15 8h-5"/><path d="M19 17V5a2 2 0 0 0-2-2H4"/><path d="M8 21h12a2 2 0 0 0 2-2v-1a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v1a2 2 0 1 1-4 0V5a2 2 0 1 0-4 0v2a1 1 0 0 0 1 1h3"/></svg>',
                    selector: 'img[alt="processo intimacao"]',
                },
                // Nomear Peritos/Dativos
                "processo intimacao_bloco": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-microscope-icon lucide-microscope"><path d="M6 18h8"/><path d="M3 22h18"/><path d="M14 22a7 7 0 1 0 0-14h-1"/><path d="M9 14h2"/><path d="M9 12a2 2 0 0 1-2-2V6h6v4a2 2 0 0 1-2 2Z"/><path d="M12 6V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v3"/></svg>',
                    selector: 'img[alt="processo intimacao_bloco"]',
                },
                // Retificar Autuação
                "processo edicao": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-spell-check-icon lucide-spell-check"><path d="m6 16 6-12 6 12"/><path d="M8 12h8"/><path d="m16 20 2 2 4-4"/></svg>',
                    selector: 'img[alt="processo edicao"]',
                },
                // Suscitar IRDR
                "processo cadastrar": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-scale-icon lucide-scale"><path d="m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z"/><path d="m2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z"/><path d="M7 21h10"/><path d="M12 3v18"/><path d="M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2"/></svg>',
                    selector: 'img[alt="processo cadastrar"]',
                },
                // Redistribuição
                "redistribuicao processo": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-git-pull-request-arrow-icon lucide-git-pull-request-arrow"><circle cx="5" cy="6" r="3"/><path d="M5 9v12"/><circle cx="19" cy="18" r="3"/><path d="m15 9-3-3 3-3"/><path d="M12 6h5a2 2 0 0 1 2 2v7"/></svg>',
                    selector: 'img[alt="redistribuicao processo"]',
                },
                // Citar
                "processo citacao": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-scroll-icon lucide-scroll"><path d="M19 17V5a2 2 0 0 0-2-2H4"/><path d="M8 21h12a2 2 0 0 0 2-2v-1a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v1a2 2 0 1 1-4 0V5a2 2 0 1 0-4 0v2a1 1 0 0 0 1 1h3"/></svg>',
                    selector: 'img[alt="processo citacao"]',
                },
                // Ações Preferenciais
                "acoes preferenciais": {
                    newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#9CA3AF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>',
                    selector: 'img[alt="acoes preferenciais"]',
                },
                // Atualizar/Refresh
                refresh: {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-ccw-icon lucide-refresh-ccw"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>',
                    selector: 'img[id="refresh"]',
                },
                // Histórico/Lista
                historico: {
                    newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
                    selector: 'img[src*="valores.gif"]',
                },
                // Nova Minuta
                "Nova Minuta": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-plus-2"><path d="M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M3 15h6"/><path d="M6 12v6"/></svg>',
                    selector: 'img[alt="Nova Minuta"]',
                },
            };

            // Mapeamentos adicionais por texto do link
            const ICON_REPLACEMENTS_BY_TEXT = {
                "Incluir em Pauta/Mesa": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-calendar-plus-icon lucide-calendar-plus"><path d="M16 19h6"/><path d="M16 2v4"/><path d="M19 16v6"/><path d="M21 12.598V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h8.5"/><path d="M3 10h18"/><path d="M8 2v4"/></svg>',
                },
                "Movimentar Processo": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left-right-icon lucide-arrow-left-right"><path d="M8 3 4 7l4 4"/><path d="M4 7h16"/><path d="m16 21 4-4-4-4"/><path d="M20 17H4"/></svg>',
                },
                "Associar Procurador Parte": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-user-plus-icon lucide-user-plus"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><line x1="19" x2="19" y1="8" y2="14"/><line x1="22" x2="16" y1="11" y2="11"/></svg>',
                },
                "Permissão/Negação Expressa": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-ban-icon lucide-ban"><circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/></svg>',
                },
                "Requisição Un. Externa": {
                    newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-building2-icon lucide-building-2"><path d="M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z"/><path d="M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2"/><path d="M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2"/><path d="M10 6h4"/><path d="M10 10h4"/><path d="M10 14h4"/><path d="M10 18h4"/></svg>',
                },
            };

            // 🎨 FUNÇÃO UTILITÁRIA: Aplicar estilos padronizados aos containers de ícones
            function applyStandardIconStyles(container) {
                container.style.display = "inline-flex";
                container.style.alignItems = "center";
                container.style.marginRight = "4px";
                container.style.verticalAlign = "middle";

                // Marcar como container de ícone eProbe para CSS
                container.setAttribute("data-eprobe-icon-container", "true");

                // Aplicar estilos aos SVGs dentro do container
                const svg = container.querySelector("svg");
                if (svg) {
                    svg.style.flexShrink = "0";
                    svg.style.verticalAlign = "middle";
                }
            }

            // Função para verificar se um elemento é seguro para implementar alternância
            function isElementSafeForToggle(imgElement) {
                try {
                    // Verificar se o elemento e seus pais existem
                    if (!imgElement || !imgElement.parentElement) {
                        return false;
                    }

                    // Encontrar o elemento clicável
                    const linkElement =
                        imgElement.closest("a") || imgElement.parentElement;
                    if (!linkElement) {
                        return false;
                    }

                    // Verificar se tem onclick válido
                    const onclickAttr = linkElement.getAttribute("onclick");
                    if (!onclickAttr) {
                        return false;
                    }

                    // Verificar se é um onclick do tipo que queremos processar
                    const isValidOnclick =
                        onclickAttr.includes("infraAbrirFecharElementoHTML") ||
                        onclickAttr.includes("conteudoInternoMinutas") ||
                        onclickAttr.includes("conteudoMinutas");

                    if (!isValidOnclick) {
                        return false;
                    }

                    // Verificar se o elemento alvo existe
                    const match = onclickAttr.match(
                        /infraAbrirFecharElementoHTML\s*\(\s*['"]([^'"]+)['"](?:,\s*['"]([^'"]+)['"])?/
                    );
                    if (match) {
                        const targetId = match[1];
                        const targetElement = document.getElementById(targetId);
                        if (!targetElement) {
                            console.warn(
                                `⚠️ ALTERNÂNCIA: Elemento alvo '${targetId}' não encontrado`
                            );
                            return false;
                        }
                    }

                    return true;
                } catch (error) {
                    console.warn(
                        "⚠️ ALTERNÂNCIA: Erro ao verificar elemento:",
                        error
                    );
                    return false;
                }
            }

            // Função para implementar alternância de expandir/retrair para ícones mais.gif e menos.gif
            function implementarAlternanciaExpandirRetrair(
                imgOriginal,
                container,
                selector
            ) {
                log(
                    `🔄 ALTERNÂNCIA: Implementando funcionalidade para ${selector}`
                );

                // Determinar o estado inicial baseado no nome do arquivo
                const isExpanded = selector.includes("menos.gif"); // menos.gif = expandido
                const isCollapsed = selector.includes("mais.gif"); // mais.gif = retraído

                // Encontrar o elemento clicável (normalmente o link pai)
                const linkElement =
                    imgOriginal.closest("a") || imgOriginal.parentElement;

                if (!linkElement) {
                    console.warn(
                        "⚠️ ALTERNÂNCIA: Link pai não encontrado para",
                        selector
                    );
                    return;
                }

                // Criar SVGs para os dois estados
                const iconExpanded =
                    '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg>'; // Seta para baixo (expandido)
                const iconCollapsed =
                    '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-right"><path d="m9 18 6-6-6-6"/></svg>'; // Seta para direita (retraído)

                // Definir o ícone inicial
                const initialIcon = isExpanded ? iconExpanded : iconCollapsed;
                container.innerHTML = initialIcon;

                // Aplicar estilos ao SVG
                const svg = container.firstElementChild;
                if (svg) {
                    svg.classList.add("iconeAcao");
                    svg.style.width = "18px";
                    svg.style.height = "18px";
                    svg.style.cursor = "pointer";
                    svg.style.transition = "transform 0.2s ease";
                }

                // Armazenar o estado atual
                container.setAttribute("data-expanded", isExpanded.toString());

                // Adicionar funcionalidade de clique
                const handleClick = (event) => {
                    event.preventDefault();
                    event.stopPropagation();

                    const currentlyExpanded =
                        container.getAttribute("data-expanded") === "true";
                    const newExpanded = !currentlyExpanded;

                    // Alternar o ícone
                    container.innerHTML = newExpanded
                        ? iconExpanded
                        : iconCollapsed;

                    // Aplicar estilos ao novo SVG
                    const newSvg = container.firstElementChild;
                    if (newSvg) {
                        newSvg.classList.add("iconeAcao");
                        newSvg.style.width = "18px";
                        newSvg.style.height = "18px";
                        newSvg.style.cursor = "pointer";
                        newSvg.style.transition = "transform 0.2s ease";
                    }

                    // Atualizar o estado
                    container.setAttribute(
                        "data-expanded",
                        newExpanded.toString()
                    );

                    // Encontrar e alternar o display do conteúdo relacionado
                    const targetElement = findToggleTarget(linkElement);
                    if (targetElement) {
                        targetElement.style.display = newExpanded
                            ? "block"
                            : "none";
                        log(
                            `🔄 ALTERNÂNCIA: Conteúdo ${
                                newExpanded ? "expandido" : "retraído"
                            }`
                        );
                    }

                    // NÃO executar o clique original do eProc para evitar conflitos
                    // A função infraAbrirFecharElementoHTML pode tentar acessar elementos que não existem
                    // ou elementos que já foram modificados pelo nosso sistema
                    log(
                        `✅ ALTERNÂNCIA: Clique processado pelo sistema eProbe - ${
                            newExpanded ? "expandido" : "retraído"
                        }`
                    );
                };

                // Adicionar listener no container
                container.addEventListener("click", handleClick);

                // Encontrar o elemento alvo inicial e definir seu estado
                const initialTarget = findToggleTarget(linkElement);
                if (initialTarget) {
                    initialTarget.style.display = isExpanded ? "block" : "none";
                }

                log(
                    `✅ ALTERNÂNCIA: Configurado ${selector} - Estado inicial: ${
                        isExpanded ? "expandido" : "retraído"
                    }`
                );
            }

            // Função auxiliar para encontrar o elemento que deve ser alternado
            function findToggleTarget(linkElement) {
                // Estratégias específicas para o eProc:

                // 1. Procurar por elementos específicos das minutas
                const minutasTargets = [
                    "conteudoInternoMinutas_0",
                    "conteudoInternoMinutas_1",
                    "conteudoInternoMinutas_2",
                    "conteudoInternoMinutas_3",
                ];

                for (const targetId of minutasTargets) {
                    const element = document.getElementById(targetId);
                    if (element) {
                        log(
                            `🎯 ALTERNÂNCIA: Encontrado elemento alvo: ${targetId}`
                        );
                        return element;
                    }
                }

                // 2. Procurar por padrão onclick do eProc
                const linkParent = linkElement.closest("button") || linkElement;
                const onclickAttr = linkParent.getAttribute("onclick");
                if (onclickAttr) {
                    // Extrair ID do onclick: infraAbrirFecharElementoHTML('conteudoInternoMinutas_0', 'imgMinutas_0')
                    const match = onclickAttr.match(
                        /infraAbrirFecharElementoHTML\s*\(\s*['"]([^'"]+)['"](?:,\s*['"]([^'"]+)['"])?/
                    );
                    if (match) {
                        const targetId = match[1];
                        log(
                            `🎯 ALTERNÂNCIA: Extraído ID do onclick: ${targetId}`
                        );
                        const element = document.getElementById(targetId);
                        if (element) {
                            return element;
                        } else {
                            console.warn(
                                `⚠️ ALTERNÂNCIA: Elemento com ID '${targetId}' não existe no DOM`
                            );
                            return null; // Retornar null se o elemento não existir
                        }
                    }
                }

                // 3. Procurar por fieldset e divs relacionados
                const fieldsetParent = linkElement.closest("fieldset");
                if (fieldsetParent) {
                    const internalDivs = fieldsetParent.querySelectorAll(
                        'div[id*="conteudoInterno"], div[id*="conteudo"]'
                    );
                    for (const div of internalDivs) {
                        if (div.id && div.id !== fieldsetParent.id) {
                            log(
                                `🎯 ALTERNÂNCIA: Encontrado div interno: ${div.id}`
                            );
                            return div;
                        }
                    }
                }

                // 4. Procurar por elementos irmãos que podem ser alternados
                let sibling = linkElement.nextElementSibling;
                while (sibling) {
                    if (
                        sibling.tagName === "DIV" &&
                        sibling.id &&
                        sibling.id.includes("conteudo")
                    ) {
                        log(
                            `🎯 ALTERNÂNCIA: Encontrado sibling: ${sibling.id}`
                        );
                        return sibling;
                    }
                    sibling = sibling.nextElementSibling;
                }

                // 5. Procurar no elemento pai por containers específicos
                const parent = linkElement.parentElement;
                if (parent) {
                    const containers = parent.querySelectorAll(
                        'div[id*="conteudoInterno"], div[id*="conteudo"], table.infraTable'
                    );
                    for (const container of containers) {
                        if (
                            container !== linkElement &&
                            !container.contains(linkElement)
                        ) {
                            log(
                                `🎯 ALTERNÂNCIA: Encontrado container: ${
                                    container.id || container.className
                                }`
                            );
                            return container;
                        }
                    }
                }

                console.warn(
                    "⚠️ ALTERNÂNCIA: Elemento alvo não encontrado para",
                    linkElement
                );
                return null;
            }

            // 🔍 FUNÇÃO AUXILIAR: Verificar se estamos numa página de capa do processo
            function isCapaProcessoPage() {
                const currentUrl = window.location.href;

                // Verificar se a URL contém o padrão de capa do processo
                const capaProcessoPatterns = [
                    "eproc1g.tjsc.jus.br/eproc/controlador.php?acao=processo_selecionar&",
                    "eproc2g.tjsc.jus.br/eproc/controlador.php?acao=processo_selecionar&",
                ];

                return capaProcessoPatterns.some((pattern) =>
                    currentUrl.includes(pattern)
                );
            }

            /**
             * 🎨 FUNÇÃO PARA APLICAR GRADIENTES NA CAPA DO PROCESSO
             * Substitui cores sólidas de background por gradientes suaves no fieldset da capa
             * Baseado na documentação "cores capa do processo.md"
             */
            function aplicarGradientesCapaProcesso() {
                log("🎨 GRADIENTES CAPA: Iniciando aplicação de gradientes...");

                // Verificar se estamos na página correta
                if (!isCapaProcessoPage()) {
                    log(
                        "❌ GRADIENTES CAPA: Não é uma página de capa de processo"
                    );
                    return false;
                }

                // Buscar o fieldset da capa
                const fieldsetCapa = document.querySelector(
                    "#fldCapa.infraFieldset.bootstrap-styles"
                );
                if (!fieldsetCapa) {
                    log("❌ GRADIENTES CAPA: Fieldset #fldCapa não encontrado");
                    return false;
                }

                log("✅ GRADIENTES CAPA: Fieldset encontrado:", fieldsetCapa);

                // Obter estilo computed atual
                const estiloComputado = window.getComputedStyle(fieldsetCapa);
                const corAtual = estiloComputado.backgroundColor;

                log("🔍 GRADIENTES CAPA: Cor atual detectada:", corAtual);

                // Função para converter RGB para hex
                function rgbParaHex(rgb) {
                    if (rgb.startsWith("#")) return rgb.toLowerCase();

                    const rgbMatch = rgb.match(
                        /rgb\((\d+),\s*(\d+),\s*(\d+)\)/
                    );
                    if (rgbMatch) {
                        const r = parseInt(rgbMatch[1])
                            .toString(16)
                            .padStart(2, "0");
                        const g = parseInt(rgbMatch[2])
                            .toString(16)
                            .padStart(2, "0");
                        const b = parseInt(rgbMatch[3])
                            .toString(16)
                            .padStart(2, "0");
                        return `#${r}${g}${b}`;
                    }

                    return rgb;
                }

                // Mapeamento de cores para gradientes conforme documentação
                const mapeamentoCores = {
                    // AMARELO
                    "#efd88f": "linear-gradient(#F9EFAF, #F7E98D)",

                    // VERMELHO (formato rgb)
                    "#db8080": "linear-gradient(#FAAFAF, #F78D8D)",

                    // AZUL
                    "#c4dffb": "linear-gradient(#AFCFFA, #8DC0F7)",

                    // VERDE
                    "#a7eda7": "linear-gradient(#AFFAB6, #8DF792)",

                    // LARANJA
                    "#f5b574": "linear-gradient(#FAD3AF, #F7C68D)",

                    // CINZA
                    "#a0b9bf": "linear-gradient(#B5C9CF, #9CB0B7)",
                    "#A0B9BF": "linear-gradient(#B5C9CF, #9CB0B7)", // case insensitive

                    // ROSA
                    "#fbc4df": "linear-gradient(#FBAFDF, #F78DC7)",
                };

                // Verificar múltiplos formatos da cor atual
                const formatosPossiveisCor = [
                    corAtual,
                    corAtual.replace(/\s+/g, ""), // sem espaços
                    rgbParaHex(corAtual),
                    rgbParaHex(corAtual).toUpperCase(),
                ];

                log(
                    "🔍 GRADIENTES CAPA: Formatos testados:",
                    formatosPossiveisCor
                );

                let gradienteEncontrado = null;
                let corCorrespondente = null;

                // Buscar correspondência nos mapeamentos
                for (const formato of formatosPossiveisCor) {
                    if (mapeamentoCores[formato]) {
                        gradienteEncontrado = mapeamentoCores[formato];
                        corCorrespondente = formato;
                        break;
                    }
                }

                if (gradienteEncontrado) {
                    log(`🎉 GRADIENTES CAPA: Correspondência encontrada!`);
                    log(`   Cor original: ${corCorrespondente}`);
                    log(`   Gradiente: ${gradienteEncontrado}`);

                    // Aplicar o gradiente seguindo padrão das outras funções
                    try {
                        fieldsetCapa.style.setProperty(
                            "background",
                            gradienteEncontrado,
                            "important"
                        );
                        log(
                            "✅ GRADIENTES CAPA: Gradiente aplicado com sucesso!"
                        );

                        return {
                            sucesso: true,
                            corOriginal: corCorrespondente,
                            gradienteAplicado: gradienteEncontrado,
                            elemento: fieldsetCapa,
                        };
                    } catch (error) {
                        logError(
                            "❌ GRADIENTES CAPA: Erro ao aplicar gradiente:",
                            error
                        );
                        return false;
                    }
                } else {
                    log(
                        `❌ GRADIENTES CAPA: Cor não reconhecida para substituição: ${corAtual}`
                    );
                    log(
                        "💡 GRADIENTES CAPA: Cores suportadas:",
                        Object.keys(mapeamentoCores)
                    );

                    return {
                        sucesso: false,
                        corNaoReconhecida: corAtual,
                        coresSuportadas: Object.keys(mapeamentoCores),
                    };
                }
            }

            /**
             * 🎨 FUNÇÃO PARA PERSONALIZAR LEGMINUTAS E TABELAS
             * Substitui cores sólidas por gradientes suaves nos elementos de minutas
             * Baseado na documentação "cores legMinutas.md"
             */
            function aplicarGradientesLegMinutas() {
                log(
                    "🎨 GRADIENTES: Iniciando aplicação em TODOS os legMinutas..."
                );

                try {
                    // Buscar TODOS os elementos legMinutas com aria-label="Histórico"
                    const elementosLegMinutas = document.querySelectorAll(
                        'legend[aria-label="Histórico"]#legMinutas.infraLegendObrigatorio'
                    );

                    log(
                        `🔍 Encontrados ${elementosLegMinutas.length} elementos legMinutas`
                    );

                    if (elementosLegMinutas.length === 0) {
                        log("❌ Nenhum elemento legMinutas encontrado");
                        return { sucesso: false, processados: 0 };
                    }

                    // Mapa de cores completo
                    const cores = {
                        "rgb(152, 245, 255)":
                            "linear-gradient(#AFCFFA, #8DC0F7)", // AZUL #98F5FF
                        "rgb(255, 160, 122)":
                            "linear-gradient(#FFB8AF, #FF9C8D)", // LARANJA INTENSO #FFA07A
                        "rgb(255, 211, 155)":
                            "linear-gradient(#FAD3AF, #F7C68D)", // LARANJA CLARO #FFD39B
                        "rgb(255, 193, 37)":
                            "linear-gradient(#FFDE8F, #FFB84D)", // DOURADO #FFC125
                        "rgb(205, 181, 205)":
                            "linear-gradient(#D8C7D8, #C4A5C4)", // LILÁS #CDB5CD
                        "rgb(211, 211, 211)":
                            "linear-gradient(#B5C9CF, #9CB0B7)", // CINZA #D3D3D3
                        "rgb(238, 99, 99)": "linear-gradient(#FAAFAF, #F78D8D)", // VERMELHA #EE6363
                        "rgb(255, 255, 0)": "linear-gradient(#FFFF8F, #F0F04D)", // VERDE LIMÃO #FFFF00
                        "rgb(255, 187, 255)":
                            "linear-gradient(#FFC9FF, #FF9CFF)", // ROSA CLARO #FFBBFF
                        "rgb(255, 246, 143)":
                            "linear-gradient(#F9EFAF, #F7E98D)", // AMARELA #FFF68F
                        "rgb(144, 238, 144)":
                            "linear-gradient(#AFFAB6, #8DF792)", // VERDE #90EE90
                    };

                    let processados = 0;

                    // Processar CADA elemento legMinutas
                    elementosLegMinutas.forEach((legMinutas, index) => {
                        const corAtual =
                            window.getComputedStyle(legMinutas).backgroundColor;

                        // Aplicar gradiente se encontrar cor correspondente
                        if (cores[corAtual]) {
                            legMinutas.style.setProperty(
                                "background",
                                cores[corAtual],
                                "important"
                            );
                            log(
                                `✅ SUCESSO: legMinutas ${
                                    index + 1
                                } - Gradiente aplicado para ${corAtual}!`
                            );
                            processados++;
                        } else {
                            log(
                                `⚠️ legMinutas ${
                                    index + 1
                                } - Cor não mapeada: ${corAtual}`
                            );
                        }
                    });

                    log(
                        `🎉 CONCLUÍDO: ${processados}/${elementosLegMinutas.length} elementos processados`
                    );

                    // Configurar observer automaticamente na primeira execução
                    if (
                        processados > 0 &&
                        typeof setupObservadorLegendMinutas === "function"
                    ) {
                        setupObservadorLegendMinutas();
                    }

                    return {
                        sucesso: processados > 0,
                        processados: processados,
                    };
                } catch (error) {
                    logError("❌ ERRO:", error);
                    return {
                        sucesso: false,
                        processados: 0,
                        erro: error.message,
                    };
                }
            }

            /**
             * 🔄 OBSERVER PARA REAPLICAR GRADIENTES AUTOMATICAMENTE
             * Monitora mudanças no DOM das minutas e reaplica gradientes
             */
            function setupObservadorLegendMinutas() {
                log(
                    "🔍 OBSERVER ANTI-FLASH: Configurando observer otimizado para legendas..."
                );

                const containerMinutas =
                    document.querySelector("#conteudoMinutas");

                if (!containerMinutas) {
                    log(
                        "⚠️ OBSERVER: Container #conteudoMinutas não encontrado"
                    );
                    return false;
                }

                // Função de reaplicação otimizada com anti-flash
                function reaplicarGradientesAntiFlash() {
                    const elementos = document.querySelectorAll(
                        'legend[aria-label="Histórico"]#legMinutas.infraLegendObrigatorio'
                    );

                    if (elementos.length === 0) return;

                    const cores = {
                        "rgb(152, 245, 255)":
                            "linear-gradient(#AFCFFA, #8DC0F7)",
                        "rgb(255, 160, 122)":
                            "linear-gradient(#FFB8AF, #FF9C8D)",
                        "rgb(255, 211, 155)":
                            "linear-gradient(#FAD3AF, #F7C68D)",
                        "rgb(255, 193, 37)":
                            "linear-gradient(#FFDE8F, #FFB84D)",
                        "rgb(205, 181, 205)":
                            "linear-gradient(#D8C7D8, #C4A5C4)",
                        "rgb(211, 211, 211)":
                            "linear-gradient(#B5C9CF, #9CB0B7)",
                        "rgb(238, 99, 99)": "linear-gradient(#FAAFAF, #F78D8D)",
                        "rgb(255, 255, 0)": "linear-gradient(#FFFF8F, #F0F04D)",
                        "rgb(255, 187, 255)":
                            "linear-gradient(#FFC9FF, #FF9CFF)",
                        "rgb(255, 246, 143)":
                            "linear-gradient(#F9EFAF, #F7E98D)",
                        "rgb(144, 238, 144)":
                            "linear-gradient(#AFFAB6, #8DF792)",
                    };

                    let reaplicados = 0;
                    elementos.forEach((el, i) => {
                        const bgColor =
                            window.getComputedStyle(el).backgroundColor;

                        // Aplicar gradiente se cor sólida detectada ou forçar padrão
                        if (bgColor !== "rgba(0, 0, 0, 0)") {
                            const gradiente =
                                cores[bgColor] ||
                                "linear-gradient(#FFDE8F, #FFB84D)"; // Padrão dourado
                            el.style.setProperty(
                                "background",
                                gradiente,
                                "important"
                            );
                            reaplicados++;
                        }
                    });

                    if (reaplicados > 0) {
                        log(
                            `🎨 OBSERVER: ${reaplicados} gradientes reaplicados (anti-flash)`
                        );
                    }
                }

                // Múltiplas tentativas com delays otimizados para anti-flash
                function reaplicarComBackoff() {
                    reaplicarGradientesAntiFlash(); // Imediato
                    setTimeout(reaplicarGradientesAntiFlash, 25);
                    setTimeout(reaplicarGradientesAntiFlash, 75);
                    setTimeout(reaplicarGradientesAntiFlash, 150);
                }

                // Observer otimizado com debounce mínimo
                const observer = new MutationObserver(
                    window.debounce(() => {
                        log(
                            "🔄 OBSERVER: Mudança detectada, reaplicando gradientes (anti-flash)..."
                        );
                        reaplicarComBackoff();
                    }, 10)
                ); // Debounce mínimo

                // Observer agressivo
                observer.observe(containerMinutas, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ["style", "class"],
                    characterData: true,
                });

                // Click listener preventivo
                document.addEventListener("click", (e) => {
                    if (
                        e.target.closest(
                            'input[type="image"][title*="Atualizar"]'
                        ) ||
                        e.target.closest(
                            'input[type="button"][value*="Expandir"]'
                        ) ||
                        e.target.closest('input[title*="Expandir"]') ||
                        e.target.closest('input[onclick*="atualizaMinutas"]')
                    ) {
                        log(
                            "🖱️ CLICK: Botão detectado, aplicação preventiva..."
                        );
                        reaplicarGradientesAntiFlash(); // Preventivo
                        setTimeout(reaplicarGradientesAntiFlash, 10);
                        setTimeout(reaplicarGradientesAntiFlash, 50);
                        setTimeout(reaplicarGradientesAntiFlash, 100);
                        setTimeout(reaplicarGradientesAntiFlash, 200);
                    }
                });

                // CSS preventivo para transição suave
                const stylePreventivo = document.createElement("style");
                stylePreventivo.id = "eprobe-anti-flash-gradientes";
                stylePreventivo.textContent = `
                    legend[aria-label="Histórico"]#legMinutas.infraLegendObrigatorio {
                        transition: background 0.1s ease-out !important;
                    }
                `;
                document.head.appendChild(stylePreventivo);

                log("✅ OBSERVER ANTI-FLASH: Configurado com sucesso!");
                return true;
            }

            /**
             * 🔄 FUNÇÃO DE APLICAÇÃO ROBUSTA DE GRADIENTES MINUTAS - Com retry automático
             */
            function aplicarGradientesLegMinutasRobusta() {
                log(
                    "🔄 GRADIENTES MINUTAS ROBUSTA: Iniciando aplicação robusta de gradientes nas minutas..."
                );

                // Verificar se estamos na página correta primeiro
                if (!isCapaProcessoPage()) {
                    log(
                        "ℹ️ GRADIENTES MINUTAS ROBUSTA: Não é uma página de capa de processo"
                    );
                    return false;
                }

                let tentativas = 0;
                const maxTentativas = 3;
                const intervalTentativas = 800; // 800ms entre tentativas

                const tentarAplicarGradientes = () => {
                    tentativas++;
                    log(
                        `🎯 GRADIENTES MINUTAS: Tentativa ${tentativas}/${maxTentativas}`
                    );

                    const resultado = aplicarGradientesLegMinutas();
                    const sucesso = resultado && resultado.sucesso;

                    if (sucesso) {
                        log(
                            `✅ GRADIENTES MINUTAS ROBUSTA: Aplicação bem-sucedida na tentativa ${tentativas}!`
                        );
                        log(
                            `📊 GRADIENTES MINUTAS: ${resultado.processados} elementos processados`
                        );
                        return true;
                    } else {
                        log(
                            `❌ GRADIENTES MINUTAS: Tentativa ${tentativas} falhou`
                        );
                        if (resultado?.motivo) {
                            log(`   Motivo: ${resultado.motivo}`);
                        }

                        if (tentativas < maxTentativas) {
                            log(
                                `🔄 GRADIENTES MINUTAS: Reagendando tentativa em ${intervalTentativas}ms...`
                            );
                            setTimeout(
                                tentarAplicarGradientes,
                                intervalTentativas
                            );
                        } else {
                            log(
                                "❌ GRADIENTES MINUTAS ROBUSTA: Todas as tentativas falharam - desistindo"
                            );
                            return false;
                        }
                    }
                };

                // Executar primeira tentativa imediatamente
                return tentarAplicarGradientes();
            }

            /**
             * 🔄 FUNÇÃO DE APLICAÇÃO ROBUSTA DE GRADIENTES - Com detecção inteligente e retry automático
             */
            function aplicarGradientesCapaProcessoRobusta() {
                log(
                    "🔄 GRADIENTES ROBUSTA: Iniciando aplicação robusta de gradientes..."
                );

                // Verificar se estamos na página correta primeiro
                if (!isCapaProcessoPage()) {
                    log(
                        "ℹ️ GRADIENTES ROBUSTA: Não é uma página de capa de processo"
                    );
                    return false;
                }

                let tentativas = 0;
                const maxTentativas = 5;
                const intervalTentativas = 1000; // 1 segundo entre tentativas

                const tentarAplicarGradientes = () => {
                    tentativas++;
                    log(
                        `🎯 GRADIENTES: Tentativa ${tentativas}/${maxTentativas}`
                    );

                    const resultado = aplicarGradientesCapaProcesso();
                    const sucesso = resultado && resultado.sucesso;

                    if (!sucesso && tentativas < maxTentativas) {
                        log(
                            `⏳ GRADIENTES: Aguardando ${intervalTentativas}ms para nova tentativa...`
                        );
                        setTimeout(tentarAplicarGradientes, intervalTentativas);
                    } else if (sucesso) {
                        log(
                            "✅ GRADIENTES ROBUSTA: Gradientes aplicados com sucesso!"
                        );
                        log(
                            `📊 RESULTADOS: Cor original: ${resultado.corOriginal}, Gradiente: ${resultado.gradienteAplicado}`
                        );
                    } else {
                        log(
                            "⚠️ GRADIENTES ROBUSTA: Não foi possível aplicar gradientes após todas as tentativas"
                        );
                    }
                };

                // Iniciar primeira tentativa
                tentarAplicarGradientes();

                // Também agendar uma verificação após carregamento completo
                if (document.readyState !== "complete") {
                    window.addEventListener("load", () => {
                        setTimeout(() => {
                            log(
                                "🔄 GRADIENTES: Verificação pós-carregamento..."
                            );
                            aplicarGradientesCapaProcesso();
                        }, 500);
                    });
                }

                return true;
            }

            // 📏 FUNÇÃO AUXILIAR: Aplicar dimensionamento específico para ícones em divListaRecursosMinuta
            function aplicarDimensionamentoRecursosMinuta(svg) {
                try {
                    // Verificar se o SVG está dentro de divListaRecursosMinuta
                    const divListaRecursos = svg.closest(
                        "#divListaRecursosMinuta"
                    );

                    if (divListaRecursos) {
                        // Aplicar tamanho específico de 17.59x17.59
                        svg.setAttribute("width", "17.59px");
                        svg.setAttribute("height", "17.59px");

                        // Aplicar via style também para garantir
                        svg.style.width = "17.59px";
                        svg.style.height = "17.59px";

                        // CORREÇÃO DE ALINHAMENTO: Aplicar propriedades de alinhamento vertical
                        svg.style.verticalAlign = "middle";
                        svg.style.display = "inline-block";
                        svg.style.margin = "0";
                        svg.style.padding = "0";
                        svg.style.lineHeight = "1";

                        // Verificar e corrigir o container pai também
                        const container = svg.parentElement;
                        if (container && container.tagName === "SPAN") {
                            container.style.display = "inline-flex";
                            container.style.alignItems = "center";
                            container.style.justifyContent = "center";
                            container.style.verticalAlign = "middle";
                            container.style.lineHeight = "1";
                            container.style.width = "17.59px";
                            container.style.height = "17.59px";
                            container.style.margin = "0";
                            container.style.padding = "0";
                        }

                        // Marcar como redimensionado
                        svg.setAttribute(
                            "data-eprobe-recursos-minuta-sized",
                            "true"
                        );

                        log(
                            `📏 RECURSOS: Ícone redimensionado e alinhado para 17.59x17.59 em divListaRecursosMinuta`
                        );
                        return true;
                    }
                } catch (error) {
                    console.warn(
                        "⚠️ RECURSOS: Erro ao aplicar dimensionamento:",
                        error
                    );
                }
                return false;
            }

            // 🔧 FUNÇÃO ESPECÍFICA: Corrigir alinhamento de todos os ícones em divListaRecursosMinuta
            function corrigirAlinhamentoRecursosMinuta() {
                try {
                    const divListaRecursos = document.getElementById(
                        "divListaRecursosMinuta"
                    );

                    if (!divListaRecursos) {
                        log(
                            "⚠️ RECURSOS: divListaRecursosMinuta não encontrado"
                        );
                        return {
                            encontrado: false,
                            icones: 0,
                            iconesCorrigidos: 0,
                        };
                    }

                    log("🔧 RECURSOS: Iniciando correção de alinhamento...");

                    // Corrigir todos os ícones SVG personalizados
                    const iconesSvg = divListaRecursos.querySelectorAll(
                        'svg[data-eprobe-icon-replaced="true"]'
                    );
                    let iconesCorrigidos = 0;

                    iconesSvg.forEach((svg, index) => {
                        if (aplicarDimensionamentoRecursosMinuta(svg)) {
                            iconesCorrigidos++;
                        }
                    });

                    // Corrigir todos os links e containers também
                    const links = divListaRecursos.querySelectorAll("a");
                    links.forEach((link) => {
                        link.style.display = "inline-flex";
                        link.style.alignItems = "center";
                        link.style.verticalAlign = "middle";
                        link.style.lineHeight = "1";
                    });

                    // Aplicar CSS global para normalizar todos os elementos da div
                    const style = document.createElement("style");
                    style.id = "eprobe-recursos-minuta-fix";

                    // Remover estilo anterior se existir
                    const oldStyle = document.getElementById(
                        "eprobe-recursos-minuta-fix"
                    );
                    if (oldStyle) oldStyle.remove();

                    style.textContent = `
                        /* CORREÇÃO CRÍTICA DE ALINHAMENTO PARA divListaRecursosMinuta */
                        #divListaRecursosMinuta {
                            line-height: 1 !important;
                        }
                        
                        #divListaRecursosMinuta * {
                            vertical-align: middle !important;
                            line-height: 1 !important;
                        }
                        
                        #divListaRecursosMinuta a {
                            display: inline-flex !important;
                            align-items: center !important;
                            vertical-align: middle !important;
                            line-height: 1 !important;
                        }
                        
                        #divListaRecursosMinuta img,
                        #divListaRecursosMinuta svg {
                            vertical-align: middle !important;
                            display: inline-block !important;
                            line-height: 1 !important;
                        }
                    `;

                    document.head.appendChild(style);

                    const resultado = {
                        encontrado: true,
                        icones: iconesSvg.length,
                        iconesCorrigidos,
                        linksCorrigidos: links.length,
                        cssAplicado: true,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };

                    log(
                        "✅ RECURSOS: Correção de alinhamento concluída:",
                        resultado
                    );

                    return resultado;
                } catch (error) {
                    console.error(
                        "❌ RECURSOS: Erro na correção de alinhamento:",
                        error
                    );
                    return {
                        encontrado: false,
                        erro: error.message,
                    };
                }
            }

            // 👁️ OBSERVADOR ESPECÍFICO: Monitorar mudanças em divListaRecursosMinuta
            function setupObservadorRecursosMinuta() {
                try {
                    const divListaRecursos = document.getElementById(
                        "divListaRecursosMinuta"
                    );

                    if (!divListaRecursos) {
                        log(
                            "📏 RECURSOS: divListaRecursosMinuta não encontrado - observer não configurado"
                        );
                        return false;
                    }

                    log(
                        "👁️ RECURSOS: Configurando observador para divListaRecursosMinuta"
                    );

                    const observer = new MutationObserver((mutations) => {
                        let needsProcessing = false;

                        mutations.forEach((mutation) => {
                            // Verificar se novos ícones SVG foram adicionados
                            if (mutation.type === "childList") {
                                mutation.addedNodes.forEach((node) => {
                                    if (node.nodeType === Node.ELEMENT_NODE) {
                                        // Verificar se é um SVG ou contém SVGs
                                        const svgs =
                                            node.tagName === "SVG"
                                                ? [node]
                                                : (node.querySelectorAll &&
                                                      node.querySelectorAll(
                                                          'svg[data-eprobe-icon-replaced="true"]'
                                                      )) ||
                                                  [];

                                        if (svgs.length > 0) {
                                            needsProcessing = true;
                                        }
                                    }
                                });
                            }

                            // Verificar se atributos de SVGs existentes mudaram
                            if (
                                mutation.type === "attributes" &&
                                mutation.target.tagName === "SVG" &&
                                mutation.target.hasAttribute(
                                    "data-eprobe-icon-replaced"
                                ) &&
                                (mutation.attributeName === "width" ||
                                    mutation.attributeName === "height" ||
                                    mutation.attributeName === "style")
                            ) {
                                needsProcessing = true;
                            }
                        });

                        if (needsProcessing) {
                            // Debounce para evitar múltiplas execuções
                            clearTimeout(observer.debounceTimer);
                            observer.debounceTimer = setTimeout(() => {
                                log(
                                    "🔧 RECURSOS: Aplicando dimensionamento após mudança no DOM"
                                );

                                // Processar todos os ícones SVG na div
                                const iconesSvg =
                                    divListaRecursos.querySelectorAll(
                                        'svg[data-eprobe-icon-replaced="true"]'
                                    );
                                let processados = 0;

                                iconesSvg.forEach((svg) => {
                                    if (
                                        aplicarDimensionamentoRecursosMinuta(
                                            svg
                                        )
                                    ) {
                                        processados++;
                                    }
                                });

                                if (processados > 0) {
                                    log(
                                        `📏 RECURSOS: ${processados} ícones redimensionados automaticamente`
                                    );
                                }
                            }, 100);
                        }
                    });

                    // Observar mudanças na div específica
                    observer.observe(divListaRecursos, {
                        childList: true,
                        subtree: true,
                        attributes: true,
                        attributeFilter: [
                            "width",
                            "height",
                            "style",
                            "data-eprobe-icon-replaced",
                        ],
                    });

                    log(
                        "✅ RECURSOS: Observador configurado com sucesso para divListaRecursosMinuta"
                    );
                    return observer;
                } catch (error) {
                    console.error(
                        "❌ RECURSOS: Erro ao configurar observador:",
                        error
                    );
                    return false;
                }
            }

            // 🔄 OBSERVADOR ESPECÍFICO: Monitorar atualizações na seção legMinutas
            function setupObservadorLegendMinutas() {
                try {
                    const legMinutas = document.getElementById("legMinutas");

                    if (!legMinutas) {
                        log(
                            "📋 MINUTAS: legMinutas não encontrado - observer não configurado"
                        );
                        return false;
                    }

                    log(
                        "👁️ MINUTAS: Configurando observador para legMinutas (Histórico)"
                    );

                    const observer = new MutationObserver((mutations) => {
                        let needsReprocessing = false;

                        mutations.forEach((mutation) => {
                            // Detectar quando conteúdo é atualizado (botão "Atualizar Minutas")
                            if (mutation.type === "childList") {
                                // Verificar se novos elementos foram adicionados ou se conteúdo foi modificado
                                if (
                                    mutation.addedNodes.length > 0 ||
                                    mutation.removedNodes.length > 0
                                ) {
                                    needsReprocessing = true;
                                    log(
                                        "🔄 MINUTAS: Conteúdo da seção legMinutas foi atualizado - reprocessando ícones..."
                                    );
                                }
                            }

                            // Detectar mudanças no innerHTML (via AJAX)
                            if (mutation.type === "characterData") {
                                needsReprocessing = true;
                                log(
                                    "🔄 MINUTAS: Texto da seção legMinutas foi modificado - reprocessando..."
                                );
                            }
                        });

                        if (needsReprocessing) {
                            // Debounce para evitar múltiplas execuções simultâneas
                            clearTimeout(observer.debounceTimer);
                            observer.debounceTimer = setTimeout(() => {
                                log(
                                    "🎨 MINUTAS: Reaplicando personalizações de ícones após atualização..."
                                );

                                try {
                                    let totalReaplicados = 0;

                                    // 1. Reaplicar ícones de ferramentas
                                    if (
                                        typeof substituirIconesFerramentas ===
                                        "function"
                                    ) {
                                        const antes =
                                            legMinutas.querySelectorAll(
                                                '[data-eprobe-icon-replaced="true"]'
                                            ).length;
                                        substituirIconesFerramentas();
                                        const depois =
                                            legMinutas.querySelectorAll(
                                                '[data-eprobe-icon-replaced="true"]'
                                            ).length;
                                        totalReaplicados += depois - antes;
                                    }

                                    // 2. Reaplicar ícones de lembretes
                                    if (
                                        typeof substituirIconesLembretes ===
                                        "function"
                                    ) {
                                        const antes =
                                            legMinutas.querySelectorAll(
                                                '[data-eprobe-icon-replaced="true"]'
                                            ).length;
                                        substituirIconesLembretes();
                                        const depois =
                                            legMinutas.querySelectorAll(
                                                '[data-eprobe-icon-replaced="true"]'
                                            ).length;
                                        totalReaplicados += depois - antes;
                                    }

                                    // 3. Reaplicar ícones globais
                                    if (
                                        typeof substituirIconesGlobalmente ===
                                        "function"
                                    ) {
                                        const antes =
                                            legMinutas.querySelectorAll(
                                                '[data-eprobe-icon-replaced="true"]'
                                            ).length;
                                        substituirIconesGlobalmente();
                                        const depois =
                                            legMinutas.querySelectorAll(
                                                '[data-eprobe-icon-replaced="true"]'
                                            ).length;
                                        totalReaplicados += depois - antes;
                                    }

                                    // 4. Corrigir alinhamento se necessário
                                    if (
                                        typeof corrigirAlinhamentoRecursosMinuta ===
                                        "function"
                                    ) {
                                        const divListaRecursos =
                                            legMinutas.querySelector(
                                                "#divListaRecursosMinuta"
                                            );
                                        if (divListaRecursos) {
                                            corrigirAlinhamentoRecursosMinuta();
                                        }
                                    }

                                    if (totalReaplicados > 0) {
                                        log(
                                            `✅ MINUTAS: ${totalReaplicados} ícones reaplicados com sucesso após atualização`
                                        );
                                    } else {
                                        log(
                                            "⚠️ MINUTAS: Nenhum ícone foi reaplicado - possível problema na detecção"
                                        );
                                    }
                                } catch (error) {
                                    console.error(
                                        "❌ MINUTAS: Erro na reaplicação de ícones:",
                                        error
                                    );
                                }
                            }, 500); // 500ms de delay para garantir que a atualização AJAX foi concluída
                        }
                    });

                    // Observar mudanças na seção legMinutas completa
                    observer.observe(legMinutas, {
                        childList: true,
                        subtree: true,
                        characterData: true,
                        attributes: false, // Não precisamos de atributos, só conteúdo
                    });

                    log(
                        "✅ MINUTAS: Observador configurado com sucesso para legMinutas"
                    );
                    return observer;
                } catch (error) {
                    console.error(
                        "❌ MINUTAS: Erro ao configurar observador:",
                        error
                    );
                    return false;
                }
            }

            //   ANTI-FLASH CRÍTICO: Ocultar ícones originais IMEDIATAMENTE e mostrar apenas personalizados
            function aplicarAntiFlashIcones() {
                try {
                    // Aplicar anti-flash total (ícones + navbar + botões)
                    if (window.eprobeAntiFlash) {
                        window.eprobeAntiFlash.aplicarAntiFlashTotal();
                        log(
                            "⚡ ANTI-FLASH TOTAL: Sistema ativo para todos os elementos"
                        );
                        return true;
                    } else {
                        log("⚠️ ANTI-FLASH: Sistema não inicializado");
                        return false;
                    }
                } catch (error) {
                    console.error("❌ ANTI-FLASH: Erro:", error);
                    return false;
                }
            }

            //  🔄 REAPLICAR ÍCONES: Força a reaplicação de ícones após atualização AJAX
            function reaplicarIconesAposAtualizacao(containerElement) {
                log(
                    "🔄 REAPLICAÇÃO: Iniciando reaplicação forçada de ícones após atualização..."
                );

                if (!containerElement) {
                    console.warn("⚠️ REAPLICAÇÃO: Container não fornecido");
                    return 0;
                }

                let totalReaplicados = 0;

                try {
                    // 1. Reaplicar ícones de lembretes (forçando bypass da restrição de URL)
                    if (typeof substituirIconesLembretes === "function") {
                        // Guardar verificação original e criar bypass temporário
                        const originalIsCapaProcessoPage =
                            window.isCapaProcessoPage;
                        window.isCapaProcessoPage = () => true; // Bypass temporário

                        try {
                            const iconesLembretes = substituirIconesLembretes();
                            totalReaplicados += iconesLembretes;
                            log(
                                `🎨 REAPLICAÇÃO: ${iconesLembretes} ícones de lembretes reaplicados`
                            );
                        } finally {
                            // Restaurar verificação original
                            window.isCapaProcessoPage =
                                originalIsCapaProcessoPage;
                        }
                    }

                    // 2. Reaplicar ícones de ferramentas globalmente
                    if (typeof substituirIconesGlobalmente === "function") {
                        const iconesGlobais = substituirIconesGlobalmente();
                        totalReaplicados += iconesGlobais;
                        log(
                            `🔧 REAPLICAÇÃO: ${iconesGlobais} ícones globais reaplicados`
                        );
                    }

                    // 3. Reaplicar ícones específicos do fieldset de ações
                    if (typeof substituirIconesFieldsetAcoes === "function") {
                        const originalIsCapaProcessoPage =
                            window.isCapaProcessoPage;
                        window.isCapaProcessoPage = () => true; // Bypass temporário

                        try {
                            const iconesFieldset =
                                substituirIconesFieldsetAcoes();
                            if (iconesFieldset) {
                                totalReaplicados += 1; // função retorna boolean
                                log(
                                    "🏗️ REAPLICAÇÃO: Ícones do fieldset de ações reaplicados"
                                );
                            }
                        } finally {
                            window.isCapaProcessoPage =
                                originalIsCapaProcessoPage;
                        }
                    }

                    // 4. Verificar especificamente por ícones que precisam ser substituídos no container
                    const iconesOriginais = containerElement.querySelectorAll(
                        'span.material-icons:not([data-eprobe-icon-replaced="true"])'
                    );
                    iconesOriginais.forEach((icone) => {
                        // Tentar detectar e substituir ícones que voltaram ao estado original
                        const textoIcone = icone.textContent.trim();
                        const parentElement = icone.parentElement;

                        // Verificar se é um ícone de lembrete que precisa ser resubstituído
                        if (
                            textoIcone === "edit" &&
                            parentElement &&
                            (parentElement
                                .getAttribute("aria-label")
                                ?.includes("Alterar Lembrete") ||
                                parentElement.href?.includes(
                                    "processo_lembrete_destino_alterar"
                                ))
                        ) {
                            log(
                                "🔍 REAPLICAÇÃO: Ícone 'edit' de lembrete detectado para resubstituição"
                            );
                        }

                        if (
                            textoIcone === "delete" &&
                            parentElement &&
                            (parentElement
                                .getAttribute("aria-label")
                                ?.includes("Desativar Lembrete") ||
                                parentElement.onclick
                                    ?.toString()
                                    .includes("desativarLembrete"))
                        ) {
                            log(
                                "🔍 REAPLICAÇÃO: Ícone 'delete' de lembrete detectado para resubstituição"
                            );
                        }
                    });

                    log(
                        `✅ REAPLICAÇÃO: Total de ${totalReaplicados} ícones reaplicados com sucesso`
                    );
                    return totalReaplicados;
                } catch (error) {
                    console.error(
                        "❌ REAPLICAÇÃO: Erro durante reaplicação de ícones:",
                        error
                    );
                    return 0;
                }
            }

            // 🔄 INTERCEPTOR MÚLTIPLO: Interceptar TODOS os botões "Atualizar Minutas" (individuais por minuta)
            function setupInterceptorTodosBotoesAtualizar() {
                try {
                    // Buscar todos os botões de atualizar minutas (principal + individuais)
                    const botoesAtualizar = document.querySelectorAll(
                        'a[aria-label="Atualizar Minutas"]'
                    );

                    if (botoesAtualizar.length === 0) {
                        log(
                            "🔄 MINUTAS MÚLTIPLAS: Nenhum botão de atualizar minutas encontrado"
                        );
                        return 0;
                    }

                    let interceptadosCount = 0;

                    botoesAtualizar.forEach((botao, index) => {
                        // Verificar se já foi interceptado
                        if (botao.hasAttribute("data-eprobe-intercepted")) {
                            log(
                                `🔄 MINUTAS MÚLTIPLAS: Botão ${index} já interceptado`
                            );
                            return;
                        }

                        log(
                            `🎯 MINUTAS MÚLTIPLAS: Configurando interceptor para botão ${index}`
                        );

                        // Guardar função/atributo onclick original
                        const onclickOriginal = botao.onclick;
                        const onclickAttrOriginal =
                            botao.getAttribute("onclick");

                        // Criar função interceptora
                        botao.onclick = function (event) {
                            log(
                                `🔄 MINUTAS MÚLTIPLAS: Botão ${index} clicado - preparando reaplicação...`
                            );

                            try {
                                // Executar função original primeiro
                                if (onclickOriginal) {
                                    onclickOriginal.call(this, event);
                                } else if (onclickAttrOriginal) {
                                    // CSP-safe: executar atualizaMinutas diretamente
                                    log(
                                        "🔄 MINUTAS MÚLTIPLAS: Executando função original (CSP-safe)..."
                                    );

                                    try {
                                        if (
                                            typeof window.atualizaMinutas ===
                                            "function"
                                        ) {
                                            // Extrair parâmetros do onclick original
                                            const params =
                                                onclickAttrOriginal.match(
                                                    /atualizaMinutas\(([^)]+)\)/
                                                );
                                            if (params && params[1]) {
                                                const cleanParams = params[1]
                                                    .split(",")
                                                    .map((p) =>
                                                        p
                                                            .trim()
                                                            .replace(
                                                                /['"]/g,
                                                                ""
                                                            )
                                                    );
                                                log(
                                                    `🎯 MINUTAS MÚLTIPLAS: Executando atualizaMinutas com parâmetros:`,
                                                    cleanParams
                                                );
                                                window.atualizaMinutas.apply(
                                                    this,
                                                    cleanParams
                                                );
                                            } else {
                                                window.atualizaMinutas();
                                            }
                                        } else {
                                            console.warn(
                                                "⚠️ MINUTAS MÚLTIPLAS: Função atualizaMinutas não encontrada"
                                            );
                                        }
                                    } catch (originalError) {
                                        console.warn(
                                            "⚠️ MINUTAS MÚLTIPLAS: Erro ao executar função original:",
                                            originalError
                                        );
                                    }
                                }

                                // Aguardar AJAX completar e reaplicar ícones
                                setTimeout(() => {
                                    log(
                                        `🎨 MINUTAS MÚLTIPLAS: Reaplicando ícones após botão ${index}...`
                                    );

                                    // ⚡ APLICAR ANTI-FLASH ANTES da reaplicação
                                    aplicarAntiFlashIcones();

                                    const legMinutas =
                                        document.getElementById("legMinutas");
                                    if (!legMinutas) {
                                        console.warn(
                                            "⚠️ MINUTAS MÚLTIPLAS: legMinutas não encontrado"
                                        );
                                        return;
                                    }

                                    // Reaplicar ícones
                                    const iconesReaplicados =
                                        reaplicarIconesAposAtualizacao(
                                            legMinutas
                                        );

                                    if (iconesReaplicados > 0) {
                                        log(
                                            `✅ MINUTAS MÚLTIPLAS: ${iconesReaplicados} ícones reaplicados após botão ${index}`
                                        );
                                    } else {
                                        log(
                                            `⚠️ MINUTAS MÚLTIPLAS: Nenhum ícone reaplicado após botão ${index}`
                                        );
                                    }

                                    // Corrigir alinhamento se necessário
                                    const divListaRecursos =
                                        legMinutas.querySelector(
                                            "#divListaRecursosMinuta"
                                        );
                                    if (
                                        divListaRecursos &&
                                        typeof corrigirAlinhamentoRecursosMinuta ===
                                            "function"
                                    ) {
                                        const resultado =
                                            corrigirAlinhamentoRecursosMinuta();
                                        if (
                                            resultado.encontrado &&
                                            resultado.iconesCorrigidos > 0
                                        ) {
                                            log(
                                                `📏 MINUTAS MÚLTIPLAS: Alinhamento corrigido - ${resultado.iconesCorrigidos} ícones`
                                            );
                                        }
                                    }
                                }, 1000); // 1 segundo para AJAX completar
                            } catch (error) {
                                console.error(
                                    `❌ MINUTAS MÚLTIPLAS: Erro no interceptor ${index}:`,
                                    error
                                );
                            }
                        };

                        // Marcar como interceptado
                        botao.setAttribute("data-eprobe-intercepted", "true");
                        botao.setAttribute(
                            "data-eprobe-interceptor-index",
                            index
                        );
                        botao.setAttribute(
                            "title",
                            (botao.title || "Atualizar") +
                                " (eProbe: Ícones reaplicados automaticamente)"
                        );

                        interceptadosCount++;
                        log(
                            `✅ MINUTAS MÚLTIPLAS: Botão ${index} interceptado com sucesso`
                        );
                    });

                    log(
                        `🎯 MINUTAS MÚLTIPLAS: ${interceptadosCount} botões interceptados de ${botoesAtualizar.length} encontrados`
                    );
                    return interceptadosCount;
                } catch (error) {
                    console.error(
                        "❌ MINUTAS MÚLTIPLAS: Erro ao configurar interceptors:",
                        error
                    );
                    return 0;
                }
            }

            // 🔄 INTERCEPTOR ESPECÍFICO: Interceptar clique no botão "Atualizar Minutas" PRINCIPAL
            function setupInterceptorAtualizarMinutas() {
                try {
                    const botaoAtualizar =
                        document.getElementById("atualizaMinutas");

                    if (!botaoAtualizar) {
                        log(
                            "🔄 MINUTAS: Botão atualizaMinutas não encontrado - interceptor não configurado"
                        );
                        return false;
                    }

                    // Verificar se já foi interceptado para evitar duplicação
                    if (
                        botaoAtualizar.hasAttribute("data-eprobe-intercepted")
                    ) {
                        log(
                            "🔄 MINUTAS: Botão atualizaMinutas já interceptado"
                        );
                        return true;
                    }

                    log(
                        "🎯 MINUTAS: Configurando interceptor para botão atualizaMinutas"
                    );

                    // Guardar a função onclick original
                    const onclickOriginal = botaoAtualizar.onclick;
                    const onclickAttrOriginal =
                        botaoAtualizar.getAttribute("onclick");

                    // Criar nova função que inclui reaplicação de ícones
                    botaoAtualizar.onclick = function (event) {
                        log(
                            '🔄 MINUTAS: Botão "Atualizar Minutas" clicado - preparando reaplicação de ícones...'
                        );

                        try {
                            // Executar a função original primeiro
                            if (onclickOriginal) {
                                onclickOriginal.call(this, event);
                            } else if (onclickAttrOriginal) {
                                // ✅ CSP COMPLIANCE: Em vez de eval(), simular o clique no botão original
                                log(
                                    "🔄 MINUTAS: Simulando clique original (CSP-safe)..."
                                );

                                // Criar evento de clique sintético
                                const syntheticEvent = new MouseEvent("click", {
                                    bubbles: true,
                                    cancelable: true,
                                    view: window,
                                });

                                // Temporariamente remover nosso interceptor
                                const tempOnclick = this.onclick;
                                this.onclick = null;

                                // Tentar executar a função original do atributo onclick de forma segura
                                try {
                                    // Buscar pela função atualizaMinutas no escopo global
                                    if (
                                        typeof window.atualizaMinutas ===
                                        "function"
                                    ) {
                                        // Extrair os parâmetros do onclick original
                                        const params =
                                            onclickAttrOriginal.match(
                                                /atualizaMinutas\(([^)]+)\)/
                                            );
                                        if (params && params[1]) {
                                            // Limpar as aspas dos parâmetros
                                            const cleanParams = params[1]
                                                .split(",")
                                                .map((p) =>
                                                    p
                                                        .trim()
                                                        .replace(/['"]/g, "")
                                                );
                                            log(
                                                "🎯 MINUTAS: Executando atualizaMinutas com parâmetros:",
                                                cleanParams
                                            );
                                            window.atualizaMinutas.apply(
                                                this,
                                                cleanParams
                                            );
                                        } else {
                                            window.atualizaMinutas();
                                        }
                                    } else {
                                        console.warn(
                                            "⚠️ MINUTAS: Função atualizaMinutas não encontrada no escopo global"
                                        );
                                    }
                                } catch (originalError) {
                                    console.warn(
                                        "⚠️ MINUTAS: Erro ao executar função original (continuando):",
                                        originalError
                                    );
                                } finally {
                                    // Restaurar nosso interceptor
                                    this.onclick = tempOnclick;
                                }
                            }

                            // Aguardar um pouco para a requisição AJAX completar, então reaplicar ícones
                            setTimeout(() => {
                                log(
                                    "🎨 MINUTAS: Reaplicando ícones personalizados após atualização..."
                                );

                                // ⚡ APLICAR ANTI-FLASH ANTES da reaplicação
                                aplicarAntiFlashIcones();

                                const legMinutas =
                                    document.getElementById("legMinutas");
                                if (!legMinutas) {
                                    console.warn(
                                        "⚠️ MINUTAS: legMinutas não encontrado após atualização"
                                    );
                                    return;
                                }

                                let totalReaplicados = 0;

                                // 1. Reaplicar ícones de ferramentas (FORÇADO após atualização)
                                const antesTotal = legMinutas.querySelectorAll(
                                    '[data-eprobe-icon-replaced="true"]'
                                ).length;

                                // Reaplicar diretamente no legMinutas sem restrições de URL
                                const iconesReaplicados =
                                    reaplicarIconesAposAtualizacao(legMinutas);
                                totalReaplicados += iconesReaplicados;

                                const depoisTotal = legMinutas.querySelectorAll(
                                    '[data-eprobe-icon-replaced="true"]'
                                ).length;

                                // 4. Corrigir alinhamento em divListaRecursosMinuta se existir
                                const divListaRecursos =
                                    legMinutas.querySelector(
                                        "#divListaRecursosMinuta"
                                    );
                                if (
                                    divListaRecursos &&
                                    typeof corrigirAlinhamentoRecursosMinuta ===
                                        "function"
                                ) {
                                    const resultado =
                                        corrigirAlinhamentoRecursosMinuta();
                                    if (
                                        resultado.encontrado &&
                                        resultado.iconesCorrigidos > 0
                                    ) {
                                        log(
                                            `📏 MINUTAS: Alinhamento corrigido - ${resultado.iconesCorrigidos} ícones processados`
                                        );
                                    }
                                }

                                if (totalReaplicados > 0) {
                                    log(
                                        `✅ MINUTAS: ${totalReaplicados} ícones reaplicados com sucesso após "Atualizar Minutas"`
                                    );
                                } else {
                                    log(
                                        "⚠️ MINUTAS: Nenhum ícone foi reaplicado - possível problema na detecção"
                                    );
                                }
                            }, 1000); // 1 segundo de delay para garantir que a atualização AJAX foi completada
                        } catch (error) {
                            console.error(
                                "❌ MINUTAS: Erro durante interceptação:",
                                error
                            );
                        }
                    };

                    // Marcar como interceptado
                    botaoAtualizar.setAttribute(
                        "data-eprobe-intercepted",
                        "true"
                    );
                    botaoAtualizar.setAttribute(
                        "title",
                        (botaoAtualizar.title || "Atualizar") +
                            " (eProbe: Ícones serão reaplicados automaticamente)"
                    );

                    log(
                        "✅ MINUTAS: Interceptor configurado com sucesso para botão atualizaMinutas"
                    );
                    return true;
                } catch (error) {
                    console.error(
                        "❌ MINUTAS: Erro ao configurar interceptor:",
                        error
                    );
                    return false;
                }
            }

            // Função para substituir ícones no fieldset de ações
            function substituirIconesFieldsetAcoes() {
                const currentUrl = window.location.href;

                // ⛔ RESTRIÇÃO: Só personalizar ícones na página de capa do processo
                if (!isCapaProcessoPage()) {
                    log(
                        "⛔ ÍCONES: Personalização de ícones restrita apenas à página de capa do processo - URL atual não permitida"
                    );
                    log("📍 URL atual:", currentUrl);
                    return false;
                }

                // ⛔ EXCEÇÃO: Não substituir ícones em páginas de cadastro de minutas
                if (currentUrl.includes("minuta_cadastrar")) {
                    log(
                        "⛔ ÍCONES: Página de cadastro de minutas detectada - ignorando substituições"
                    );
                    return false;
                }

                log(
                    "🎨 ÍCONES: Iniciando substituição de ícones no fieldset de ações"
                );

                const fieldset = document.querySelector(
                    "#fldAcoes.infraFieldset"
                );
                if (!fieldset) {
                    logError("❌ ÍCONES: Fieldset #fldAcoes não encontrado");
                    return false;
                }

                let substituicoesRealizadas = 0;

                // Substituir ícones por atributo alt
                Object.values(ICON_REPLACEMENTS).forEach((replacement) => {
                    const img = fieldset.querySelector(replacement.selector);
                    if (img) {
                        // 🛡️ PROTEÇÃO: Verificar se elemento ainda é válido
                        if (!img.parentNode || !img.src) {
                            console.warn(
                                "⚠️ ÍCONES: Elemento img inválido, pulando substituição"
                            );
                            return;
                        }

                        // 🛡️ PROTEÇÃO: Marcar elemento como processado para evitar problemas
                        if (img.hasAttribute("data-eprobe-processing")) {
                            log(
                                "ℹ️ ÍCONES: Elemento já sendo processado, pulando"
                            );
                            return;
                        }
                        img.setAttribute("data-eprobe-processing", "true");

                        try {
                            const container = document.createElement("span");
                            container.innerHTML = replacement.newSvg;

                            // 🎨 APLICAR ESTILOS PADRONIZADOS
                            applyStandardIconStyles(container);

                            // 🛡️ PROTEÇÃO: Marcar container como modificado pela extensão
                            container.setAttribute(
                                "data-eprobe-modified",
                                "true"
                            );
                            container.setAttribute(
                                "data-original-alt",
                                img.alt || ""
                            );

                            // Preservar classes e atributos importantes
                            const svg = container.firstElementChild;
                            if (svg) {
                                // 🛡️ PROTEÇÃO: Usar setAttribute para SVG className
                                svg.setAttribute("class", "iconeAcao");
                                svg.setAttribute("data-eprobe-icon", "true");
                                svg.style.width = "18px";
                                svg.style.height = "18px";
                            }

                            // 🛡️ PROTEÇÃO: Substituição mais segura com verificação
                            if (
                                img.parentNode &&
                                img.parentNode.contains(img)
                            ) {
                                img.parentNode.replaceChild(container, img);
                                substituicoesRealizadas++;
                                // Log compacto apenas para os primeiros
                                if (substituicoesRealizadas <= 3) {
                                    log(
                                        `✅ ÍCONES: Substituído ${img.alt} (${substituicoesRealizadas})`
                                    );
                                }
                            } else {
                                console.warn(
                                    "⚠️ ÍCONES: Elemento não mais no DOM, cancelando substituição"
                                );
                            }
                        } catch (error) {
                            console.error(
                                "❌ ÍCONES: Erro durante substituição:",
                                error
                            );
                            // Remove marca de processamento em caso de erro
                            img.removeAttribute("data-eprobe-processing");
                        }
                    }
                });

                // Substituir ícones por texto do link
                Object.entries(ICON_REPLACEMENTS_BY_TEXT).forEach(
                    ([text, replacement]) => {
                        // Buscar especificamente por links com classe infraButton
                        const links =
                            fieldset.querySelectorAll("a.infraButton, a");
                        links.forEach((link) => {
                            // Verificar se o texto do link termina com o texto procurado
                            const linkText = link.textContent.trim();
                            if (
                                linkText.includes(text) ||
                                linkText.endsWith(text)
                            ) {
                                const img =
                                    link.querySelector("img.iconeAcao, img");
                                if (img) {
                                    // 🛡️ PROTEÇÃO: Verificar se elemento ainda é válido
                                    if (!img.parentNode || !img.src) {
                                        console.warn(
                                            "⚠️ ÍCONES: Elemento img inválido no link, pulando substituição"
                                        );
                                        return;
                                    }

                                    // 🛡️ PROTEÇÃO: Marcar elemento como processado
                                    if (
                                        img.hasAttribute(
                                            "data-eprobe-processing"
                                        )
                                    ) {
                                        return;
                                    }
                                    img.setAttribute(
                                        "data-eprobe-processing",
                                        "true"
                                    );

                                    try {
                                        const container =
                                            document.createElement("span");
                                        container.innerHTML =
                                            replacement.newSvg;
                                        container.style.display = "inline-flex";
                                        container.style.alignItems = "center";
                                        container.style.marginRight = "4px";

                                        // 🛡️ PROTEÇÃO: Marcar container como modificado
                                        container.setAttribute(
                                            "data-eprobe-modified",
                                            "true"
                                        );
                                        container.setAttribute(
                                            "data-original-text",
                                            text
                                        );

                                        const svg = container.firstElementChild;
                                        if (svg) {
                                            // 🛡️ PROTEÇÃO: Usar setAttribute para SVG className
                                            svg.setAttribute(
                                                "class",
                                                "iconeAcao"
                                            );
                                            svg.style.width = "18px";
                                            svg.style.height = "18px";
                                            svg.setAttribute(
                                                "data-eprobe-icon-replaced",
                                                "true"
                                            );
                                            svg.setAttribute(
                                                "data-original-text",
                                                text
                                            );

                                            // 📏 DIMENSIONAMENTO ESPECÍFICO: Verificar se está em divListaRecursosMinuta
                                            aplicarDimensionamentoRecursosMinuta(
                                                svg
                                            );
                                        }

                                        // 🛡️ PROTEÇÃO: Substituição mais segura
                                        if (
                                            img.parentNode &&
                                            img.parentNode.contains(img)
                                        ) {
                                            img.parentNode.replaceChild(
                                                container,
                                                img
                                            );
                                            substituicoesRealizadas++;
                                            log(
                                                `✅ ÍCONES: Substituído ícone para "${text}"`
                                            );
                                        } else {
                                            console.warn(
                                                "⚠️ ÍCONES: Elemento img não mais no DOM"
                                            );
                                        }
                                    } catch (error) {
                                        console.error(
                                            "❌ ÍCONES: Erro durante substituição por texto:",
                                            error
                                        );
                                        img.removeAttribute(
                                            "data-eprobe-processing"
                                        );
                                    }
                                }
                            }
                        });
                    }
                );

                // Substituições específicas por src de imagem
                const imgsBySrc = [
                    {
                        selector: 'img[src*="remover.gif"]',
                        newSvg: ICON_REPLACEMENTS[
                            "processo movimento_desativar_consulta"
                        ].newSvg,
                    },
                    {
                        selector: 'img[src*="receber.gif"]',
                        newSvg: ICON_REPLACEMENTS_BY_TEXT["Movimentar Processo"]
                            .newSvg,
                    },
                    {
                        selector: 'img[src*="mais.gif"]',
                        newSvg: ICON_REPLACEMENTS_BY_TEXT[
                            "Associar Procurador Parte"
                        ].newSvg,
                    },
                    {
                        selector: 'img[src*="microphone.png"]',
                        newSvg: ICON_REPLACEMENTS["audiencia listar"].newSvg,
                    },
                    {
                        selector: 'img[src*="pdf.gif"]',
                        newSvg: ICON_REPLACEMENTS[
                            "selecionar processos_agendar_arquivo_completo"
                        ].newSvg,
                    },
                    {
                        selector: 'img[src*="anexos.gif"]',
                        newSvg: ICON_REPLACEMENTS[
                            "processo enviar_email_listar"
                        ].newSvg,
                    },
                    {
                        selector: 'img[src*="email.gif"]',
                        newSvg: ICON_REPLACEMENTS[
                            "processo expedir_carta_subform"
                        ].newSvg,
                    },
                    {
                        selector: 'img[src*="marcar.gif"]',
                        newSvg: ICON_REPLACEMENTS[
                            "gerenciamento partes_situacao_listar"
                        ].newSvg,
                    },
                    {
                        selector: 'img[src*="encaminhar.gif"]',
                        newSvg: ICON_REPLACEMENTS["processo intimacao"].newSvg,
                    },
                    {
                        selector: 'img[src*="assinar.gif"]',
                        newSvg: ICON_REPLACEMENTS["processo edicao"].newSvg,
                    },
                    {
                        selector: 'img[src*="atualizar.gif"]',
                        newSvg: ICON_REPLACEMENTS["processo cadastrar"].newSvg,
                    },
                    {
                        selector: 'img[src*="predio.png"]',
                        newSvg: ICON_REPLACEMENTS_BY_TEXT[
                            "Requisição Un. Externa"
                        ].newSvg,
                    },
                    {
                        selector: 'img[src*="hierarquia.gif"]',
                        newSvg: ICON_REPLACEMENTS["redistribuicao processo"]
                            .newSvg,
                    },
                    {
                        selector: 'img[src*="newspaper.png"]',
                        newSvg: ICON_REPLACEMENTS["processo citacao"].newSvg,
                    },
                    {
                        selector: 'img[src*="configuracao.gif"]',
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#9CA3AF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="eprobe-svg-icon eprobe-svg-config" style="pointer-events: none;"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>',
                    },
                    {
                        selector: 'img[src*="refresh.gif"]',
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-ccw-icon lucide-refresh-ccw"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>',
                    },
                    {
                        selector: 'img[src*="valores.gif"]',
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
                    },
                    {
                        selector: 'img[src*="minuta_historico.gif"]',
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
                    },
                    {
                        selector: 'img[src*="novo.gif"]',
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-plus-2"><path d="M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M3 15h6"/><path d="M6 12v6"/></svg>',
                    },
                    {
                        selector: 'img[src*="minuta_alterar.gif"]',
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-pen-line-icon lucide-file-pen-line"><path d="m18 5-2.414-2.414A2 2 0 0 0 14.172 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2"/><path d="M21.378 12.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/><path d="M8 18h1"/></svg>',
                    },
                    {
                        selector: 'img[src*="minuta_assinar2.gif"]',
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" height="18px" viewBox="0 -960 960 960" width="18px" fill="currentColor"><path d="m495.35-537.67 41.08 41.32 199-199-41.08-41.08-199 198.76ZM205.8-206.57h39.09l217.76-217-40.32-40.32L205.8-246.13v39.56Zm366.63-181.76L387.57-572.67l122.95-123.96-50.24-48.72-206.8 206.81-71.63-71.39 214.98-212.98q26.63-26.63 65.45-26.63 38.83 0 65.7 26.63l54.41 54.41L655-839.35q17.43-17.43 40.85-17.43 23.41 0 40.85 17.43L838.35-737.7q17.19 17.44 16.69 41.35-.5 23.92-16.69 42.35L572.43-388.33Zm-283.1 283.11H104.22v-183.35l283.35-284.1 184.86 184.34-283.1 283.11Z"/></svg>',
                    },
                    {
                        selector: 'img[src*="alterar.gif"]',
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#f97316" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14,2 14,8 20,8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10,9 9,9 8,9"/></svg>',
                    },
                    {
                        selector: 'img[src*="balao.gif"]',
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="#FEF3C7" stroke="#D97706" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="eprobe-svg-icon eprobe-svg-bubble" style="pointer-events: none;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>',
                    },
                    {
                        selector: 'img[src*="linkeditor.png"]',
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#D1D5DB" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>',
                    },
                    {
                        selector: 'img[src*="html.gif"]',
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14,2 14,8 20,8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10,9 9,9 8,9"/></svg>',
                    },
                    {
                        selector: 'img[src*="tooltip.gif"]',
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sticky-note-icon lucide-sticky-note"><path d="M16 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8Z"/><path d="M15 3v4a2 2 0 0 0 2 2h4"/></svg>',
                    },
                    {
                        selector: 'img[src*="duvida.png"]',
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-question-mark-icon lucide-circle-question-mark"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>',
                    },
                    /*             {
                selector: 'img[src*="ver_resumo.gif"]',
                newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-square-minus-icon lucide-square-minus"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M8 12h8"/></svg>',
            },
            {
                selector: 'img[src*="ver_tudo.gif"]',
                newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-square-plus-icon lucide-square-plus"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M8 12h8"/><path d="M12 8v8"/></svg>',
            }, */
                    {
                        selector: 'img[src*="lupa.gif"]',
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search-icon lucide-search"><path d="m21 21-4.34-4.34"/><circle cx="11" cy="11" r="8"/></svg>',
                    },
                    // DESABILITADO: Substituições de estrelas para preservar funcionalidade do eProc
                    /*
                    {
                        selector: 'img[src*="EstrelaAcesa.gif"]',
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#e0bb00" stroke="#e0bb00" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star-icon lucide-star"><path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"/></svg>',
                    },
                    {
                        selector: 'img[src*="EstrelaApagada.gif"]',
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star-icon lucide-star"><path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"/></svg>',
                    },
                    */
                    {
                        selector: 'img[src*="oral_video.png"]',
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-video-icon lucide-video"><path d="m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5"/><rect x="2" y="6" width="14" height="12" rx="2"/></svg>',
                    },
                    {
                        selector: 'img[src*="menos.gif"]',
                        newSvg: ICON_REPLACEMENTS_BY_TEXT[
                            "Permissão/Negação Expressa"
                        ].newSvg,
                    },
                ];

                imgsBySrc.forEach(({ selector, newSvg }) => {
                    // 🚨 PROTEÇÃO CRÍTICA: NUNCA substituir ícones de estrela
                    if (
                        selector &&
                        (selector.includes("Estrela") ||
                            selector.includes("star"))
                    ) {
                        console.log(
                            "🛡️ PROTEÇÃO: Bloqueando substituição de estrela:",
                            selector
                        );
                        return; // Pular esta substituição
                    }

                    const img = fieldset.querySelector(selector);
                    if (img) {
                        // 🚨 VERIFICAÇÃO ADICIONAL: Verificar se é ícone de estrela
                        if (
                            (img.src &&
                                (img.src.includes("Estrela") ||
                                    img.src.includes("star"))) ||
                            (img.alt &&
                                (img.alt.includes("Evento relevante") ||
                                    img.alt.includes("relevante")))
                        ) {
                            console.log(
                                "🛡️ PROTEÇÃO: Bloqueando substituição de elemento estrela encontrado"
                            );
                            return; // Pular esta substituição
                        }

                        const container = document.createElement("span");
                        container.innerHTML = newSvg;

                        // 🎨 APLICAR ESTILOS PADRONIZADOS
                        applyStandardIconStyles(container);

                        const svg = container.firstElementChild;
                        if (svg) {
                            svg.classList.add("iconeAcao");
                            svg.style.width = "18px";
                            svg.style.height = "18px";
                        }

                        // Funcionalidade especial para ícones mais.gif e menos.gif
                        if (
                            selector.includes("mais.gif") ||
                            selector.includes("menos.gif")
                        ) {
                            // Verificar se o elemento é seguro para processar
                            if (isElementSafeForToggle(img)) {
                                log(
                                    `🔄 ALTERNÂNCIA: Detectado ícone expansível válido: ${selector}`
                                );
                                implementarAlternanciaExpandirRetrair(
                                    img,
                                    container,
                                    selector
                                );
                            } else {
                                log(
                                    `⚠️ ALTERNÂNCIA: Ignorando ícone inseguro: ${selector}`
                                );
                            }
                        }

                        img.parentNode.replaceChild(container, img);
                        substituicoesRealizadas++;
                        log(`✅ ÍCONES: Substituído ícone ${selector}`);
                    }
                });

                // Estratégia específica para "Incluir em Pauta/Mesa"
                const linksPauta = fieldset.querySelectorAll("a.infraButton");
                linksPauta.forEach((link) => {
                    if (
                        link.textContent
                            .trim()
                            .endsWith("Incluir em Pauta/Mesa")
                    ) {
                        // Verificar se já foi processado
                        if (link.classList.contains("icon-processed")) {
                            return;
                        }

                        const img = link.querySelector("img");

                        if (
                            img &&
                            !img.classList.contains("substituted-icon")
                        ) {
                            // Caso 1: Link tem imagem - substituir a imagem
                            const container = document.createElement("span");
                            container.innerHTML =
                                ICON_REPLACEMENTS_BY_TEXT[
                                    "Incluir em Pauta/Mesa"
                                ].newSvg;
                            container.style.display = "inline-flex";
                            container.style.alignItems = "center";
                            container.style.marginRight = "4px";

                            const svg = container.firstElementChild;
                            if (svg) {
                                svg.classList.add(
                                    "iconeAcao",
                                    "substituted-icon"
                                );
                                svg.style.width = "18px";
                                svg.style.height = "18px";
                            }

                            img.parentNode.replaceChild(container, img);
                            link.classList.add("icon-processed");
                            substituicoesRealizadas++;
                            log(
                                `✅ ÍCONES: Substituído ícone "Incluir em Pauta/Mesa" (com imagem)`
                            );
                        } else if (!img) {
                            // Caso 2: Link apenas texto - adicionar ícone no início
                            const container = document.createElement("span");
                            container.innerHTML =
                                ICON_REPLACEMENTS_BY_TEXT[
                                    "Incluir em Pauta/Mesa"
                                ].newSvg;
                            container.style.display = "inline-flex";
                            container.style.alignItems = "center";
                            container.style.marginRight = "6px";

                            const svg = container.firstElementChild;
                            if (svg) {
                                svg.classList.add(
                                    "iconeAcao",
                                    "substituted-icon"
                                );
                                svg.style.width = "18px";
                                svg.style.height = "18px";
                                svg.style.verticalAlign = "middle";
                            }

                            // Inserir o ícone no início do link
                            link.insertBefore(container, link.firstChild);
                            link.style.display = "inline-flex";
                            link.style.alignItems = "center";
                            link.classList.add("icon-processed");
                            substituicoesRealizadas++;
                            log(
                                `✅ ÍCONES: Adicionado ícone "Incluir em Pauta/Mesa" (link texto)`
                            );
                        }
                    }
                });

                log(
                    `🎨 ÍCONES: Concluída substituição - ${substituicoesRealizadas} ícones substituídos`
                );
                return substituicoesRealizadas > 0;
            }

            // Função adicional para substituição global de ícones específicos
            function substituirIconesGlobalmente() {
                const currentUrl = window.location.href;

                // ⛔ RESTRIÇÃO: Só personalizar ícones na página de capa do processo
                if (!isCapaProcessoPage()) {
                    log(
                        "⛔ ÍCONES: Personalização de ícones globais restrita apenas à página de capa do processo - URL atual não permitida"
                    );
                    log("📍 URL atual:", currentUrl);
                    return false;
                }

                // ⛔ EXCEÇÃO: Não substituir ícones em páginas de cadastro de minutas
                if (currentUrl.includes("minuta_cadastrar")) {
                    log(
                        "⛔ ÍCONES: Página de cadastro de minutas detectada - ignorando substituições globais"
                    );
                    return false;
                }

                log(
                    "🎨 ÍCONES: Iniciando substituição global de ícones específicos"
                );

                let substituicoesRealizadas = 0;

                // Mapeamento global para ícones específicos que podem aparecer em qualquer lugar
                const iconesGlobais = [
                    {
                        // Ícones de configuração
                        selectors: [
                            'img[src*="configuracao.gif"]',
                            'img[title*="Ações Preferenciais"]',
                            'img[alt*="Ações Preferenciais"]',
                        ],
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#9CA3AF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>',
                        name: "Configuração",
                    },
                    {
                        // Ícones de refresh
                        selectors: [
                            'img[src*="refresh.gif"]',
                            'img[id="refresh"]',
                            'img[title*="Atualizar"]',
                        ],
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-ccw-icon lucide-refresh-ccw"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>',
                        name: "Refresh",
                    },
                    {
                        // Ícones de histórico/lista
                        selectors: [
                            'img[src*="valores.gif"]',
                            'img[src*="minuta_historico.gif"]',
                            'img[alt*="Histórico"]',
                            'img[title*="Histórico"]',
                        ],
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
                        name: "Histórico",
                    },
                    {
                        // Ícones de nova minuta/documento
                        selectors: [
                            'img[src*="novo.gif"]',
                            'img[alt*="Nova Minuta"]',
                            'img[title*="Nova Minuta"]',
                        ],
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-plus-2"><path d="M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M3 15h6"/><path d="M6 12v6"/></svg>',
                        name: "Nova Minuta",
                    },
                    {
                        // Ícones de editar minuta
                        selectors: [
                            'img[src*="minuta_alterar.gif"]',
                            'img[title*="Alterar Julgamento"]',
                            'img[alt*="Alterar Julgamento"]',
                        ],
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-pen-line-icon lucide-file-pen-line"><path d="m18 5-2.414-2.414A2 2 0 0 0 14.172 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2"/><path d="M21.378 12.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/><path d="M8 18h1"/></svg>',
                        name: "Editar Minuta",
                    },
                    {
                        // Ícones de assinar minuta
                        selectors: [
                            'img[src*="minuta_assinar2.gif"]',
                            'img[title*="Assinar Minuta"]',
                            'img[alt*="Assinar Minuta"]',
                        ],
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" height="18px" viewBox="0 -960 960 960" width="18px" fill="currentColor"><path d="m495.35-537.67 41.08 41.32 199-199-41.08-41.08-199 198.76ZM205.8-206.57h39.09l217.76-217-40.32-40.32L205.8-246.13v39.56Zm366.63-181.76L387.57-572.67l122.95-123.96-50.24-48.72-206.8 206.81-71.63-71.39 214.98-212.98q26.63-26.63 65.45-26.63 38.83 0 65.7 26.63l54.41 54.41L655-839.35q17.43-17.43 40.85-17.43 23.41 0 40.85 17.43L838.35-737.7q17.19 17.44 16.69 41.35-.5 23.92-16.69 42.35L572.43-388.33Zm-283.1 283.11H104.22v-183.35l283.35-284.1 184.86 184.34-283.1 283.11Z"/></svg>',
                        name: "Assinar Minuta",
                    },
                    {
                        // Ícones de editar genérico
                        selectors: [
                            'img[src*="alterar.gif"]',
                            'img[title*="Alterar"]',
                            'img[alt*="Alterar"]',
                        ],
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#f97316" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14,2 14,8 20,8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10,9 9,9 8,9"/></svg>',
                        name: "Editar",
                    },
                    {
                        // Ícones de balão/memo
                        selectors: [
                            'img[src*="balao.gif"]',
                            'img[alt*="Incluir Memo"]',
                            'img[title*="Memo"]',
                        ],
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="#FEF3C7" stroke="#D97706" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>',
                        name: "Memo Balão",
                    },
                    {
                        // Ícones de link
                        selectors: [
                            'img[src*="linkeditor.png"]',
                            'img[alt*="Link"]',
                            'img[title*="Link"]',
                        ],
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#D1D5DB" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>',
                        name: "Link",
                    },
                    {
                        // Ícones de visualizar documento HTML
                        selectors: [
                            'img[src*="html.gif"]',
                            'img[title*="Visualizar Documento"]',
                            'img[alt*="Visualizar"]',
                        ],
                        newSvg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14,2 14,8 20,8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10,9 9,9 8,9"/></svg>',
                        name: "Visualizar HTML",
                    },
                    {
                        // Ícones de PDF
                        selectors: [
                            'img[src*="pdf.gif"]',
                            'img[title*="PDF"]',
                            'img[alt*="PDF"]',
                        ],
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" height="18px" viewBox="0 -960 960 960" width="18px" fill="currentColor"><path d="M360-460h40v-80h40q17 0 28.5-11.5T480-580v-40q0-17-11.5-28.5T440-660h-80v200Zm40-120v-40h40v40h-40Zm120 120h80q17 0 28.5-11.5T640-500v-120q0-17-11.5-28.5T600-660h-80v200Zm40-40v-120h40v120h-40Zm120 40h40v-80h40v-40h-40v-40h40v-40h-80v200ZM320-240q-33 0-56.5-23.5T240-320v-480q0-33 23.5-56.5T320-880h480q33 0 56.5 23.5T880-800v480q0 33-23.5 56.5T800-240H320Zm0-80h480v-480H320v480ZM160-80q-33 0-56.5-23.5T80-160v-560h80v560h560v80H160Zm160-720v480-480Z"/></svg>',
                        name: "PDF",
                    },
                    {
                        // Ícones de tooltip/memo
                        selectors: [
                            'img[src*="tooltip.gif"]',
                            'img[alt*="Incluir Memo"]',
                            'img[title*="Tooltip"]',
                        ],
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sticky-note-icon lucide-sticky-note"><path d="M16 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8Z"/><path d="M15 3v4a2 2 0 0 0 2 2h4"/></svg>',
                        name: "Memo Tooltip",
                    },
                    {
                        // Ícones de ajuda/interrogação
                        selectors: [
                            'img[src*="duvida.png"]',
                            'img[alt*="Ajuda"]',
                            'img[title*="Ajuda"]',
                        ],
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-question-mark-icon lucide-circle-question-mark"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>',
                        name: "Ajuda",
                    },
                    /*             {
                // Ícones de ocultar/resumo
                selectors: [
                    'img[src*="ver_resumo.gif"]',
                    'img[title*="Ocultar"]',
                    'img[alt*="Resumo"]',
                ],
                newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-square-minus-icon lucide-square-minus"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M8 12h8"/></svg>',
                name: "Ocultar",
            },
            {
                // Ícones de mostrar/ver tudo
                selectors: [
                    'img[src*="ver_tudo.gif"]',
                    'img[title*="Mostrar"]',
                    'img[alt*="Ver Tudo"]',
                ],
                newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-square-plus-icon lucide-square-plus"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M8 12h8"/><path d="M12 8v8"/></svg>',
                name: "Mostrar",
            }, */
                    {
                        // Ícones de lupa/busca
                        selectors: [
                            'img[src*="lupa.gif"]',
                            'img[alt*="Informações do Evento"]',
                            'img[title*="Buscar"]',
                        ],
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search-icon lucide-search"><path d="m21 21-4.34-4.34"/><circle cx="11" cy="11" r="8"/></svg>',
                        name: "Lupa",
                    },
                    // DESABILITADO: Ícones de estrela para preservar funcionalidade do eProc
                    /*
                    {
                        // Ícones de estrela acesa (preenchida)
                        selectors: [
                            'img[src*="EstrelaAcesa.gif"]',
                            'img[alt*="Evento relevante"]',
                            'img[title*="Relevante"]',
                        ],
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#e0bb00" stroke="#e0bb00" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star-icon lucide-star"><path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"/></svg>',
                        name: "Estrela Acesa",
                    },
                    {
                        // Ícones de estrela apagada (só contorno)
                        selectors: [
                            'img[src*="EstrelaApagada.gif"]',
                            'img[src*="estrela_apagada.gif"]',
                            'img[alt*="Evento normal"]',
                        ],
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star-icon lucide-star"><path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"/></svg>',
                        name: "Estrela Apagada",
                    },
                    */ // FIM DAS SUBSTITUIÇÕES DE ESTRELA DESABILITADAS
                    {
                        // Ícones de vídeo/televisão
                        selectors: [
                            'img[src*="oral_video.png"]',
                            'img[alt*="Vídeo"]',
                            'img[title*="Vídeo"]',
                        ],
                        newSvg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-video-icon lucide-video"><path d="m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5"/><rect x="2" y="6" width="14" height="12" rx="2"/></svg>',
                        name: "Vídeo",
                    },
                ];

                iconesGlobais.forEach((icone) => {
                    icone.selectors.forEach((selector) => {
                        const elementos = document.querySelectorAll(selector);

                        elementos.forEach((img) => {
                            // Verificar se já foi substituído
                            if (
                                img.hasAttribute("data-eprobe-icon-replaced") ||
                                img.classList.contains("substituted-icon")
                            ) {
                                return;
                            }

                            // 🚨 PROTEÇÃO CRÍTICA: NÃO substituir ícones de estrela que são interativos
                            // Verifica se é um ícone de estrela e se tem funcionalidade de clique
                            const isEstrelaIcon =
                                selector.includes("Estrela") ||
                                img.src.includes("EstrelaAcesa") ||
                                img.src.includes("EstrelaApagada") ||
                                img.alt.includes("Evento relevante") ||
                                img.alt.includes("Evento normal");

                            if (isEstrelaIcon) {
                                // Verificar se tem onclick ou está em link com javascript
                                const hasOnclick =
                                    img.onclick || img.hasAttribute("onclick");
                                const parentLink = img.closest(
                                    "a[href*='javascript:'], a[onclick]"
                                );

                                if (hasOnclick || parentLink) {
                                    console.log(
                                        "🛡️ PROTEÇÃO: Ícone de estrela interativo preservado:",
                                        {
                                            src: img.src,
                                            hasOnclick: !!hasOnclick,
                                            parentLink: !!parentLink,
                                            linkHref: parentLink?.href || "N/A",
                                        }
                                    );

                                    // Apenas adicionar visual feedback que está sendo protegido
                                    img.style.filter =
                                        "drop-shadow(0 0 2px rgba(224, 187, 0, 0.3))";
                                    img.setAttribute(
                                        "data-eprobe-protected",
                                        "true"
                                    );
                                    img.setAttribute(
                                        "title",
                                        (img.title || img.alt) +
                                            " (Protegido pelo eProbe)"
                                    );
                                    return; // NÃO substituir
                                }
                            }

                            try {
                                // Preservar todas as propriedades originais
                                const originalWidth =
                                    img.style.width ||
                                    img.getAttribute("width") ||
                                    getComputedStyle(img).width ||
                                    "1.1em";
                                const originalHeight =
                                    img.style.height ||
                                    img.getAttribute("height") ||
                                    getComputedStyle(img).height ||
                                    "1.1em";
                                const originalOpacity =
                                    img.style.opacity || "1";
                                const originalBorderWidth =
                                    img.style.borderWidth || "0";
                                const originalPaddingRight =
                                    img.style.paddingRight || "";

                                // Criar container SVG
                                const container =
                                    document.createElement("span");
                                container.innerHTML = icone.newSvg;

                                // 🎨 APLICAR ESTILOS PADRONIZADOS
                                applyStandardIconStyles(container);

                                const svg = container.firstElementChild;
                                if (svg) {
                                    // Aplicar todas as propriedades preservadas
                                    svg.style.width = originalWidth;
                                    svg.style.height = originalHeight;
                                    svg.style.opacity = originalOpacity;
                                    svg.style.borderWidth = originalBorderWidth;
                                    if (originalPaddingRight) {
                                        svg.style.paddingRight =
                                            originalPaddingRight;
                                    }

                                    // Preservar classes CSS - CORRIGIDO para SVG
                                    if (img.className) {
                                        // SVG usa setAttribute para classes, não className
                                        svg.setAttribute(
                                            "class",
                                            img.className + " substituted-icon"
                                        );
                                    } else {
                                        svg.classList.add("substituted-icon");
                                    }

                                    // Preservar atributos importantes
                                    [
                                        "title",
                                        "alt",
                                        "aria-hidden",
                                        "role",
                                        "id",
                                    ].forEach((attr) => {
                                        const value = img.getAttribute(attr);
                                        if (value) {
                                            svg.setAttribute(attr, value);
                                        }
                                    });

                                    // Adicionar atributos de controle
                                    svg.setAttribute(
                                        "data-eprobe-icon-replaced",
                                        "true"
                                    );
                                    svg.setAttribute(
                                        "data-original-name",
                                        icone.name
                                    );
                                    svg.setAttribute(
                                        "data-original-selector",
                                        selector
                                    );

                                    // 📏 DIMENSIONAMENTO ESPECÍFICO: Verificar se está em divListaRecursosMinuta
                                    aplicarDimensionamentoRecursosMinuta(svg);

                                    // Preservar eventos
                                    if (img.onclick) {
                                        svg.onclick = img.onclick;
                                    }

                                    // Realizar substituição
                                    img.parentNode.replaceChild(container, img);
                                    substituicoesRealizadas++;
                                    log(
                                        `✅ ÍCONES GLOBAL: Substituído ${icone.name} via "${selector}"`
                                    );
                                }
                            } catch (error) {
                                console.warn(
                                    `⚠️ ÍCONES GLOBAL: Erro ao substituir ${icone.name}:`,
                                    error
                                );
                            }
                        });
                    });
                });

                // ========================================
                // 🎨 SUBSTITUIÇÃO ESPECÍFICA PARA ÍCONES DE LEMBRETES
                // ========================================

                // Substituir ícones Material Icons para Material Symbols nos lembretes
                // 1. Ícone de editar: "edit" → "ink_pen"
                const iconesEditarLembrete = document.querySelectorAll(
                    'a[aria-label="Alterar Lembrete"] span.material-icons'
                );

                iconesEditarLembrete.forEach((icone) => {
                    if (icone.textContent === "edit") {
                        // Verificar se já foi substituído
                        if (icone.hasAttribute("data-eprobe-icon-replaced")) {
                            return;
                        }

                        // Criar novo SVG Material Symbol "ink_pen"
                        const svgContainer = document.createElement("span");
                        svgContainer.innerHTML =
                            '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#545454"><path d="m478.61-517.54 41.62 41.62L736.31-692l-41.62-41.62-216.08 216.08ZM218.69-216h41.62l223.77-223.77-41.62-41.62-223.77 223.77V-216Zm320.62-204.69L423.77-536.61l148.31-148.31-43.69-43.69q-3.08-3.08-9.23-3.08-6.16 0-9.24 3.08L320.85-539.54l-37.15-36.38 191.23-189.85q18.69-18.69 45.3-18.69 26.62 0 45.31 18.69l43.69 43.69 54.54-54.53q12.85-12.85 31.11-12.85 18.27 0 31.12 12.85l54.84 54.84q12.85 12.85 11.97 29.85-.89 17-12.73 30.84L539.31-420.69ZM282.23-164H166.69v-115.54l256.7-257.07 115.92 115.92L282.23-164Z"/></svg>';

                        const svg = svgContainer.firstElementChild;

                        // Preservar classes e atributos do ícone original
                        svg.classList.add("material-icons"); // Manter compatibilidade
                        svg.setAttribute("data-eprobe-icon-replaced", "true");
                        svg.setAttribute("data-original-icon", "edit");
                        svg.setAttribute("data-new-icon", "ink_pen");

                        // Substituir o ícone
                        icone.parentNode.replaceChild(svg, icone);
                        substituicoesRealizadas++;
                        log(
                            "✅ LEMBRETES: Ícone 'edit' substituído por Material Symbol 'ink_pen'"
                        );
                    }
                });

                // 2. Ícone de excluir: "delete" → "delete" (mesmo nome, mas Material Symbol)
                const iconesExcluirLembrete = document.querySelectorAll(
                    'a[aria-label="Desativar Lembrete"] span.material-icons'
                );

                iconesExcluirLembrete.forEach((icone) => {
                    if (icone.textContent === "delete") {
                        // Verificar se já foi substituído
                        if (icone.hasAttribute("data-eprobe-icon-replaced")) {
                            return;
                        }

                        // Criar novo SVG Material Symbol "delete"
                        const svgContainer = document.createElement("span");
                        svgContainer.innerHTML =
                            '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#545454"><path d="M324.31-164q-26.62 0-45.47-18.84Q260-201.69 260-228.31V-696h-48v-52h172v-43.38h192V-748h172v52h-48v467.26q0 27.74-18.65 46.24Q662.7-164 635.69-164H324.31ZM648-696H312v467.69q0 5.39 3.46 8.85t8.85 3.46h311.38q4.62 0 8.46-3.85 3.85-3.84 3.85-8.46V-696ZM400.16-288h51.99v-336h-51.99v336Zm107.69 0h51.99v-336h-51.99v336ZM312-696v480-480Z"/></svg>';

                        const svg = svgContainer.firstElementChild;

                        // Preservar classes e atributos do ícone original
                        svg.classList.add("material-icons"); // Manter compatibilidade
                        svg.setAttribute("data-eprobe-icon-replaced", "true");

                        // ⚡ SISTEMA ANTI-FLASH: Revelar ícone personalizado
                        if (window.eprobeAntiFlash) {
                            window.eprobeAntiFlash.revelarIcone(svg);
                        }

                        svg.setAttribute("data-original-icon", "delete");
                        svg.setAttribute(
                            "data-new-icon",
                            "delete_material_symbol"
                        );

                        // Preservar atributos importantes do ícone original
                        if (icone.title) svg.setAttribute("title", icone.title);
                        if (icone.getAttribute("alt"))
                            svg.setAttribute("alt", icone.getAttribute("alt"));
                        if (icone.getAttribute("aria-hidden"))
                            svg.setAttribute(
                                "aria-hidden",
                                icone.getAttribute("aria-hidden")
                            );

                        // Substituir o ícone
                        icone.parentNode.replaceChild(svg, icone);
                        substituicoesRealizadas++;
                        log(
                            "✅ LEMBRETES: Ícone 'delete' substituído por Material Symbol 'delete'"
                        );
                    }
                });

                log(
                    `🎨 ÍCONES GLOBAL: ${substituicoesRealizadas} ícones substituídos globalmente`
                );
                return substituicoesRealizadas > 0;
            }

            // Função de teste para debug de ícones
            function debugIconesSubstituicao() {
                log("🔍 DEBUG ÍCONES: Analisando página atual...");

                const iconesTeste = [
                    'img[src*="configuracao.gif"]',
                    'img[src*="refresh.gif"]',
                    'img[src*="valores.gif"]',
                    'img[src*="minuta_historico.gif"]',
                    'img[src*="novo.gif"]',
                    'img[src*="minuta_alterar.gif"]',
                    'img[src*="minuta_assinar2.gif"]',
                    'img[src*="alterar.gif"]',
                    'img[src*="balao.gif"]',
                    'img[src*="linkeditor.png"]',
                    'img[src*="html.gif"]',
                    'img[src*="pdf.gif"]',
                    'img[src*="tooltip.gif"]',
                    'img[src*="duvida.png"]',
                    'img[src*="ver_resumo.gif"]',
                    'img[src*="ver_tudo.gif"]',
                    'img[src*="lupa.gif"]',
                    'img[src*="EstrelaAcesa.gif"]',
                    'img[src*="EstrelaApagada.gif"]',
                    'img[src*="oral_video.png"]',
                    'img[title*="Ações Preferenciais"]',
                    'img[title*="Atualizar"]',
                    'img[title*="Alterar Julgamento"]',
                    'img[title*="Visualizar Documento"]',
                    'img[title*="Ajuda"]',
                    'img[title*="Ocultar"]',
                    'img[title*="Mostrar"]',
                    'img[title*="Buscar"]',
                    'img[title*="Relevante"]',
                    'img[title*="Vídeo"]',
                    'img[alt*="Nova Minuta"]',
                    'img[alt*="Incluir Memo"]',
                    'img[alt*="Visualizar"]',
                    'img[alt*="Ajuda"]',
                    'img[alt*="Resumo"]',
                    'img[alt*="Ver Tudo"]',
                    'img[alt*="Informações do Evento"]',
                    'img[alt*="Evento relevante"]',
                    'img[alt*="Evento normal"]',
                    'img[alt*="Vídeo"]',
                    'img[id="refresh"]',
                ];

                log("📊 ESTATÍSTICAS DE ÍCONES:");
                iconesTeste.forEach((selector) => {
                    const elementos = document.querySelectorAll(selector);
                    const substituidos = document.querySelectorAll(
                        selector.replace("img", "[data-eprobe-icon-replaced]")
                    );

                    log(
                        `${selector}: ${elementos.length} encontrados, ${substituidos.length} já substituídos`
                    );

                    if (elementos.length > 0) {
                        elementos.forEach((img, i) => {
                            log(`  - Item ${i + 1}:`, {
                                src: img.src,
                                alt: img.alt,
                                title: img.title,
                                id: img.id,
                                className: img.className,
                                substituido: img.hasAttribute(
                                    "data-eprobe-icon-replaced"
                                ),
                            });
                        });
                    }
                });

                // Executar todas as funções de substituição
                log("🔄 EXECUTANDO SUBSTITUIÇÕES...");
                try {
                    const resultados = {
                        fieldset: substituirIconesFieldsetAcoes(),
                        ferramentas: substituirIconesFerramentas(),
                        global: substituirIconesGlobalmente(),
                    };

                    log("✅ RESULTADOS:", resultados);

                    // Estatísticas finais
                    const totalSubstituidos = document.querySelectorAll(
                        "[data-eprobe-icon-replaced]"
                    ).length;
                    log(
                        `🎯 TOTAL DE ÍCONES SUBSTITUÍDOS: ${totalSubstituidos}`
                    );

                    return resultados;
                } catch (error) {
                    console.error("❌ ERRO NO DEBUG:", error);
                    return { erro: error.message };
                }
            }

            /**
             * 🎨 FUNÇÃO ESPECÍFICA PARA SUBSTITUIÇÃO DE ÍCONES DOS LEMBRETES
             * Substitui Material Icons por Material Symbols nos botões de editar e excluir lembretes
             * PRESERVA 100% das funcionalidades originais
             */
            function substituirIconesLembretes() {
                // ⚡ ANTI-FLASH: Aplicar CSS crítico ANTES de qualquer processamento
                aplicarAntiFlashIcones();

                // ⛔ RESTRIÇÃO: Só personalizar ícones na página de capa do processo
                if (!isCapaProcessoPage()) {
                    log(
                        "⛔ ÍCONES: Personalização de ícones de lembretes restrita apenas à página de capa do processo - URL atual não permitida"
                    );
                    log("📍 URL atual:", window.location.href);
                    return 0;
                }

                log(
                    "🎨 LEMBRETES: Iniciando substituição específica de ícones dos lembretes..."
                );

                let substituicoesRealizadas = 0;

                try {
                    // 1. Substituir ícone de EDITAR LEMBRETE: "edit" → "ink_pen"
                    const iconesEditarLembrete = document.querySelectorAll(
                        'a[aria-label="Alterar Lembrete"] span.material-icons, a[href*="processo_lembrete_destino_alterar"] span.material-icons'
                    );

                    iconesEditarLembrete.forEach((icone) => {
                        if (
                            icone.textContent.trim() === "edit" &&
                            !icone.hasAttribute("data-eprobe-icon-replaced")
                        ) {
                            try {
                                // Criar novo SVG Material Symbol "ink_pen"
                                const svgContainer =
                                    document.createElement("span");
                                svgContainer.innerHTML =
                                    '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#545454"><path d="m478.61-517.54 41.62 41.62L736.31-692l-41.62-41.62-216.08 216.08ZM218.69-216h41.62l223.77-223.77-41.62-41.62-223.77 223.77V-216Zm320.62-204.69L423.77-536.61l148.31-148.31-43.69-43.69q-3.08-3.08-9.23-3.08-6.16 0-9.24 3.08L320.85-539.54l-37.15-36.38 191.23-189.85q18.69-18.69 45.3-18.69 26.62 0 45.31 18.69l43.69 43.69 54.54-54.53q12.85-12.85 31.11-12.85 18.27 0 31.12 12.85l54.84 54.84q12.85 12.85 11.97 29.85-.89 17-12.73 30.84L539.31-420.69ZM282.23-164H166.69v-115.54l256.7-257.07 115.92 115.92L282.23-164Z"/></svg>';

                                const svg = svgContainer.firstElementChild;

                                // Preservar TODAS as classes e atributos do ícone original
                                if (icone.className) {
                                    svg.setAttribute(
                                        "class",
                                        icone.className +
                                            " eprobe-substituted-icon"
                                    );
                                } else {
                                    svg.classList.add(
                                        "material-icons",
                                        "eprobe-substituted-icon"
                                    );
                                }

                                // Marcar como substituído
                                svg.setAttribute(
                                    "data-eprobe-icon-replaced",
                                    "true"
                                );

                                // ⚡ SISTEMA ANTI-FLASH: Revelar ícone personalizado
                                if (window.eprobeAntiFlash) {
                                    window.eprobeAntiFlash.revelarIcone(svg);
                                }

                                svg.setAttribute("data-original-icon", "edit");
                                svg.setAttribute("data-new-icon", "ink_pen");
                                svg.setAttribute(
                                    "data-icon-type",
                                    "lembrete-editar"
                                );

                                // 📏 DIMENSIONAMENTO ESPECÍFICO: Verificar se está em divListaRecursosMinuta
                                aplicarDimensionamentoRecursosMinuta(svg);

                                // Substituir o ícone mantendo o link funcional
                                icone.parentNode.replaceChild(svg, icone);
                                substituicoesRealizadas++;
                                log(
                                    "✅ LEMBRETES: Ícone 'edit' substituído por Material Symbol 'ink_pen'"
                                );
                            } catch (error) {
                                console.warn(
                                    "⚠️ LEMBRETES: Erro ao substituir ícone de editar:",
                                    error
                                );
                            }
                        }
                    });

                    // 2. Substituir ícone de EXCLUIR LEMBRETE: "delete" → "delete" (Material Symbol)
                    const iconesExcluirLembrete = document.querySelectorAll(
                        'a[aria-label="Desativar Lembrete"] span.material-icons, a[onclick*="desativarLembrete"] span.material-icons'
                    );

                    iconesExcluirLembrete.forEach((icone) => {
                        if (
                            icone.textContent.trim() === "delete" &&
                            !icone.hasAttribute("data-eprobe-icon-replaced")
                        ) {
                            try {
                                // Criar novo SVG Material Symbol "delete"
                                const svgContainer =
                                    document.createElement("span");
                                svgContainer.innerHTML =
                                    '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#545454"><path d="M324.31-164q-26.62 0-45.47-18.84Q260-201.69 260-228.31V-696h-48v-52h172v-43.38h192V-748h172v52h-48v467.26q0 27.74-18.65 46.24Q662.7-164 635.69-164H324.31ZM648-696H312v467.69q0 5.39 3.46 8.85t8.85 3.46h311.38q4.62 0 8.46-3.85 3.85-3.84 3.85-8.46V-696ZM400.16-288h51.99v-336h-51.99v336Zm107.69 0h51.99v-336h-51.99v336ZM312-696v480-480Z"/></svg>';

                                const svg = svgContainer.firstElementChild;

                                // Preservar TODAS as classes e atributos do ícone original
                                if (icone.className) {
                                    svg.setAttribute(
                                        "class",
                                        icone.className +
                                            " eprobe-substituted-icon"
                                    );
                                } else {
                                    svg.classList.add(
                                        "material-icons",
                                        "eprobe-substituted-icon"
                                    );
                                }

                                // Preservar atributos importantes
                                if (icone.title)
                                    svg.setAttribute("title", icone.title);
                                if (icone.getAttribute("alt"))
                                    svg.setAttribute(
                                        "alt",
                                        icone.getAttribute("alt")
                                    );
                                if (icone.getAttribute("aria-hidden"))
                                    svg.setAttribute(
                                        "aria-hidden",
                                        icone.getAttribute("aria-hidden")
                                    );

                                // Marcar como substituído
                                svg.setAttribute(
                                    "data-eprobe-icon-replaced",
                                    "true"
                                );
                                svg.setAttribute(
                                    "data-original-icon",
                                    "delete"
                                );
                                svg.setAttribute(
                                    "data-new-icon",
                                    "delete_material_symbol"
                                );
                                svg.setAttribute(
                                    "data-icon-type",
                                    "lembrete-excluir"
                                );

                                // 📏 DIMENSIONAMENTO ESPECÍFICO: Verificar se está em divListaRecursosMinuta
                                aplicarDimensionamentoRecursosMinuta(svg);

                                // Substituir o ícone mantendo o link funcional
                                icone.parentNode.replaceChild(svg, icone);
                                substituicoesRealizadas++;
                                log(
                                    "✅ LEMBRETES: Ícone 'delete' substituído por Material Symbol 'delete'"
                                );
                            } catch (error) {
                                console.warn(
                                    "⚠️ LEMBRETES: Erro ao substituir ícone de excluir:",
                                    error
                                );
                            }
                        }
                    });

                    // 3. MARCAR TODOS OS LEMBRETES COMO PROCESSADOS PARA ELIMINAR FLASH
                    const lembretes = document.querySelectorAll(
                        ".lista-lembretes .lembrete"
                    );
                    lembretes.forEach((lembrete) => {
                        if (
                            !lembrete.classList.contains(
                                "eprobe-lembrete-processado"
                            )
                        ) {
                            lembrete.classList.add(
                                "eprobe-lembrete-processado"
                            );
                            log(
                                "🎯 LEMBRETES: Lembrete marcado como processado"
                            );
                        }
                    });

                    log(
                        `🎨 LEMBRETES: ${substituicoesRealizadas} ícones de lembretes substituídos com sucesso`
                    );
                    return substituicoesRealizadas;
                } catch (error) {
                    console.error(
                        "❌ LEMBRETES: Erro geral na substituição de ícones:",
                        error
                    );
                    return 0;
                }
            }

            /**
             * 🧪 FUNÇÃO DE TESTE PARA ÍCONES DE LEMBRETES
             * Testa e debug específico para ícones de lembretes
             */
            function testarIconesLembretes() {
                log(
                    "🧪 TESTE LEMBRETES: Iniciando diagnóstico de ícones de lembretes..."
                );

                // Buscar todos os links de lembretes
                const linksEditarLembrete = document.querySelectorAll(
                    'a[aria-label="Alterar Lembrete"], a[href*="processo_lembrete_destino_alterar"]'
                );
                const linksExcluirLembrete = document.querySelectorAll(
                    'a[aria-label="Desativar Lembrete"], a[onclick*="desativarLembrete"]'
                );

                log(
                    `📊 TESTE LEMBRETES: Encontrados ${linksEditarLembrete.length} links de editar e ${linksExcluirLembrete.length} links de excluir`
                );

                // Analisar ícones de editar
                linksEditarLembrete.forEach((link, index) => {
                    const icone = link.querySelector("span.material-icons");
                    log(`🔍 EDITAR ${index + 1}:`, {
                        link: link.outerHTML.substring(0, 100) + "...",
                        icone: icone ? icone.textContent : "sem ícone",
                        substituido: icone
                            ? icone.hasAttribute("data-eprobe-icon-replaced")
                            : false,
                    });
                });

                // Analisar ícones de excluir
                linksExcluirLembrete.forEach((link, index) => {
                    const icone = link.querySelector("span.material-icons");
                    log(`🗑️ EXCLUIR ${index + 1}:`, {
                        link: link.outerHTML.substring(0, 100) + "...",
                        icone: icone ? icone.textContent : "sem ícone",
                        substituido: icone
                            ? icone.hasAttribute("data-eprobe-icon-replaced")
                            : false,
                    });
                });

                // Executar substituição
                const resultado = substituirIconesLembretes();
                log(
                    `✅ TESTE LEMBRETES: Resultado da substituição: ${resultado} ícones substituídos`
                );

                return {
                    linksEditar: linksEditarLembrete.length,
                    linksExcluir: linksExcluirLembrete.length,
                    substituidos: resultado,
                };
            }

            // ===== SISTEMA DE THROTTLING ULTRA-OTIMIZADO PARA PERFORMANCE =====
            let ultimaSubstituicaoIcones = 0;
            let contadorSubstituicoes = 0;
            const THROTTLE_ICONES_MS = 10000; // ✅ 10 segundos mínimo entre execuções (otimizado)
            const MAX_SUBSTITUICOES_POR_MINUTO = 3; // ✅ Máximo 3 execuções por minuto (otimizado)
            let historicoSubstituicoes = [];
            let executandoSubstituicao = false; // Flag para evitar execuções simultâneas

            // Função para substituir ícones de ferramentas em toda a página
            function substituirIconesFerramentas() {
                const currentUrl = window.location.href;

                // ⛔ RESTRIÇÃO: Só personalizar ícones na página de capa do processo
                if (!isCapaProcessoPage()) {
                    log(
                        "⛔ ÍCONES: Personalização de ícones restrita apenas à página de capa do processo - URL atual não permitida"
                    );
                    log("📍 URL atual:", currentUrl);
                    return {
                        ignorado: true,
                        motivo: "url_nao_permitida",
                    };
                }

                // ⛔ EXCEÇÃO: Não substituir ícones em páginas de cadastro de minutas
                if (currentUrl.includes("minuta_cadastrar")) {
                    log(
                        "⛔ ÍCONES: Página de cadastro de minutas detectada - ignorando substituições"
                    );
                    return {
                        ignorado: true,
                        motivo: "pagina_minuta_cadastrar",
                    };
                }

                const agora = Date.now();

                // ===== CONTROLE DE THROTTLING ULTRA-RIGOROSO =====

                // 0. Verificar se já está executando
                if (executandoSubstituicao) {
                    log("⏸️ ÍCONES: Ignorando execução - já está em andamento");
                    return { ignorado: true, motivo: "em_andamento" };
                }

                // 1. Verificar intervalo mínimo
                if (agora - ultimaSubstituicaoIcones < THROTTLE_ICONES_MS) {
                    log(
                        "⏱️ ÍCONES: Ignorando execução - muito frequente (throttle)"
                    );
                    return { ignorado: true, motivo: "throttle_tempo" };
                }

                // 2. Limpar histórico antigo (mais de 1 minuto)
                historicoSubstituicoes = historicoSubstituicoes.filter(
                    (timestamp) => agora - timestamp < 60000
                );

                // 3. Verificar limite por minuto
                if (
                    historicoSubstituicoes.length >=
                    MAX_SUBSTITUICOES_POR_MINUTO
                ) {
                    log(
                        "⏱️ ÍCONES: Ignorando execução - limite por minuto atingido"
                    );
                    return { ignorado: true, motivo: "limite_minuto" };
                }

                // 4. Marcar como executando e registrar
                executandoSubstituicao = true;
                ultimaSubstituicaoIcones = agora;
                historicoSubstituicoes.push(agora);
                contadorSubstituicoes++;

                log(
                    `🎨 ÍCONES: Iniciando substituição otimizada #${contadorSubstituicoes} (${historicoSubstituicoes.length}/${MAX_SUBSTITUICOES_POR_MINUTO} este minuto)`
                );

                let substituicoesRealizadas = 0;
                let errosEncontrados = [];

                try {
                    // ===============================
                    // DEFINIÇÃO DOS ÍCONES DE FERRAMENTAS - VERSÃO EXPANDIDA
                    // ===============================
                    const ferramentasIcones = {
                        // Ícones de configuração/ferramentas (chave inglesa)
                        Configuracao: {
                            selectors: [
                                'img[src*="configuracao.gif"]',
                                'img[title*="Ações Preferenciais"]',
                                'img[alt*="Ações Preferenciais"]',
                            ],
                            newSvg: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#9CA3AF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>`,
                        },
                        // Ícones de refresh/atualização
                        Refresh: {
                            selectors: [
                                'img[src*="refresh.gif"]',
                                'img[id="refresh"]',
                                'img[title*="Atualizar"]',
                            ],
                            newSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-ccw-icon lucide-refresh-ccw"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>`,
                        },
                        // Ícones de lista/histórico (valores.gif)
                        Historico: {
                            selectors: [
                                'img[src*="valores.gif"]',
                                'img[src*="minuta_historico.gif"]',
                                'img[alt*="Histórico"]',
                                'img[title*="Histórico"]',
                            ],
                            newSvg: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>`,
                        },
                        // Ícones de nova minuta/novo documento
                        "Nova Minuta": {
                            selectors: [
                                'img[src*="novo.gif"]',
                                'img[alt*="Nova Minuta"]',
                                'img[title*="Nova Minuta"]',
                            ],
                            newSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-plus-2"><path d="M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M3 15h6"/><path d="M6 12v6"/></svg>`,
                        },
                        // Ícones de editar minuta
                        "Editar Minuta": {
                            selectors: [
                                'img[src*="minuta_alterar.gif"]',
                                'img[title*="Alterar Julgamento"]',
                                'img[alt*="Alterar Julgamento"]',
                            ],
                            newSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-file-pen-line-icon lucide-file-pen-line"><path d="m18 5-2.414-2.414A2 2 0 0 0 14.172 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2"/><path d="M21.378 12.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/><path d="M8 18h1"/></svg>`,
                        },
                        // Ícones de assinar minuta
                        "Assinar Minuta": {
                            selectors: [
                                'img[src*="minuta_assinar2.gif"]',
                                'img[title*="Assinar Minuta"]',
                                'img[alt*="Assinar Minuta"]',
                            ],
                            newSvg: `<svg xmlns="http://www.w3.org/2000/svg" height="18px" viewBox="0 -960 960 960" width="18px" fill="currentColor"><path d="m495.35-537.67 41.08 41.32 199-199-41.08-41.08-199 198.76ZM205.8-206.57h39.09l217.76-217-40.32-40.32L205.8-246.13v39.56Zm366.63-181.76L387.57-572.67l122.95-123.96-50.24-48.72-206.8 206.81-71.63-71.39 214.98-212.98q26.63-26.63 65.45-26.63 38.83 0 65.7 26.63l54.41 54.41L655-839.35q17.43-17.43 40.85-17.43 23.41 0 40.85 17.43L838.35-737.7q17.19 17.44 16.69 41.35-.5 23.92-16.69 42.35L572.43-388.33Zm-283.1 283.11H104.22v-183.35l283.35-284.1 184.86 184.34-283.1 283.11Z"/></svg>`,
                        },
                        // Ícones de editar genérico
                        Editar: {
                            selectors: [
                                'img[src*="alterar.gif"]',
                                'img[title*="Alterar"]',
                                'img[alt*="Alterar"]',
                            ],
                            newSvg: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#f97316" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14,2 14,8 20,8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10,9 9,9 8,9"/></svg>`,
                        },
                        // Ícones de balão/memo
                        "Memo Balão": {
                            selectors: [
                                'img[src*="balao.gif"]',
                                'img[alt*="Incluir Memo"]',
                                'img[title*="Memo"]',
                            ],
                            newSvg: `<svg width="18" height="18" viewBox="0 0 24 24" fill="#FEF3C7" stroke="#D97706" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>`,
                        },
                        // Ícones de link
                        Link: {
                            selectors: [
                                'img[src*="linkeditor.png"]',
                                'img[alt*="Link"]',
                                'img[title*="Link"]',
                            ],
                            newSvg: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#6B7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: auto; width: 1.1em; height: 1.1em; opacity: 1; cursor: pointer;" class="clickable-icon substituted-icon" data-eprobe-icon-replaced="true"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>`,
                        },
                        // Ícones de visualizar documento HTML
                        "Visualizar HTML": {
                            selectors: [
                                'img[src*="html.gif"]',
                                'img[title*="Visualizar Documento"]',
                                'img[alt*="Visualizar"]',
                            ],
                            newSvg: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14,2 14,8 20,8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10,9 9,9 8,9"/></svg>`,
                        },
                        // Ícones de PDF
                        PDF: {
                            selectors: [
                                'img[src*="pdf.gif"]',
                                'img[title*="PDF"]',
                                'img[alt*="PDF"]',
                            ],
                            newSvg: `<svg xmlns="http://www.w3.org/2000/svg" height="18px" viewBox="0 -960 960 960" width="18px" fill="currentColor"><path d="M360-460h40v-80h40q17 0 28.5-11.5T480-580v-40q0-17-11.5-28.5T440-660h-80v200Zm40-120v-40h40v40h-40Zm120 120h80q17 0 28.5-11.5T640-500v-120q0-17-11.5-28.5T600-660h-80v200Zm40-40v-120h40v120h-40Zm120 40h40v-80h40v-40h-40v-40h40v-40h-80v200ZM320-240q-33 0-56.5-23.5T240-320v-480q0-33 23.5-56.5T320-880h480q33 0 56.5 23.5T880-800v480q0 33-23.5 56.5T800-240H320Zm0-80h480v-480H320v480ZM160-80q-33 0-56.5-23.5T80-160v-560h80v560h560v80H160Zm160-720v480-480Z"/></svg>`,
                        },
                        // Ícones de tooltip/memo
                        "Memo Tooltip": {
                            selectors: [
                                'img[src*="tooltip.gif"]',
                                'img[alt*="Incluir Memo"]',
                                'img[title*="Tooltip"]',
                            ],
                            newSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sticky-note-icon lucide-sticky-note"><path d="M16 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8Z"/><path d="M15 3v4a2 2 0 0 0 2 2h4"/></svg>`,
                        },
                        // Ícones de ajuda/interrogação
                        Ajuda: {
                            selectors: [
                                'img[src*="duvida.png"]',
                                'img[alt*="Ajuda"]',
                                'img[title*="Ajuda"]',
                            ],
                            newSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-question-mark-icon lucide-circle-question-mark"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>`,
                        },
                        // Ícones de ocultar/resumo
                        /*                 Ocultar: {
                    selectors: [
                        'img[src*="ver_resumo.gif"]',
                        'img[title*="Ocultar"]',
                        'img[alt*="Resumo"]',
                    ],
                    newSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-square-minus-icon lucide-square-minus"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M8 12h8"/></svg>`,
                },
                // Ícones de mostrar/ver tudo
                Mostrar: {
                    selectors: [
                        'img[src*="ver_tudo.gif"]',
                        'img[title*="Mostrar"]',
                        'img[alt*="Ver Tudo"]',
                    ],
                    newSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-square-plus-icon lucide-square-plus"><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M8 12h8"/><path d="M12 8v8"/></svg>`,
                }, */
                        // Ícones de lupa/busca
                        Lupa: {
                            selectors: [
                                'img[src*="lupa.gif"]',
                                'img[alt*="Informações do Evento"]',
                                'img[title*="Buscar"]',
                            ],
                            newSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search-icon lucide-search"><path d="m21 21-4.34-4.34"/><circle cx="11" cy="11" r="8"/></svg>`,
                        },
                        // ⚠️ ESTRELAS DESABILITADAS: Preservando funcionalidade original do eProc
                        /*
                        "Estrela Acesa": {
                            selectors: [
                                'img[src*="EstrelaAcesa.gif"]',
                                'img[alt*="Evento relevante"]',
                                'img[title*="Relevante"]',
                            ],
                            newSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#e0bb00" stroke="#e0bb00" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star-icon lucide-star" style="pointer-events: none;"><path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"/></svg>`,
                            preserveOriginal: true,
                        },
                        "Estrela Apagada": {
                            selectors: [
                                'img[src*="EstrelaApagada.gif"]',
                                'img[src*="estrela_apagada.gif"]',
                                'img[alt*="Evento normal"]',
                            ],
                            newSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star-icon lucide-star" style="pointer-events: none;"><path d="M11.525 2.295a.53.53 0 0 1 .95 0l2.31 4.679a2.123 2.123 0 0 0 1.595 1.16l5.166.756a.53.53 0 0 1 .294.904l-3.736 3.638a2.123 2.123 0 0 0-.611 1.878l.882 5.14a.53.53 0 0 1-.771.56l-4.618-2.428a2.122 2.122 0 0 0-1.973 0L6.396 21.01a.53.53 0 0 1-.77-.56l.881-5.139a2.122 2.122 0 0 0-.611-1.879L2.16 9.795a.53.53 0 0 1 .294-.906l5.165-.755a2.122 2.122 0 0 0 1.597-1.16z"/></svg>`,
                            preserveOriginal: true,
                        },
                        */ // FIM DAS DEFINIÇÕES DE ESTRELAS DESABILITADAS
                        // Ícones de vídeo/televisão
                        Vídeo: {
                            selectors: [
                                'img[src*="oral_video.png"]',
                                'img[alt*="Vídeo"]',
                                'img[title*="Vídeo"]',
                            ],
                            newSvg: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-video-icon lucide-video"><path d="m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5"/><rect x="2" y="6" width="14" height="12" rx="2"/></svg>`,
                        },
                    };

                    // ===============================
                    // SUBSTITUIÇÃO PRINCIPAL - VERSÃO MELHORADA
                    // ===============================
                    Object.entries(ferramentasIcones).forEach(
                        ([nome, config]) => {
                            try {
                                // Tentar cada seletor até encontrar elementos
                                config.selectors.forEach((selector) => {
                                    const elementos =
                                        document.querySelectorAll(selector);

                                    elementos.forEach((img) => {
                                        // Verificar se já foi substituído
                                        if (
                                            img.hasAttribute(
                                                "data-eprobe-icon-replaced"
                                            ) ||
                                            img.classList.contains(
                                                "substituted-icon"
                                            )
                                        ) {
                                            return;
                                        }

                                        // ⚡ OTIMIZAÇÃO PERFORMANCE: Detecção simples de clicabilidade
                                        const parentElement = img.parentNode;
                                        const isClickableElement = !!(
                                            img.onclick ||
                                            img.getAttribute("onclick") ||
                                            (parentElement &&
                                                parentElement.tagName === "A")
                                        );

                                        // Preservar dimensões originais
                                        const originalWidth =
                                            img.style.width ||
                                            img.getAttribute("width") ||
                                            "1.1em";
                                        const originalHeight =
                                            img.style.height ||
                                            img.getAttribute("height") ||
                                            "1.1em";
                                        const originalOpacity =
                                            img.style.opacity || "1";

                                        // Criar container SVG
                                        const container =
                                            document.createElement("span");
                                        container.innerHTML = config.newSvg;

                                        // 🎨 APLICAR ESTILOS PADRONIZADOS
                                        applyStandardIconStyles(container);

                                        // ⚡ OTIMIZAÇÃO PERFORMANCE: Aplicar pointer-events de forma eficiente
                                        if (isClickableElement) {
                                            // Elemento clicável: permitir eventos
                                            container.style.pointerEvents =
                                                "auto";
                                        } else {
                                            // Elemento não-clicável: bloquear eventos para performance
                                            container.style.pointerEvents =
                                                "none";
                                        }

                                        const svg = container.firstElementChild;
                                        if (svg) {
                                            // ⚡ OTIMIZAÇÃO PERFORMANCE: Configuração básica do SVG
                                            svg.style.width = originalWidth;
                                            svg.style.height = originalHeight;
                                            svg.style.opacity = originalOpacity;
                                            svg.style.pointerEvents =
                                                isClickableElement
                                                    ? "auto"
                                                    : "none";

                                            // ⚡ OTIMIZAÇÃO: Copiar apenas eventos essenciais
                                            if (isClickableElement) {
                                                if (img.onclick)
                                                    svg.onclick = img.onclick;
                                                const onclickAttr =
                                                    img.getAttribute("onclick");
                                                if (onclickAttr)
                                                    svg.setAttribute(
                                                        "onclick",
                                                        onclickAttr
                                                    );
                                                svg.style.cursor = "pointer";

                                                // ⚡ CORREÇÃO CRÍTICA: Adicionar classe clickable-icon para escapar do CSS pointer-events: none
                                                try {
                                                    svg.classList.add(
                                                        "clickable-icon"
                                                    );
                                                } catch (e) {
                                                    // Fallback para SVGs que não suportam classList
                                                    const currentClass =
                                                        svg.getAttribute(
                                                            "class"
                                                        ) || "";
                                                    svg.setAttribute(
                                                        "class",
                                                        currentClass +
                                                            " clickable-icon"
                                                    );
                                                }
                                            }

                                            // ⚡ OTIMIZAÇÃO: Marcar substituição sem processamento excessivo
                                            svg.setAttribute(
                                                "data-eprobe-icon-replaced",
                                                "true"
                                            );

                                            // 📏 DIMENSIONAMENTO ESPECÍFICO: Verificar se está em divListaRecursosMinuta
                                            aplicarDimensionamentoRecursosMinuta(
                                                svg
                                            );

                                            // ⚡ CORREÇÃO: SVG não pode ter className - usar classList.add
                                            if (img.className) {
                                                const classes = img.className
                                                    .split(" ")
                                                    .filter((cls) =>
                                                        cls.trim()
                                                    );
                                                classes.forEach((cls) => {
                                                    try {
                                                        svg.classList.add(cls);
                                                    } catch (e) {
                                                        // Fallback para SVGs que não suportam classList
                                                        const currentClass =
                                                            svg.getAttribute(
                                                                "class"
                                                            ) || "";
                                                        svg.setAttribute(
                                                            "class",
                                                            currentClass +
                                                                " " +
                                                                cls
                                                        );
                                                    }
                                                });
                                            }

                                            try {
                                                svg.classList.add(
                                                    "substituted-icon"
                                                );
                                            } catch (e) {
                                                // Fallback para SVGs que não suportam classList
                                                const currentClass =
                                                    svg.getAttribute("class") ||
                                                    "";
                                                svg.setAttribute(
                                                    "class",
                                                    currentClass +
                                                        " substituted-icon"
                                                );
                                            }

                                            // ⚡ CORREÇÃO: Definir ID de forma segura para SVG
                                            if (img.id) {
                                                try {
                                                    svg.id = img.id;
                                                } catch (e) {
                                                    // Fallback para SVGs que não aceitam ID direto
                                                    svg.setAttribute(
                                                        "id",
                                                        img.id
                                                    );
                                                }
                                            }

                                            // ⚡ OTIMIZAÇÃO: Substituição eficiente
                                            img.parentNode.replaceChild(
                                                container,
                                                img
                                            );
                                            substituicoesRealizadas++;
                                        }
                                    });
                                });
                            } catch (error) {
                                const errorMsg = `Erro ao processar "${nome}": ${error.message}`;
                                errosEncontrados.push(errorMsg);
                                console.warn(`⚠️ ÍCONES: ${errorMsg}`);
                            }
                        }
                    );

                    // ===============================
                    // RELATÓRIO FINAL
                    // ===============================
                    log(
                        `🎨 ÍCONES: Substituição de ferramentas concluída - ${substituicoesRealizadas} ícones substituídos`
                    );

                    if (errosEncontrados.length > 0) {
                        console.warn(
                            `⚠️ ÍCONES: ${errosEncontrados.length} erros encontrados:`,
                            errosEncontrados
                        );
                    }

                    return substituicoesRealizadas > 0;
                } catch (error) {
                    console.error(
                        "❌ ÍCONES: Erro crítico na substituição de ferramentas:",
                        error
                    );
                    return false;
                } finally {
                    // Sempre marcar como não executando
                    executandoSubstituicao = false;
                }
            }

            // Função de teste para verificar se as funções de ícones estão funcionando
            function testarFuncoesIcones() {
                log("🧪 TESTE: Verificando funções de ícones...");

                const funcoes = [
                    "substituirIconesFieldsetAcoes",
                    "substituirIconesFerramentas",
                    "inicializarSubstituicaoIcones",
                    "debugIconesNaPagina",
                ];

                funcoes.forEach((funcao) => {
                    if (typeof window.SENT1_AUTO[funcao] === "function") {
                        log(`✅ TESTE: ${funcao} está definida`);
                    } else {
                        console.error(`❌ TESTE: ${funcao} NÃO está definida`);
                    }
                });

                // Testar execução
                try {
                    substituirIconesFieldsetAcoes();
                    log(
                        "✅ TESTE: substituirIconesFieldsetAcoes executada com sucesso"
                    );
                } catch (error) {
                    console.error(
                        "❌ TESTE: Erro ao executar substituirIconesFieldsetAcoes:",
                        error
                    );
                }

                try {
                    substituirIconesFerramentas();
                    log(
                        "✅ TESTE: substituirIconesFerramentas executada com sucesso"
                    );
                } catch (error) {
                    console.error(
                        "❌ TESTE: Erro ao executar substituirIconesFerramentas:",
                        error
                    );
                }
            }

            // Função de debug para analisar ícones na página
            function debugIconesNaPagina() {
                log("🔍 DEBUG: Analisando ícones na página...");

                // Analisar ícones no fieldset #fldAcoes
                const fieldset = document.querySelector("#fldAcoes");
                if (fieldset) {
                    log("🔍 DEBUG: Fieldset #fldAcoes encontrado");
                    const imagens = fieldset.querySelectorAll("img");
                    log(
                        `🔍 DEBUG: ${imagens.length} imagens encontradas no fieldset`
                    );

                    imagens.forEach((img, index) => {
                        log(`🔍 DEBUG: Imagem ${index + 1}:`, {
                            src: img?.src || "N/A",
                            alt: img?.alt || "N/A",
                            className: img?.className || "N/A",
                            width: img?.style?.width || "N/A",
                            height: img?.style?.height || "N/A",
                        });
                    });
                } else {
                    logError("⚠️ DEBUG: Fieldset #fldAcoes não encontrado");
                }

                // Analisar ícones novo.gif na página
                const iconesNovo = document.querySelectorAll(
                    'img[src*="novo.gif"]'
                );
                log(
                    `🔍 DEBUG: ${iconesNovo.length} ícones novo.gif encontrados`
                );
                iconesNovo.forEach((img, index) => {
                    log(`🔍 DEBUG: novo.gif ${index + 1}:`, {
                        src: img?.src || "N/A",
                        alt: img?.alt || "N/A",
                        parentElement: img?.parentElement?.tagName || "N/A",
                        parentText:
                            img?.parentElement?.textContent
                                ?.trim()
                                .substring(0, 50) || "N/A",
                    });
                });

                // Analisar todos os ícones GIF na página
                const todosGifs = document.querySelectorAll('img[src*=".gif"]');
                log(
                    `🔍 DEBUG: ${todosGifs.length} ícones GIF encontrados na página`
                );

                const gifsSumario = {};
                todosGifs.forEach((img) => {
                    // 🛡️ PROTEÇÃO: Verificar se img e img.src existem antes de acessar
                    if (!img || !img.src) {
                        console.warn(
                            "⚠️ IMG SRC: Elemento img sem src encontrado:",
                            img
                        );
                        return;
                    }

                    const nomeArquivo = img.src.split("/").pop();
                    if (!gifsSumario[nomeArquivo]) {
                        gifsSumario[nomeArquivo] = 0;
                    }
                    gifsSumario[nomeArquivo]++;
                });

                log("🔍 DEBUG: Resumo de GIFs por arquivo:", gifsSumario);
            }

            // Expor função globalmente para debug (movidas para namespace principal)

            // Função de debug para analisar elementos "Incluir em Pauta/Mesa"
            function debugIncluirPautaMesa() {
                log("🔍 DEBUG: Analisando elementos 'Incluir em Pauta/Mesa'");

                const fieldset = document.querySelector(
                    "#fldAcoes.infraFieldset"
                );
                if (!fieldset) {
                    logError("❌ DEBUG: Fieldset #fldAcoes não encontrado");
                    return;
                }

                // Procurar especificamente por infraButton com texto "Incluir em Pauta/Mesa"
                const infraButtons = fieldset.querySelectorAll("a.infraButton");
                log(
                    `🔍 DEBUG: Encontrados ${infraButtons.length} links com classe infraButton`
                );

                let encontrados = 0;
                infraButtons.forEach((button, index) => {
                    const text = button.textContent.trim();
                    if (
                        text.includes("Incluir") ||
                        text.includes("Pauta") ||
                        text.includes("Mesa")
                    ) {
                        encontrados++;
                        log(`🎯 DEBUG: InfraButton ${index + 1}:`, {
                            text: text,
                            textLength: text.length,
                            endsWith: text.endsWith("Incluir em Pauta/Mesa"),
                            includes: text.includes("Incluir em Pauta/Mesa"),
                            hasImage: !!button.querySelector("img"),
                            href: button.href.substring(0, 100) + "...", // Mostrar só início do href
                            isProcessed:
                                button.classList.contains("icon-processed"),
                            outerHTML:
                                button.outerHTML.substring(0, 200) + "...", // Mostrar estrutura
                        });
                    }
                });

                if (encontrados === 0) {
                    log(
                        "❌ DEBUG: Nenhum link relacionado a 'Incluir em Pauta/Mesa' encontrado"
                    );

                    // Procurar por qualquer link que contenha "Incluir"
                    const linksIncluir = fieldset.querySelectorAll("a");
                    linksIncluir.forEach((link, index) => {
                        if (link.textContent.includes("Incluir")) {
                            log(`📋 DEBUG: Link com 'Incluir' ${index + 1}:`, {
                                text: link.textContent.trim(),
                                classes: link.className,
                                outerHTML:
                                    link.outerHTML.substring(0, 150) + "...",
                            });
                        }
                    });
                }

                return encontrados;
            }

            // Expor função de debug globalmente (movida para namespace principal)

            // 🚀 EXECUÇÃO AUTOMÁTICA - Aguardar navbar estar pronta
            setTimeout(() => {
                inicializarPersonalizacaoPesquisaNavbar();
            }, 1500);

            // 🎨 EXECUÇÃO AUTOMÁTICA - Sistema de substituição de ícones
            setTimeout(() => {
                log("🎨 ÍCONES: Iniciando sistema automaticamente...");
                try {
                    // ⛔ VERIFICAÇÃO: Só executar em páginas de capa do processo
                    if (isCapaProcessoPage()) {
                        inicializarSubstituicaoIcones();
                        logCritical(
                            "✅ ÍCONES: Sistema inicializado com sucesso"
                        );
                    } else {
                        log(
                            "⛔ ÍCONES: Inicialização automática bloqueada - página atual não é capa do processo"
                        );
                        log("📍 URL atual:", window.location.href);
                    }
                } catch (error) {
                    console.error("❌ ÍCONES: Erro na inicialização:", error);
                }
            }, 2000);

            // 🔍 EXECUÇÃO AUTOMÁTICA - Inicializar observer de interface
            setTimeout(() => {
                log("🔍 OBSERVER: Iniciando observer de interface...");
                try {
                    if (typeof setupInterfaceObserver === "function") {
                        setupInterfaceObserver();
                        log(
                            "✅ OBSERVER: Interface observer inicializado com sucesso"
                        );
                    } else {
                        console.warn(
                            "⚠️ OBSERVER: Função setupInterfaceObserver não encontrada"
                        );
                    }
                } catch (error) {
                    console.error("❌ OBSERVER: Erro na inicialização:", error);
                }
            }, 2100);

            // 📏 EXECUÇÃO AUTOMÁTICA - Inicializar observer específico para divListaRecursosMinuta
            setTimeout(() => {
                // ⛔ VERIFICAÇÃO: Só executar em páginas de capa do processo
                if (isCapaProcessoPage()) {
                    log(
                        "📏 RECURSOS: Iniciando observer específico para divListaRecursosMinuta..."
                    );
                    try {
                        if (
                            typeof setupObservadorRecursosMinuta === "function"
                        ) {
                            const observer = setupObservadorRecursosMinuta();
                            if (observer) {
                                log(
                                    "✅ RECURSOS: Observer específico inicializado com sucesso"
                                );
                            } else {
                                log(
                                    "⚠️ RECURSOS: Observer não configurado - divListaRecursosMinuta não encontrado"
                                );
                            }
                        } else {
                            console.warn(
                                "⚠️ RECURSOS: Função setupObservadorRecursosMinuta não encontrada"
                            );
                        }
                    } catch (error) {
                        console.error(
                            "❌ RECURSOS: Erro na inicialização do observer:",
                            error
                        );
                    }
                } else {
                    log(
                        "⛔ RECURSOS: Observer específico bloqueado - página atual não é capa do processo"
                    );
                }
            }, 2200);

            // 🔧 EXECUÇÃO AUTOMÁTICA - Corrigir alinhamento de ícones em divListaRecursosMinuta
            setTimeout(() => {
                // ⛔ VERIFICAÇÃO: Só executar em páginas de capa do processo
                if (isCapaProcessoPage()) {
                    log(
                        "🔧 RECURSOS: Iniciando correção automática de alinhamento..."
                    );
                    try {
                        if (
                            typeof corrigirAlinhamentoRecursosMinuta ===
                            "function"
                        ) {
                            const resultado =
                                corrigirAlinhamentoRecursosMinuta();
                            if (resultado.encontrado) {
                                log(
                                    `✅ RECURSOS: Alinhamento corrigido - ${resultado.iconesCorrigidos} ícones processados`
                                );
                            } else {
                                log(
                                    "⚠️ RECURSOS: divListaRecursosMinuta não encontrado para correção"
                                );
                            }
                        } else {
                            console.warn(
                                "⚠️ RECURSOS: Função corrigirAlinhamentoRecursosMinuta não encontrada"
                            );
                        }
                    } catch (error) {
                        console.error(
                            "❌ RECURSOS: Erro na correção de alinhamento:",
                            error
                        );
                    }
                } else {
                    log(
                        "⛔ RECURSOS: Correção de alinhamento bloqueada - página atual não é capa do processo"
                    );
                }
            }, 2300);

            // 🔄 EXECUÇÃO AUTOMÁTICA - Inicializar observer para legMinutas (Histórico)
            setTimeout(() => {
                // ⛔ VERIFICAÇÃO: Só executar em páginas de capa do processo
                if (isCapaProcessoPage()) {
                    log(
                        "🔄 MINUTAS: Iniciando observer para legMinutas (detectar atualizações)..."
                    );
                    try {
                        if (
                            typeof setupObservadorLegendMinutas === "function"
                        ) {
                            const observer = setupObservadorLegendMinutas();
                            if (observer) {
                                log(
                                    "✅ MINUTAS: Observer para legMinutas inicializado com sucesso"
                                );
                            } else {
                                log(
                                    "⚠️ MINUTAS: Observer não configurado - legMinutas não encontrado"
                                );
                            }
                        } else {
                            console.warn(
                                "⚠️ MINUTAS: Função setupObservadorLegendMinutas não encontrada"
                            );
                        }
                    } catch (error) {
                        console.error(
                            "❌ MINUTAS: Erro na inicialização do observer:",
                            error
                        );
                    }
                } else {
                    log(
                        "⛔ MINUTAS: Observer legMinutas bloqueado - página atual não é capa do processo"
                    );
                }
            }, 2400);

            // 🎯 EXECUÇÃO AUTOMÁTICA - Inicializar interceptor para botão "Atualizar Minutas"
            setTimeout(() => {
                // ⛔ VERIFICAÇÃO: Só executar em páginas de capa do processo
                if (isCapaProcessoPage()) {
                    log(
                        "🎯 MINUTAS: Iniciando interceptor para botão 'Atualizar Minutas'..."
                    );
                    try {
                        if (
                            typeof setupInterceptorAtualizarMinutas ===
                            "function"
                        ) {
                            const interceptorAtivo =
                                setupInterceptorAtualizarMinutas();
                            if (interceptorAtivo) {
                                log(
                                    "✅ MINUTAS: Interceptor configurado com sucesso para botão 'Atualizar Minutas' principal"
                                );
                            } else {
                                log(
                                    "⚠️ MINUTAS: Interceptor não configurado - botão 'atualizaMinutas' principal não encontrado"
                                );
                            }
                        } else {
                            console.warn(
                                "⚠️ MINUTAS: Função setupInterceptorAtualizarMinutas não está disponível"
                            );
                        }

                        // 🔄 NOVO: Configurar interceptor para TODOS os botões de minutas individuais
                        if (
                            typeof setupInterceptorTodosBotoesAtualizar ===
                            "function"
                        ) {
                            const botoesInterceptados =
                                setupInterceptorTodosBotoesAtualizar();
                            if (botoesInterceptados > 0) {
                                log(
                                    `✅ MINUTAS MÚLTIPLAS: ${botoesInterceptados} botões individuais interceptados com sucesso`
                                );
                            } else {
                                log(
                                    "⚠️ MINUTAS MÚLTIPLAS: Nenhum botão individual encontrado ou interceptado"
                                );
                            }
                        } else {
                            console.warn(
                                "⚠️ MINUTAS: Função setupInterceptorTodosBotoesAtualizar não está disponível"
                            );
                        }
                    } catch (error) {
                        console.error(
                            "❌ MINUTAS: Erro na configuração do interceptor:",
                            error
                        );
                    }
                } else {
                    log(
                        "⛔ MINUTAS: Interceptor bloqueado - página atual não é capa do processo"
                    );
                }
            }, 2500);

            // 🔧 EXECUÇÃO AUTOMÁTICA - Corrigir pointer-events de botões críticos
            setTimeout(() => {
                log(
                    "🔧 CORREÇÃO: Aplicando correção automática de pointer-events..."
                );
                try {
                    if (typeof corrigirPointerEventsBotoes === "function") {
                        const resultado = corrigirPointerEventsBotoes();
                        log(
                            "✅ CORREÇÃO: Pointer-events corrigidos automaticamente:",
                            resultado
                        );
                    } else {
                        console.warn(
                            "⚠️ CORREÇÃO: Função corrigirPointerEventsBotoes não encontrada"
                        );
                    }
                } catch (error) {
                    console.error(
                        "❌ CORREÇÃO: Erro na correção automática:",
                        error
                    );
                }
            }, 750);

            // 🔧 EXECUÇÃO AUTOMÁTICA - Corrigir função switchRelevanciaDocumento (VERSÃO ROBUSTA)
            setTimeout(() => {
                log(
                    "  CORREÇÃO ROBUSTA: Aplicando correção automática da função switchRelevanciaDocumento (versão robusta)..."
                );
                try {
                    if (
                        typeof corrigirSwitchRelevanciaDocumentoRobusta ===
                        "function"
                    ) {
                        // DESABILITADO: const resultado = corrigirSwitchRelevanciaDocumentoRobusta();
                        log(
                            "⚠️ CORREÇÃO DESABILITADA: switchRelevanciaDocumento NÃO corrigida para preservar funcionalidade"
                        );
                    } else if (
                        typeof corrigirSwitchRelevanciaDocumento === "function"
                    ) {
                        const resultado = corrigirSwitchRelevanciaDocumento();
                        log(
                            "✅ CORREÇÃO: switchRelevanciaDocumento corrigida automaticamente (versão padrão):",
                            resultado
                        );
                    } else {
                        console.warn(
                            "⚠️ CORREÇÃO: Nenhuma função de correção de switchRelevanciaDocumento encontrada"
                        );
                    }
                } catch (error) {
                    console.error(
                        "❌ CORREÇÃO: Erro na correção da função switchRelevanciaDocumento:",
                        error
                    );
                }
            }, 1000);

            // 🔧 EXECUÇÃO ROBUSTA - Segunda tentativa para correção de inconsistências
            setTimeout(() => {
                log("🔧 ROBUSTA: Verificação e correção de inconsistências...");

                // Verificar se modo ultra-performance está bloqueando
                if (MODO_ULTRA_PERFORMANCE) {
                    log(
                        "⚠️ ROBUSTA: Modo ultra-performance ativo - funções podem estar bloqueadas"
                    );
                } else {
                    // Verificar se ícones foram substituídos
                    const fieldsetAcoes = document.querySelector(
                        "#fldAcoes.infraFieldset"
                    );
                    if (fieldsetAcoes) {
                        const iconesGIF =
                            fieldsetAcoes.querySelectorAll('img[src*=".gif"]');
                        const iconesSVG =
                            fieldsetAcoes.querySelectorAll("svg.lucide");

                        if (iconesGIF.length > 0 && iconesSVG.length === 0) {
                            log(
                                "🔧 ROBUSTA: Ícones não foram substituídos - executando correção..."
                            );
                            try {
                                // ⛔ VERIFICAÇÃO: Só executar em páginas de capa do processo
                                if (isCapaProcessoPage()) {
                                    substituirIconesFieldsetAcoes();
                                    substituirIconesFerramentas();
                                } else {
                                    log(
                                        "⛔ ROBUSTA: Correção de ícones bloqueada - página não é capa do processo"
                                    );
                                }
                                log("✅ ROBUSTA: Correção de ícones executada");
                            } catch (error) {
                                console.error(
                                    "❌ ROBUSTA: Erro na correção:",
                                    error
                                );
                            }
                        }
                    }

                    // Verificar botão Resumir Documento
                    const botaoResumir =
                        document.getElementById(
                            "documento-relevante-auto-button"
                        ) ||
                        document.getElementById("sent1-auto-button") ||
                        document.getElementById("eprobe-btn");
                    if (!botaoResumir) {
                        log(
                            "🔧 ROBUSTA: Botão não encontrado - tentando criação..."
                        );
                        try {
                            if (typeof ensureButtonExists === "function") {
                                ensureButtonExists();
                                log(
                                    "✅ ROBUSTA: Tentativa de criação de botão executada"
                                );
                            }
                        } catch (error) {
                            console.error(
                                "❌ ROBUSTA: Erro na criação do botão:",
                                error
                            );
                        }
                    }
                }
            }, 5000);

            // =============================================
            // INICIALIZAÇÃO DO SISTEMA MATERIAL DESIGN
            // =============================================

            log(
                "🚀 SISTEMA: Inicializando Material Design para cards de sessão"
            );

            // Aguardar carregamento da página antes de detectar cards
            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", () => {
                    setTimeout(inicializarMaterialDesign, 1000);
                });
            } else {
                setTimeout(inicializarMaterialDesign, 1000);
            }

            log(
                "✅ NAMESPACE: Todos os fallbacks seguros configurados - extensão protegida contra ReferenceError"
            );

            log("🔧 NAMESPACE: Sistema de fallback universal configurado");

            log(
                "✅ NAMESPACE: Todos os fallbacks seguros configurados - extensão protegida contra ReferenceError"
            );

            log("🔧 NAMESPACE: Sistema de fallback universal configurado");

            log(
                "✅ FUNÇÕES DE TESTE: Carregadas fora da IIFE - sempre disponíveis"
            );

            // ============================================================================
            // 🔧 SISTEMA DE CONFIGURAÇÃO E INICIALIZAÇÃO
            // ============================================================================

            // ===== INSTRUÇÕES DE USO - APENAS LAYOUT ÚNICO =====
            log("  FUNÇÕES PRINCIPAIS DISPONÍVEIS (ÚNICA ESTRATÉGIA):");
            log("- window.SENT1_AUTO.testarMaterialBaseLayout()");
            log("- window.SENT1_AUTO.testarXPathMaterialDesign()");
            logCritical(
                "✅ eProbe Extension carregada com sucesso - LAYOUT MATERIAL ÚNICO!"
            );

            // ===== CONTROLE GLOBAL DE EXECUÇÕES - ANTI-LOOP =====
            window.eProbeExecucoes = {
                detectarDataSessao: 0,
                inserirInterface: 0,
                criarCard: 0,
                substituirIcones: 0,
                maxExecucoesPorFuncao: 5,

                // Verificar se função pode executar
                podeExecutar: function (nomeFuncao) {
                    if (!this[nomeFuncao]) this[nomeFuncao] = 0;

                    if (this[nomeFuncao] >= this.maxExecucoesPorFuncao) {
                        log(
                            `🛑 ANTI-LOOP: ${nomeFuncao} atingiu limite de execuções (${this.maxExecucoesPorFuncao})`
                        );
                        return false;
                    }

                    this[nomeFuncao]++;
                    log(
                        `📊 EXECUÇÃO: ${nomeFuncao} (#${this[nomeFuncao]}/${this.maxExecucoesPorFuncao})`
                    );
                    return true;
                },

                // Resetar contadores (a cada 2 minutos)
                reset: function () {
                    log("🔄 ANTI-LOOP: Resetando contadores de execução");
                    for (const key in this) {
                        if (typeof this[key] === "number") {
                            this[key] = 0;
                        }
                    }
                },
            };

            // Auto-reset a cada 2 minutos
            setInterval(() => {
                window.eProbeExecucoes.reset();
            }, 120000);

            // ============================================================================
            // 🎯 CORRIGIR TOOLTIP NO CARD ORIGINAL MATERIAL DESIGN
            // ============================================================================

            // Função para adicionar tooltip ao card original existente

            // Função para extrair dados da sessão a partir do texto do botão
            function extrairDadosSessao(texto, dadosCamara = null) {
                log("🔍 EXTRAIR DADOS: Processando texto:", texto);
                log("🔍 EXTRAIR DADOS: Dados da câmara:", dadosCamara);

                // Padrões para extrair informações
                const padraoData = /(\d{2}\/\d{2}\/\d{4})/;
                const padraoStatus =
                    /(Incluído em Pauta|Incluído em Mesa|Retirado de Pauta|Pedido de Vista|Julgado em Pauta|Adiado|Sobrestado)/i;
                const padraoTipo = /(Apelação|Agravo|Embargos|Recurso)[^,]*/i;

                const data = texto.match(padraoData)?.[1];
                const status = texto.match(padraoStatus)?.[1];
                let tipo = texto.match(padraoTipo)?.[1] || "Apelação Cível";

                // Tratamento especial para "Embargos" -> "Embargos de Declaração"
                if (tipo && tipo.toLowerCase().includes("embargos")) {
                    tipo = "Embargos de Declaração";
                }

                // Usar dados da câmara do XPath se disponível, senão tentar extrair do texto
                let camara = dadosCamara || "Câmara não identificada";
                if (!dadosCamara) {
                    const padraoCamara = /(\d+ª\s+Câmara[^,]*)/i;
                    const camaraTexto = texto.match(padraoCamara)?.[1];
                    if (camaraTexto) {
                        camara = camaraTexto;
                    }
                }

                if (!data || !status) {
                    logError("❌ EXTRAIR DADOS: Dados insuficientes no texto");
                    return null;
                }

                // Determinar cor baseada no status
                let cor = "#6B7280"; // Cinza padrão
                if (status.toLowerCase().includes("incluído")) {
                    cor = "#007acc"; // Azul para atual
                } else if (status.toLowerCase().includes("retirado")) {
                    cor = "#CE2D4F"; // Vermelho
                } else if (status.toLowerCase().includes("vista")) {
                    cor = "#FFBF46"; // Amarelo
                } else if (status.toLowerCase().includes("julgado")) {
                    cor = "#10B981"; // Verde
                } else if (status.toLowerCase().includes("adiado")) {
                    cor = "#F59E0B"; // Laranja
                } else if (status.toLowerCase().includes("sobrestado")) {
                    cor = "#8B5CF6"; // Roxo
                }

                const dadosSessao = {
                    data: data,
                    status: status,
                    camara: camara,
                    tipo: tipo,
                    cor: cor,
                    isAtual: status.toLowerCase().includes("incluído"),
                };

                log("✅ DADOS EXTRAÍDOS:", dadosSessao);
                return dadosSessao;
            }

            // Função para gerar HTML do card da sessão
            function gerarHtmlCardSessao(sessao, isAtual = false) {
                const borderStyle = isAtual
                    ? `border: 2px solid ${sessao.cor}`
                    : `border: 1px solid #E6E0E9`;
                const backgroundColor = isAtual
                    ? `background: ${sessao.cor}`
                    : `background: #FFFBFE`;
                const tagAtual = isAtual
                    ? `<div style="background: ${sessao.cor}; color: #FFFFFF; font-size: 9px; font-weight: 600; padding: 3px 8px; border-radius: 12px; text-transform: uppercase; letter-spacing: 0.5px; position: absolute; top: 8px; right: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); z-index: 10;">ATUAL</div>`
                    : "";

                return `
        <div style="min-width: 140px; padding: 12px; ${borderStyle}; border-radius: 8px; ${backgroundColor}; position: relative; transition: all 0.2s ease; cursor: pointer;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                <span style="color: ${sessao.cor}; font-size: 16px;">●</span>
                <div style="font-size: 12px; font-weight: 500; color: #1C1B1F; flex: 1;">${sessao.status}</div>
            </div>
            ${tagAtual}
            <div style="font-size: 13px; font-weight: 600; color: #1C1B1F; line-height: 18px; margin-bottom: 4px;">${sessao.data}</div>
            <div style="font-size: 11px; color: #49454F; line-height: 14px; margin-bottom: 2px;">${sessao.camara}</div>
            <div style="font-size: 11px; color: #79747E; line-height: 12px; font-style: italic;">${sessao.tipo}</div>
        </div> `;
            }

            log(
                "🤖 AUTO-EXECUÇÃO: Tooltip será corrigido no card original em 2 segundos"
            );

            let nsRunFullAutomation = async function () {
                console.error(
                    "❌ NAMESPACE: runFullAutomation não está disponível"
                );
                return false;
            };

            let nsAutoOpenDocumentoRelevante = async function () {
                console.error(
                    "❌ NAMESPACE: autoOpenDocumentoRelevante não está disponível"
                );
                return false;
            };

            let nsAutoExtractText = async function () {
                console.error(
                    "❌ NAMESPACE: autoExtractText não está disponível"
                );
                return null;
            };

            let nsCopyToClipboard = async function (text) {
                console.error(
                    "❌ NAMESPACE: copyToClipboard não está disponível"
                );
                return false;
            };

            let nsSendToPerplexity = async function (texto) {
                console.error(
                    "❌ NAMESPACE: sendToPerplexity não está disponível"
                );
                return false;
            };

            let nsDetectPageType = function () {
                console.error(
                    "❌ NAMESPACE: detectPageType não está disponível"
                );
                return "unknown";
            };

            let nsIsValidPageForButton = function () {
                console.warn(
                    "⚠️ NAMESPACE: Usando fallback para isValidPageForButton"
                );

                // Implementar lógica básica de validação
                const url = window.location.href;
                const hasProcessForm =
                    !!document.querySelector("#frmProcessoLista");
                const hasProcessTitle = document
                    .querySelector("h1")
                    ?.textContent.includes(
                        "Consulta Processual - Detalhes do Processo"
                    );

                return (
                    (hasProcessForm && hasProcessTitle) ||
                    (url.includes("eproc") &&
                        (url.includes("documento") || url.includes("processo")))
                );
            };

            let nsFindDocumentosRelevantes = function () {
                console.error(
                    "❌ NAMESPACE: findDocumentosRelevantes não está disponível"
                );
                return [];
            };

            let nsShowDocumentSelectionModal = function (docs) {
                console.error(
                    "❌ NAMESPACE: showDocumentSelectionModal não está disponível"
                );
                return false;
            };

            let nsShowSentenceProcessingOptions = function () {
                console.error(
                    "❌ NAMESPACE: showSentenceProcessingOptions não está disponível"
                );
                return false;
            };

            // Funções de API e armazenamento
            let nsGetStoredApiKey = async function () {
                console.error(
                    "❌ NAMESPACE: getStoredApiKey não está disponível"
                );
                return null;
            };

            let nsExtractTextFromPDF = async function () {
                if (typeof extractTextFromPDF === "function") {
                    return await extractTextFromPDF();
                } else {
                    console.error(
                        "❌ NAMESPACE: extractTextFromPDF não está disponível"
                    );
                    return null;
                }
            };

            // Funções de utilidade
            let nsCleanInvisibleChars = function (text) {
                console.error(
                    "❌ NAMESPACE: cleanInvisibleChars não está disponível"
                );
                return text || "";
            };

            let nsStoreApiKey = async function (apiKey) {
                console.error("❌ NAMESPACE: storeApiKey não está disponível");
                return false;
            };

            // Funções de debug e API
            let nsRemoveStoredApiKey = async function () {
                console.error(
                    "❌ NAMESPACE: removeStoredApiKey não está disponível"
                );
                return false;
            };

            let nsDebugEventStructure = function (linkElement) {
                console.error(
                    "❌ NAMESPACE: debugEventStructure não está disponível"
                );
                return {};
            };

            let nsShouldShowIntegratedButton = function () {
                console.error(
                    "❌ NAMESPACE: shouldShowIntegratedButton não está disponível"
                );
                return false;
            };

            let nsShouldShowFloatingButton = function () {
                console.error(
                    "❌ NAMESPACE: shouldShowFloatingButton não está disponível"
                );
                return false;
            };

            let nsEnsureButtonExists = function () {
                console.error(
                    "❌ NAMESPACE: ensureButtonExists não está disponível"
                );
                return false;
            };

            log("🔧 NAMESPACE: Funções principais preparadas para o namespace");

            // ##### SISTEMA DE FALLBACK UNIVERSAL #####
            // Criar versões seguras para TODAS as funções do namespace que podem não estar disponíveis

            const createSafeFallback = (funcName, returnValue = null) => {
                return function (...args) {
                    console.warn(
                        `⚠️ FALLBACK: ${funcName} usando fallback seguro`
                    );
                    return returnValue;
                };
            };

            const createAsyncSafeFallback = (funcName, returnValue = null) => {
                return async function (...args) {
                    console.warn(
                        `⚠️ FALLBACK: ${funcName} usando fallback seguro (async)`
                    );
                    return returnValue;
                };
            };

            // Verificar e criar fallbacks seguros para todas as funções críticas
            const safeFunctions = {
                testApiKey: createAsyncSafeFallback("testApiKey", false),
                showErrorLogs: createSafeFallback("showErrorLogs", false),
                debugApiCall: createSafeFallback("debugApiCall", {}),
                showApiQuotaInfo: createSafeFallback("showApiQuotaInfo", false),
                getDataSessaoPautado: createSafeFallback(
                    "getDataSessaoPautado",
                    null
                ),
                hasDataSessaoPautado: createSafeFallback(
                    "hasDataSessaoPautado",
                    false
                ),
                resetDataSessaoPautado: createSafeFallback(
                    "resetDataSessaoPautado",
                    true
                ),
                showDataSessaoPautadoInfo: createSafeFallback(
                    "showDataSessaoPautadoInfo",
                    false
                ),
                validarDataBrasileira: createSafeFallback(
                    "validarDataBrasileira",
                    false
                ),

                // Funções de interface
                inserirDataSessaoNaInterface: createSafeFallback(
                    "inserirDataSessaoNaInterface",
                    false
                ),
                removerDataSessaoDaInterface: createSafeFallback(
                    "removerDataSessaoDaInterface",
                    false
                ),
                atualizarDataSessaoNaInterface: createSafeFallback(
                    "atualizarDataSessaoNaInterface",
                    false
                ),
                forcarInsercaoCardSemValidacao: createSafeFallback(
                    "forcarInsercaoCardSemValidacao",
                    false
                ),

                // Funções de dados de sessão
                buscarDadosSessoes: createAsyncSafeFallback(
                    "buscarDadosSessoes",
                    []
                ),
                parsearDadosSessoes: createSafeFallback(
                    "parsearDadosSessoes",
                    []
                ),
                extrairDadosLinhaSessao: createSafeFallback(
                    "extrairDadosLinhaSessao",
                    null
                ),
                buscarSessaoPorData: createSafeFallback(
                    "buscarSessaoPorData",
                    null
                ),
                cruzarDadosDataSessao: createAsyncSafeFallback(
                    "cruzarDadosDataSessao",
                    null
                ),

                // detectarDataSessaoExperimental: REMOVIDA - substituída por detectarCardSessaoSimplificado ÚNICA
            };

            // Fallbacks seguros para funções de interface e botões
            const interfaceFunctions = {
                criarBotaoEleganteeProc: createSafeFallback(
                    "criarBotaoEleganteeProc",
                    null
                ),
                botaoBrancoCapaProcesso: createSafeFallback(
                    "botaoBrancoCapaProcesso",
                    null
                ),
                criarInfraButtonPrimary: createSafeFallback(
                    "criarInfraButtonPrimary",
                    null
                ),
                botaoAzuleProc: createSafeFallback("botaoAzuleProc", null),
            };

            // Fallbacks seguros para funções de localizadores
            const localizadorFunctions = {
                detectarPaginaLocalizadores: createSafeFallback(
                    "detectarPaginaLocalizadores",
                    false
                ),
                processarTabelaLocalizadores: createSafeFallback(
                    "processarTabelaLocalizadores",
                    []
                ),
                destacarLocalizadoresUrgentes: createSafeFallback(
                    "destacarLocalizadoresUrgentes",
                    0
                ),
            };

            // Fallbacks seguros para funções de status
            const statusFunctions = {
                detectarStatusSessao: createSafeFallback(
                    "detectarStatusSessao",
                    null
                ),
                // detectarDataSessaoComStatus: REMOVIDA - substituída por detectarCardSessaoSimplificado ÚNICA
                obterTextoCardPorStatus: createSafeFallback(
                    "obterTextoCardPorStatus",
                    "Status não encontrado"
                ),
                obterCorCardPorStatus: createSafeFallback(
                    "obterCorCardPorStatus",
                    "#6B7280"
                ),
                getStatusSessao: createSafeFallback("getStatusSessao", null),
                hasStatusSessao: createSafeFallback("hasStatusSessao", false),
                resetStatusSessao: createSafeFallback(
                    "resetStatusSessao",
                    true
                ),
                showStatusSessaoInfo: createSafeFallback(
                    "showStatusSessaoInfo",
                    false
                ),
            };

            // Fallbacks seguros para funções de dados completos de sessão
            const sessionDataFunctions = {
                getDadosCompletosSessionJulgamento: createSafeFallback(
                    "getDadosCompletosSessionJulgamento",
                    null
                ),
                hasDadosCompletosSessionJulgamento: createSafeFallback(
                    "hasDadosCompletosSessionJulgamento",
                    false
                ),
                resetDadosCompletosSessionJulgamento: createSafeFallback(
                    "resetDadosCompletosSessionJulgamento",
                    true
                ),
                showDadosCompletosSessionJulgamento: createSafeFallback(
                    "showDadosCompletosSessionJulgamento",
                    false
                ),
            };

            // Fallbacks seguros para funções de debug e interface
            const debugInterfaceFunctions = {
                debugButtonCreation: createSafeFallback(
                    "debugButtonCreation",
                    true
                ),
                forceCreateButton: createSafeFallback(
                    "forceCreateButton",
                    false
                ),
                getCachedBoundingRect: createSafeFallback(
                    "getCachedBoundingRect",
                    {}
                ),
                setupInterfaceObserver: createSafeFallback(
                    "setupInterfaceObserver",
                    true
                ),

                // Funções de diagnóstico e sistema
                diagnosticarCompleto: createSafeFallback(
                    "diagnosticarCompleto",
                    {}
                ),
                corrigirProblemas: createSafeFallback(
                    "corrigirProblemas",
                    true
                ),
                forcarReaplicacaoIcones: createSafeFallback(
                    "forcarReaplicacaoIcones",
                    0
                ),
                inicializarSubstituicaoIcones: createSafeFallback(
                    "inicializarSubstituicaoIcones",
                    true
                ),
                diagnosticarIconesCSS: createSafeFallback(
                    "diagnosticarIconesCSS",
                    {}
                ),
            };

            // ##### FALLBACKS UNIVERSAIS PARA TODAS AS FUNÇÕES PROBLEMÁTICAS #####
            const allMissingFunctions = {
                // Funções de localizadores
                detectarPaginaLocalizadores: createSafeFallback(
                    "detectarPaginaLocalizadores",
                    false
                ),
                processarTabelaLocalizadores: createSafeFallback(
                    "processarTabelaLocalizadores",
                    []
                ),
                destacarLocalizadoresUrgentes: createSafeFallback(
                    "destacarLocalizadoresUrgentes",
                    0
                ),

                // Funções de card e sessão (detectarCardSessaoSimplificado movido para linha 19345)
                criarCardSessaoMaterial: createSafeFallback(
                    "criarCardSessaoMaterial",
                    null
                ),
                obterConfigFigmaStatus: createSafeFallback(
                    "obterConfigFigmaStatus",
                    {}
                ),

                // Funções de tooltip
                adicionarTooltipInterativo: createSafeFallback(
                    "adicionarTooltipInterativo",
                    false
                ),
                adicionarRichTooltipMaterialDesign: createSafeFallback(
                    "adicionarRichTooltipMaterialDesign",
                    false
                ),
                criarTooltipSimplificado: createSafeFallback(
                    "criarTooltipSimplificado",
                    false
                ),
                testarFuncaoTooltip: createSafeFallback(
                    "testarFuncaoTooltip",
                    true
                ),

                // Funções de estilização
                debugDivLembrete: createSafeFallback("debugDivLembrete", {}),
                estilizarDivLembrete: createSafeFallback(
                    "estilizarDivLembrete",
                    true
                ),

                // Funções de debug para status
                debugPadraoRetirado: createSafeFallback(
                    "debugPadraoRetirado",
                    {}
                ),
                debugStatusCompleto: createSafeFallback(
                    "debugStatusCompleto",
                    {}
                ),
                forcarAtualizacaoStatus: createSafeFallback(
                    "forcarAtualizacaoStatus",
                    true
                ),
                testarCasoRetirado: createSafeFallback(
                    "testarCasoRetirado",
                    {}
                ),
                testarSistemaStatusSessao: createSafeFallback(
                    "testarSistemaStatusSessao",
                    {}
                ),

                // Funções de alternância
                findToggleTarget: createSafeFallback("findToggleTarget", null),
                implementarAlternanciaExpandirRetrair: createSafeFallback(
                    "implementarAlternanciaExpandirRetrair",
                    false
                ),
                isElementSafeForToggle: createSafeFallback(
                    "isElementSafeForToggle",
                    false
                ),

                // Funções de teste simplificado
                debugPadroesStatusSessao: createSafeFallback(
                    "debugPadroesStatusSessao",
                    {}
                ),
                forcarStatusSessao: createSafeFallback(
                    "forcarStatusSessao",
                    false
                ),
                encontrarTextoRetirado: createSafeFallback(
                    "encontrarTextoRetirado",
                    null
                ),
                forcarDeteccaoCompleta: createSafeFallback(
                    "forcarDeteccaoCompleta",
                    {}
                ),

                // Funções de ícones
                substituirIconesFieldsetAcoes: createSafeFallback(
                    "substituirIconesFieldsetAcoes",
                    0
                ),
                substituirIconesFerramentas: createSafeFallback(
                    "substituirIconesFerramentas",
                    0
                ),
                substituirIconesGlobalmente: createSafeFallback(
                    "substituirIconesGlobalmente",
                    0
                ),
                debugIconesSubstituicao: createSafeFallback(
                    "debugIconesSubstituicao",
                    {}
                ),
                testarFuncoesIcones: createSafeFallback(
                    "testarFuncoesIcones",
                    true
                ),
                debugIconesNaPagina: createSafeFallback(
                    "debugIconesNaPagina",
                    {}
                ),
                debugIncluirPautaMesa: createSafeFallback(
                    "debugIncluirPautaMesa",
                    {}
                ),

                // Funções de card avançadas
                forcarRecriacaoCardSessao: createSafeFallback(
                    "forcarRecriacaoCardSessao",
                    false
                ),
                encontrarContainerParaCard: createSafeFallback(
                    "encontrarContainerParaCard",
                    null
                ),

                // Funções de dados globais de sessão
                getTipoJulgamentoProcessoPautado: createSafeFallback(
                    "getTipoJulgamentoProcessoPautado",
                    null
                ),
                setTipoJulgamentoProcessoPautado: createSafeFallback(
                    "setTipoJulgamentoProcessoPautado",
                    true
                ),
                getStatusJulgamento: createSafeFallback(
                    "getStatusJulgamento",
                    null
                ),
                setStatusJulgamento: createSafeFallback(
                    "setStatusJulgamento",
                    true
                ),
                getDataSessao: createSafeFallback("getDataSessao", null),
                setDataSessao: createSafeFallback("setDataSessao", true),
                resetDadosGlobaisSessao: createSafeFallback(
                    "resetDadosGlobaisSessao",
                    true
                ),
                showDadosGlobaisSessao: createSafeFallback(
                    "showDadosGlobaisSessao",
                    {}
                ),

                // processarTextoFieldsetSessao: REMOVIDA - substituída por detectarCardSessaoSimplificado ÚNICA
            };

            log(
                "✅ NAMESPACE: Todos os fallbacks seguros configurados - extensão protegida contra ReferenceError"
            );

            log("🔧 NAMESPACE: Sistema de fallback universal configurado");

            // ============================================================
            // 🔧 IMPLEMENTAÇÃO DAS FUNÇÕES FALTANTES PARA NAMESPACE
            // ============================================================

            /**
             * 🔍 DIAGNÓSTICO ESTRUTURA DOM MINUTAS
             * Analisa a estrutura DOM das minutas para debug
             */
            function diagnosticarEstruturaDOMMinutas() {
                try {
                    log(
                        "🔍 DIAGNÓSTICO DOM: Iniciando análise da estrutura das minutas..."
                    );

                    const resultados = {
                        fieldsetPrincipal: null,
                        minutasEncontradas: [],
                        estrutura: {},
                        recomendacoes: [],
                        problemaDetectado: null,
                    };

                    // 1. Buscar o fieldset principal #fldMinutas
                    const fieldsetPrincipal =
                        document.querySelector("#fldMinutas");
                    if (!fieldsetPrincipal) {
                        logCritical(
                            "❌ DIAGNÓSTICO: fieldset#fldMinutas NÃO ENCONTRADO!"
                        );
                        resultados.recomendacoes.push(
                            "Verificar se está na página correta de minutas"
                        );
                        return resultados;
                    }

                    resultados.fieldsetPrincipal = {
                        encontrado: true,
                        id: fieldsetPrincipal.id,
                        classes: fieldsetPrincipal.className,
                        filhos: fieldsetPrincipal.children.length,
                    };

                    log("✅ DIAGNÓSTICO: fieldset#fldMinutas encontrado!");

                    // 2. Verificar hierarquia específica do problema
                    const conteudoMinutas =
                        fieldsetPrincipal.querySelector("#conteudoMinutas");
                    if (!conteudoMinutas) {
                        resultados.problemaDetectado =
                            "Elemento #conteudoMinutas não encontrado";
                        logCritical(
                            "❌ PROBLEMA: #conteudoMinutas não encontrado!"
                        );
                        return resultados;
                    }

                    const conteudoDinamico = conteudoMinutas.querySelector(
                        'div[id^="conteudoMinutas_"]'
                    );
                    if (!conteudoDinamico) {
                        resultados.problemaDetectado =
                            "Div dinâmica conteudoMinutas_ não encontrada";
                        logCritical(
                            "❌ PROBLEMA: Div dinâmica conteudoMinutas_ não encontrada!"
                        );
                        return resultados;
                    }

                    log("✅ DIAGNÓSTICO: Hierarquia DOM até div dinâmica OK");

                    // 3. FOCO NO PROBLEMA: Analisar todos os botões na div dinâmica
                    const todosBotoes =
                        conteudoDinamico.querySelectorAll("button");
                    log(
                        `🔍 DIAGNÓSTICO: ${todosBotoes.length} botões encontrados na div dinâmica`
                    );

                    const analiseBotoes = [];
                    todosBotoes.forEach((botao, index) => {
                        const analise = {
                            indice: index + 1,
                            classes: botao.className,
                            temTexto: !!botao.textContent?.trim(),
                            texto: botao.textContent?.trim().substring(0, 100),
                            innerHTML: botao.innerHTML?.substring(0, 100),
                            matchesSeletor: botao.matches(
                                "button.infraLegendObrigatorio.btn.btn-link.btn-sm.p-0"
                            ),
                            matchesInfraLegend: botao.matches(
                                "button.infraLegendObrigatorio"
                            ),
                            matchesBtnLink: botao.matches("button.btn-link"),
                        };
                        analiseBotoes.push(analise);

                        log(`   Botão ${index + 1}:`, analise);
                    });

                    resultados.analiseBotoes = analiseBotoes;

                    // 4. Tentar seletores alternativos
                    const seletoresAlternativos = [
                        "button.infraLegendObrigatorio",
                        "button[class*='infraLegend']",
                        "button.btn-link",
                        "button",
                        ".infraLegendObrigatorio",
                    ];

                    const testeSeletores = {};
                    seletoresAlternativos.forEach((seletor) => {
                        const elemento =
                            conteudoDinamico.querySelector(seletor);
                        testeSeletores[seletor] = {
                            encontrado: !!elemento,
                            temTexto: elemento
                                ? !!elemento.textContent?.trim()
                                : false,
                            texto: elemento
                                ? elemento.textContent?.trim().substring(0, 50)
                                : null,
                            classes: elemento ? elemento.className : null,
                        };
                    });

                    resultados.testeSeletores = testeSeletores;
                    log(
                        "🔍 DIAGNÓSTICO: Teste de seletores alternativos:",
                        testeSeletores
                    );

                    // 5. Analisar fieldsets internos (método original)
                    const minutasFieldsets = fieldsetPrincipal.querySelectorAll(
                        "div > div:nth-child(2) > fieldset"
                    );
                    log(
                        `🔍 DIAGNÓSTICO: ${minutasFieldsets.length} fieldsets de minutas encontrados`
                    );

                    minutasFieldsets.forEach((fieldset, index) => {
                        const botao = fieldset.querySelector(
                            "legend > span:first-child > button"
                        );
                        const textoMinuta =
                            botao?.textContent?.trim() || "Sem texto";

                        resultados.minutasEncontradas.push({
                            indice: index + 1,
                            temBotao: !!botao,
                            texto: textoMinuta,
                            comprimento: textoMinuta.length,
                        });
                    });

                    log(
                        `📋 MINUTA ${index + 1}: ${textoMinuta.substring(
                            0,
                            100
                        )}...`
                    );

                    // 3. Estrutura geral
                    resultados.estrutura = {
                        totalMinutas: minutasFieldsets.length,
                        minutasComTexto: resultados.minutasEncontradas.filter(
                            (m) => m.texto !== "Sem texto"
                        ).length,
                        minutasComBotao: resultados.minutasEncontradas.filter(
                            (m) => m.temBotao
                        ).length,
                    };

                    // 4. Recomendações
                    if (minutasFieldsets.length === 0) {
                        resultados.recomendacoes.push(
                            "Nenhuma minuta encontrada - verificar seletor CSS"
                        );
                    } else if (resultados.estrutura.minutasComTexto === 0) {
                        resultados.recomendacoes.push(
                            "Minutas encontradas mas sem texto - verificar estrutura interna"
                        );
                    } else {
                        resultados.recomendacoes.push(
                            `Sistema funcionando: ${resultados.estrutura.minutasComTexto} minutas com texto`
                        );
                    }

                    logCritical(
                        `🎯 DIAGNÓSTICO COMPLETO: ${JSON.stringify(
                            resultados.estrutura
                        )}`
                    );
                    return resultados;
                } catch (error) {
                    console.error(
                        "❌ DIAGNÓSTICO: Erro na análise DOM:",
                        error
                    );
                    return {
                        erro: error.message,
                        recomendacoes: [
                            "Erro interno - verificar console para detalhes",
                        ],
                    };
                }
            }

            /**
             * 🧪 TESTE ROBUSTO DE DETECÇÃO
             * Executa testes completos do sistema de detecção
             */
            function testarDeteccaoRobusta() {
                try {
                    log("🧪 TESTE ROBUSTO: Iniciando bateria de testes...");

                    const resultados = {
                        timestamp: new Date().toLocaleString(),
                        processo: obterNumeroProcesso() || "N/A",
                        url: window.location.href,
                        testes: {},
                    };

                    // TESTE 1: Diagnóstico DOM
                    log("🔍 TESTE 1: Diagnóstico da estrutura DOM...");
                    resultados.testes.diagnosticoDOM =
                        diagnosticarEstruturaDOMMinutas();

                    // TESTE 2: Detecção simplificada
                    log("🔍 TESTE 2: Detecção simplificada de sessão...");
                    const deteccaoSimplificada =
                        detectarCardSessaoSimplificado();
                    resultados.testes.deteccaoSimplificada = {
                        sucesso: !!deteccaoSimplificada,
                        dados: deteccaoSimplificada,
                        sessaoEncontrada: !!dataSessaoPautado,
                    };

                    // TESTE 3: Verificação de cache
                    log("🔍 TESTE 3: Verificação de dados em cache...");
                    resultados.testes.cache = {
                        dataSessaoPautado: dataSessaoPautado,
                        processoComDataSessao: processoComDataSessao,
                        dadosCompletosMinutas:
                            window.dadosCompletosMinutas || null,
                    };

                    // TESTE 4: Criação de card
                    log("🔍 TESTE 4: Teste de criação de card...");
                    if (deteccaoSimplificada) {
                        try {
                            criarCardSessaoMaterial(deteccaoSimplificada);
                            resultados.testes.criacaoCard = { sucesso: true };
                        } catch (cardError) {
                            resultados.testes.criacaoCard = {
                                sucesso: false,
                                erro: cardError.message,
                            };
                        }
                    } else {
                        resultados.testes.criacaoCard = {
                            sucesso: false,
                            motivo: "Nenhum dado de sessão encontrado",
                        };
                    }

                    // RELATÓRIO FINAL
                    const totalTestes = Object.keys(resultados.testes).length;
                    const testesPassaram = Object.values(
                        resultados.testes
                    ).filter(
                        (t) =>
                            t.sucesso === true ||
                            (t.diagnosticoDOM &&
                                t.diagnosticoDOM.fieldsetPrincipal
                                    ?.encontrado) ||
                            (t.cache &&
                                (t.cache.dataSessaoPautado ||
                                    t.cache.dadosCompletosMinutas))
                    ).length;

                    logCritical(
                        `🎯 TESTE ROBUSTO CONCLUÍDO: ${testesPassaram}/${totalTestes} testes passaram`
                    );
                    logCritical(
                        `📊 RESULTADOS: ${JSON.stringify(resultados, null, 2)}`
                    );

                    return resultados;
                } catch (error) {
                    console.error(
                        "❌ TESTE ROBUSTO: Erro durante testes:",
                        error
                    );
                    return {
                        erro: error.message,
                        timestamp: new Date().toLocaleString(),
                    };
                }
            }

            // ============================================================
            // 🔧 FIM DAS IMPLEMENTAÇÕES - FUNÇÕES PRONTAS PARA NAMESPACE
            // ============================================================

            // ##### INÍCIO DO NAMESPACE CONSOLIDADO #####
            // TEMPORÁRIO: Salvar funções em variável para exposição após IIFE

            const eProbeNamespaceFunctions = {
                runFullAutomation: nsRunFullAutomation,
                autoOpenDocumentoRelevante: nsAutoOpenDocumentoRelevante,
                autoExtractText: nsAutoExtractText,
                copyToClipboard: nsCopyToClipboard,
                sendToPerplexity: nsSendToPerplexity,
                detectPageType: nsDetectPageType,
                isValidPageForButton: nsIsValidPageForButton,
                findDocumentosRelevantes: nsFindDocumentosRelevantes,
                showDocumentSelectionModal: nsShowDocumentSelectionModal,
                showSentenceProcessingOptions: nsShowSentenceProcessingOptions,
                getStoredApiKey: nsGetStoredApiKey,
                storeApiKey: nsStoreApiKey,
                removeStoredApiKey: nsRemoveStoredApiKey,
                testApiKey: safeFunctions.testApiKey,
                showErrorLogs: safeFunctions.showErrorLogs,
                debugApiCall: safeFunctions.debugApiCall,
                showApiQuotaInfo: safeFunctions.showApiQuotaInfo,
                cleanInvisibleChars: nsCleanInvisibleChars,
                debugEventStructure: nsDebugEventStructure,
                extractTextFromPDF: extractTextFromPDF,
                tryAutomaticSelection: tryAutomaticSelection,
                isValidLegalDocument: isValidLegalDocument,
                cleanExtractedText: cleanExtractedText,
                debugPDFExtracao: function () {
                    console.log(
                        "🔍 DEBUG PDF EPROC: Analisando página atual..."
                    );

                    const url = window.location.href;
                    const urlParams = new URLSearchParams(
                        window.location.search
                    );
                    const dadosIconLink = urlParams.get("dadosIconLink");

                    let mimeTypeInfo = "N/A";
                    if (dadosIconLink) {
                        try {
                            const decoded = atob(dadosIconLink);
                            mimeTypeInfo = decoded.includes(
                                '"MimeType";s:3:"pdf"'
                            )
                                ? "PDF detectado!"
                                : "Não é PDF";
                        } catch (e) {
                            mimeTypeInfo = "Erro ao decodificar";
                        }
                    }

                    const info = {
                        url: url,
                        isEprocDocument: url.includes("acessar_documento"),
                        dadosIconLink: dadosIconLink
                            ? dadosIconLink.substring(0, 50) + "..."
                            : "N/A",
                        mimeTypeInfo: mimeTypeInfo,
                        detectPageTypeResult:
                            window.SENT1_AUTO.detectPageType(),

                        // Elementos PDF na página
                        temIframes: document.querySelectorAll("iframe").length,
                        temEmbeds: document.querySelectorAll("embed").length,
                        temObjects: document.querySelectorAll("object").length,

                        // Teste de seletores específicos
                        plugin: !!document.querySelector("#plugin"),
                        iframePdf:
                            !!document.querySelector('iframe[src*="pdf"]'),
                        embedPdf:
                            !!document.querySelector('embed[type*="pdf"]'),
                    };

                    console.log("📊 RELATÓRIO COMPLETO:", info);
                    return info;
                },
                // Novas funções de detecção de data de sessão - CORRIGIDA ESTRUTURA DOM
                detectarDataSessao: function () {
                    log(
                        "⚠️ FUNÇÃO REDIRECIONADA: Use window.SENT1_AUTO.detectarSessoesUnificado() com nova estrutura DOM"
                    );
                    return window.SENT1_AUTO.detectarSessoesUnificado();
                },
                getDataSessaoPautado: getDataSessaoPautado,
                hasDataSessaoPautado: hasDataSessaoPautado,
                resetDataSessaoPautado: resetDataSessaoPautado,
                showDataSessaoPautadoInfo: showDataSessaoPautadoInfo,
                validarDataBrasileira: validarDataBrasileira,
                // Funções de interface para data da sessão
                inserirDataSessaoNaInterface: inserirDataSessaoNaInterface,
                removerDataSessaoDaInterface: removerDataSessaoDaInterface,
                atualizarDataSessaoNaInterface: atualizarDataSessaoNaInterface,
                forcarInsercaoCardSemValidacao:
                    safeFunctions.forcarInsercaoCardSemValidacao,
                // Funções de cruzamento de dados de sessão
                buscarDadosSessoes: safeFunctions.buscarDadosSessoes,
                parsearDadosSessoes: safeFunctions.parsearDadosSessoes,
                extrairDadosLinhaSessao: safeFunctions.extrairDadosLinhaSessao,
                buscarSessaoPorData: safeFunctions.buscarSessaoPorData,
                cruzarDadosDataSessao: safeFunctions.cruzarDadosDataSessao,

                // 🏛️ FUNÇÕES DE TRADUÇÃO DE ÓRGÃOS TJSC
                traduzirSiglaOrgao: traduzirSiglaOrgao,

                // 🎯 FUNÇÕES DE EXTRAÇÃO DE TIPO DE SESSÃO
                extrairTipoSessao: extrairTipoSessao,

                getDadosCompletosSessionJulgamento:
                    sessionDataFunctions.getDadosCompletosSessionJulgamento,
                hasDadosCompletosSessionJulgamento:
                    sessionDataFunctions.hasDadosCompletosSessionJulgamento,
                resetDadosCompletosSessionJulgamento:
                    sessionDataFunctions.resetDadosCompletosSessionJulgamento,
                showDadosCompletosSessionJulgamento:
                    sessionDataFunctions.showDadosCompletosSessionJulgamento,
                // Funções de interface reutilizável
                criarBotaoEleganteeProc:
                    interfaceFunctions.criarBotaoEleganteeProc,
                botaoBrancoCapaProcesso:
                    interfaceFunctions.botaoBrancoCapaProcesso,
                criarInfraButtonPrimary:
                    interfaceFunctions.criarInfraButtonPrimary,
                botaoAzuleProc: interfaceFunctions.botaoAzuleProc,
                // Funções de localizadores (agora disponíveis globalmente)
                detectarPaginaLocalizadores: window.detectarPaginaLocalizadores,
                processarTabelaLocalizadores:
                    window.processarTabelaLocalizadores,
                destacarLocalizadoresUrgentes:
                    window.destacarLocalizadoresUrgentes,
                debugLocalizadores: function () {
                    const currentUrl = window.location.href;
                    const isLocalizadoresPage = currentUrl.includes(
                        "acao=usuario_tipo_monitoramento_localizador_listar"
                    );
                    const tabela = document.querySelector(
                        'table.infraTable[summary*="Localizadores"]'
                    );
                    const toolbar = document.getElementById(
                        "eprobe-separadores-toolbar"
                    );

                    console.log("🐛 DEBUG LOCALIZADORES:", {
                        url: currentUrl,
                        isLocalizadoresPage: isLocalizadoresPage,
                        tabelaEncontrada: !!tabela,
                        toolbarCriado: !!toolbar,
                        urlPattern:
                            "acao=usuario_tipo_monitoramento_localizador_listar",
                        numeroLinhas: tabela
                            ? tabela.querySelectorAll(
                                  "tbody tr:not(.eprobe-divisor-linha)"
                              ).length
                            : 0,
                    });

                    if (!isLocalizadoresPage) {
                        console.log("⚠️ Não está na página de localizadores");
                    } else {
                        console.log("✅ Está na página de localizadores");
                        if (tabela) {
                            console.log(
                                "✅ Tabela encontrada - forçando reprocessamento"
                            );
                            // Forçar re-processamento
                            window.processarTabelaLocalizadores();
                        } else {
                            console.log("❌ Tabela não encontrada");
                        }
                    }

                    return {
                        isLocalizadoresPage,
                        tabelaEncontrada: !!tabela,
                        toolbarCriado: !!toolbar,
                    };
                },
                testarSeparadoresHover: function () {
                    console.log("🧪 TESTE: Verificando hover dos separadores");
                    const separadores = document.querySelectorAll(
                        ".eprobe-divisor-linha"
                    );
                    console.log(
                        `🔍 Encontrados ${separadores.length} separadores`
                    );

                    separadores.forEach((separador, index) => {
                        const botaoRemover = separador.querySelector(
                            ".eprobe-remove-button"
                        );
                        const titulo = separador.querySelector(
                            ".eprobe-container-hover"
                        );

                        console.log(`📋 Separador ${index + 1}:`, {
                            temBotaoRemover: !!botaoRemover,
                            temTitulo: !!titulo,
                            visibilidadeBotao: botaoRemover
                                ? window.getComputedStyle(botaoRemover).opacity
                                : "N/A",
                        });
                    });

                    return separadores.length;
                },
                corrigirVisibilidadeBotoes: function () {
                    console.log(
                        "🔧 CORRIGIR: Ajustando visibilidade dos botões de remoção"
                    );

                    const css = `
                    .eprobe-remove-button {
                        opacity: 0 !important;
                        transition: opacity 0.2s ease !important;
                    }
                    .eprobe-container-hover:hover .eprobe-remove-button {
                        opacity: 1 !important;
                    }
                `;

                    let styleElement =
                        document.getElementById("eprobe-hover-fix");
                    if (!styleElement) {
                        styleElement = document.createElement("style");
                        styleElement.id = "eprobe-hover-fix";
                        document.head.appendChild(styleElement);
                    }

                    styleElement.textContent = css;
                    console.log("✅ CORRIGIR: CSS de hover aplicado");

                    return true;
                },
                forcarInicializacaoLocalizadores: function () {
                    console.log(
                        "🚀 FORÇA: Inicializando sistema de localizadores manualmente"
                    );

                    // Forçar detecção e processamento
                    detectarPaginaLocalizadores();

                    // Aguardar um momento e processar novamente se necessário
                    setTimeout(() => {
                        const tabela = document.querySelector(
                            'table.infraTable[summary*="Localizadores"]'
                        );
                        if (tabela) {
                            console.log(
                                "✅ FORÇA: Tabela encontrada, reprocessando..."
                            );
                            processarTabelaLocalizadores();
                        } else {
                            console.log("❌ FORÇA: Tabela não encontrada");
                        }
                    }, 500);

                    return "Inicialização forçada - verifique o console para resultados";
                },
                diagnosticarMenuContexto: function () {
                    console.log(
                        "🔍 DIAGNÓSTICO COMPLETO: Menu de contexto dos localizadores"
                    );

                    const currentUrl = window.location.href;
                    const isLocalizadoresPage = currentUrl.includes(
                        "acao=usuario_tipo_monitoramento_localizador_listar"
                    );
                    const tabela = document.querySelector(
                        'table.infraTable[summary*="Localizadores"]'
                    );
                    const linhas = tabela
                        ? tabela.querySelectorAll(
                              "tbody tr:not(.eprobe-divisor-linha)"
                          )
                        : [];
                    const infoSeparadores = document.getElementById(
                        "eprobe-info-separadores"
                    );

                    // Verificar event listeners nas linhas
                    let linhasComEventListener = 0;
                    if (linhas.length > 0) {
                        linhas.forEach((linha, index) => {
                            // Verificar se tem cursor de contexto
                            const hasContextCursor =
                                linha.style.cursor === "context-menu";
                            const hasTitle =
                                linha.title &&
                                linha.title.includes("botão direito");

                            if (hasContextCursor || hasTitle) {
                                linhasComEventListener++;
                            }

                            console.log(`📋 Linha ${index + 1}:`, {
                                hasContextCursor,
                                hasTitle,
                                title: linha.title || "sem title",
                            });
                        });
                    }

                    const relatorio = {
                        url: currentUrl,
                        isLocalizadoresPage,
                        tabelaEncontrada: !!tabela,
                        numeroLinhas: linhas.length,
                        linhasComEventListener,
                        infoSeparadoresExiste: !!infoSeparadores,
                        funcaoDetectarDisponivel:
                            typeof detectarPaginaLocalizadores === "function",
                        funcaoProcessarDisponivel:
                            typeof processarTabelaLocalizadores === "function",
                        funcaoMenuContextoDisponivel:
                            typeof adicionarMenuContextoLinhas === "function",
                    };

                    console.log("📊 RELATÓRIO DIAGNÓSTICO:", relatorio);

                    // Sugestões baseadas no diagnóstico
                    if (!isLocalizadoresPage) {
                        console.log(
                            "❌ PROBLEMA: Não está na página de localizadores"
                        );
                        console.log(
                            "💡 SOLUÇÃO: Navegue para 'Controle de Processos > Meus Localizadores'"
                        );
                    } else if (!tabela) {
                        console.log(
                            "❌ PROBLEMA: Tabela de localizadores não encontrada"
                        );
                        console.log(
                            "💡 SOLUÇÃO: Verifique se a página carregou completamente"
                        );
                    } else if (linhasComEventListener === 0) {
                        console.log(
                            "❌ PROBLEMA: Linhas não têm event listeners configurados"
                        );
                        console.log(
                            "💡 SOLUÇÃO: Execute window.SENT1_AUTO.forcarInicializacaoLocalizadores()"
                        );
                    } else {
                        console.log(
                            "✅ STATUS: Sistema parece estar configurado corretamente"
                        );
                        console.log(
                            "💡 TESTE: Clique com botão direito em qualquer linha da tabela"
                        );
                    }

                    return relatorio;
                },
                testarMenuContextoForcado: function () {
                    console.log(
                        "🧪 TESTE: Simulando clique direito para testar menu"
                    );

                    const tabela = document.querySelector(
                        'table.infraTable[summary*="Localizadores"]'
                    );
                    if (!tabela) {
                        console.log("❌ TESTE: Tabela não encontrada");
                        return false;
                    }

                    const linhas = tabela.querySelectorAll(
                        "tbody tr:not(.eprobe-divisor-linha)"
                    );
                    if (linhas.length === 0) {
                        console.log("❌ TESTE: Nenhuma linha encontrada");
                        return false;
                    }

                    // Testar na primeira linha
                    const primeiraLinha = linhas[0];
                    console.log(
                        "🎯 TESTE: Testando primeira linha:",
                        primeiraLinha
                    );

                    // Criar evento de contexto simulado
                    const eventoContexto = new MouseEvent("contextmenu", {
                        bubbles: true,
                        cancelable: true,
                        clientX: 100,
                        clientY: 100,
                        button: 2,
                    });

                    console.log("📤 TESTE: Disparando evento contextmenu...");
                    const resultado =
                        primeiraLinha.dispatchEvent(eventoContexto);

                    // Verificar se o menu foi criado
                    setTimeout(() => {
                        const menu = document.getElementById(
                            "eprobe-menu-contexto-separador"
                        );
                        if (menu) {
                            console.log(
                                "✅ TESTE: Menu criado com sucesso!",
                                menu
                            );
                            // Remover o menu após 3 segundos
                            setTimeout(() => {
                                menu.remove();
                                console.log(
                                    "🗑️ TESTE: Menu removido automaticamente"
                                );
                            }, 3000);
                        } else {
                            console.log("❌ TESTE: Menu não foi criado");
                        }
                    }, 100);

                    return resultado;
                },
                testarMenuCompleto: function () {
                    console.log(
                        "🧪 TESTE COMPLETO: Sistema de menu de contexto para separadores"
                    );

                    // 1. Verificar se estamos na página correta
                    const currentUrl = window.location.href;
                    const isLocalizadoresPage = currentUrl.includes(
                        "acao=usuario_tipo_monitoramento_localizador_listar"
                    );

                    if (!isLocalizadoresPage) {
                        console.log(
                            "❌ ERRO: Não está na página de localizadores"
                        );
                        console.log(
                            "💡 SOLUÇÃO: Navegue para 'Controle de Processos > Meus Localizadores'"
                        );
                        return false;
                    }

                    // 2. Verificar tabela
                    const tabela = document.querySelector(
                        'table.infraTable[summary*="Localizadores"]'
                    );
                    if (!tabela) {
                        console.log(
                            "❌ ERRO: Tabela de localizadores não encontrada"
                        );
                        return false;
                    }

                    // 3. Verificar linhas
                    const linhas = tabela.querySelectorAll(
                        "tbody tr:not(.eprobe-divisor-linha)"
                    );
                    console.log(
                        `✅ Encontradas ${linhas.length} linhas de localizadores`
                    );

                    // 4. Verificar se as linhas têm event listeners configurados
                    let linhasComListener = 0;
                    linhas.forEach((linha, index) => {
                        if (
                            linha.style.cursor === "context-menu" ||
                            (linha.title &&
                                linha.title.includes("botão direito"))
                        ) {
                            linhasComListener++;
                        }
                    });

                    console.log(
                        `✅ ${linhasComListener} linhas têm event listeners configurados`
                    );

                    // 5. Teste de criação de menu simulado com overlay
                    if (linhas.length > 0) {
                        console.log(
                            "🧪 Simulando clique direito na primeira linha com sistema de overlay..."
                        );

                        const primeiraLinha = linhas[0];
                        const rect = primeiraLinha.getBoundingClientRect();
                        const evento = new MouseEvent("contextmenu", {
                            bubbles: true,
                            cancelable: true,
                            clientX: rect.left + 100, // Posição visível na tela
                            clientY: rect.top + 10, // Posição visível na tela
                            button: 2,
                        });

                        primeiraLinha.dispatchEvent(evento);

                        // Verificar se menu e overlay foram criados
                        setTimeout(() => {
                            const menu = document.getElementById(
                                "eprobe-menu-contexto-separador"
                            );
                            const overlay = document.getElementById(
                                "eprobe-menu-overlay"
                            );

                            if (menu && overlay) {
                                console.log(
                                    "✅ SUCESSO: Menu com overlay criado!",
                                    { menu, overlay }
                                );
                                console.log("🎯 POSIÇÃO DO MENU:", {
                                    left: menu.style.left,
                                    top: menu.style.top,
                                    zIndex: menu.style.zIndex,
                                });
                                console.log(
                                    "🛡️ OVERLAY Z-INDEX:",
                                    overlay.style.zIndex
                                );
                                console.log(
                                    "🚫 MENU NATIVO BLOQUEADO: Overlay ativo"
                                );

                                // Remover menu após 3 segundos
                                setTimeout(() => {
                                    overlay.remove(); // Remove overlay e menu junto
                                    console.log(
                                        "🗑️ Menu e overlay removidos automaticamente"
                                    );
                                }, 3000);
                            } else {
                                console.log(
                                    "❌ FALHA: Menu ou overlay não foi criado"
                                );
                                if (!menu)
                                    console.log("  - Menu principal ausente");
                                if (!overlay)
                                    console.log(
                                        "  - Overlay de bloqueio ausente"
                                    );
                            }
                        }, 100);
                    }

                    const resultado = {
                        paginaCorreta: isLocalizadoresPage,
                        tabelaEncontrada: !!tabela,
                        numeroLinhas: linhas.length,
                        linhasComListener: linhasComListener,
                        percentualConfigurado: Math.round(
                            (linhasComListener / linhas.length) * 100
                        ),
                    };

                    console.log("📊 RESULTADO FINAL:", resultado);
                    console.log(
                        resultado.percentualConfigurado === 100
                            ? "✅ SISTEMA 100% FUNCIONAL"
                            : "⚠️ SISTEMA PARCIALMENTE CONFIGURADO"
                    );

                    return resultado;
                },
                // Funções de status de sessão
                detectarStatusSessao: statusFunctions.detectarStatusSessao,
                obterTextoCardPorStatus:
                    statusFunctions.obterTextoCardPorStatus,
                obterCorCardPorStatus: statusFunctions.obterCorCardPorStatus,
                getStatusSessao: statusFunctions.getStatusSessao,
                hasStatusSessao: statusFunctions.hasStatusSessao,
                resetStatusSessao: statusFunctions.resetStatusSessao,
                showStatusSessaoInfo: statusFunctions.showStatusSessaoInfo,

                // 🔍 FUNÇÕES DE DEBUG PARA STATUS DE SESSÃO - IMPLEMENTAÇÕES DIRETAS
                debugDeteccaoStatusSessao: function () {
                    log("🔍 DEBUG: Detectando status de sessão manualmente...");
                    return detectarCardSessaoSimplificado();
                },
                debugStatusSessao: function () {
                    log(
                        "🔍 DEBUG: Mostrando informações do status da sessão..."
                    );
                    return statusFunctions.showStatusSessaoInfo();
                },

                // 🎯 SISTEMA UNIFICADO DE SESSÕES - ÚNICA IMPLEMENTAÇÃO
                detectarSessoesUnificado: detectarSessoesUnificado,
                detectarCardSessaoSimplificado: detectarSessoesUnificado, // Alias para compatibilidade
                aplicarTooltipUnificado: aplicarTooltipUnificado,
                diagnosticarSistemaCompleto: diagnosticarSistemaCompleto,
                obterCorPorStatus: obterCorPorStatus,
                extrairDadosPautaMesa: extrairDadosPautaMesa, // 🎯 NOVA: Extração de dados de pauta/mesa

                // 🧪 TESTE ESPECÍFICO PARA DADOS DE PAUTA/MESA
                testarExtracaoPautaMesa: function (dataTeste = "21/08/2025") {
                    console.log(
                        "🧪 TESTE PAUTA/MESA: Iniciando teste de extração..."
                    );
                    console.log(
                        `📅 TESTE PAUTA/MESA: Data para teste: ${dataTeste}`
                    );

                    // Verificar se estamos na página correta
                    const tabelaEventos = document.querySelector("#tblEventos");
                    if (!tabelaEventos) {
                        console.log(
                            "❌ TESTE PAUTA/MESA: Tabela #tblEventos não encontrada"
                        );
                        console.log(
                            "💡 TESTE PAUTA/MESA: Este teste deve ser executado na página de detalhes do processo"
                        );
                        return { erro: "Tabela de eventos não encontrada" };
                    }

                    console.log(
                        "✅ TESTE PAUTA/MESA: Tabela de eventos encontrada"
                    );

                    // Executar extração
                    const resultado = extrairDadosPautaMesa(dataTeste);

                    if (resultado) {
                        console.log(
                            "🎉 TESTE PAUTA/MESA: Dados extraídos com sucesso!"
                        );
                        console.table(resultado);

                        // Verificar estrutura dos dados
                        const estruturaCorreta = {
                            temTipoInclusao:
                                resultado.hasOwnProperty("tipoInclusao"),
                            temModalidade:
                                resultado.hasOwnProperty("modalidade"),
                            temSequencial:
                                resultado.hasOwnProperty("sequencial"),
                            temDataEncontrada:
                                resultado.hasOwnProperty("dataEncontrada"),
                            temEventoId: resultado.hasOwnProperty("eventoId"),
                        };

                        console.log(
                            "🔍 TESTE PAUTA/MESA: Verificação de estrutura:",
                            estruturaCorreta
                        );

                        return {
                            sucesso: true,
                            dados: resultado,
                            estrutura: estruturaCorreta,
                        };
                    } else {
                        console.log(
                            "❌ TESTE PAUTA/MESA: Nenhum dado encontrado para a data especificada"
                        );

                        // Listar todos os eventos para debug
                        const linhasEvento =
                            tabelaEventos.querySelectorAll(
                                'tr[id^="trEvento"]'
                            );
                        console.log(
                            `🔍 TESTE PAUTA/MESA: ${linhasEvento.length} eventos encontrados na tabela:`
                        );

                        linhasEvento.forEach((linha, index) => {
                            const labelDescricao = linha.querySelector(
                                "label.infraEventoDescricao"
                            );
                            const texto = labelDescricao
                                ? labelDescricao.textContent
                                : "N/A";
                            console.log(
                                `   ${index + 1}. ${
                                    linha.id
                                }: ${texto.substring(0, 100)}...`
                            );
                        });

                        return {
                            sucesso: false,
                            totalEventos: linhasEvento.length,
                        };
                    }
                },

                // 🧪 FUNÇÃO DE TESTE PARA PADRÃO ESPECÍFICO
                testarPadraoEspecifico: function () {
                    console.log(
                        "🧪 TESTE ESPECÍFICO: Testando padrão do usuário..."
                    );

                    const textoTeste =
                        "Mérito (Julgado em Pauta em 01/07/2025 - CAMPUB5)";
                    const padraoUnificado =
                        /^([A-Za-zÀ-ÿ\s]+?)\s*\((Julgado|Retirado|Incluído)\s+em\s+Pauta\s+em\s+(\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9\-º]+(?:\s+[A-Z]+)*)\)$/;

                    console.log("📝 Texto de teste:", textoTeste);
                    console.log("🎯 Regex unificado:", padraoUnificado);

                    const match = textoTeste.match(padraoUnificado);

                    if (match) {
                        const [, tipo, status, data, orgao] = match;
                        const sessao = {
                            tipo: tipo.trim(),
                            status: status.trim(),
                            data: data.trim(),
                            orgao: orgao.trim(),
                            textoCompleto: textoTeste,
                            cor: obterCorPorStatus(status.trim()),
                        };

                        console.log("✅ SUCESSO! Sessão detectada:", sessao);

                        // Tentar criar tooltip se card existir
                        const card =
                            document.getElementById("eprobe-data-sessao");
                        if (card) {
                            aplicarTooltipUnificado(card, [sessao]);
                            console.log("🎨 Tooltip aplicado ao card");
                        }

                        return sessao;
                    } else {
                        console.log("❌ FALHA: Padrão não correspondeu");
                        return null;
                    }
                },
                testarPadraoEspecifico: function () {
                    console.log(
                        "🧪 TESTE ESPECÍFICO: Testando padrão do usuário..."
                    );

                    const textoTeste =
                        "Mérito (Julgado em Pauta em 01/07/2025 - CAMPUB5)";
                    const padraoUnificado =
                        /^([A-Za-zÀ-ÿ\s]+?)\s*\((Julgado|Retirado|Incluído)\s+em\s+Pauta\s+em\s+(\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9\-º]+(?:\s+[A-Z]+)*)\)$/;

                    console.log("📝 Texto de teste:", textoTeste);
                    console.log("🎯 Regex unificado:", padraoUnificado);

                    const match = textoTeste.match(padraoUnificado);

                    if (match) {
                        const [, tipo, status, data, orgao] = match;
                        const sessao = {
                            tipo: tipo.trim(),
                            status: status.trim(),
                            data: data.trim(),
                            orgao: orgao.trim(),
                            textoCompleto: textoTeste,
                            cor: this.obterCorPorStatus(status.trim()),
                        };

                        console.log("✅ SUCESSO! Sessão detectada:", sessao);
                        return sessao;
                    } else {
                        console.log("❌ FALHA: Padrão não correspondeu");
                        return null;
                    }
                },
                criarCardSessaoMaterial: criarCardSessaoMaterial,

                // 🔍 FUNÇÕES DE DIAGNÓSTICO E TESTE IMPLEMENTADAS
                diagnosticarEstruturaDOMMinutas:
                    diagnosticarEstruturaDOMMinutas,
                testarDeteccaoRobusta: testarDeteccaoRobusta,

                // ✅ FUNÇÕES DE LOCALIZADORES (referência corrigida - removida duplicação)
                // As funções de localizadores já estão definidas acima na linha 20410
                // 🎯 TOOLTIP UNIFICADO - ÚNICA IMPLEMENTAÇÃO
                adicionarTooltipUnificado: adicionarTooltipUnificado, // ← FUNÇÃO PRINCIPAL

                // 🚫 FUNÇÕES DESCONTINUADAS (redirecionam para a unificada)
                adicionarTooltipInterativo: adicionarTooltipInterativo, // deprecated
                adicionarRichTooltipMaterialDesign:
                    adicionarRichTooltipMaterialDesign, // deprecated
                criarTooltipSimplificado: criarTooltipSimplificado, // deprecated
                testarFuncaoTooltip: function () {
                    // deprecated
                    log(
                        "⚠️ DEPRECATED: testarFuncaoTooltip - use adicionarTooltipUnificado()"
                    );
                    return false;
                },
                // 🎨 FUNÇÕES DE ESTILIZAÇÃO divLembrete - SISTEMA INTELIGENTE
                debugDivLembrete,
                estilizarDivLembrete,
                estilizarDivLembreteVermelho,
                estilizarDivLembreteAzul,
                estilizarDivLembreteVerde,
                estilizarDivLembreteLaranja,
                estilizarTodosDivLembrete,
                debugTodosDivLembrete,
                aplicarEstilizacaoLembretesRobusta,

                // 🎨 GRADIENTES PARA CAPA DO PROCESSO
                aplicarGradientesCapaProcesso, // 🎯 NOVA: Aplica gradientes na capa do processo
                aplicarGradientesCapaProcessoRobusta, // 🔄 NOVA: Aplicação robusta com retry automático
                aplicarGradientesLegMinutas, // 🎯 NOVA: Aplica gradientes nas legendas e tabelas de minutas
                aplicarGradientesLegMinutasRobusta, // 🔄 NOVA: Aplicação robusta com retry para minutas

                // 🧠 NOVA DETECÇÃO INTELIGENTE DE LEMBRETES
                detectarTiposLembretesNaPagina,

                // 🔄 TESTES DO SISTEMA CORRIGIDO
                testarSistemaEstilizacaoCorrigido: function () {
                    log("🧪 TESTE: Sistema de estilização inteligente...");
                    log("1️⃣ Detectando tipos de lembretes...");
                    const deteccao = detectarTiposLembretesNaPagina();
                    log("2️⃣ Aplicando estilização robusta...");
                    aplicarEstilizacaoLembretesRobusta();
                    return deteccao;
                },

                // 🚨 DIAGNÓSTICO COMPLETO DE LEMBRETES
                diagnosticarLembretesCompleto: function () {
                    log(
                        "🔍 DIAGNÓSTICO COMPLETO: Analisando sistema de lembretes..."
                    );

                    // 1. Verificar se as funções existem
                    const funcoesExistem = {
                        detectarTiposLembretesNaPagina:
                            typeof detectarTiposLembretesNaPagina ===
                            "function",
                        aplicarEstilizacaoImediataLembretes:
                            typeof aplicarEstilizacaoImediataLembretes ===
                            "function",
                        aplicarEstilizacaoLembretesRobusta:
                            typeof aplicarEstilizacaoLembretesRobusta ===
                            "function",
                        estilizarTodosDivLembrete:
                            typeof estilizarTodosDivLembrete === "function",
                    };

                    log("📊 FUNÇÕES DISPONÍVEIS:", funcoesExistem);

                    // 2. Detectar lembretes na página
                    const deteccao = detectarTiposLembretesNaPagina();
                    log("🎯 DETECÇÃO:", deteccao);

                    // 3. Tentar múltiplos seletores
                    const seletoresTeste = [
                        "div.divLembrete",
                        ".lista-lembretes .lembrete",
                        'div[style*="#efef8f"]',
                        'div[style*="#db8080"]',
                        'div[style*="#87adcd"]',
                        'div[style*="#a7eda7"]',
                        'div[style*="#f5b574"]',
                    ];

                    const resultadosSeletores = {};
                    seletoresTeste.forEach((seletor) => {
                        const elementos = document.querySelectorAll(seletor);
                        resultadosSeletores[seletor] = elementos.length;
                        if (elementos.length > 0) {
                            log(
                                `✅ ${seletor}: ${elementos.length} elementos encontrados`
                            );
                        }
                    });

                    // 4. Forçar estilização se elementos existem
                    let totalEstilizados = 0;
                    if (deteccao.coresEncontradas.length > 0) {
                        log("🎨 FORÇANDO ESTILIZAÇÃO...");
                        totalEstilizados =
                            estilizarTodosDivLembrete().total || 0;
                    }

                    const diagnostico = {
                        funcoesExistem,
                        deteccao,
                        resultadosSeletores,
                        totalEstilizados,
                        sucesso: totalEstilizados > 0,
                    };

                    log("🏁 DIAGNÓSTICO FINAL:", diagnostico);
                    return diagnostico;
                },

                // 🔧 FORÇAR ESTILIZAÇÃO MANUAL
                forcarEstilizacaoLembretes: function () {
                    log(
                        "🚀 FORÇA: Forçando estilização manual de lembretes..."
                    );

                    try {
                        // Tentar detecção primeiro
                        const deteccao = detectarTiposLembretesNaPagina();

                        if (deteccao.coresEncontradas.length === 0) {
                            log(
                                "⚠️ Nenhum lembrete encontrado, tentando seletores alternativos..."
                            );

                            // Tentar seletores genéricos
                            const seletoresGenéricos = [
                                'div[style*="background-color"]',
                                ".lista-lembretes div",
                                "div.divLembrete",
                            ];

                            for (const seletor of seletoresGenéricos) {
                                const elementos =
                                    document.querySelectorAll(seletor);
                                if (elementos.length > 0) {
                                    log(
                                        `✅ Encontrados ${elementos.length} elementos com ${seletor}`
                                    );

                                    elementos.forEach((elem, i) => {
                                        const style =
                                            elem.getAttribute("style") || "";
                                        if (
                                            style.includes("background-color")
                                        ) {
                                            log(
                                                `🎨 Estilizando elemento ${
                                                    i + 1
                                                }:`,
                                                style
                                            );

                                            // Aplicar gradiente baseado na cor
                                            if (style.includes("#efef8f")) {
                                                elem.style.background =
                                                    "linear-gradient(#F9EFAF, #F7E98D)";
                                            } else if (
                                                style.includes("#db8080")
                                            ) {
                                                elem.style.background =
                                                    "linear-gradient(#FAAFAF, #F78D8D)";
                                            } else if (
                                                style.includes("#87adcd")
                                            ) {
                                                elem.style.background =
                                                    "linear-gradient(#AFCFFA, #8DC0F7)";
                                            } else if (
                                                style.includes("#a7eda7")
                                            ) {
                                                elem.style.background =
                                                    "linear-gradient(#AFFAB6, #8DF792)";
                                            } else if (
                                                style.includes("#f5b574")
                                            ) {
                                                elem.style.background =
                                                    "linear-gradient(#FAD3AF, #F7C68D)";
                                            }

                                            // Aplicar estilos adicionais
                                            elem.style.padding = "20px";
                                            elem.style.boxShadow =
                                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                                            elem.style.transition =
                                                "box-shadow 0.5s ease";
                                        }
                                    });
                                    break;
                                }
                            }
                        } else {
                            // Usar detecção inteligente
                            aplicarEstilizacaoLembretesRobusta();
                        }

                        log("✅ FORÇA: Estilização manual concluída");
                        return true;
                    } catch (error) {
                        log(
                            "❌ FORÇA: Erro durante estilização manual:",
                            error
                        );
                        return false;
                    }
                },
                // 🔍 FUNÇÕES DE DEBUG PARA STATUS
                debugPadraoRetirado: allMissingFunctions.debugPadraoRetirado,
                debugStatusCompleto: allMissingFunctions.debugStatusCompleto,
                forcarAtualizacaoStatus:
                    allMissingFunctions.forcarAtualizacaoStatus,
                testarCasoRetirado: allMissingFunctions.testarCasoRetirado,
                debugStatusSessao: showStatusSessaoInfo,
                testarSistemaStatusSessao:
                    allMissingFunctions.testarSistemaStatusSessao,
                // 🔄 FUNÇÕES DE DEBUG PARA ALTERNÂNCIA
                findToggleTarget: allMissingFunctions.findToggleTarget,
                implementarAlternanciaExpandirRetrair:
                    allMissingFunctions.implementarAlternanciaExpandirRetrair,
                isElementSafeForToggle:
                    allMissingFunctions.isElementSafeForToggle,

                // ========== FUNÇÕES CONSOLIDADAS (anteriormente espalhadas) ==========

                // 🧪 FUNÇÕES DE TESTE SIMPLIFICADO
                debugPadroesStatusSessao:
                    allMissingFunctions.debugPadroesStatusSessao,
                forcarStatusSessao: allMissingFunctions.forcarStatusSessao,
                encontrarTextoRetirado:
                    allMissingFunctions.encontrarTextoRetirado,
                forcarDeteccaoCompleta:
                    allMissingFunctions.forcarDeteccaoCompleta,

                // 🧪 TESTE CRÍTICO PARA DETECÇÃO DINÂMICA DE FIELDSET
                testarDeteccaoDinamicaFieldset: testarDeteccaoDinamicaFieldset,

                // 🔧 FUNÇÕES AUXILIARES - Extração e normalização de dados
                getData: getData,
                extrairDataSessaoNormalizada: extrairDataSessaoNormalizada,

                // 🎨 FUNÇÕES DE ÍCONES
                substituirIconesFieldsetAcoes:
                    allMissingFunctions.substituirIconesFieldsetAcoes,
                substituirIconesFerramentas:
                    allMissingFunctions.substituirIconesFerramentas,
                substituirIconesGlobalmente:
                    allMissingFunctions.substituirIconesGlobalmente,
                // ✨ NOVO: Funções específicas para ícones de lembretes
                substituirIconesLembretes: substituirIconesLembretes,
                // 🔄 NOVO: Reaplicação forçada de ícones após atualização AJAX
                reaplicarIconesAposAtualizacao: reaplicarIconesAposAtualizacao,
                // ⚡ NOVO: Anti-flash crítico para ícones
                aplicarAntiFlashIcones: aplicarAntiFlashIcones,
                // 🔄 NOVO: Interceptor para múltiplos botões de atualizar minutas
                setupInterceptorTodosBotoesAtualizar:
                    setupInterceptorTodosBotoesAtualizar,
                testarIconesLembretes: testarIconesLembretes,
                // ⚡ NOVO: Funções para eliminar flash visual
                aplicarEstilizacaoImediataLembretes:
                    aplicarEstilizacaoImediataLembretes,
                substituirIconesLembretesImediato:
                    substituirIconesLembretesImediato,
                debugIconesSubstituicao:
                    allMissingFunctions.debugIconesSubstituicao,
                configurarAlternanciaEstrelas: function () {
                    log(
                        "⚠️ ESTRELAS: Função configurarAlternanciaEstrelas foi removida (prevenção de erros)"
                    );
                    return 0; // Retorna 0 estrelas configuradas
                },

                // 🔍 FUNÇÕES DE DIAGNÓSTICO E CORREÇÃO - IMPLEMENTAÇÕES REAIS
                diagnosticarCompleto:
                    debugInterfaceFunctions.diagnosticarCompleto,
                corrigirProblemas: debugInterfaceFunctions.corrigirProblemas,
                corrigirPointerEventsBotoes: corrigirPointerEventsBotoes, // CORREÇÃO CRÍTICA para botões bloqueados
                corrigirSwitchRelevanciaDocumento:
                    corrigirSwitchRelevanciaDocumento, // CORREÇÃO CRÍTICA para função de relevância
                corrigirSwitchRelevanciaDocumentoRobusta:
                    corrigirSwitchRelevanciaDocumentoRobusta, // NOVA VERSÃO ROBUSTA - usa implementação própria
                forcarReaplicacaoIcones: forcarReaplicacaoIcones, // Implementação real
                inicializarSubstituicaoIcones: inicializarSubstituicaoIcones, // Implementação real
                diagnosticarIconesCSS:
                    debugInterfaceFunctions.diagnosticarIconesCSS,

                // Função de teste para verificar restrições de personalização
                testarRestricaoPersonalizacaoIcones: () => {
                    const urlAtual = window.location.href;
                    const isCapaProcesso = isCapaProcessoPage();

                    console.log("🔍 TESTE RESTRIÇÃO PERSONALIZAÇÃO:");
                    console.log("📍 URL atual:", urlAtual);
                    console.log(
                        "🏠 É página de capa do processo:",
                        isCapaProcesso
                    );

                    if (isCapaProcesso) {
                        console.log(
                            "✅ PERMITIDO: Personalização de ícones habilitada"
                        );
                        console.log("🎨 Testando inicialização de ícones...");
                        if (
                            typeof inicializarSubstituicaoIcones === "function"
                        ) {
                            const resultado = inicializarSubstituicaoIcones();
                            console.log("📊 Resultado:", resultado);
                        }
                    } else {
                        console.log(
                            "⛔ BLOQUEADO: Personalização restrita a páginas de capa"
                        );
                        console.log(
                            "💡 Para testar, navegue para uma página que contenha:"
                        );
                        console.log(
                            "   • eproc1g.tjsc.jus.br/eproc/controlador.php?acao=processo_selecionar&"
                        );
                        console.log(
                            "   • eproc2g.tjsc.jus.br/eproc/controlador.php?acao=processo_selecionar&"
                        );
                    }

                    return {
                        urlAtual,
                        isCapaProcesso,
                        personalizacaoPermitida: isCapaProcesso,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };
                },

                // 📏 Função de teste para verificar dimensionamento em divListaRecursosMinuta
                testarDimensionamentoRecursosMinuta: () => {
                    console.log("📏 TESTE DIMENSIONAMENTO RECURSOS MINUTA:");

                    const divListaRecursos = document.getElementById(
                        "divListaRecursosMinuta"
                    );

                    if (!divListaRecursos) {
                        console.log(
                            "⚠️ divListaRecursosMinuta não encontrado na página atual"
                        );
                        return {
                            encontrado: false,
                            icones: 0,
                            iconesCorretos: 0,
                            timestamp: new Date().toLocaleString("pt-BR"),
                        };
                    }

                    console.log(
                        "✅ divListaRecursosMinuta encontrado:",
                        divListaRecursos
                    );

                    // Buscar todos os ícones SVG dentro da div
                    const iconesSvg = divListaRecursos.querySelectorAll(
                        'svg[data-eprobe-icon-replaced="true"]'
                    );
                    console.log(
                        `📊 Total de ícones SVG eProbe encontrados: ${iconesSvg.length}`
                    );

                    let iconesCorretos = 0;
                    const detalhes = [];

                    iconesSvg.forEach((svg, index) => {
                        const width =
                            svg.style.width ||
                            svg.getAttribute("width") ||
                            "não definido";
                        const height =
                            svg.style.height ||
                            svg.getAttribute("height") ||
                            "não definido";
                        const isCorreto =
                            width === "17.59px" && height === "17.59px";

                        if (isCorreto) iconesCorretos++;

                        const detalhe = {
                            indice: index + 1,
                            width,
                            height,
                            tamanhoCorreto: isCorreto,
                            temMarcacao: svg.hasAttribute(
                                "data-eprobe-recursos-minuta-sized"
                            ),
                            originalType:
                                svg.getAttribute("data-original-name") ||
                                "desconhecido",
                        };

                        detalhes.push(detalhe);

                        console.log(`📐 Ícone ${index + 1}:`, detalhe);

                        // Se não estiver no tamanho correto, aplicar correção
                        if (!isCorreto) {
                            console.log(
                                `🔧 Corrigindo dimensão do ícone ${
                                    index + 1
                                }...`
                            );
                            aplicarDimensionamentoRecursosMinuta(svg);
                        }
                    });

                    const resultado = {
                        encontrado: true,
                        divId: "divListaRecursosMinuta",
                        icones: iconesSvg.length,
                        iconesCorretos,
                        porcentagemCorretos:
                            iconesSvg.length > 0
                                ? (
                                      (iconesCorretos / iconesSvg.length) *
                                      100
                                  ).toFixed(1) + "%"
                                : "0%",
                        detalhes,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };

                    console.log("📊 RESULTADO FINAL:", resultado);

                    if (
                        iconesCorretos === iconesSvg.length &&
                        iconesSvg.length > 0
                    ) {
                        console.log(
                            "✅ Todos os ícones estão no tamanho correto (17.59x17.59)!"
                        );
                    } else if (iconesSvg.length === 0) {
                        console.log(
                            "⚠️ Nenhum ícone eProbe encontrado em divListaRecursosMinuta"
                        );
                    } else {
                        console.log(
                            `⚠️ ${
                                iconesSvg.length - iconesCorretos
                            } ícones precisam de correção`
                        );

                        // Aplicar correção automática de alinhamento se necessário
                        console.log(
                            "🔧 Aplicando correção automática de alinhamento..."
                        );
                        if (
                            typeof corrigirAlinhamentoRecursosMinuta ===
                            "function"
                        ) {
                            const correcao =
                                corrigirAlinhamentoRecursosMinuta();
                            resultado.correcaoAlinhamento = correcao;
                            console.log("📊 Resultado da correção:", correcao);
                        }
                    }

                    return resultado;
                },

                // 🔧 Função para corrigir alinhamento em divListaRecursosMinuta
                corrigirAlinhamentoRecursosMinuta: () => {
                    console.log("🔧 CORREÇÃO ALINHAMENTO RECURSOS MINUTA:");

                    if (
                        typeof corrigirAlinhamentoRecursosMinuta === "function"
                    ) {
                        const resultado = corrigirAlinhamentoRecursosMinuta();
                        console.log("📊 Resultado da correção:", resultado);

                        if (resultado.encontrado) {
                            console.log(
                                `✅ Correção aplicada: ${resultado.iconesCorrigidos} ícones processados`
                            );
                            console.log(
                                `🔗 Links corrigidos: ${resultado.linksCorrigidos}`
                            );
                            console.log(
                                `💅 CSS aplicado: ${resultado.cssAplicado}`
                            );
                        } else {
                            console.log(
                                "⚠️ divListaRecursosMinuta não encontrado"
                            );
                        }

                        return resultado;
                    } else {
                        console.log(
                            "❌ Função corrigirAlinhamentoRecursosMinuta não disponível"
                        );
                        return { erro: "função não disponível" };
                    }
                },

                // 👁️ Função para diagnóstico visual de alinhamento em divListaRecursosMinuta
                diagnosticarAlinhamentoVisual: () => {
                    console.log("👁️ DIAGNÓSTICO VISUAL RECURSOS MINUTA:");

                    const divListaRecursos = document.getElementById(
                        "divListaRecursosMinuta"
                    );

                    if (!divListaRecursos) {
                        console.log(
                            "⚠️ divListaRecursosMinuta não encontrado na página atual"
                        );
                        return { encontrado: false };
                    }

                    // Aplicar estilos visuais temporários para debug
                    const diagnosticStyle = document.createElement("style");
                    diagnosticStyle.id = "eprobe-diagnostic-style";

                    // Remover estilo anterior se existir
                    const oldDiagnostic = document.getElementById(
                        "eprobe-diagnostic-style"
                    );
                    if (oldDiagnostic) oldDiagnostic.remove();

                    diagnosticStyle.textContent = `
                        /* DIAGNÓSTICO VISUAL TEMPORÁRIO */
                        #divListaRecursosMinuta {
                            background: rgba(255, 255, 0, 0.1) !important;
                            border: 2px dashed orange !important;
                            padding: 5px !important;
                        }
                        
                        #divListaRecursosMinuta * {
                            outline: 1px solid rgba(255, 0, 0, 0.3) !important;
                        }
                        
                        #divListaRecursosMinuta img {
                            background: rgba(0, 255, 0, 0.3) !important;
                            outline: 2px solid green !important;
                        }
                        
                        #divListaRecursosMinuta svg[data-eprobe-icon-replaced="true"] {
                            background: rgba(0, 0, 255, 0.3) !important;
                            outline: 2px solid blue !important;
                        }
                        
                        #divListaRecursosMinuta a {
                            background: rgba(255, 0, 255, 0.2) !important;
                        }
                    `;

                    document.head.appendChild(diagnosticStyle);

                    // Coletar informações detalhadas
                    const icones =
                        divListaRecursos.querySelectorAll("img, svg");
                    const links = divListaRecursos.querySelectorAll("a");
                    const iconesPersonalizados =
                        divListaRecursos.querySelectorAll(
                            'svg[data-eprobe-icon-replaced="true"]'
                        );

                    const detalhes = {
                        totalIcones: icones.length,
                        iconesPersonalizados: iconesPersonalizados.length,
                        iconesOriginais:
                            icones.length - iconesPersonalizados.length,
                        totalLinks: links.length,
                    };

                    console.log("📊 Estrutura encontrada:");
                    console.log("🟡 Fundo amarelo: divListaRecursosMinuta");
                    console.log("🟢 Contorno verde: Ícones originais (IMG)");
                    console.log(
                        "🔵 Contorno azul: Ícones personalizados (SVG eProbe)"
                    );
                    console.log("🟣 Fundo roxo: Links (A)");
                    console.log("🔴 Contorno vermelho: Todos os elementos");

                    console.table(detalhes);

                    // Análise individual dos ícones
                    iconesPersonalizados.forEach((svg, index) => {
                        const rect = svg.getBoundingClientRect();
                        const computed = getComputedStyle(svg);

                        console.log(`🔵 Ícone personalizado ${index + 1}:`, {
                            width:
                                svg.style.width ||
                                svg.getAttribute("width") ||
                                "não definido",
                            height:
                                svg.style.height ||
                                svg.getAttribute("height") ||
                                "não definido",
                            computedWidth: computed.width,
                            computedHeight: computed.height,
                            verticalAlign: computed.verticalAlign,
                            display: computed.display,
                            boundingRect: {
                                width: rect.width,
                                height: rect.height,
                                x: Math.round(rect.x),
                                y: Math.round(rect.y),
                            },
                        });
                    });

                    // Auto-remover o estilo após 10 segundos
                    setTimeout(() => {
                        const styleToRemove = document.getElementById(
                            "eprobe-diagnostic-style"
                        );
                        if (styleToRemove) {
                            styleToRemove.remove();
                            console.log(
                                "👁️ Diagnóstico visual removido automaticamente"
                            );
                        }
                    }, 10000);

                    console.log("⏰ Diagnóstico visual ativo por 10 segundos");
                    console.log(
                        "🔧 Para corrigir problemas encontrados, execute: window.SENT1_AUTO.corrigirAlinhamentoRecursosMinuta()"
                    );

                    return {
                        encontrado: true,
                        ...detalhes,
                        diagnosticoAtivo: true,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };
                },

                //   Função para testar reaplicação de ícones em legMinutas
                testarReaplicacaoIconesMinutas: () => {
                    console.log("🔄 TESTE REAPLICAÇÃO ÍCONES MINUTAS:");

                    const legMinutas = document.getElementById("legMinutas");

                    if (!legMinutas) {
                        console.log(
                            "⚠️ legMinutas não encontrado na página atual"
                        );
                        return {
                            encontrado: false,
                            erro: "legMinutas não encontrado",
                        };
                    }

                    console.log("✅ legMinutas encontrado:", legMinutas);

                    // Verificar estado atual dos ícones
                    const iconesOriginais = legMinutas.querySelectorAll(
                        "img:not([data-eprobe-protected])"
                    );
                    const iconesPersonalizados = legMinutas.querySelectorAll(
                        'svg[data-eprobe-icon-replaced="true"]'
                    );
                    const divListaRecursos = legMinutas.querySelector(
                        "#divListaRecursosMinuta"
                    );

                    const estadoAntes = {
                        iconesOriginais: iconesOriginais.length,
                        iconesPersonalizados: iconesPersonalizados.length,
                        temDivListaRecursos: !!divListaRecursos,
                    };

                    console.log("📊 Estado ANTES da reaplicação:", estadoAntes);

                    // Forçar reaplicação de todas as substituições
                    let totalReaplicados = 0;

                    try {
                        // 1. Reaplicar ícones de ferramentas
                        if (typeof substituirIconesFerramentas === "function") {
                            const antes = legMinutas.querySelectorAll(
                                '[data-eprobe-icon-replaced="true"]'
                            ).length;
                            substituirIconesFerramentas();
                            const depois = legMinutas.querySelectorAll(
                                '[data-eprobe-icon-replaced="true"]'
                            ).length;
                            const novos = depois - antes;
                            totalReaplicados += novos;
                            console.log(
                                `🔧 Ícones de ferramentas: +${novos} aplicados`
                            );
                        }

                        // 2. Reaplicar ícones de lembretes
                        if (typeof substituirIconesLembretes === "function") {
                            const antes = legMinutas.querySelectorAll(
                                '[data-eprobe-icon-replaced="true"]'
                            ).length;
                            substituirIconesLembretes();
                            const depois = legMinutas.querySelectorAll(
                                '[data-eprobe-icon-replaced="true"]'
                            ).length;
                            const novos = depois - antes;
                            totalReaplicados += novos;
                            console.log(
                                `📝 Ícones de lembretes: +${novos} aplicados`
                            );
                        }

                        // 3. Reaplicar ícones globais
                        if (typeof substituirIconesGlobalmente === "function") {
                            const antes = legMinutas.querySelectorAll(
                                '[data-eprobe-icon-replaced="true"]'
                            ).length;
                            substituirIconesGlobalmente();
                            const depois = legMinutas.querySelectorAll(
                                '[data-eprobe-icon-replaced="true"]'
                            ).length;
                            const novos = depois - antes;
                            totalReaplicados += novos;
                            console.log(
                                `🌐 Ícones globais: +${novos} aplicados`
                            );
                        }

                        // 4. Corrigir alinhamento se necessário
                        if (
                            divListaRecursos &&
                            typeof corrigirAlinhamentoRecursosMinuta ===
                                "function"
                        ) {
                            const resultado =
                                corrigirAlinhamentoRecursosMinuta();
                            console.log(
                                "📏 Correção de alinhamento:",
                                resultado
                            );
                        }
                    } catch (error) {
                        console.error("❌ Erro durante reaplicação:", error);
                    }

                    // Verificar estado final
                    const iconesOriginaisDepois = legMinutas.querySelectorAll(
                        "img:not([data-eprobe-protected])"
                    );
                    const iconesPersonalizadosDepois =
                        legMinutas.querySelectorAll(
                            'svg[data-eprobe-icon-replaced="true"]'
                        );

                    const estadoDepois = {
                        iconesOriginais: iconesOriginaisDepois.length,
                        iconesPersonalizados: iconesPersonalizadosDepois.length,
                        temDivListaRecursos: !!divListaRecursos,
                    };

                    console.log(
                        "📊 Estado DEPOIS da reaplicação:",
                        estadoDepois
                    );

                    const resultado = {
                        encontrado: true,
                        estadoAntes,
                        estadoDepois,
                        totalReaplicados,
                        diferencaPersonalizados:
                            estadoDepois.iconesPersonalizados -
                            estadoAntes.iconesPersonalizados,
                        diferencaOriginais:
                            estadoAntes.iconesOriginais -
                            estadoDepois.iconesOriginais,
                        sucesso: totalReaplicados > 0,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };

                    if (resultado.sucesso) {
                        console.log(
                            `✅ Reaplicação concluída com sucesso! ${totalReaplicados} ícones processados`
                        );
                        console.log(
                            `📈 Ícones personalizados: ${estadoAntes.iconesPersonalizados} → ${estadoDepois.iconesPersonalizados}`
                        );
                        console.log(
                            `📉 Ícones originais: ${estadoAntes.iconesOriginais} → ${estadoDepois.iconesOriginais}`
                        );
                    } else {
                        console.log(
                            "⚠️ Nenhum ícone foi reaplicado - possível problema na detecção ou nenhum ícone original encontrado"
                        );
                    }

                    return resultado;
                },

                //  🔧 FUNÇÕES DE DEBUG PARA CRIAÇÃO DE BOTÃO
                debugButtonCreation:
                    debugInterfaceFunctions.debugButtonCreation,
                forceCreateButton: debugInterfaceFunctions.forceCreateButton,
                ensureButtonExists: nsEnsureButtonExists,
                shouldShowIntegratedButton: nsShouldShowIntegratedButton,
                shouldShowFloatingButton: nsShouldShowFloatingButton,
                getCachedBoundingRect:
                    debugInterfaceFunctions.getCachedBoundingRect,

                // 🔍 INTERFACE OBSERVER GLOBAL
                setupInterfaceObserver:
                    debugInterfaceFunctions.setupInterfaceObserver,

                // 🔧 FUNÇÕES DE DEBUG PARA CARD DE SESSÃO
                debugStatusCard: function () {
                    log(
                        "🔍 DEBUG STATUS CARD: Verificando estado completo do sistema"
                    );
                    const processoAtual = obterNumeroProcesso();
                    const temDados = hasDataSessaoPautado();
                    const dados = getDataSessaoPautado();
                    const cardExiste =
                        !!document.getElementById("eprobe-data-sessao");

                    log({
                        processoAtual,
                        temDados,
                        dados,
                        cardExiste,
                        processosProcessados: Array.from(
                            processosJaProcessados || []
                        ),
                        dataSessaoPautadoGlobal: dataSessaoPautado,
                        processoComDataSessaoGlobal: processoComDataSessao,
                    });

                    return { processoAtual, temDados, dados, cardExiste };
                },

                forcarCriacaoCard: function () {
                    log("🚨 FORÇAR CARD: Criando card com dados de teste");
                    try {
                        // Forçar dados se não existir
                        if (!dataSessaoPautado) {
                            log(
                                "  FORÇA: Criando dados temporários para teste"
                            );
                            dataSessaoPautado = {
                                dataFormatada: new Date().toLocaleDateString(
                                    "pt-BR"
                                ),
                                dataOriginal: new Date().toLocaleDateString(
                                    "pt-BR"
                                ),
                                status: "Pautado (Teste)",
                            };
                            processoComDataSessao =
                                obterNumeroProcesso() || "TESTE-PROCESSO";
                        }

                        return inserirDataSessaoNaInterface();
                    } catch (error) {
                        console.error("❌ ERRO ao forçar criação:", error);
                        return false;
                    }
                },

                testarDeteccaoCompleta: function () {
                    log("🧪 TESTE COMPLETO: Testando todo o fluxo de detecção");

                    // 1. Reset completo
                    this.resetarSistemaCard();

                    // 2. Tentar detecção via XPath
                    log("🔍 PASSO 1: Tentando detecção via XPath");
                    const xpath = this.detectarCardSessaoSimplificado();
                    log("📊 RESULTADO XPATH:", xpath);

                    // 3. Verificar dados salvos
                    log("🔍 PASSO 2: Verificando dados após detecção");
                    log(
                        "  - hasDataSessaoPautado():",
                        this.hasDataSessaoPautado()
                    );
                    log(
                        "  - getDataSessaoPautado():",
                        this.getDataSessaoPautado()
                    );

                    // 4. Tentar criar card
                    log("🔍 PASSO 3: Tentando criar card");
                    const cardCriado = this.inserirDataSessaoNaInterface();
                    log("📊 RESULTADO CRIAÇÃO:", cardCriado);

                    // 5. Verificar se card existe
                    const cardExiste =
                        !!document.getElementById("eprobe-data-sessao");
                    log("📊 CARD EXISTE NO DOM:", cardExiste);

                    return {
                        deteccao: !!xpath,
                        temDados: this.hasDataSessaoPautado(),
                        dados: this.getDataSessaoPautado(),
                        cardCriado: cardCriado,
                        cardExiste: cardExiste,
                    };
                },

                // 🧪 FUNÇÃO DE TESTE PARA O NOVO CARD FIGMA COM TOOLTIP
                testarCardFigmaAtualizado: function () {
                    log(
                        "🎨 TESTE FIGMA: Testando novo card com ícone clock e tooltip..."
                    );

                    try {
                        // Dados de teste com múltiplas sessões para tooltip
                        const dadosTeste = [
                            {
                                status: "PAUTADO",
                                data: "28/01/2025",
                                orgao: "2ª CÂMARA",
                                tipo: "Incluído em Pauta",
                                sessoes: [
                                    {
                                        status: "PAUTADO",
                                        data: "28/01/2025",
                                        orgao: "2ª CÂMARA",
                                        tipo: "Incluído em Pauta",
                                        cor: "#5C85B4",
                                    },
                                    {
                                        status: "ADIADO",
                                        data: "20/01/2025",
                                        orgao: "2ª CÂMARA",
                                        tipo: "Sessão Adiada",
                                        cor: "#F55D3E",
                                    },
                                    {
                                        status: "VISTA",
                                        data: "15/01/2025",
                                        orgao: "2ª CÂMARA",
                                        tipo: "Pedido de Vista",
                                        cor: "#FFBF46",
                                    },
                                ],
                            },
                            {
                                status: "JULGADO",
                                data: "28/01/2025",
                                orgao: "1ª CÂMARA",
                                tipo: "Julgamento Finalizado",
                                sessoes: [
                                    {
                                        status: "JULGADO",
                                        data: "28/01/2025",
                                        orgao: "1ª CÂMARA",
                                        tipo: "Julgamento Finalizado",
                                        cor: "#3AB795",
                                    },
                                    {
                                        status: "PAUTADO",
                                        data: "21/01/2025",
                                        orgao: "1ª CÂMARA",
                                        tipo: "Incluído em Pauta",
                                        cor: "#5C85B4",
                                    },
                                ],
                            },
                            {
                                status: "RETIRADO",
                                data: "28/01/2025",
                                orgao: "3ª CÂMARA",
                                tipo: "Retirado de Pauta",
                            },
                            {
                                status: "SOBRESTADO",
                                data: "28/01/2025",
                                orgao: "PLENO",
                                tipo: "Sobrestamento",
                                sessoes: [
                                    {
                                        status: "SOBRESTADO",
                                        data: "28/01/2025",
                                        orgao: "PLENO",
                                        tipo: "Sobrestamento",
                                        cor: "#FCB0B3",
                                    },
                                    {
                                        status: "PAUTADO",
                                        data: "14/01/2025",
                                        orgao: "PLENO",
                                        tipo: "Incluído em Pauta",
                                        cor: "#5C85B4",
                                    },
                                    {
                                        status: "VISTA",
                                        data: "07/01/2025",
                                        orgao: "PLENO",
                                        tipo: "Pedido de Vista",
                                        cor: "#FFBF46",
                                    },
                                    {
                                        status: "ADIADO",
                                        data: "03/01/2025",
                                        orgao: "PLENO",
                                        tipo: "Sessão Adiada",
                                        cor: "#F55D3E",
                                    },
                                ],
                            },
                        ];

                        log(
                            "🎯 TESTE: Testando com",
                            dadosTeste.length,
                            "variações com tooltip..."
                        );

                        dadosTeste.forEach((dados, index) => {
                            setTimeout(() => {
                                log(
                                    `🎨 TESTE ${
                                        index + 1
                                    }: Criando card para status ${
                                        dados.status
                                    } ${
                                        dados.sessoes
                                            ? `(${dados.sessoes.length} sessões)`
                                            : "(sem histórico)"
                                    }`
                                );

                                // Remover card anterior
                                const cardAnterior = document.getElementById(
                                    "eprobe-card-sessao-material"
                                );
                                if (cardAnterior) {
                                    cardAnterior.remove();
                                }

                                // Criar novo card
                                const card = criarCardSessaoMaterial(dados);

                                if (card) {
                                    log(
                                        `✅ TESTE ${
                                            index + 1
                                        }: Card criado com sucesso!`
                                    );
                                    log(
                                        `🎨 STATUS: ${dados.status} → COR aplicada`
                                    );
                                    log(
                                        `📍 POSIÇÃO: Card integrado na interface`
                                    );
                                    if (
                                        dados.sessoes &&
                                        dados.sessoes.length > 1
                                    ) {
                                        log(
                                            `🖱️ TOOLTIP: Passe o mouse sobre o card para ver ${dados.sessoes.length} sessões!`
                                        );
                                    }
                                } else {
                                    log(
                                        `❌ TESTE ${
                                            index + 1
                                        }: Falha ao criar card`
                                    );
                                }
                            }, index * 3000); // 3 segundos entre cada teste para permitir interação
                        });

                        return "🎨 TESTE FIGMA: Sequência de testes com tooltip iniciada!";
                    } catch (error) {
                        console.error("❌ TESTE FIGMA: Erro no teste:", error);
                        return "❌ TESTE FIGMA: Erro no teste - veja console";
                    }
                },

                //  FUNÇÃO DE DIAGNÓSTICO DOM PARA ESTRUTURA ROBUSTA
                diagnosticarEstruturaDOMMinutas: function () {
                    logCritical(
                        "🩺 DIAGNÓSTICO: Verificando estrutura DOM para minutas"
                    );

                    const diagnostico = {
                        timestamp: new Date().toLocaleString("pt-BR"),
                        url: window.location.href,
                        processo: obterNumeroProcesso() || "N/A",
                        estrutura: {},
                    };

                    try {
                        // 1. Verificar elementos básicos
                        diagnostico.estrutura.body = !!document.body;
                        diagnostico.estrutura.formProcesso =
                            !!document.querySelector(
                                'form[name="frmProcessoLista"]'
                            );

                        // 2. Verificar todos os fieldsets na página
                        const todosFieldsets =
                            document.querySelectorAll("fieldset");
                        diagnostico.estrutura.totalFieldsets =
                            todosFieldsets.length;

                        // 3. Verificar especificamente o fieldset de minutas
                        const fieldsetMinutas =
                            document.querySelector("#fldMinutas");
                        diagnostico.estrutura.fieldsetMinutas =
                            !!fieldsetMinutas;

                        if (fieldsetMinutas) {
                            // 4. Verificar estrutura interna das minutas
                            const minutasFieldsets =
                                fieldsetMinutas.querySelectorAll(
                                    "div > div:nth-child(2) > fieldset"
                                );
                            diagnostico.estrutura.fieldsetsInternos =
                                minutasFieldsets.length;

                            // 5. Verificar botões de minutas
                            const botoes = fieldsetMinutas.querySelectorAll(
                                "legend > span:first-child > button"
                            );
                            diagnostico.estrutura.botoesMinutas = botoes.length;

                            // 6. Capturar textos dos botões
                            diagnostico.estrutura.textosMinutas = Array.from(
                                botoes
                            )
                                .map((botao) => botao.textContent?.trim())
                                .filter((texto) => texto);
                        }

                        // 7. Verificar fieldsets por posição (método antigo para comparação)
                        for (let i = 1; i <= 20; i++) {
                            const fieldsetPorPosicao = document.querySelector(
                                `form[name="frmProcessoLista"] fieldset:nth-child(${i})`
                            );
                            if (fieldsetPorPosicao) {
                                const id = fieldsetPorPosicao.id;
                                const legend = fieldsetPorPosicao
                                    .querySelector("legend")
                                    ?.textContent?.trim();
                                if (
                                    id === "fldMinutas" ||
                                    legend?.includes("Minutas")
                                ) {
                                    diagnostico.estrutura[
                                        `fieldset_posicao_${i}`
                                    ] = { id, legend };
                                }
                            }
                        }

                        logCritical("📊 DIAGNÓSTICO COMPLETO:", diagnostico);

                        // Mostrar resultado resumido
                        if (diagnostico.estrutura.fieldsetMinutas) {
                            logCritical(
                                `✅ SUCESSO: fieldset#fldMinutas encontrado com ${diagnostico.estrutura.fieldsetsInternos} fieldsets internos e ${diagnostico.estrutura.botoesMinutas} botões`
                            );
                        } else {
                            logCritical(
                                "❌ PROBLEMA: fieldset#fldMinutas não encontrado - verifique se você está na página correta"
                            );
                        }

                        return diagnostico;
                    } catch (error) {
                        diagnostico.erro = error.message;
                        logCritical(
                            `❌ DIAGNÓSTICO: Erro durante a verificação - ${error.message}`
                        );
                        return diagnostico;
                    }
                },

                // 🧪 FUNÇÃO DE TESTE COMPLETO COM LOGS DETALHADOS
                testarDeteccaoComLogsCompletos: function () {
                    logCritical(
                        "🧪 TESTE COMPLETO: Iniciando teste com logs detalhados"
                    );
                    logCritical(
                        `🕐 TIMESTAMP: ${new Date().toLocaleString("pt-BR")}`
                    );
                    logCritical(`🌐 URL: ${window.location.href}`);
                    logCritical(
                        `🔍 PROCESSO: ${obterNumeroProcesso() || "N/A"}`
                    );

                    try {
                        // 1. Reset completo
                        logCritical("🔄 PASSO 1: Resetando sistema...");
                        this.resetarSistemaCard();

                        // 2. Diagnóstico estrutural
                        logCritical(
                            "🩺 PASSO 2: Diagnóstico da estrutura DOM..."
                        );
                        const diagnostico =
                            this.diagnosticarEstruturaDOMMinutas();

                        if (!diagnostico.estrutura.fieldsetMinutas) {
                            logError(
                                "❌ TESTE: fieldset#fldMinutas não encontrado - teste abortado"
                            );

                            // TESTE EMERGENCIAL: Forçar criação do card mesmo sem dados
                            logCritical(
                                "🚨 TESTE EMERGENCIAL: Criando card com dados de teste..."
                            );
                            this.forcarCriacaoCardTeste();

                            return {
                                sucesso: false,
                                erro: "fieldset não encontrado",
                                diagnostico: diagnostico,
                                cardTeste: true,
                            };
                        }

                        // 3. Detecção robusta
                        logCritical(
                            "🎯 PASSO 3: Executando detecção robusta..."
                        );
                        const dadosDetectados =
                            this.detectarCardSessaoSimplificado();

                        // 4. Verificação final
                        logCritical("🔍 PASSO 4: Verificação final...");

                        const cardExiste = !!(
                            document.getElementById(
                                "eprobe-card-sessao-material"
                            ) || document.getElementById("eprobe-data-sessao")
                        );
                        const temDados = !!dadosDetectados;
                        const processo = obterNumeroProcesso();

                        const resultado = {
                            sucesso: temDados && cardExiste,
                            timestamp: new Date().toISOString(),
                            url: window.location.href,
                            processo: processo,
                            diagnostico: {
                                fieldsetEncontrado:
                                    diagnostico.estrutura.fieldsetMinutas,
                                fieldsetsInternos:
                                    diagnostico.estrutura.fieldsetsInternos,
                                botoesMinutas:
                                    diagnostico.estrutura.botoesMinutas,
                            },
                            deteccao: {
                                dadosEncontrados: temDados,
                                numeroSessoes:
                                    dadosDetectados?.totalSessoes || 0,
                                dadosCompletos: dadosDetectados,
                            },
                            card: {
                                existe: cardExiste,
                                elemento: cardExiste
                                    ? document.getElementById(
                                          "eprobe-card-sessao-material"
                                      ) ||
                                      document.getElementById(
                                          "eprobe-data-sessao"
                                      )
                                    : null,
                            },
                        };

                        // 5. Relatório final
                        logCritical("📊 RESULTADO FINAL DO TESTE:");
                        logCritical(`  ✅ Sucesso geral: ${resultado.sucesso}`);
                        logCritical(
                            `  🔍 fieldset encontrado: ${resultado.diagnostico.fieldsetEncontrado}`
                        );
                        logCritical(
                            `  📊 fieldsets internos: ${resultado.diagnostico.fieldsetsInternos}`
                        );
                        logCritical(
                            `  🔘 botões de minutas: ${resultado.diagnostico.botoesMinutas}`
                        );
                        logCritical(
                            `  📅 dados detectados: ${resultado.deteccao.dadosEncontrados}`
                        );
                        logCritical(
                            `  🎯 sessões encontradas: ${resultado.deteccao.numeroSessoes}`
                        );
                        logCritical(
                            `  🎨 card criado: ${resultado.card.existe}`
                        );

                        if (resultado.sucesso) {
                            logCritical("🎉 TESTE CONCLUÍDO COM SUCESSO!");
                            logCritical(
                                "💡 O card deve estar visível na interface"
                            );
                        } else {
                            logError(
                                "❌ TESTE FALHOU - verifique os logs acima para detalhes"
                            );

                            if (!resultado.diagnostico.fieldsetEncontrado) {
                                logError(
                                    "💡 SOLUÇÃO: Navegue para uma página de detalhes de processo no eProc"
                                );
                            } else if (!resultado.deteccao.dadosEncontrados) {
                                logError(
                                    "💡 SOLUÇÃO: Verifique se há informações de sessão/minutas na página"
                                );
                            } else if (!resultado.card.existe) {
                                logError(
                                    "💡 SOLUÇÃO: Execute window.SENT1_AUTO.forcarCriacaoCardTeste() manualmente"
                                );
                            }
                        }

                        return resultado;
                    } catch (error) {
                        logError("❌ TESTE: Erro durante execução:", error);

                        // TESTE EMERGENCIAL em caso de erro
                        logCritical(
                            "🚨 ERRO DETECTADO: Executando teste emergencial..."
                        );
                        this.forcarCriacaoCardTeste();

                        return {
                            sucesso: false,
                            erro: error.message,
                            stack: error.stack,
                            cardTeste: true,
                        };
                    }
                },

                // 🧪 FUNÇÃO DE TESTE PARA A NOVA DETECÇÃO ROBUSTA
                testarDeteccaoRobusta: function () {
                    logCritical(
                        "🧪 TESTE ROBUSTA: Testando nova detecção com fieldset#fldMinutas"
                    );

                    try {
                        // 1. Verificar se o fieldset existe
                        const fieldsetMinutas =
                            document.querySelector("#fldMinutas");
                        logCritical(
                            `📍 FIELDSET fldMinutas encontrado: ${!!fieldsetMinutas}`
                        );

                        if (!fieldsetMinutas) {
                            logCritical(
                                "❌ TESTE: fieldset#fldMinutas não encontrado na página atual"
                            );
                            return {
                                sucesso: false,
                                motivo: "fieldset não encontrado",
                            };
                        }

                        // 2. Verificar estrutura interna
                        const minutasFieldsets =
                            fieldsetMinutas.querySelectorAll(
                                "div > div:nth-child(2) > fieldset"
                            );
                        logCritical(
                            `📍 FIELDSETS internos encontrados: ${minutasFieldsets.length}`
                        );

                        // 3. Testar a função principal
                        const resultado = this.detectarCardSessaoSimplificado();
                        logCritical(
                            `📍 RESULTADO da detecção: ${JSON.stringify(
                                resultado
                            )}`
                        );

                        // 4. Verificar se dados foram salvos
                        const temDados = this.hasDataSessaoPautado();
                        const dados = this.getDataSessaoPautado();
                        logCritical(`📍 DADOS salvos: ${temDados} | ${dados}`);

                        // 5. Verificar se card foi criado
                        const cardExiste =
                            !!document.getElementById("eprobe-data-sessao");
                        logCritical(`📍 CARD criado: ${cardExiste}`);

                        return {
                            sucesso: !!resultado,
                            fieldsetEncontrado: !!fieldsetMinutas,
                            fieldsetsInternos: minutasFieldsets.length,
                            resultado: resultado,
                            dadosSalvos: temDados,
                            cardCriado: cardExiste,
                        };
                    } catch (error) {
                        logCritical(
                            `❌ TESTE: Erro durante o teste - ${error.message}`
                        );
                        return { sucesso: false, erro: error.message };
                    }
                },

                // 🧪 FUNÇÃO DE TESTE ESPECÍFICA PARA TOOLTIP
                testarTooltipSessoes: function () {
                    log(
                        "🧪 TESTE TOOLTIP: Testando tooltip com múltiplas sessões..."
                    );

                    try {
                        const dadosExemplo = {
                            status: "PAUTADO",
                            data: "28/01/2025",
                            orgao: "2ª CÂMARA DE DIREITO CIVIL",
                            tipo: "Incluído em Pauta em 28/01/2025 - 2CCiv",
                            sessoes: [
                                {
                                    status: "PAUTADO",
                                    data: "28/01/2025",
                                    orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                    tipo: "Incluído em Pauta em 28/01/2025 - 2CCiv",
                                    cor: "#5C85B4",
                                },
                                {
                                    status: "ADIADO",
                                    data: "21/01/2025",
                                    orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                    tipo: "Sessão Adiada em 21/01/2025 - 2CCiv",
                                    cor: "#F55D3E",
                                },
                                {
                                    status: "VISTA",
                                    data: "14/01/2025",
                                    orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                    tipo: "Pedido de Vista em 14/01/2025 - 2CCiv",
                                    cor: "#FFBF46",
                                },
                                {
                                    status: "PAUTADO",
                                    data: "07/01/2025",
                                    orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                    tipo: "Incluído em Pauta em 07/01/2025 - 2CCiv",
                                    cor: "#5C85B4",
                                },
                                {
                                    status: "ADIADO",
                                    data: "31/12/2024",
                                    orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                    tipo: "Sessão Adiada em 31/12/2024 - 2CCiv",
                                    cor: "#F55D3E",
                                },
                            ],
                        };

                        setTimeout(() => {
                            log("📋 Criando card com tooltip rico...");

                            // Remover card anterior se existir
                            const cardAnterior = document.getElementById(
                                "eprobe-card-sessao-material"
                            );
                            if (cardAnterior) {
                                cardAnterior.remove();
                            }

                            const card = criarCardSessaoMaterial(dadosExemplo);

                            if (card) {
                                setTimeout(() => {
                                    log(
                                        "💡 Dica: Passe o mouse sobre o card para ver o tooltip!"
                                    );
                                    log(
                                        "🖱️ Ou clique no card para alternar a visualização do tooltip"
                                    );
                                    log(
                                        `📊 Tooltip contém ${dadosExemplo.sessoes.length} sessões históricas`
                                    );
                                }, 1000);
                            }
                        }, 500);

                        return "🧪 TESTE TOOLTIP: Card com tooltip criado!";
                    } catch (error) {
                        console.error("❌ TESTE TOOLTIP: Erro:", error);
                        return "❌ TESTE TOOLTIP: Erro - veja console";
                    }
                },

                // 🧪 FUNÇÃO DE TESTE SIMPLES PARA CARD DE SESSÃO
                testarCardSessaoAgora: function () {
                    log(
                        "🧪 TESTE IMEDIATO: Iniciando teste completo do card de sessão..."
                    );

                    try {
                        // 1. Verificar página atual
                        log("🔍 PASSO 0: Verificando página atual...");

                        // Verificar qual fieldset existe (6 ou 7)
                        let fieldsetExiste = false;
                        let fieldsetNumero = null;

                        for (const num of [6, 7]) {
                            const xpath = `/html/body/div[2]/div[3]/div[2]/div/div[1]/form[2]/div[3]/div/div/fieldset[${num}]`;
                            const elemento = document.evaluate(
                                xpath,
                                document,
                                null,
                                XPathResult.FIRST_ORDERED_NODE_TYPE,
                                null
                            ).singleNodeValue;

                            if (elemento) {
                                fieldsetExiste = true;
                                fieldsetNumero = num;
                                break;
                            }
                        }

                        const paginaInfo = {
                            url: window.location.href,
                            processo: this.obterNumeroProcesso(),
                            fieldsetExiste,
                            fieldsetNumero,
                        };
                        log("📊 Info da página:", paginaInfo);

                        // 2. Reset completo
                        log("🔄 PASSO 1: Resetando sistema...");
                        this.resetarSistemaCard();

                        // 3. Tentar detecção real
                        log("🔍 PASSO 2: Tentando detecção real...");
                        const dados = this.detectarCardSessaoSimplificado();
                        log("📊 Dados detectados:", dados);

                        // 4. Se não detectou, criar dados de teste
                        if (!dados && paginaInfo.processo) {
                            log("⚡ PASSO 2.1: Criando dados de teste...");
                            dataSessaoPautado = {
                                data: new Date().toLocaleDateString("pt-BR"),
                                dataFormatada: new Date().toLocaleDateString(
                                    "pt-BR"
                                ),
                                status: "Teste - Sessão Simulada",
                                textoCompleto:
                                    "Dados criados para teste do sistema eProbe",
                            };
                            processoComDataSessao = paginaInfo.processo;
                            logCritical("✅ Dados de teste criados");
                        }

                        // 5. Forçar criação do card
                        log("🎯 PASSO 3: Criando card...");
                        const cardCriado = this.inserirDataSessaoNaInterface();

                        // 6. Verificar resultado final
                        setTimeout(() => {
                            const cardExiste =
                                !!document.getElementById("eprobe-data-sessao");
                            log("🎯 RESULTADO FINAL:");
                            logCritical("  ✅ Card criado:", cardCriado);
                            log("  ✅ Card existe no DOM:", cardExiste);
                            log(
                                "  📊 Dados finais:",
                                this.getDataSessaoPautado()
                            );

                            if (cardExiste) {
                                log(
                                    "🎉 SUCESSO: Card visível no canto superior direito!"
                                );
                            } else {
                                logError("❌ PROBLEMA: Card não foi criado");
                            }
                        }, 100);

                        return {
                            paginaValida: paginaInfo.fieldsetExiste,
                            processo: paginaInfo.processo,
                            dadosDetectados: !!dados,
                            cardCriado: cardCriado,
                        };
                    } catch (error) {
                        console.error("❌ ERRO no teste:", error);
                        return { erro: error.message };
                    }
                },

                resetarSistemaCard: function () {
                    log("🔄 RESET CARD: Limpando sistema completo");
                    resetDataSessaoPautado();
                    resetControlesRequisicao();

                    const cardExistente =
                        document.getElementById("eprobe-data-sessao");
                    if (cardExistente) {
                        cardExistente.remove();
                        log("🗑️ RESET: Card removido da interface");
                    }

                    // Limpar cache de processos processados para este processo
                    const processoAtual = obterNumeroProcesso();
                    if (
                        processoAtual &&
                        processosJaProcessados.has(processoAtual)
                    ) {
                        processosJaProcessados.delete(processoAtual);
                        log(
                            `🧹 RESET: Processo ${processoAtual} removido da lista de processados`
                        );
                    }

                    log("✅ RESET: Sistema completamente limpo");
                    return true;
                },

                // 🌐 FUNÇÕES GLOBAIS PARA DADOS DA SESSÃO - IMPLEMENTAÇÕES REAIS
                getTipoJulgamentoProcessoPautado:
                    getTipoJulgamentoProcessoPautado,
                setTipoJulgamentoProcessoPautado:
                    setTipoJulgamentoProcessoPautado,
                getStatusJulgamento: getStatusJulgamento,
                setStatusJulgamento: setStatusJulgamento,
                getDataSessao: getDataSessao,
                setDataSessao: setDataSessao,
                resetDadosGlobaisSessao: resetDadosGlobaisSessao,
                showDadosGlobaisSessao: showDadosGlobaisSessao,

                // 🧪 FUNÇÕES DE TESTE
                testarXPathMaterialDesign: function () {
                    log(
                        "🧪 TESTE COMPLETO: XPath Exclusivo + Material Design Figma"
                    );
                    try {
                        const resultadoXPath =
                            window.SENT1_AUTO.detectarCardSessaoSimplificado?.();
                        if (!resultadoXPath) {
                            return {
                                sucesso: false,
                                etapa: "Detecção XPath",
                                motivo: "Nenhuma estratégia XPath encontrou dados",
                            };
                        }
                        const cardMaterial =
                            window.SENT1_AUTO.criarCardMaterialDesign?.(
                                resultadoXPath
                            );
                        const configFigma =
                            window.SENT1_AUTO.obterConfigFigmaStatus?.(
                                "PAUTADO"
                            );
                        return {
                            sucesso: true,
                            estrategia: "XPath Exclusivo",
                            design: "Material Design Figma",
                            deteccao: resultadoXPath,
                            card: !!cardMaterial,
                            configuracao: configFigma,
                        };
                    } catch (error) {
                        console.error("❌ ERRO no teste:", error);
                        return { sucesso: false, erro: error.message };
                    }
                },

                testarCorrecaoSVG: function () {
                    logError(
                        "🧪 TESTE: Validando correção do erro SVG className"
                    );
                    try {
                        window.SENT1_AUTO.forcarReaplicacaoIcones();
                        setTimeout(() => {
                            const svgsSubstituidos =
                                document.querySelectorAll(".substituted-icon");
                            log(
                                `✅ TESTE: ${svgsSubstituidos.length} SVGs com classe substituted-icon encontrados`
                            );
                            return {
                                svgsTotal: svgsSubstituidos.length,
                                sucesso: true,
                            };
                        }, 1000);
                    } catch (error) {
                        console.error(
                            "❌ TESTE: Erro durante validação:",
                            error
                        );
                        return { sucesso: false, erro: error.message };
                    }
                },

                testarCriacaoCard: function () {
                    log(
                        "🧪 TESTE: Validando criação do card Material Design com XPath exclusivo"
                    );
                    try {
                        const resultadoXPath =
                            window.SENT1_AUTO.detectarCardSessaoSimplificado?.();
                        if (!resultadoXPath) {
                            return {
                                sucesso: false,
                                etapa: "Detecção",
                                motivo: "Não foi possível detectar dados do card",
                            };
                        }
                        const cardCriado =
                            window.SENT1_AUTO.criarCardMaterialDesign?.(
                                resultadoXPath
                            );
                        return {
                            sucesso: !!cardCriado,
                            dados: resultadoXPath,
                            card: !!cardCriado,
                        };
                    } catch (error) {
                        console.error("❌ TESTE: Erro no teste:", error);
                        return { sucesso: false, erro: error.message };
                    }
                },

                testarCardFigmaExato: function () {
                    log(
                        "🧪 TESTE FIGMA: Testando card com especificações EXATAS do design Figma"
                    );
                    const dadosTeste = {
                        data: "22/07/2025",
                        status: "PAUTADO",
                        orgao: "2ª Câmara de Direito Civil",
                        processo: "TESTE-FIGMA",
                    };
                    try {
                        const card =
                            window.SENT1_AUTO.criarCardMaterialDesign?.(
                                dadosTeste
                            );
                        return { sucesso: !!card, dados: dadosTeste };
                    } catch (error) {
                        console.error("❌ TESTE FIGMA: Erro:", error);
                        return { sucesso: false, erro: error.message };
                    }
                },

                testarErroSwitchRelevancia: function () {
                    logError(
                        "🧪 TESTE: Diagnosticando erro switchRelevanciaEvento"
                    );
                    // Função de teste para debug de erros específicos
                    return { teste: "switch_relevancia", status: "ok" };
                },

                forcarRecriacaoCardSessao:
                    allMissingFunctions.forcarRecriacaoCardSessao,
                encontrarContainerParaCard:
                    allMissingFunctions.encontrarContainerParaCard,

                diagnosticoCompletoCard: function () {
                    log("🩺 DIAGNÓSTICO COMPLETO - Card de Sessão");
                    const relatorio = {
                        timestamp: new Date().toLocaleString("pt-BR"),
                        url: window.location.href,
                        diagnosticos: {},
                    };
                    return relatorio;
                },

                // 🧪 TESTE DE TOOLTIP MATERIAL SYMBOLS
                testarTooltipMaterialSymbols: function () {
                    log(
                        "🧪 TESTE MATERIAL SYMBOLS: Criando tooltip com ícones Material Symbols"
                    );

                    try {
                        // Dados de exemplo para demonstração
                        const sessoesExemplo = [
                            {
                                status: "PAUTADO",
                                data: "28/01/2025",
                                orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                tipo: "Julgamento de Mérito",
                                cor: "#1976d2",
                                isAtual: true,
                            },
                            {
                                status: "ADIADO",
                                data: "21/01/2025",
                                orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                tipo: "Sessão Adiada",
                                cor: "#f44336",
                            },
                            {
                                status: "VISTA",
                                data: "14/01/2025",
                                orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                tipo: "Pedido de Vista",
                                cor: "#ff9800",
                                observacoes:
                                    "Prazo de 30 dias para apresentação de parecer",
                            },
                        ];

                        // Criar um elemento temporário para demonstrar o tooltip
                        let elementoTeste = document.getElementById(
                            "eprobe-teste-tooltip"
                        );
                        if (!elementoTeste) {
                            elementoTeste = document.createElement("div");
                            elementoTeste.id = "eprobe-teste-tooltip";
                            elementoTeste.style.cssText = `
                            position: fixed;
                            top: 20px;
                            right: 20px;
                            background: #1976d2;
                            color: white;
                            padding: 12px 16px;
                            border-radius: 8px;
                            cursor: pointer;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            z-index: 10000;
                            font-family: Roboto, sans-serif;
                            font-size: 14px;
                            font-weight: 500;
                        `;
                            elementoTeste.innerHTML =
                                "🧪 Teste Material Symbols Tooltip";
                            document.body.appendChild(elementoTeste);
                        }

                        // Aplicar o tooltip com Material Symbols
                        aplicarTooltipUnificado(elementoTeste, sessoesExemplo);

                        // Auto-remover após 30 segundos
                        setTimeout(() => {
                            if (elementoTeste && elementoTeste.parentNode) {
                                elementoTeste.remove();
                            }
                        }, 30000);

                        log(
                            "✅ TESTE MATERIAL SYMBOLS: Tooltip criado! Passe o mouse sobre o elemento azul no canto superior direito"
                        );
                        log(
                            `📊 TESTE: Tooltip contém ${sessoesExemplo.length} sessões com ícones Material Symbols`
                        );
                        log(
                            "🎨 ICONS: event_repeat (📅) e gavel (🏛️) convertidos para Material Symbols"
                        );

                        return {
                            sucesso: true,
                            elemento: elementoTeste.id,
                            sessoes: sessoesExemplo.length,
                            icons: ["event_repeat", "gavel"],
                            posicao: "top-right",
                        };
                    } catch (error) {
                        console.error(
                            "❌ TESTE MATERIAL SYMBOLS: Erro:",
                            error
                        );
                        return {
                            sucesso: false,
                            erro: error.message,
                        };
                    }
                },

                // 🔥 FUNÇÕES DE CONTROLE DE PERFORMANCE ULTRA
                ativarModoUltraPerformance: function () {
                    log("🔥 PERFORMANCE: Modo ultra-performance ATIVADO");
                    return true;
                },

                desativarModoUltraPerformance: function () {
                    log("✅ PERFORMANCE: Modo ultra-performance DESATIVADO");
                    return false;
                },

                statusModoUltraPerformance: function () {
                    log("📊 PERFORMANCE: Status do modo ultra-performance");
                    return false; // Default
                },

                // 📋 NAMESPACE ESPECÍFICO PARA LOCALIZADORES
                localizadores: {
                    detectarPagina:
                        allMissingFunctions.detectarPaginaLocalizadores,
                    processarTabela:
                        allMissingFunctions.processarTabelaLocalizadores,
                    destacarUrgentes:
                        allMissingFunctions.destacarLocalizadoresUrgentes,
                    debug: function () {
                        log("🐛 DEBUG LOCALIZADORES");
                    },
                },

                // 🔧 FUNÇÕES DE SISTEMA E TESTES
                testarSistemaCompleto, // Usar implementação real da linha 12371

                // 🧪 TESTE ESPECÍFICO PARA LINKS DE SESSÃO
                testarExtracacaoLink: async function (indiceSessao = 1) {
                    logCritical(
                        "🧪 TESTE: Iniciando teste de extração de link para sessão",
                        indiceSessao
                    );

                    try {
                        // Debug: Primeiro vamos ver o elemento encontrado
                        const xpathUnico = `/html/body/div[1]/div/div/div/div[1]/div/div/div/div[2]/div/form/div[2]/div/table/tbody/tr[${indiceSessao}]/td[1]/a`;
                        const linkElement = document.evaluate(
                            xpathUnico,
                            document,
                            null,
                            XPathResult.FIRST_ORDERED_NODE_TYPE,
                            null
                        ).singleNodeValue;

                        if (linkElement) {
                            logCritical("🔍 ELEMENTO ENCONTRADO:", linkElement);
                            logCritical(
                                "📄 HTML BRUTO do elemento:",
                                linkElement.outerHTML
                            );
                            logCritical(
                                "🔗 href processado pelo browser:",
                                linkElement.href
                            );
                            logCritical(
                                "📋 getAttribute('href'):",
                                linkElement.getAttribute("href")
                            );
                            logCritical(
                                "📏 Tamanho getAttribute:",
                                linkElement.getAttribute("href")?.length || 0
                            );
                            logCritical(
                                "📏 Tamanho href:",
                                linkElement.href?.length || 0
                            );
                        } else {
                            logCritical(
                                "❌ ELEMENTO NÃO ENCONTRADO com XPath:",
                                xpathUnico
                            );
                            return { erro: "Elemento não encontrado" };
                        }

                        const link = extrairLinkSessao(indiceSessao);

                        if (link) {
                            logCritical(
                                "✅ TESTE: Link extraído com sucesso:",
                                link
                            );
                            logCritical(
                                "📏 TESTE: Tamanho do link extraído:",
                                link.length
                            );

                            // Verificar se contém os parâmetros essenciais
                            const parametrosEssenciais = [
                                "id_sessao_julgamento",
                                "id_orgao_julgador",
                                "txtNumProcesso",
                                "hash",
                            ];

                            logCritical("🔍 VERIFICAÇÃO DE PARÂMETROS:");
                            parametrosEssenciais.forEach((param) => {
                                const tem = link.includes(param);
                                logCritical(
                                    `  ${tem ? "✅" : "❌"} ${param}: ${
                                        tem ? "PRESENTE" : "AUSENTE"
                                    }`
                                );
                            });

                            // Testar construção da URL
                            const dadosTeste = { indice: indiceSessao };
                            const urlCompleta = await construirUrlSessao(
                                dadosTeste
                            );

                            logCritical(
                                "🚀 TESTE: URL completa construída:",
                                urlCompleta
                            );

                            return {
                                sucesso: true,
                                linkExtraido: link,
                                tamanhoLink: link.length,
                                urlCompleta: urlCompleta,
                                parametrosPresentes:
                                    parametrosEssenciais.filter((p) =>
                                        link.includes(p)
                                    ),
                            };
                        } else {
                            logCritical("❌ TESTE: Falha na extração do link");
                            return { erro: "Falha na extração" };
                        }
                    } catch (error) {
                        logCritical("💥 TESTE: Erro durante teste:", error);
                        return { erro: error.message };
                    }
                },

                testarTooltipSessoes: function () {
                    log(
                        "🧪 TESTE TOOLTIP: Testando tooltip com múltiplas sessões..."
                    );

                    try {
                        const dadosExemplo = {
                            status: "PAUTADO",
                            data: "28/01/2025",
                            orgao: "2ª CÂMARA DE DIREITO CIVIL",
                            tipo: "Incluído em Pauta em 28/01/2025 - 2CCiv",
                            sessoes: [
                                {
                                    status: "PAUTADO",
                                    data: "28/01/2025",
                                    orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                    tipo: "Incluído em Pauta em 28/01/2025 - 2CCiv",
                                    cor: "#5C85B4",
                                },
                                {
                                    status: "ADIADO",
                                    data: "21/01/2025",
                                    orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                    tipo: "Sessão Adiada em 21/01/2025 - 2CCiv",
                                    cor: "#F55D3E",
                                },
                                {
                                    status: "VISTA",
                                    data: "14/01/2025",
                                    orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                    tipo: "Pedido de Vista em 14/01/2025 - 2CCiv",
                                    cor: "#FFBF46",
                                },
                                {
                                    status: "PAUTADO",
                                    data: "07/01/2025",
                                    orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                    tipo: "Incluído em Pauta em 07/01/2025 - 2CCiv",
                                    cor: "#5C85B4",
                                },
                                {
                                    status: "ADIADO",
                                    data: "31/12/2024",
                                    orgao: "2ª CÂMARA DE DIREITO CIVIL",
                                    tipo: "Sessão Adiada em 31/12/2024 - 2CCiv",
                                    cor: "#F55D3E",
                                },
                            ],
                        };

                        setTimeout(() => {
                            log("📋 Criando card com tooltip rico...");

                            // Remover card anterior se existir
                            const cardAnterior = document.getElementById(
                                "eprobe-card-sessao-material"
                            );
                            if (cardAnterior) {
                                cardAnterior.remove();
                            }

                            const card = criarCardSessaoMaterial(dadosExemplo);

                            if (card) {
                                setTimeout(() => {
                                    log(
                                        "💡 Dica: Passe o mouse sobre o card para ver o tooltip!"
                                    );
                                    log(
                                        "🖱️ Ou clique no card para alternar a visualização do tooltip"
                                    );
                                    log(
                                        `📊 Tooltip contém ${dadosExemplo.sessoes.length} sessões históricas`
                                    );
                                }, 1000);
                            }
                        }, 500);

                        return "🧪 TESTE TOOLTIP: Card com tooltip criado!";
                    } catch (error) {
                        console.error("❌ TESTE TOOLTIP: Erro:", error);
                        return "❌ TESTE TOOLTIP: Erro - veja console";
                    }
                },

                debugPaginaSessoes, // Usar implementação real da linha 12436

                resetControlesRequisicao: function () {
                    log("🔄 RESET: Controles de requisição");
                },

                statusControlesRequisicao: function () {
                    log("📊 STATUS: Controles de requisição");
                },

                obterNumeroProcesso: function () {
                    return "TESTE-PROCESSO";
                },

                obterProcessoAtual: function () {
                    return "PROCESSO-ATUAL";
                },

                listarProcessosProcessados: function () {
                    return [];
                },

                resetProcessosProcessados: function () {
                    log("🔄 RESET: Processos processados");
                },

                statusProcessos: function () {
                    log("📊 STATUS: Processos");
                },

                statusRequisicoes: function () {
                    log("📊 STATUS: Requisições");
                },

                desabilitarRequisicoes: function () {
                    log("🚫 DESABILITAR: Requisições");
                },

                habilitarRequisicoes: function () {
                    log("✅ HABILITAR: Requisições");
                },

                forcarCruzamento: function () {
                    log("🔄 FORÇA: Cruzamento");
                    return Promise.resolve(true);
                },

                autoCorrecaoTooltip: function () {
                    log("🔧 AUTO: Correção tooltip");
                },

                diagnosticarECorrigirTooltip: diagnosticarECorrigirTooltip,

                corrigirProblemasRapido: function () {
                    log("🔧 CORREÇÃO RÁPIDA: Iniciando...");
                    return { botao: true, card: true, tooltip: true };
                },

                // 🔧 FUNÇÕES DE DEBUG E TESTE CONSOLIDADAS
                debugTooltipDireto: function () {
                    log("🔍 DEBUG DIRETO: Investigando tooltip...");
                    return { status: "configurado" };
                },

                // Funções de ícones consolidadas
                testarFuncoesIcones: function () {
                    log("🧪 TESTE: Funções de ícones");
                },

                debugIconesNaPagina: function () {
                    log("🔍 DEBUG: Ícones na página");
                },

                debugIncluirPautaMesa: function () {
                    log("🔍 DEBUG: Incluir em Pauta/Mesa");
                },

                // Funções de teste de cards
                testarCardFigmaEspecificacoes: function () {
                    log("🧪 TESTE: Especificações Figma");
                },

                testarTodosCards: function () {
                    log("🧪 TESTE: Todos os cards");
                },

                obterConfigCardPorStatus: function (status) {
                    log("🔧 CONFIG: Card por status", status);
                    return {};
                },

                diagnosticoRapido: function () {
                    log(
                        "🩺 DIAGNÓSTICO RÁPIDO: Verificando estado da extensão..."
                    );
                    return {
                        botao: true,
                        card: true,
                        dadosSessao: true,
                        processo: true,
                    };
                },

                testarDeteccaoCard: function () {
                    log("🧪 TESTE CARD: Iniciando teste de detecção");
                    return { teste: "deteccao_card", status: "ok" };
                },

                debugRapido: function () {
                    log("🔧 DEBUG RÁPIDO eProbe");
                    return {
                        namespace: typeof window.SENT1_AUTO,
                        totalFuncoes: Object.keys(window.SENT1_AUTO).length,
                        url: window.location.href,
                        eProc: window.location.href.includes("eproc"),
                    };
                },

                testarMultiplasSessoes: function () {
                    log(
                        "🧪 TESTE MÚLTIPLAS SESSÕES: Testando sistema de tooltip"
                    );
                    return true;
                },

                testarNovoFormatoTooltip: function (textoTeste) {
                    const texto =
                        textoTeste || "Texto de teste do novo tooltip";
                    log("🔧 TESTE TOOLTIP:", texto);
                    return null;
                },

                // 🎯 FUNÇÃO DE DIAGNÓSTICO E CORREÇÃO DO TOOLTIP DO CARD
                diagnosticarECorrigirTooltipCard: function () {
                    logCritical(
                        "🔍 DIAGNÓSTICO TOOLTIP CARD: Verificando sistema completo..."
                    );

                    const relatorio = {
                        timestamp: new Date().toLocaleString("pt-BR"),
                        cardEncontrado: false,
                        cardVisivel: false,
                        indicadorTooltip: false,
                        tooltipExiste: false,
                        funcaoDisponivel:
                            typeof adicionarTooltipUnificado === "function",
                        problemas: [],
                        acoes: [],
                    };

                    // 1. Verificar se o card existe
                    const card = document.querySelector(
                        "#eprobe-card-sessao-material, #eprobe-data-sessao"
                    );
                    if (card) {
                        relatorio.cardEncontrado = true;
                        relatorio.cardVisivel =
                            card.style.display !== "none" &&
                            card.offsetParent !== null;
                        log("✅ CARD: Encontrado", card.id);
                    } else {
                        relatorio.problemas.push(
                            "Card de sessão não encontrado"
                        );
                        logError("❌ CARD: Não encontrado na página");
                    }

                    // 2. Verificar indicador de tooltip
                    const indicador = document.querySelector(
                        ".eprobe-figma-sessions-indicator"
                    );
                    if (indicador) {
                        relatorio.indicadorTooltip = true;
                        log("✅ INDICADOR: Encontrado");
                    } else {
                        relatorio.problemas.push(
                            "Indicador de tooltip não encontrado"
                        );
                        logError("❌ INDICADOR: Não encontrado");
                    }

                    // 3. Verificar tooltip atual
                    const tooltipExistente = document.getElementById(
                        "eprobe-rich-tooltip"
                    );
                    if (tooltipExistente) {
                        relatorio.tooltipExiste = true;
                        log("✅ TOOLTIP: Já existe no DOM");
                    } else {
                        log(
                            "ℹ️ TOOLTIP: Não existe (normal, é criado on-demand)"
                        );
                    }

                    // 4. Se card existe mas não tem tooltip, aplicar
                    if (card && !indicador && relatorio.funcaoDisponivel) {
                        log(
                            "🔧 CORREÇÃO: Aplicando tooltip ao card encontrado..."
                        );
                        try {
                            const resultado = adicionarTooltipUnificado(card);
                            if (resultado && resultado.status === "sucesso") {
                                relatorio.acoes.push(
                                    "Tooltip aplicado com sucesso"
                                );
                                logCritical(
                                    "✅ CORREÇÃO: Tooltip aplicado com sucesso!"
                                );
                            } else {
                                relatorio.problemas.push(
                                    "Falha ao aplicar tooltip"
                                );
                                logError(
                                    "❌ CORREÇÃO: Falha ao aplicar tooltip"
                                );
                            }
                        } catch (error) {
                            relatorio.problemas.push(
                                `Erro ao aplicar tooltip: ${error.message}`
                            );
                            logError(
                                "❌ CORREÇÃO: Erro ao aplicar tooltip:",
                                error
                            );
                        }
                    }

                    // 5. Se não há card, tentar criar
                    if (!card) {
                        log("🔧 CORREÇÃO: Tentando criar card de sessão...");
                        try {
                            const cardCriado =
                                this.inserirDataSessaoNaInterface();
                            if (cardCriado) {
                                relatorio.acoes.push("Card de sessão criado");
                                log("✅ CORREÇÃO: Card criado com sucesso");
                            } else {
                                relatorio.problemas.push(
                                    "Falha ao criar card de sessão"
                                );
                                logError("❌ CORREÇÃO: Falha ao criar card");
                            }
                        } catch (error) {
                            relatorio.problemas.push(
                                `Erro ao criar card: ${error.message}`
                            );
                            logError("❌ CORREÇÃO: Erro ao criar card:", error);
                        }
                    }

                    // 6. Relatório final
                    const sucesso = relatorio.problemas.length === 0;
                    logCritical("📊 RELATÓRIO FINAL:", relatorio);
                    logCritical(
                        sucesso
                            ? "✅ DIAGNÓSTICO: Sistema funcionando"
                            : "⚠️ DIAGNÓSTICO: Problemas encontrados"
                    );

                    return relatorio;
                },

                // 🔧 FUNÇÃO RÁPIDA PARA FORÇAR TOOLTIP
                forcarTooltipCard: function () {
                    log("🚀 FORÇA: Forçando aplicação de tooltip no card...");

                    const card = document.querySelector(
                        "#eprobe-card-sessao-material, #eprobe-data-sessao"
                    );
                    if (!card) {
                        logError(
                            "❌ FORÇA: Nenhum card encontrado para aplicar tooltip"
                        );
                        return false;
                    }

                    try {
                        const resultado = adicionarTooltipUnificado(card);
                        if (resultado && resultado.status === "sucesso") {
                            logCritical(
                                "✅ FORÇA: Tooltip forçado com sucesso!"
                            );
                            return true;
                        } else {
                            logError("❌ FORÇA: Falha ao forçar tooltip");
                            return false;
                        }
                    } catch (error) {
                        logError("❌ FORÇA: Erro ao forçar tooltip:", error);
                        return false;
                    }
                },

                // 🔍 FUNÇÃO DE DEBUG ESPECÍFICA PARA DOCUMENTOS RELEVANTES
                debugDocumentosRelevantes: function () {
                    log("🔍 DEBUG DOCUMENTOS RELEVANTES: Analisando página...");

                    const resultado = {
                        pageType: detectPageType ? detectPageType() : "N/A",
                        url: window.location.href,
                        analise: {},
                        documentosEncontrados: [],
                        estrategias: {},
                    };

                    try {
                        // Analisar elementos disponíveis
                        resultado.analise = {
                            todosLinks: document.querySelectorAll("a").length,
                            linksInfraLinkDocumento: document.querySelectorAll(
                                "a.infraLinkDocumento"
                            ).length,
                            linksComHrefDocumento: document.querySelectorAll(
                                'a[href*="documento"]'
                            ).length,
                            elementosComDataNome:
                                document.querySelectorAll("[data-nome]").length,
                            tabelasNaPagina:
                                document.querySelectorAll("table").length,
                            linksEmTabelas:
                                document.querySelectorAll("table a").length,
                        };

                        // Testar estratégias individuais
                        const tiposRelevantes = [
                            "SENT",
                            "INIC",
                            "DECI",
                            "DESP",
                            "PETI",
                        ];

                        // Estratégia 1: Por data-nome
                        resultado.estrategias.porDataNome = [];
                        tiposRelevantes.forEach((tipo) => {
                            const links = document.querySelectorAll(
                                `a[data-nome*="${tipo}"]`
                            );
                            if (links.length > 0) {
                                resultado.estrategias.porDataNome.push({
                                    tipo: tipo,
                                    quantidade: links.length,
                                    elementos: Array.from(links).map((l) => ({
                                        texto: l.textContent.trim(),
                                        href: l.getAttribute("href"),
                                        dataNome: l.getAttribute("data-nome"),
                                    })),
                                });
                            }
                        });

                        // Estratégia 2: Por texto do link
                        resultado.estrategias.porTexto = [];
                        const todosLinks = Array.from(
                            document.querySelectorAll("a")
                        );
                        tiposRelevantes.forEach((tipo) => {
                            const linksPorTipo = todosLinks.filter((link) => {
                                const texto = link.textContent
                                    .trim()
                                    .toUpperCase();
                                return texto.includes(tipo);
                            });
                            if (linksPorTipo.length > 0) {
                                resultado.estrategias.porTexto.push({
                                    tipo: tipo,
                                    quantidade: linksPorTipo.length,
                                    elementos: linksPorTipo.map((l) => ({
                                        texto: l.textContent.trim(),
                                        href: l.getAttribute("href"),
                                        classe: l.className,
                                    })),
                                });
                            }
                        });

                        // Estratégia 3: Por href
                        resultado.estrategias.porHref = [];
                        tiposRelevantes.forEach((tipo) => {
                            const links = document.querySelectorAll(
                                `a[href*="${tipo}"]`
                            );
                            if (links.length > 0) {
                                resultado.estrategias.porHref.push({
                                    tipo: tipo,
                                    quantidade: links.length,
                                    elementos: Array.from(links).map((l) => ({
                                        texto: l.textContent.trim(),
                                        href: l.getAttribute("href"),
                                    })),
                                });
                            }
                        });

                        // Chamar a função original se estiver disponível
                        if (typeof findDocumentosRelevantes === "function") {
                            try {
                                const documentos = findDocumentosRelevantes();
                                resultado.documentosEncontrados =
                                    documentos || [];
                                resultado.funcaoOriginalFuncionou = true;
                            } catch (error) {
                                resultado.erroFuncaoOriginal = error.message;
                            }
                        } else {
                            resultado.funcaoOriginalDisponivel = false;
                        }

                        log("📊 RESULTADO COMPLETO:", resultado);

                        log("\n📋 RESUMO:");
                        log(`  • Tipo de página: ${resultado.pageType}`);
                        log(
                            `  • Links totais: ${resultado.analise.todosLinks}`
                        );
                        log(
                            `  • Links infraLinkDocumento: ${resultado.analise.linksInfraLinkDocumento}`
                        );
                        log(
                            `  • Estratégia por data-nome: ${resultado.estrategias.porDataNome.length} tipos encontrados`
                        );
                        log(
                            `  • Estratégia por texto: ${resultado.estrategias.porTexto.length} tipos encontrados`
                        );
                        log(
                            `  • Estratégia por href: ${resultado.estrategias.porHref.length} tipos encontrados`
                        );
                        log(
                            `  • Documentos finais: ${
                                Array.isArray(resultado.documentosEncontrados)
                                    ? resultado.documentosEncontrados.length
                                    : "N/A"
                            }`
                        );

                        return resultado;
                    } catch (error) {
                        console.error("❌ Erro no debug:", error);
                        return {
                            erro: error.message,
                            url: window.location.href,
                        };
                    }
                },

                // 🧪 FUNÇÃO DE TESTE PARA ORDENAÇÃO DE DOCUMENTOS POR DATA
                testarOrdenacaoDocumentosPorData: function () {
                    log(
                        "🧪 TESTE: Validando ordenação de documentos por data de assinatura..."
                    );

                    // Dados de teste com diferentes datas
                    const documentosTeste = [
                        {
                            eventoDescricao: "SENTENÇA MAIS ANTIGA",
                            seqEvento: "10",
                            tipoDocumento: "SENT1",
                            eventoData: "15/01/2024",
                            texto: "Documento antigo",
                        },
                        {
                            eventoDescricao: "SENTENÇA MAIS RECENTE",
                            seqEvento: "30",
                            tipoDocumento: "SENT1",
                            eventoData: "20/07/2025",
                            texto: "Documento recente",
                        },
                        {
                            eventoDescricao: "SENTENÇA MÉDIA",
                            seqEvento: "20",
                            tipoDocumento: "SENT1",
                            eventoData: "10/06/2025",
                            texto: "Documento médio",
                        },
                        {
                            eventoDescricao: "DOCUMENTO SEM DATA",
                            seqEvento: "5",
                            tipoDocumento: "INIC1",
                            eventoData: "",
                            texto: "Sem data",
                        },
                    ];

                    log("📋 ANTES DA ORDENAÇÃO:");
                    documentosTeste.forEach((doc, i) => {
                        log(
                            `  ${i + 1}. ${doc.eventoDescricao} - ${
                                doc.eventoData || "Sem data"
                            }`
                        );
                    });

                    // Aplicar a mesma lógica de ordenação do modal
                    const documentosOrdenados = [...documentosTeste].sort(
                        (a, b) => {
                            const parseDataBrasileira = (dataStr) => {
                                if (!dataStr || typeof dataStr !== "string")
                                    return null;

                                const match = dataStr.match(
                                    /(\d{1,2})\/(\d{1,2})\/(\d{2,4})/
                                );
                                if (!match) return null;

                                let [, dia, mes, ano] = match;

                                if (ano.length === 2) {
                                    ano = "20" + ano;
                                }

                                return new Date(
                                    parseInt(ano),
                                    parseInt(mes) - 1,
                                    parseInt(dia)
                                );
                            };

                            const dataA = parseDataBrasileira(a.eventoData);
                            const dataB = parseDataBrasileira(b.eventoData);

                            if (dataA && dataB) {
                                return dataB.getTime() - dataA.getTime();
                            }

                            if (dataA && !dataB) return -1;
                            if (!dataA && dataB) return 1;

                            const seqA = parseInt(a.seqEvento) || 0;
                            const seqB = parseInt(b.seqEvento) || 0;
                            return seqB - seqA;
                        }
                    );

                    log("🔄 APÓS A ORDENAÇÃO (mais novo → mais antigo):");
                    documentosOrdenados.forEach((doc, i) => {
                        log(
                            `  ${i + 1}. ${doc.eventoDescricao} - ${
                                doc.eventoData || "Sem data"
                            }`
                        );
                    });

                    // Validar se a ordenação está correta
                    const validacao = {
                        primeiroEhMaisRecente:
                            documentosOrdenados[0].eventoData === "20/07/2025",
                        segundoEhMedio:
                            documentosOrdenados[1].eventoData === "10/06/2025",
                        terceiroEhMaisAntigo:
                            documentosOrdenados[2].eventoData === "15/01/2024",
                        ultimoEhSemData: !documentosOrdenados[3].eventoData,
                    };

                    log("✅ VALIDAÇÃO DA ORDENAÇÃO:");
                    Object.entries(validacao).forEach(([teste, passou]) => {
                        log(
                            `  ${passou ? "✅" : "❌"} ${teste}: ${
                                passou ? "PASSOU" : "FALHOU"
                            }`
                        );
                    });

                    const todosTestes = Object.values(validacao).every(
                        (v) => v
                    );
                    log(
                        `🎯 RESULTADO FINAL: ${
                            todosTestes
                                ? "✅ TODOS OS TESTES PASSARAM"
                                : "❌ ALGUNS TESTES FALHARAM"
                        }`
                    );

                    return {
                        sucesso: todosTestes,
                        documentosOriginais: documentosTeste,
                        documentosOrdenados: documentosOrdenados,
                        validacao: validacao,
                    };
                },

                // 🔧 FUNÇÕES DE DEBUG PARA RESOLUCIONAR PROBLEMAS COM CARD
                debugStatusCard: function () {
                    log(
                        "🔍 DEBUG CARD: Verificando status completo do sistema"
                    );

                    const processoAtual = obterNumeroProcesso();
                    const temDados = hasDataSessaoPautado();
                    const dados = getDataSessaoPautado();
                    const cardExiste =
                        !!document.getElementById("eprobe-data-sessao");

                    const status = {
                        processoAtual: processoAtual,
                        temDados: temDados,
                        dados: dados,
                        cardExiste: cardExiste,
                        processoComDataSessao: processoComDataSessao,
                        jaProcessado: processoAtual
                            ? processosJaProcessados.has(processoAtual)
                            : false,
                    };

                    log("📊 STATUS COMPLETO:", status);

                    if (!temDados) {
                        logError(
                            "⚠️ PROBLEMA: Não há dados de sessão detectados"
                        );
                        log(
                            "💡 SOLUÇÃO: Execute window.SENT1_AUTO.detectarCardSessaoSimplificado()"
                        );
                    } else if (!cardExiste) {
                        logError(
                            "⚠️ PROBLEMA: Há dados mas card não foi criado"
                        );
                        log(
                            "💡 SOLUÇÃO: Execute window.SENT1_AUTO.inserirDataSessaoNaInterface()"
                        );
                    } else {
                        log("✅ STATUS: Tudo funcionando corretamente");
                    }

                    return status;
                },

                forcarCriacaoCard: function () {
                    log(
                        "🚀 FORÇA: Forçando criação do card ignorando validações"
                    );

                    // Tentar detectar dados primeiro
                    const dados = this.detectarCardSessaoSimplificado();
                    log("📊 DADOS DETECTADOS:", dados);

                    // Forçar criação mesmo se não houver dados
                    const resultado = this.inserirDataSessaoNaInterface();
                    log("🎯 RESULTADO CRIAÇÃO:", resultado);

                    return {
                        dadosDetectados: !!dados,
                        cardCriado: resultado,
                        cardExiste: !!(
                            document.getElementById("eprobe-data-sessao") ||
                            document.getElementById(
                                "eprobe-card-sessao-material"
                            )
                        ),
                    };
                },

                // 🚨 FUNÇÃO DE TESTE EMERGENCIAL - FORÇA CRIAÇÃO DO CARD
                forcarCriacaoCardTeste: function () {
                    logCritical(
                        "🚨 TESTE EMERGENCIAL: Forçando criação de card com dados de teste"
                    );

                    try {
                        // Dados de teste para garantir que o card apareça
                        const dadosTeste = {
                            data: "28/01/2025",
                            status: "PAUTADO",
                            orgao: "2ª Câmara de Direito Civil",
                            tipo: "Incluído em Pauta",
                            totalSessoes: 1,
                            sessoes: [
                                {
                                    data: "28/01/2025",
                                    status: "PAUTADO",
                                    orgao: "2ª Câmara de Direito Civil",
                                    tipo: "Incluído em Pauta",
                                    cor: "#5C85B4",
                                },
                            ],
                        };

                        logCritical("📊 DADOS DE TESTE:", dadosTeste);

                        // Criar card diretamente
                        const card = criarCardSessaoMaterial(dadosTeste);

                        if (card) {
                            // Garantir posição fixa visível
                            card.style.position = "fixed";
                            card.style.top = "100px";
                            card.style.right = "20px";
                            card.style.zIndex = "99999";
                            card.style.display = "block";

                            // Inserir no body se não estiver no DOM
                            if (!document.body.contains(card)) {
                                document.body.appendChild(card);
                            }

                            logCritical(
                                "✅ TESTE EMERGENCIAL: Card de teste criado e inserido!"
                            );
                            logCritical(
                                "📍 Posição: fixed top:100px right:20px z-index:99999"
                            );

                            // Verificação visual
                            setTimeout(() => {
                                const cardVisivel = document.getElementById(
                                    "eprobe-card-sessao-material"
                                );
                                if (cardVisivel) {
                                    const rect =
                                        cardVisivel.getBoundingClientRect();
                                    logCritical(
                                        `✅ VERIFICAÇÃO: Card visível! Posição: x:${rect.x}, y:${rect.y}`
                                    );
                                } else {
                                    logError(
                                        "❌ VERIFICAÇÃO: Card ainda não visível!"
                                    );
                                }
                            }, 100);

                            return true;
                        } else {
                            logError(
                                "❌ TESTE EMERGENCIAL: Falha ao criar card"
                            );
                            return false;
                        }
                    } catch (error) {
                        logError("❌ TESTE EMERGENCIAL: Erro:", error);
                        return false;
                    }
                },

                resetarSistemaCard: function () {
                    log("🔄 RESET: Resetando sistema completo do card");

                    // Remover card existente
                    const cardExistente =
                        document.getElementById("eprobe-data-sessao");
                    if (cardExistente) {
                        cardExistente.remove();
                        log("🗑️ Card removido");
                    }

                    // Reset dados
                    this.resetDataSessaoPautado();

                    // Reset processo processado
                    const processo = obterNumeroProcesso();
                    if (processo) {
                        processosJaProcessados.delete(processo);
                        log("🔄 Processo removido da lista de processados");
                    }

                    log(
                        "✅ RESET: Sistema resetado, pronto para nova detecção"
                    );
                    return true;
                },

                // 🎯 FUNÇÕES UNIFICADAS DE TOOLTIP - SISTEMA ÚNICO CONSOLIDADO
                // Removidas todas as implementações duplicadas. APENAS adicionarTooltipUnificado() agora.
                detectarEConfigurarTooltipUnificado: function () {
                    log(
                        "  TOOLTIP: Função removida - use adicionarTooltipUnificado() diretamente"
                    );
                    return null;
                },

                configurarTooltipPorTipo: function (dados) {
                    log(
                        "🔧 TOOLTIP: Função removida - use adicionarTooltipUnificado() diretamente"
                    );
                    return null;
                },

                criarCardComTooltipIntegrado: function () {
                    log(
                        "🔧 TOOLTIP: Função removida - use adicionarTooltipUnificado() diretamente"
                    );
                    return null;
                },

                testarSistemaTooltipUnificado: function () {
                    log(
                        "🧪 TESTE UNIFICADO: Testando sistema simplificado de tooltip"
                    );

                    // Encontrar card
                    const card = document.querySelector(
                        "#eprobe-data-sessao, .eprobe-figma-card-pautado"
                    );
                    if (!card) {
                        log("❌ Card não encontrado");
                        return false;
                    }

                    // Aplicar tooltip unificado
                    const resultado = adicionarTooltipUnificado(card);
                    log("✅ Resultado:", resultado);

                    return resultado;
                },

                corrigirTooltipCardOriginal: function () {
                    log("🔧 CORRIGIR TOOLTIP: Usando função unificada...");

                    const cardOriginal = document.querySelector(
                        "#eprobe-data-sessao, .eprobe-figma-card-pautado"
                    );
                    if (!cardOriginal) {
                        logError("❌ Card original não encontrado");
                        return { erro: "card_original_nao_encontrado" };
                    }

                    // Usar APENAS a função unificada
                    const resultado = adicionarTooltipUnificado(cardOriginal);

                    if (resultado && resultado.status === "sucesso") {
                        log("✅ TOOLTIP CORRIGIDO: Sistema funcional aplicado");
                        return resultado;
                    } else {
                        logError("❌ TOOLTIP CORRIGIDO: Falha na aplicação");
                        return { erro: "falha_funcao_unificada" };
                    }
                },

                // 🧪 FUNÇÃO DE TESTE DE NAMESPACE
                testarNamespaceSENT1_AUTO: function () {
                    log(
                        "🧪 TESTE NAMESPACE: Validando todas as funções do namespace..."
                    );

                    if (typeof window.SENT1_AUTO === "undefined") {
                        console.error(
                            "❌ NAMESPACE: window.SENT1_AUTO não está definido!"
                        );
                        return false;
                    }

                    const funcoes = Object.keys(window.SENT1_AUTO);
                    const resultados = {
                        total: funcoes.length,
                        funcionais: 0,
                        comErro: 0,
                        erros: [],
                    };

                    log(
                        `📊 TESTE: Encontradas ${funcoes.length} funções no namespace`
                    );

                    funcoes.forEach((nome) => {
                        try {
                            const funcao = window.SENT1_AUTO[nome];
                            if (typeof funcao === "function") {
                                // Testamos apenas se a função é chamável, sem executá-la
                                const isCallable =
                                    funcao.constructor === Function ||
                                    funcao.constructor === AsyncFunction;
                                if (isCallable) {
                                    resultados.funcionais++;
                                    log(`✅ ${nome}: Função válida`);
                                } else {
                                    console.warn(
                                        `⚠️ ${nome}: Não é função executável`
                                    );
                                }
                            } else {
                                console.warn(
                                    `⚠️ ${nome}: Não é uma função (tipo: ${typeof funcao})`
                                );
                            }
                        } catch (error) {
                            resultados.comErro++;
                            resultados.erros.push({
                                nome,
                                erro: error.message,
                            });
                            console.error(
                                `❌ ${nome}: Erro - ${error.message}`
                            );
                        }
                    });

                    log("📈 RESULTADO FINAL:");
                    log(`  Total de funções: ${resultados.total}`);
                    log(`  Funcionais: ${resultados.funcionais}`);
                    logError(`  Com erro: ${resultados.comErro}`);

                    if (resultados.erros.length > 0) {
                        console.warn("⚠️ ERROS ENCONTRADOS:");
                        resultados.erros.forEach(({ nome, erro }) => {
                            console.warn(`  - ${nome}: ${erro}`);
                        });
                    }

                    const sucesso = resultados.comErro === 0;
                    log(
                        sucesso
                            ? "✅ TESTE: Namespace totalmente funcional!"
                            : "⚠️ TESTE: Namespace com problemas"
                    );

                    return {
                        sucesso,
                        ...resultados,
                    };
                },

                // 🔍 FUNÇÃO DE VERIFICAÇÃO DE REFERENCEERROR (REMOVIDA DO WINDOW.* INCORRETO)
                verificarReferenceErrors: function () {
                    log(
                        "🔍 VERIFICAÇÃO: Testando todas as funções problemáticas..."
                    );

                    const funcoesTestadas = [
                        "detectarPaginaLocalizadores",
                        "processarTabelaLocalizadores",
                        "destacarLocalizadoresUrgentes",
                        "detectarCardSessaoSimplificado",
                        "criarCardMaterialDesign",
                        "obterConfigFigmaStatus",
                        "adicionarTooltipInterativo",
                        "adicionarRichTooltipMaterialDesign",
                        "criarTooltipSimplificado",
                        "testarFuncaoTooltip",
                        "debugDivLembrete",
                        "estilizarDivLembrete",
                        "debugPadraoRetirado",
                        "debugStatusCompleto",
                        "forcarAtualizacaoStatus",
                        "testarCasoRetirado",
                        "testarSistemaStatusSessao",
                        "findToggleTarget",
                        "implementarAlternanciaExpandirRetrair",
                        "isElementSafeForToggle",
                        "debugPadroesStatusSessao",
                        "forcarStatusSessao",
                        "encontrarTextoRetirado",
                        "forcarDeteccaoCompleta",
                        "substituirIconesFieldsetAcoes",
                        "substituirIconesFerramentas",
                        "substituirIconesGlobalmente",
                        "debugIconesSubstituicao",
                        "forcarRecriacaoCardSessao",
                        "encontrarContainerParaCard",
                        "getTipoJulgamentoProcessoPautado",
                        "setTipoJulgamentoProcessoPautado",
                        "getStatusJulgamento",
                        "setStatusJulgamento",
                        "getDataSessao",
                        "setDataSessao",
                        "resetDadosGlobaisSessao",
                        "showDadosGlobaisSessao",
                    ];

                    const resultados = {
                        total: funcoesTestadas.length,
                        funcionais: 0,
                        problemáticas: 0,
                        erros: [],
                    };

                    log(`📊 Testando ${funcoesTestadas.length} funções...`);

                    funcoesTestadas.forEach((nome) => {
                        try {
                            if (
                                window.SENT1_AUTO &&
                                typeof window.SENT1_AUTO[nome] === "function"
                            ) {
                                // Função existe e é executável
                                resultados.funcionais++;
                                log(`✅ ${nome}: OK`);
                            } else {
                                resultados.problemáticas++;
                                resultados.erros.push(
                                    `${nome}: Não é função ou não existe`
                                );
                                console.warn(`⚠️ ${nome}: PROBLEMA`);
                            }
                        } catch (error) {
                            resultados.problemáticas++;
                            resultados.erros.push(`${nome}: ${error.message}`);
                            console.error(
                                `❌ ${nome}: ERRO - ${error.message}`
                            );
                        }
                    });

                    log("🎯 RESULTADO FINAL:");
                    log(`  ✅ Funcionais: ${resultados.funcionais}`);
                    logError(`  ❌ Problemáticas: ${resultados.problemáticas}`);

                    if (resultados.problemáticas === 0) {
                        log(
                            "🎉 SUCESSO TOTAL: Todos os ReferenceError foram eliminados!"
                        );
                    } else {
                        console.warn("⚠️ AINDA HÁ PROBLEMAS:");
                        resultados.erros.forEach((erro) =>
                            console.warn(`  - ${erro}`)
                        );
                    }

                    return resultados;
                },

                // 🔧 VERIFICAÇÃO SILENCIOSA DE FUNÇÕES (REMOVIDA DO WINDOW.* INCORRETO)
                verificarFuncoesSilenciosamente: function () {
                    const problemas = [];
                    const funcoesChave = [
                        "detectarCardSessaoSimplificado",
                        "criarCardMaterialDesign",
                        "detectarPaginaLocalizadores",
                        "substituirIconesFieldsetAcoes",
                    ];

                    funcoesChave.forEach((nome) => {
                        if (
                            !window.SENT1_AUTO ||
                            typeof window.SENT1_AUTO[nome] !== "function"
                        ) {
                            problemas.push(nome);
                        }
                    });

                    return {
                        temProblemas: problemas.length > 0,
                        problemas: problemas,
                        total: funcoesChave.length,
                        funcionais: funcoesChave.length - problemas.length,
                    };
                },

                // 🧠 SEMANTIC KERNEL - FUNCIONALIDADES EXPERIMENTAIS
                experimental: {
                    detectarDataSessaoComIA: detectarDataSessaoComIA,
                    semanticKernel: window.eProbeSemanticKernel,

                    // Função para testar o sistema
                    async testarIA() {
                        log("🧪 TESTE: Iniciando teste do Semantic Kernel");

                        const sk = window.eProbeSemanticKernel;
                        log("📊 Stats:", sk.getStats());

                        const resultado = await detectarDataSessaoComIA();

                        if (resultado) {
                            log("✅ TESTE: Sucesso!", resultado);
                            alert(
                                `Teste do Semantic Kernel:\n\n✅ Sucesso!\nData: ${
                                    resultado.dataFormatada
                                }\nMétodo: ${
                                    resultado.metodoDeteccao
                                }\nConfiança: ${resultado.confiancaIA || "N/A"}`
                            );
                        } else {
                            logError("❌ TESTE: Nenhuma data encontrada");
                            alert(
                                "Teste do Semantic Kernel:\n\n❌ Nenhuma data encontrada\n\nVerifique se há informações de sessão na página atual."
                            );
                        }

                        log("📊 Stats finais:", sk.getStats());
                        return resultado;
                    },

                    // Função para habilitar/desabilitar
                    toggleIA(enable) {
                        const sk = window.eProbeSemanticKernel;
                        if (enable) {
                            sk.enable();
                        } else {
                            sk.disable();
                        }
                        log(`🔧 IA ${enable ? "habilitada" : "desabilitada"}`);
                    },

                    // Função para ver estatísticas
                    statsIA() {
                        const stats = window.eProbeSemanticKernel.getStats();
                        log("📊 SEMANTIC KERNEL STATS:", stats);
                        alert(
                            `Estatísticas do Semantic Kernel:\n\n• Habilitado: ${
                                stats.enabled ? "Sim" : "Não"
                            }\n• Requisições usadas: ${stats.requestCount}/${
                                stats.maxRequests
                            }\n• Restantes: ${
                                stats.requestsRemaining
                            }\n• Modo teste: ${
                                stats.testMode ? "Sim" : "Não"
                            }\n• Fallback: ${
                                stats.fallbackEnabled ? "Sim" : "Não"
                            }`
                        );
                        return stats;
                    },
                },

                // 🔗 FUNÇÕES DE TESTE PARA LINKS DE SESSÃO
                testarExtracacaoLinkSessao: async function (indiceSessao = 1) {
                    logCritical(
                        `🧪 TESTE: Testando extração de link da sessão ${indiceSessao}`
                    );

                    try {
                        const url = window.location.href;
                        logCritical(`📍 TESTE: URL atual: ${url}`);

                        // Verificar se estamos na página correta
                        if (url.includes("processo_selecionar")) {
                            logCritical(
                                "⚠️ TESTE: Você está na página de seleção - navegue para a página de detalhes do processo"
                            );
                            alert(
                                "Para testar a extração de links de sessão, você precisa estar na página de detalhes do processo, não na página de seleção."
                            );
                            return null;
                        }

                        const linkExtraido = await extrairLinkSessao(
                            indiceSessao
                        );

                        if (linkExtraido) {
                            logCritical(`✅ TESTE: Link extraído com sucesso!`);
                            logCritical(`🔗 TESTE: Link: ${linkExtraido}`);

                            // Verificar se é o tipo de link que queremos
                            const ehLinkSessaoJulgamento =
                                linkExtraido.includes(
                                    "sessao_julgamento_exibir_painel"
                                );
                            const temParametrosCompletos = [
                                "id_sessao_julgamento",
                                "id_orgao_julgador",
                                "txtNumProcesso",
                            ].every((param) => linkExtraido.includes(param));

                            logCritical(
                                `🎯 TESTE: É link de sessão de julgamento: ${ehLinkSessaoJulgamento}`
                            );
                            logCritical(
                                `📊 TESTE: Tem parâmetros completos: ${temParametrosCompletos}`
                            );

                            alert(
                                `Link da sessão extraído!\n\nTipo: ${
                                    ehLinkSessaoJulgamento
                                        ? "Sessão de Julgamento"
                                        : "Outro tipo"
                                }\nCompleto: ${
                                    temParametrosCompletos ? "Sim" : "Não"
                                }\n\nVerifique o console para detalhes.`
                            );

                            return {
                                link: linkExtraido,
                                tipoCorreto: ehLinkSessaoJulgamento,
                                parametrosCompletos: temParametrosCompletos,
                            };
                        } else {
                            logCritical(`❌ TESTE: Falha na extração do link`);
                            alert(
                                "Falha na extração do link. Verifique o console para detalhes."
                            );
                            return null;
                        }
                    } catch (error) {
                        console.error("❌ TESTE: Erro durante o teste:", error);
                        alert(`Erro durante o teste: ${error.message}`);
                        return null;
                    }
                },

                extrairLinkSessao: extrairLinkSessao,
                construirUrlSessao: construirUrlSessao,

                // 🧪 DEBUG - Tooltip Unificado
                debugTooltipUnificado: debugTooltipUnificado,

                // 🎯 TOOLTIP UNIFICADO - FUNÇÕES DE TESTE SIMPLIFICADAS
                testarTooltipComDadosReais: function () {
                    log("🎨 TESTE: Aplicando tooltip visual rico restaurado");

                    const card = document.querySelector(
                        "#eprobe-data-sessao, .eprobe-figma-card-pautado"
                    );
                    if (!card) {
                        log("❌ TOOLTIP: Card não encontrado");
                        return false;
                    }

                    // Criar dados de teste com visual rico
                    const dadosTeste = [
                        {
                            tipo: "Julgamento Virtual",
                            status: "Julgado",
                            data: "25/07/2025",
                            orgao: "2ª Câmara de Direito Civil",
                            cor: "#22C55E",
                            statusOriginal: "JULGADO",
                            isAtual: true,
                            observacoes:
                                "Julgamento realizado em sessão virtual",
                        },
                        {
                            tipo: "Julgamento Presencial",
                            status: "Pautado",
                            data: "30/07/2025",
                            orgao: "1ª Câmara de Direito Público",
                            cor: "#3B82F6",
                            statusOriginal: "PAUTADO",
                            isAtual: false,
                        },
                    ];

                    // Aplicar tooltip unificado com dados de teste
                    const resultado = adicionarTooltipUnificado(
                        card,
                        dadosTeste
                    );

                    if (resultado && resultado.status === "sucesso") {
                        log(
                            "✅ TOOLTIP RICO: Aplicado com sucesso - passe o mouse sobre o card para ver!"
                        );

                        // Simular hover automático para demonstração
                        setTimeout(() => {
                            const mouseEvent = new MouseEvent("mouseenter", {
                                bubbles: true,
                                cancelable: true,
                                clientX: 200,
                                clientY: 200,
                            });
                            card.dispatchEvent(mouseEvent);

                            log(
                                "🎯 DEMONSTRAÇÃO: Tooltip ativado automaticamente por 5 segundos"
                            );

                            // Esconder após demonstração
                            setTimeout(() => {
                                const mouseLeave = new MouseEvent(
                                    "mouseleave",
                                    {
                                        bubbles: true,
                                        cancelable: true,
                                    }
                                );
                                card.dispatchEvent(mouseLeave);
                                log("✨ DEMONSTRAÇÃO: Tooltip escondido");
                            }, 5000);
                        }, 1000);

                        return true;
                    } else {
                        log("❌ TOOLTIP RICO: Falha na aplicação");
                        return false;
                    }
                },

                validarSistemaTooltipCompleto: function () {
                    log("🎯 VALIDAÇÃO: Sistema de tooltip unificado");

                    const relatorio = {
                        timestamp: new Date().toLocaleString("pt-BR"),
                        tooltipsNaPagina:
                            document.querySelectorAll('[id*="tooltip"]').length,
                        funcaoUnificada:
                            typeof adicionarTooltipUnificado === "function",
                        cardEncontrado: !!document.querySelector(
                            "#eprobe-data-sessao, .eprobe-figma-card-pautado"
                        ),
                    };

                    log("📊 RELATÓRIO:", relatorio);
                    return relatorio;
                },

                testarPosicionamentoCorrigido: function () {
                    log("🚀 TESTE: Posicionamento fixo do tooltip");

                    const card = document.querySelector(
                        "#eprobe-data-sessao, .eprobe-figma-card-pautado"
                    );
                    if (!card) {
                        log("❌ Card não encontrado");
                        return false;
                    }

                    // Testar tooltip com posicionamento fixo
                    const resultado = adicionarTooltipUnificado(card);

                    if (resultado && resultado.status === "sucesso") {
                        log(
                            "✅ Tooltip configurado! Passe o mouse sobre o indicador para ver na posição top: 70px, left: -50px"
                        );
                        return true;
                    } else {
                        log("❌ Falha ao configurar tooltip");
                        return false;
                    }
                },

                // 🧪 FUNÇÃO DE TESTE RÁPIDA PARA DEBUG - NOVA ESTRUTURA DOM
                debugDeteccaoSessaoRapida: debugDeteccaoSessaoRapida,

                // 🧪 TESTE ESPECÍFICO PARA REGEX
                testarRegexEspecifica: testarRegexEspecifica,

                // 🧪 TESTE PARA EXTRAÇÃO DE TIPOS
                testarExtracaoTipos: testarExtracaoTipos,

                // 🔍 DEBUG ESPECÍFICO PARA TOOLTIP E TIPO
                debugTooltipComTipo: debugTooltipComTipo,

                // 🔍 NOVA FUNÇÃO: Verificar se o tipo de sessão está sendo capturado corretamente
                debugTipoSessaoTooltip: function () {
                    log("🔍 DEBUG: Verificando captura do tipo de sessão...");

                    // 1. Verificar dados detectados
                    const dadosSessoes =
                        window.SENT1_AUTO.detectarSessoesUnificado(true);
                    if (!dadosSessoes || !dadosSessoes.todasSessoes) {
                        console.error("❌ Nenhuma sessão detectada");
                        return false;
                    }

                    log("📊 SESSÕES DETECTADAS:", dadosSessoes);

                    // 2. Verificar cada sessão individualmente
                    dadosSessoes.todasSessoes.forEach((sessao, index) => {
                        log(`🔍 SESSÃO ${index + 1}:`, {
                            tipo: sessao.tipo,
                            status: sessao.status,
                            data: sessao.data,
                            orgao: sessao.orgao,
                            textoCompleto:
                                sessao.textoCompleto?.substring(0, 100) + "...",
                        });

                        // Verificar se o tipo está vazio ou indefinido
                        if (!sessao.tipo || sessao.tipo.trim() === "") {
                            console.warn(
                                `⚠️ SESSÃO ${
                                    index + 1
                                }: Tipo vazio ou indefinido!`
                            );

                            // Tentar extrair o tipo novamente do texto completo
                            if (sessao.textoCompleto) {
                                const match =
                                    sessao.textoCompleto.match(/^([^(]+)/);
                                if (match) {
                                    const tipoExtraido = match[1].trim();
                                    log(`💡 TIPO EXTRAÍDO: "${tipoExtraido}"`);
                                }
                            }
                        } else {
                            log(
                                `✅ SESSÃO ${index + 1}: Tipo OK - "${
                                    sessao.tipo
                                }"`
                            );
                        }
                    });

                    // 3. Verificar tooltip atual
                    const card = document.querySelector(".eprobe-card-sessao");
                    if (card) {
                        log("🎯 TESTANDO TOOLTIP:");

                        // Simular hover para ativar tooltip
                        const event = new MouseEvent("mouseenter", {
                            bubbles: true,
                            cancelable: true,
                        });
                        card.dispatchEvent(event);

                        setTimeout(() => {
                            const tooltip = document.querySelector(
                                ".eprobe-tooltip-unificado"
                            );
                            if (tooltip) {
                                const conteudo = tooltip.innerHTML;
                                log(
                                    "📝 CONTEÚDO DO TOOLTIP:",
                                    conteudo.substring(0, 500) + "..."
                                );

                                // Verificar se há menção aos tipos
                                const tiposEncontrados = conteudo.match(
                                    /Embargos|Apelação|Agravo|Recurso/gi
                                );
                                if (tiposEncontrados) {
                                    log(
                                        "✅ TIPOS ENCONTRADOS NO TOOLTIP:",
                                        tiposEncontrados
                                    );
                                } else {
                                    console.warn(
                                        "⚠️ NENHUM TIPO ENCONTRADO NO TOOLTIP"
                                    );
                                }
                            }
                        }, 200);
                    }

                    return true;
                },

                // 🎨 FUNÇÃO UNIFICADA DE NAVBAR - SOLUÇÃO CONSOLIDADA
                unificarNavbarStyles: unificarNavbarStyles,

                // 🎯 FUNÇÃO OBRIGATÓRIA: Forçar flexbox na navbar - CRÍTICA
                forcarFlexboxNavbar: () => {
                    const elementosNavbar =
                        document.querySelectorAll(".d-none.d-md-flex");
                    elementosNavbar.forEach((elemento) => {
                        elemento.style.setProperty(
                            "display",
                            "flex",
                            "important"
                        );
                        elemento.style.setProperty(
                            "align-items",
                            "center",
                            "important"
                        );
                        elemento.style.setProperty(
                            "visibility",
                            "visible",
                            "important"
                        );
                        elemento.style.setProperty("opacity", "1", "important");
                    });

                    if (elementosNavbar.length > 0) {
                        console.log(
                            `🎯 NAVBAR CRÍTICO: Flexbox forçado em ${elementosNavbar.length} elementos via namespace principal`
                        );
                    }
                    return elementosNavbar.length;
                },
            };

            // Fim da seção de funcionalidades
            // ##### FIM DO NAMESPACE CONSOLIDADO #####
        })(); // ← FECHAMENTO DA FUNÇÃO ASYNC INTERNA

        // 🎨 DEFINIR FUNÇÕES DE GRADIENTES ANTES DO NAMESPACE

        // 🔍 FUNÇÃO AUXILIAR: Verificar se estamos numa página de capa do processo
        function isCapaProcessoPage() {
            const url = window.location.href;
            // Verificar se a URL contém o padrão de capa do processo
            return (
                url.includes("acao=processo_selecionar") &&
                (url.includes("eproc1g.tjsc.jus.br") ||
                    url.includes("eproc2g.tjsc.jus.br"))
            );
        }

        /**
         * 🎨 FUNÇÃO PARA APLICAR GRADIENTES NA CAPA DO PROCESSO
         * Substitui cores sólidas de background por gradientes suaves no fieldset da capa
         * Baseado na documentação "cores capa do processo.md"
         */
        function aplicarGradientesCapaProcesso() {
            log("🎨 GRADIENTES CAPA: Iniciando aplicação de gradientes...");

            // Verificar se estamos na página correta
            if (!isCapaProcessoPage()) {
                log("❌ GRADIENTES CAPA: Não é uma página de capa de processo");
                return false;
            }

            // Buscar o fieldset da capa
            const fieldsetCapa = document.querySelector(
                "#fldCapa.infraFieldset.bootstrap-styles"
            );
            if (!fieldsetCapa) {
                log("❌ GRADIENTES CAPA: Fieldset #fldCapa não encontrado");
                return false;
            }

            log("✅ GRADIENTES CAPA: Fieldset encontrado:", fieldsetCapa);

            // Obter estilo computed atual
            const estiloComputado = window.getComputedStyle(fieldsetCapa);
            const corAtual = estiloComputado.backgroundColor;

            log("🔍 GRADIENTES CAPA: Cor atual detectada:", corAtual);

            // Função para converter RGB para hex
            function rgbParaHex(rgb) {
                if (rgb.startsWith("#")) return rgb.toLowerCase();

                const rgbMatch = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1])
                        .toString(16)
                        .padStart(2, "0");
                    const g = parseInt(rgbMatch[2])
                        .toString(16)
                        .padStart(2, "0");
                    const b = parseInt(rgbMatch[3])
                        .toString(16)
                        .padStart(2, "0");
                    return `#${r}${g}${b}`;
                }

                return rgb;
            }

            // Mapeamento de cores para gradientes conforme documentação
            const mapeamentoCores = {
                // AMARELO
                "#efd88f": "linear-gradient(#F9EFAF, #F7E98D)",

                // VERMELHO (formato rgb)
                "rgb(142, 53, 35)": "linear-gradient(#FAAFAF, #F78D8D)",
                "rgb(142,53,35)": "linear-gradient(#FAAFAF, #F78D8D)", // sem espaços

                // AZUL
                "#c4dffb": "linear-gradient(#AFCFFA, #8DC0F7)",

                // VERDE
                "#a7eda7": "linear-gradient(#AFFAB6, #8DF792)",

                // LARANJA
                "#f5b574": "linear-gradient(#FAD3AF, #F7C68D)",

                // CINZA
                "#a0b9bf": "linear-gradient(#B5C9CF, #9CB0B7)",
                "#A0B9BF": "linear-gradient(#B5C9CF, #9CB0B7)", // case insensitive

                // ROSA
                "#fbc4df": "linear-gradient(#FBAFDF, #F78DC7)",
            };

            // Verificar múltiplos formatos da cor atual
            const formatosPossiveisCor = [
                corAtual,
                corAtual.replace(/\s+/g, ""), // sem espaços
                rgbParaHex(corAtual),
                rgbParaHex(corAtual).toUpperCase(),
            ];

            log("🔍 GRADIENTES CAPA: Formatos testados:", formatosPossiveisCor);

            let gradienteEncontrado = null;
            let corCorrespondente = null;

            // Buscar correspondência nos mapeamentos
            for (const formato of formatosPossiveisCor) {
                if (mapeamentoCores[formato]) {
                    gradienteEncontrado = mapeamentoCores[formato];
                    corCorrespondente = formato;
                    break;
                }
            }

            if (gradienteEncontrado) {
                log(`🎉 GRADIENTES CAPA: Correspondência encontrada!`);
                log(`   Cor original: ${corCorrespondente}`);
                log(`   Gradiente: ${gradienteEncontrado}`);

                // Aplicar o gradiente seguindo padrão das outras funções
                try {
                    fieldsetCapa.style.setProperty(
                        "background",
                        gradienteEncontrado,
                        "important"
                    );
                    log("✅ GRADIENTES CAPA: Gradiente aplicado com sucesso!");

                    return {
                        sucesso: true,
                        corOriginal: corCorrespondente,
                        gradienteAplicado: gradienteEncontrado,
                        elemento: fieldsetCapa,
                    };
                } catch (error) {
                    logError(
                        "❌ GRADIENTES CAPA: Erro ao aplicar gradiente:",
                        error
                    );
                    return false;
                }
            } else {
                log(
                    `❌ GRADIENTES CAPA: Cor não reconhecida para substituição: ${corAtual}`
                );
                log(
                    "💡 GRADIENTES CAPA: Cores suportadas:",
                    Object.keys(mapeamentoCores)
                );

                return {
                    sucesso: false,
                    corNaoReconhecida: corAtual,
                    coresSuportadas: Object.keys(mapeamentoCores),
                };
            }
        }

        /**
         * 🔄 FUNÇÃO DE APLICAÇÃO ROBUSTA DE GRADIENTES - Com detecção inteligente e retry automático
         */
        function aplicarGradientesCapaProcessoRobusta() {
            log(
                "🔄 GRADIENTES ROBUSTA: Iniciando aplicação robusta de gradientes..."
            );

            // Verificar se estamos na página correta primeiro
            if (!isCapaProcessoPage()) {
                log(
                    "ℹ️ GRADIENTES ROBUSTA: Não é uma página de capa de processo"
                );
                return false;
            }

            let tentativas = 0;
            const maxTentativas = 5;
            const intervalTentativas = 1000; // 1 segundo entre tentativas

            const tentarAplicarGradientes = () => {
                tentativas++;
                log(`🎯 GRADIENTES: Tentativa ${tentativas}/${maxTentativas}`);

                const resultado = aplicarGradientesCapaProcesso();
                const sucesso = resultado && resultado.sucesso;

                if (!sucesso && tentativas < maxTentativas) {
                    log(
                        `⏳ GRADIENTES: Aguardando ${intervalTentativas}ms para nova tentativa...`
                    );
                    setTimeout(tentarAplicarGradientes, intervalTentativas);
                } else if (sucesso) {
                    log(
                        "✅ GRADIENTES ROBUSTA: Gradientes aplicados com sucesso!"
                    );
                    log(
                        `📊 RESULTADOS: Cor original: ${resultado.corOriginal}, Gradiente: ${resultado.gradienteAplicado}`
                    );
                } else {
                    log(
                        "⚠️ GRADIENTES ROBUSTA: Não foi possível aplicar gradientes após todas as tentativas"
                    );
                }
            };

            // Iniciar primeira tentativa
            tentarAplicarGradientes();

            // Também agendar uma verificação após carregamento completo
            if (document.readyState !== "complete") {
                window.addEventListener("load", () => {
                    setTimeout(() => {
                        log("🔄 GRADIENTES: Verificação pós-carregamento...");
                        aplicarGradientesCapaProcesso();
                    }, 500);
                });
            }

            return true;
        }

        /**
         * 🎨 FUNÇÃO PARA PERSONALIZAR LEGMINUTAS E TABELAS
         * Substitui cores sólidas por gradientes suaves nos elementos de minutas
         * Baseado na documentação "cores legMinutas.md"
         */
        function aplicarGradientesLegMinutas() {
            log(
                "🎨 GRADIENTES MINUTAS: Iniciando aplicação de gradientes nas minutas..."
            );

            // Verificar se estamos na página correta
            if (!isCapaProcessoPage()) {
                log(
                    "⛔ GRADIENTES MINUTAS: Função restrita à capa do processo"
                );
                return { sucesso: false, motivo: "página não permitida" };
            }

            // Mapeamento de cores para gradientes - legMinutas
            const mapeamentoCoresLegendas = {
                "#98F5FF": "linear-gradient(#AFCFFA, #8DC0F7)", // AZUL
                "#FFA07A": "linear-gradient(#FFB8AF, #FF9C8D)", // LARANJA INTENSO
                "#FFD39B": "linear-gradient(#FAD3AF, #F7C68D)", // LARANJA CLARO
                "#FFC125": "linear-gradient(#FFDE8F, #FFB84D)", // DOURADO
                "#CDB5CD": "linear-gradient(#D8C7D8, #C4A5C4)", // LILÁS
                "#D3D3D3": "linear-gradient(#B5C9CF, #9CB0B7)", // CINZA
                "#EE6363": "linear-gradient(#FAAFAF, #F78D8D)", // VERMELHA
                "#FFFF00": "linear-gradient(#FFFF8F, #F0F04D)", // VERDE LIMÃO
                "#FFBBFF": "linear-gradient(#FFC9FF, #FF9CFF)", // ROSA CLARO
                "#FFF68F": "linear-gradient(#F9EFAF, #F7E98D)", // AMARELA
                "#90EE90": "linear-gradient(#AFFAB6, #8DF792)", // VERDE
            };

            // Mapeamento de cores para tabelas - infraTrClara (tons claros)
            const mapeamentoCoresInfraClara = {
                "#98F5FF": "linear-gradient(#AFCFFA, #8DC0F7)", // AZUL
                "#FFA07A": "linear-gradient(#FFB8AF, #FF9C8D)", // LARANJA INTENSO
                "#FFD39B": "linear-gradient(#FAD3AF, #F7C68D)", // LARANJA CLARO
                "#FFC125": "linear-gradient(#FFDE8F, #FFB84D)", // DOURADO
                "#CDB5CD": "linear-gradient(#D8C7D8, #C4A5C4)", // LILÁS
                "#D3D3D3": "linear-gradient(#B5C9CF, #9CB0B7)", // CINZA
                "#EE6363": "linear-gradient(#FAAFAF, #F78D8D)", // VERMELHA
                "#FFFF00": "linear-gradient(#FFFF8F, #F0F04D)", // VERDE LIMÃO
                "#FFBBFF": "linear-gradient(#FFC9FF, #FF9CFF)", // ROSA CLARO
                "#FFF68F": "linear-gradient(#F9EFAF, #F7E98D)", // AMARELA
                "#90EE90": "linear-gradient(#AFFAB6, #8DF792)", // VERDE
            };

            // Mapeamento de cores para tabelas - infraTrEscura (tons escuros)
            const mapeamentoCoresInfraEscura = {
                "#98F5FF": "linear-gradient(#7AB5F3, #5A9DEF)", // AZUL
                "#FFA07A": "linear-gradient(#FF8D7A, #FF6B58)", // LARANJA INTENSO
                "#FFD39B": "linear-gradient(#F5B87A, #F2A558)", // LARANJA CLARO
                "#FFC125": "linear-gradient(#FFA93A, #FF9520)", // DOURADO
                "#CDB5CD": "linear-gradient(#B593B5, #A082A0)", // LILÁS
                "#D3D3D3": "linear-gradient(#8A9EA5, #778C93)", // CINZA
                "#EE6363": "linear-gradient(#F47A7A, #F15858)", // VERMELHA
                "#FFFF00": "linear-gradient(#E6E63A, #CCCC20)", // VERDE LIMÃO
                "#FFBBFF": "linear-gradient(#FF7AFF, #FF58FF)", // ROSA CLARO
                "#FFF68F": "linear-gradient(#F5DC7A, #F3D058)", // AMARELA
                "#90EE90": "linear-gradient(#7AF381, #58EF5F)", // VERDE
            };

            let processados = 0;

            // Função para converter RGB para hex
            function rgbParaHex(rgb) {
                if (rgb.startsWith("#")) return rgb.toLowerCase();

                const rgbMatch = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1])
                        .toString(16)
                        .padStart(2, "0");
                    const g = parseInt(rgbMatch[2])
                        .toString(16)
                        .padStart(2, "0");
                    const b = parseInt(rgbMatch[3])
                        .toString(16)
                        .padStart(2, "0");
                    return `#${r}${g}${b}`;
                }

                return rgb;
            }

            try {
                // 1. PROCESSAR LEGENDA MINUTAS - USAR QUERYSELECTORALL PARA TODOS OS ELEMENTOS
                const elementosLegMinutas = document.querySelectorAll(
                    'legend[aria-label="Histórico"]#legMinutas.infraLegendObrigatorio'
                );

                log(
                    `🔍 GRADIENTES MINUTAS: Encontrados ${elementosLegMinutas.length} elementos legMinutas`
                );

                elementosLegMinutas.forEach((legMinutas, index) => {
                    const corAtual = rgbParaHex(
                        window.getComputedStyle(legMinutas).backgroundColor
                    );
                    if (
                        corAtual &&
                        mapeamentoCoresLegendas[corAtual.toUpperCase()]
                    ) {
                        const novoGradiente =
                            mapeamentoCoresLegendas[corAtual.toUpperCase()];
                        legMinutas.style.setProperty(
                            "background",
                            novoGradiente,
                            "important"
                        );
                        log(
                            `✅ GRADIENTES MINUTAS: legMinutas ${
                                index + 1
                            } ${corAtual} → ${novoGradiente}`
                        );
                        processados++;
                    } else {
                        log(
                            `⚠️ GRADIENTES MINUTAS: legMinutas ${
                                index + 1
                            } cor não mapeada: ${corAtual}`
                        );
                    }
                });

                // 2. PROCESSAR TABELAS DENTRO DOS CONTAINERS DE MINUTAS
                const containersMinutas = document.querySelectorAll(
                    '[id^="conteudoInternoMinutas_"]'
                );
                containersMinutas.forEach((container, index) => {
                    log(
                        `🔍 GRADIENTES MINUTAS: Processando container ${
                            index + 1
                        }: ${container.id}`
                    );

                    // Processar linhas claras (infraTrClara)
                    const linhasClaras =
                        container.querySelectorAll("tr.infraTrClara");
                    linhasClaras.forEach((linha, linhaIndex) => {
                        const corAtual = rgbParaHex(
                            window.getComputedStyle(linha).backgroundColor
                        );
                        if (
                            corAtual &&
                            mapeamentoCoresInfraClara[corAtual.toUpperCase()]
                        ) {
                            const novoGradiente =
                                mapeamentoCoresInfraClara[
                                    corAtual.toUpperCase()
                                ];
                            linha.style.setProperty(
                                "background",
                                novoGradiente,
                                "important"
                            );
                            log(
                                `✅ GRADIENTES MINUTAS: infraTrClara[${linhaIndex}] ${corAtual} → ${novoGradiente}`
                            );
                            processados++;
                        }
                    });

                    // Processar linhas escuras (infraTrEscura)
                    const linhasEscuras =
                        container.querySelectorAll("tr.infraTrEscura");
                    linhasEscuras.forEach((linha, linhaIndex) => {
                        const corAtual = rgbParaHex(
                            window.getComputedStyle(linha).backgroundColor
                        );
                        if (
                            corAtual &&
                            mapeamentoCoresInfraEscura[corAtual.toUpperCase()]
                        ) {
                            const novoGradiente =
                                mapeamentoCoresInfraEscura[
                                    corAtual.toUpperCase()
                                ];
                            linha.style.setProperty(
                                "background",
                                novoGradiente,
                                "important"
                            );
                            log(
                                `✅ GRADIENTES MINUTAS: infraTrEscura[${linhaIndex}] ${corAtual} → ${novoGradiente}`
                            );
                            processados++;
                        }
                    });
                });

                log(
                    `✅ GRADIENTES MINUTAS: ${processados} elementos processados com sucesso`
                );
                return {
                    sucesso: true,
                    processados,
                    legMinutasEncontrado: !!document.querySelector(
                        "#legMinutas.infraLegendObrigatorio"
                    ),
                    containersEncontrados: containersMinutas.length,
                };
            } catch (error) {
                console.error(
                    "❌ GRADIENTES MINUTAS: Erro durante aplicação:",
                    error
                );
                return {
                    sucesso: false,
                    motivo: error.message,
                    processados,
                };
            }
        }

        /**
         * 🔄 FUNÇÃO DE APLICAÇÃO ROBUSTA DE GRADIENTES MINUTAS - Com retry automático
         */
        function aplicarGradientesLegMinutasRobusta() {
            log(
                "🔄 GRADIENTES MINUTAS ROBUSTA: Iniciando aplicação robusta de gradientes nas minutas..."
            );

            // Verificar se estamos na página correta primeiro
            if (!isCapaProcessoPage()) {
                log(
                    "ℹ️ GRADIENTES MINUTAS ROBUSTA: Não é uma página de capa de processo"
                );
                return false;
            }

            let tentativas = 0;
            const maxTentativas = 3;
            const intervalTentativas = 800; // 800ms entre tentativas

            const tentarAplicarGradientes = () => {
                tentativas++;
                log(
                    `🎯 GRADIENTES MINUTAS: Tentativa ${tentativas}/${maxTentativas}`
                );

                const resultado = aplicarGradientesLegMinutas();
                const sucesso = resultado && resultado.sucesso;

                if (sucesso) {
                    log(
                        `✅ GRADIENTES MINUTAS ROBUSTA: Aplicação bem-sucedida na tentativa ${tentativas}!`
                    );
                    log(
                        `📊 GRADIENTES MINUTAS: ${resultado.processados} elementos processados`
                    );
                    return true;
                } else {
                    log(
                        `❌ GRADIENTES MINUTAS: Tentativa ${tentativas} falhou`
                    );
                    if (resultado?.motivo) {
                        log(`   Motivo: ${resultado.motivo}`);
                    }

                    if (tentativas < maxTentativas) {
                        log(
                            `🔄 GRADIENTES MINUTAS: Reagendando tentativa em ${intervalTentativas}ms...`
                        );
                        setTimeout(tentarAplicarGradientes, intervalTentativas);
                    } else {
                        log(
                            "❌ GRADIENTES MINUTAS ROBUSTA: Todas as tentativas falharam - desistindo"
                        );
                        return false;
                    }
                }
            };

            // Executar primeira tentativa imediatamente
            return tentarAplicarGradientes();
        }

        // 🚀 EXPOSIÇÃO GLOBAL DO NAMESPACE - CRÍTICO!
        // Criar namespace com funções essenciais diretamente

        window.SENT1_AUTO = {
            // Funções principais detectadas e disponíveis
            detectarSessoesUnificado:
                typeof detectarSessoesUnificado === "function"
                    ? detectarSessoesUnificado
                    : () =>
                          console.log(
                              "detectarSessoesUnificado não disponível"
                          ),
            aplicarTooltipUnificado:
                typeof aplicarTooltipUnificado === "function"
                    ? aplicarTooltipUnificado
                    : () =>
                          console.log("aplicarTooltipUnificado não disponível"),
            criarCardSessaoMaterial:
                typeof criarCardSessaoMaterial === "function"
                    ? criarCardSessaoMaterial
                    : () =>
                          console.log("criarCardSessaoMaterial não disponível"),

            // Funções de teste e debug
            testarRegexEspecifica:
                typeof testarRegexEspecifica === "function"
                    ? testarRegexEspecifica
                    : () => console.log("testarRegexEspecifica não disponível"),
            testarExtracaoTipos:
                typeof testarExtracaoTipos === "function"
                    ? testarExtracaoTipos
                    : () => console.log("testarExtracaoTipos não disponível"),
            debugTooltipComTipo:
                typeof debugTooltipComTipo === "function"
                    ? debugTooltipComTipo
                    : () => console.log("debugTooltipComTipo não disponível"),
            debugDeteccaoSessaoRapida:
                typeof debugDeteccaoSessaoRapida === "function"
                    ? debugDeteccaoSessaoRapida
                    : () =>
                          console.log(
                              "debugDeteccaoSessaoRapida não disponível"
                          ),
            diagnosticarSistemaCompleto:
                typeof diagnosticarSistemaCompleto === "function"
                    ? diagnosticarSistemaCompleto
                    : () =>
                          console.log(
                              "diagnosticarSistemaCompleto não disponível"
                          ),

            // Funções de dados
            hasDataSessaoPautado: hasDataSessaoPautado,
            getDataSessaoPautado: getDataSessaoPautado,
            resetDataSessaoPautado: resetDataSessaoPautado,
            resetControlesRequisicao: resetControlesRequisicao,
            obterNumeroProcesso: obterNumeroProcesso,

            // Funções de interface
            inserirDataSessaoNaInterface: inserirDataSessaoNaInterface,
            inserirCardNaInterface:
                typeof inserirCardNaInterface === "function"
                    ? inserirCardNaInterface
                    : () =>
                          console.log("inserirCardNaInterface não disponível"),
            testarDeteccaoDinamicaFieldset:
                typeof testarDeteccaoDinamicaFieldset === "function"
                    ? testarDeteccaoDinamicaFieldset
                    : () =>
                          console.log(
                              "testarDeteccaoDinamicaFieldset não disponível"
                          ),

            // Funções de tema
            applyThemeStyles:
                typeof applyThemeStyles === "function"
                    ? applyThemeStyles
                    : window.applyThemeStyles ||
                      (() => console.log("applyThemeStyles não disponível")),
            unificarNavbarStyles:
                typeof unificarNavbarStyles === "function"
                    ? unificarNavbarStyles
                    : window.unificarNavbarStyles ||
                      (() =>
                          console.log("unificarNavbarStyles não disponível")),
            corrigirCorDeFundoConservadora: corrigirCorDeFundoConservadora,
            debugEncontrarCores:
                typeof debugEncontrarCores === "function"
                    ? debugEncontrarCores
                    : () => console.log("debugEncontrarCores não disponível"),
            testarCorrecaoCorFundo:
                typeof testarCorrecaoCorFundo === "function"
                    ? testarCorrecaoCorFundo
                    : () =>
                          console.log("testarCorrecaoCorFundo não disponível"),

            // 🎨 GRADIENTES PARA CAPA DO PROCESSO
            aplicarGradientesCapaProcesso:
                typeof aplicarGradientesCapaProcesso === "function"
                    ? aplicarGradientesCapaProcesso
                    : () =>
                          console.log(
                              "aplicarGradientesCapaProcesso não disponível"
                          ),
            aplicarGradientesCapaProcessoRobusta:
                typeof aplicarGradientesCapaProcessoRobusta === "function"
                    ? aplicarGradientesCapaProcessoRobusta
                    : () =>
                          console.log(
                              "aplicarGradientesCapaProcessoRobusta não disponível"
                          ),
            aplicarGradientesLegMinutas:
                typeof aplicarGradientesLegMinutas === "function"
                    ? aplicarGradientesLegMinutas
                    : () =>
                          console.log(
                              "aplicarGradientesLegMinutas não disponível"
                          ),
            aplicarGradientesLegMinutasRobusta:
                typeof aplicarGradientesLegMinutasRobusta === "function"
                    ? aplicarGradientesLegMinutasRobusta
                    : () =>
                          console.log(
                              "aplicarGradientesLegMinutasRobusta não disponível"
                          ),
            forcarFlexboxNavbar: () => {
                const elementosNavbar =
                    document.querySelectorAll(".d-none.d-md-flex");
                elementosNavbar.forEach((elemento) => {
                    elemento.style.setProperty("display", "flex", "important");
                    elemento.style.setProperty(
                        "align-items",
                        "center",
                        "important"
                    );
                    elemento.style.setProperty(
                        "visibility",
                        "visible",
                        "important"
                    );
                    elemento.style.setProperty("opacity", "1", "important");
                });
                return elementosNavbar.length;
            },

            // Funções de controle de processo
            processoJaFoiProcessado: processoJaFoiProcessado,
            marcarProcessoComoProcessado: marcarProcessoComoProcessado,

            // Funções auxiliares
            traduzirSiglaOrgao:
                typeof traduzirSiglaOrgao === "function"
                    ? traduzirSiglaOrgao
                    : () => console.log("traduzirSiglaOrgao não disponível"),
            extrairTipoSessao:
                typeof extrairTipoSessao === "function"
                    ? extrairTipoSessao
                    : () => console.log("extrairTipoSessao não disponível"),
            obterCorPorStatus:
                typeof obterCorPorStatus === "function"
                    ? obterCorPorStatus
                    : () => console.log("obterCorPorStatus não disponível"),

            // Função para verificar se é página de capa do processo
            isCapaProcessoPage:
                typeof isCapaProcessoPage === "function"
                    ? isCapaProcessoPage
                    : () => console.log("isCapaProcessoPage não disponível"),

            // 📏 Função para aplicar dimensionamento específico em divListaRecursosMinuta
            aplicarDimensionamentoRecursosMinuta:
                typeof aplicarDimensionamentoRecursosMinuta === "function"
                    ? aplicarDimensionamentoRecursosMinuta
                    : () =>
                          console.log(
                              "aplicarDimensionamentoRecursosMinuta não disponível"
                          ),

            // 👁️ Função para configurar observador específico de divListaRecursosMinuta
            setupObservadorRecursosMinuta:
                typeof setupObservadorRecursosMinuta === "function"
                    ? setupObservadorRecursosMinuta
                    : () =>
                          console.log(
                              "setupObservadorRecursosMinuta não disponível"
                          ),

            //   Função para configurar observador de legMinutas (Histórico)
            setupObservadorLegendMinutas:
                typeof setupObservadorLegendMinutas === "function"
                    ? setupObservadorLegendMinutas
                    : () =>
                          console.log(
                              "setupObservadorLegendMinutas não disponível"
                          ),

            //  🔧 Função para corrigir alinhamento em divListaRecursosMinuta
            corrigirAlinhamentoRecursosMinuta:
                typeof corrigirAlinhamentoRecursosMinuta === "function"
                    ? corrigirAlinhamentoRecursosMinuta
                    : () =>
                          console.log(
                              "corrigirAlinhamentoRecursosMinuta não disponível"
                          ),

            // Funções específicas do teste
            detectarCardSessaoSimplificado: () => {
                console.log(
                    "🔄 detectarCardSessaoSimplificado: redirecionando para detectarSessoesUnificado"
                );
                if (typeof detectarSessoesUnificado === "function") {
                    return detectarSessoesUnificado();
                } else {
                    console.log(
                        "⚠️ detectarSessoesUnificado não está disponível"
                    );
                    return null;
                }
            },
            testarPadraoInclusoMesa: () => {
                console.log("🧪 TESTE: Validando padrão 'Incluído em Mesa'...");

                const exemplosMesa = [
                    "Juízo de Retratação (Incluído em Mesa em 21/08/2025 - CAMPUB5)",
                    "Mérito (Incluído em Mesa em 15/09/2025 - CAMCIV2)",
                    "Preliminar (Incluído em Mesa em 10/10/2025 - SORGESP)",
                ];

                const padraoMesa =
                    /^([A-Za-zÀ-ÿ\s]+?)\s*\(Incluído em Mesa em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi;

                let testesPassaram = 0;

                exemplosMesa.forEach((exemplo, index) => {
                    padraoMesa.lastIndex = 0; // Reset regex
                    const match = padraoMesa.exec(exemplo);

                    if (match) {
                        console.log(`✅ Teste ${index + 1}: PASSOU`);
                        console.log(`   Tipo: "${match[1]}"`);
                        console.log(`   Data: "${match[2]}"`);
                        console.log(`   Órgão: "${match[3]}"`);
                        testesPassaram++;
                    } else {
                        console.log(
                            `❌ Teste ${index + 1}: FALHOU - ${exemplo}`
                        );
                    }
                });

                const resultado = {
                    totalTestes: exemplosMesa.length,
                    testesPassaram: testesPassaram,
                    sucesso: testesPassaram === exemplosMesa.length,
                };

                console.log(
                    `🎯 RESULTADO: ${testesPassaram}/${exemplosMesa.length} testes passaram`
                );
                return resultado;
            },
            testarDeteccaoRobusta: () => {
                console.log(
                    "🧪 testarDeteccaoRobusta: Executando teste de detecção robusta"
                );
                try {
                    if (typeof detectarSessoesUnificado === "function") {
                        const resultado = detectarSessoesUnificado(true);
                        console.log(
                            "✅ Teste de detecção robusta concluído:",
                            resultado
                        );
                        return resultado;
                    } else {
                        console.log(
                            "⚠️ detectarSessoesUnificado não disponível para teste"
                        );
                        return false;
                    }
                } catch (error) {
                    console.error(
                        "❌ Erro no teste de detecção robusta:",
                        error
                    );
                    return false;
                }
            },
            diagnosticarEstruturaDOMMinutas: () => {
                console.log(
                    "🔍 diagnosticarEstruturaDOMMinutas: Analisando estrutura DOM"
                );
                try {
                    const minutas = document.querySelector("#fldMinutas");
                    const resultado = {
                        minutasEncontradas: !!minutas,
                        conteudo: minutas
                            ? minutas.textContent?.length || 0
                            : 0,
                        estrutura: minutas ? "Presente" : "Ausente",
                    };
                    console.log("📊 Diagnóstico DOM Minutas:", resultado);
                    return resultado;
                } catch (error) {
                    console.error("❌ Erro no diagnóstico DOM:", error);
                    return { erro: error.message };
                }
            },

            // Função de debug PDF
            debugPDFExtracao: () => {
                console.log(
                    "🔍 debugPDFExtracao: Analisando capacidades de extração de PDF"
                );
                try {
                    const pdfElements = document.querySelectorAll(
                        'iframe[src*="pdf"], embed[type="application/pdf"], object[type="application/pdf"]'
                    );
                    const resultado = {
                        elementosPDF: pdfElements.length,
                        urlAtual: window.location.href,
                        isDocumento:
                            window.location.href.includes("acessar_documento"),
                        estrategias: [
                            "Fetch + Response",
                            "Seleção DOM",
                            "Clipboard",
                            "URL Direta",
                        ],
                    };
                    console.log("📊 Debug PDF Extração:", resultado);
                    return resultado;
                } catch (error) {
                    console.error("❌ Erro no debug PDF:", error);
                    return { erro: error.message };
                }
            },

            // Funções experimentais
            experimental: {
                detectarDataSessaoComIA:
                    typeof detectarDataSessaoComIA === "function"
                        ? detectarDataSessaoComIA
                        : () =>
                              console.log(
                                  "detectarDataSessaoComIA não disponível"
                              ),
                semanticKernel: window.eProbeSemanticKernel || null,
            },

            // Metadados
            status: "sistema-principal-corrigido",
            versao: "1.0.0-fix",
            timestamp: new Date().toISOString(),
            totalFuncoes: 0, // Será calculado abaixo
        };

        // Calcular total de funções disponíveis
        window.SENT1_AUTO.totalFuncoes = Object.keys(window.SENT1_AUTO).filter(
            (key) => typeof window.SENT1_AUTO[key] === "function"
        ).length;

        console.log(
            "✅ NAMESPACE CORRIGIDO: window.SENT1_AUTO criado com",
            window.SENT1_AUTO.totalFuncoes,
            "funções disponíveis"
        );

        // 🔧 TESTE: Listar funções disponíveis no namespace
        console.log(
            "🔍 Funções disponíveis no SENT1_AUTO:",
            Object.keys(window.SENT1_AUTO)
        );

        // 🚨 EXECUÇÃO IMEDIATA DAS CORREÇÕES CRÍTICAS
        logCritical(
            "🔧 EXECUÇÃO IMEDIATA: Aplicando correções críticas na inicialização..."
        );

        // Executar correções de pointer-events imediatamente
        try {
            if (typeof corrigirPointerEventsBotoes === "function") {
                const resultadoPointer = corrigirPointerEventsBotoes();
                logCritical(
                    "✅ CORREÇÃO IMEDIATA: Pointer-events corrigidos:",
                    resultadoPointer
                );
            }
        } catch (error) {
            console.error(
                "❌ ERRO na correção imediata de pointer-events:",
                error
            );
        }

        // Executar correção de switchRelevanciaDocumento imediatamente (VERSÃO ROBUSTA)
        try {
            if (
                typeof corrigirSwitchRelevanciaDocumentoRobusta === "function"
            ) {
                // DESABILITADO: const resultadoSwitch = corrigirSwitchRelevanciaDocumentoRobusta();
                logCritical(
                    "⚠️ CORREÇÃO DESABILITADA: switchRelevanciaDocumento NÃO corrigido para preservar funcionalidade"
                );
            } else if (
                typeof corrigirSwitchRelevanciaDocumento === "function"
            ) {
                const resultadoSwitch = corrigirSwitchRelevanciaDocumento();
                logCritical(
                    "✅ CORREÇÃO IMEDIATA: switchRelevanciaDocumento corrigido:",
                    resultadoSwitch
                );
            }
        } catch (error) {
            console.error(
                "❌ ERRO na correção imediata de switchRelevanciaDocumento:",
                error
            );
        }

        // Aguardar um pouco e executar novamente (para casos onde as funções do eProc ainda não existem)
        setTimeout(() => {
            logCritical(
                "🔧 SEGUNDA TENTATIVA ROBUSTA: Reaplicando correções após delay..."
            );
            try {
                if (
                    typeof corrigirSwitchRelevanciaDocumentoRobusta ===
                    "function"
                ) {
                    // DESABILITADO: const resultado = corrigirSwitchRelevanciaDocumentoRobusta();
                    logCritical(
                        "⚠️ SEGUNDA TENTATIVA DESABILITADA: switchRelevanciaDocumento NÃO re-corrigido para preservar funcionalidade"
                    );
                } else if (
                    typeof corrigirSwitchRelevanciaDocumento === "function"
                ) {
                    const resultado = corrigirSwitchRelevanciaDocumento();
                    logCritical(
                        "✅ SEGUNDA TENTATIVA: switchRelevanciaDocumento re-corrigido:",
                        resultado
                    );
                }
            } catch (error) {
                console.error(
                    "❌ ERRO na segunda tentativa de correção:",
                    error
                );
            }
        }, 2000);

        logCritical(
            "✅ eProbe Extension carregada com sucesso - Sistema completo inicializado!"
        );

        // ========================================
        // 🔧 TESTE DE NAMESPACE - VALIDAÇÃO IMEDIATA
        // ========================================

        // Teste imediato das funções críticas
        setTimeout(() => {
            try {
                if (typeof window.SENT1_AUTO === "object") {
                    const funcoesCriticas = [
                        "detectarCardSessaoSimplificado",
                        "testarDeteccaoRobusta",
                        "diagnosticarEstruturaDOMMinutas",
                        "debugPDFExtracao",
                        "detectarSessoesUnificado",
                        "forcarFlexboxNavbar",
                    ];
                    const resultados = funcoesCriticas.map((nome) => {
                        const existe =
                            typeof window.SENT1_AUTO[nome] === "function";
                        return `${existe ? "✅" : "❌"} ${nome}: ${
                            existe ? "OK" : "AUSENTE"
                        }`;
                    });
                    logCritical("🔍 TESTE NAMESPACE IMEDIATO:");
                    resultados.forEach((r) => logCritical(`  ${r}`));

                    if (resultados.every((r) => r.includes("✅"))) {
                        logCritical(
                            "🎉 SUCESSO: Todas as funções críticas estão disponíveis!"
                        );
                    } else {
                        console.warn(
                            "⚠️ AVISO: Algumas funções críticas estão ausentes, mas o sistema funciona com fallbacks"
                        );
                        // Listar funções funcionais
                        const funcionaisFuncionais = resultados.filter((r) =>
                            r.includes("✅")
                        ).length;
                        console.log(
                            `📊 Status: ${funcionaisFuncionais}/${funcoesCriticas.length} funções críticas disponíveis`
                        );
                    }
                } else {
                    console.error(
                        "❌ CRÍTICO: window.SENT1_AUTO não foi criado!"
                    );
                }
            } catch (error) {
                console.error("❌ ERRO no teste de namespace:", error);
            }
        }, 100);

        // ========================================
        // 🔧 FUNÇÕES FINAIS - APENAS VALIDAÇÃO
        // ========================================

        // 🎯 SUCESSO - IIFE completou sem erros
        logCritical(
            "✅ IIFE: Execução completada com sucesso - criando namespace completo"
        );

        // ✅ MARCAR EXECUÇÃO COMO COMPLETA E CANCELAR TIMEOUT DE EMERGÊNCIA
        mainExecutionCompleted = true;
        namespaceCreated = true;
        clearTimeout(timeoutSeguranca);
        logCritical(
            "🛡️ PROTEÇÃO: Timeout de emergência cancelado - execução normal completa"
        );
    } catch (error) {
        logError("💥 IIFE: ERRO CRÍTICO durante execução:", error);
        logError("📍 ERRO em:", error.stack);

        // 🆘 EM CASO DE ERRO: Tentar criar namespace de emergência imediatamente
        logError(
            "🆘 ERRO: Tentando criar namespace de emergência devido ao erro..."
        );
        clearTimeout(timeoutSeguranca);
        garantirNamespace();

        // Re-throw para ativar o .catch() da IIFE
        throw error;
    }
})().catch((error) => {
    console.error("💥 ASYNC IIFE: Erro não capturado:", error);
    console.error("🔍 Stack trace:", error.stack);
    // Tentar criar namespace de emergência mesmo com erro
    try {
        if (typeof garantirNamespace === "function") {
            garantirNamespace();
        }
    } catch (emergencyError) {
        console.error(
            "❌ FALHA CRÍTICA: Não foi possível criar namespace de emergência:",
            emergencyError
        );
    }
});

// � CRIAÇÃO GLOBAL DO NAMESPACE - FORA DA IIFE!
// Este namespace é criado FORA da IIFE para garantir exposição global
(function criarNamespaceGlobal() {
    console.log("🚀 CRIANDO NAMESPACE GLOBAL: window.SENT1_AUTO...");

    // Função de correção de cores (sempre disponível)
    const corrigirCorDeFundoConservadora = function () {
        console.log("🎨 CORREÇÃO: Alterando cor de fundo dos elementos...");

        const elementos = document.querySelectorAll("*");
        let elementosProcessados = 0;

        elementos.forEach((el) => {
            const style = window.getComputedStyle(el);
            const bgColor = style.backgroundColor;

            if (bgColor === "rgb(235, 242, 223)") {
                elementosProcessados++;

                console.log(`📦 ELEMENTO ${elementosProcessados}:`, {
                    tag: el.tagName,
                    classe: el.className,
                    corOriginal: bgColor,
                });

                try {
                    el.style.setProperty(
                        "background-color",
                        "#C8E6C9",
                        "important"
                    );
                    console.log(
                        `✅ ELEMENTO ${elementosProcessados}: Cor alterada para #C8E6C9!`
                    );
                } catch (error) {
                    console.error(
                        `❌ ERRO no elemento ${elementosProcessados}:`,
                        error
                    );
                }
            }
        });

        console.log(`\n📊 RESUMO FINAL:`);
        console.log(`  ✅ Elementos processados: ${elementosProcessados}`);
        console.log(`  🎯 Nova cor aplicada: #C8E6C9 (verde suave)`);

        return { processados: elementosProcessados };
    };

    // Criar namespace global
    window.SENT1_AUTO = {
        corrigirCorDeFundoConservadora: corrigirCorDeFundoConservadora,
        status: "namespace_global_ativo",
        versao: "2.0.0-global",
        timestamp: new Date().toISOString(),
    };

    console.log(
        "✅ NAMESPACE GLOBAL CRIADO! window.SENT1_AUTO disponível globalmente"
    );
    console.log("🎯 Funções disponíveis:", Object.keys(window.SENT1_AUTO));
})();

// �🚨 INTERCEPTAÇÃO FINAL BRUTAL - ÚLTIMA LINHA DE DEFESA
(function interceptacaoFinalBrutal() {
    console.log(
        "🔥 INTERCEPTAÇÃO FINAL: Substituição brutal de switchRelevanciaEvento"
    );

    // Função ultra-segura local
    function switchRelevanciaEventoSegura(idEvento, relevancia, tipo, urlAjax) {
        console.log(
            "✅ FUNÇÃO SEGURA FINAL: switchRelevanciaEvento executada sem erros"
        );

        // Validação extrema
        if (!idEvento || !urlAjax) {
            console.warn("⚠️ Parâmetros inválidos, abortando operação segura");
            return false;
        }

        try {
            // Construir URL segura
            const url =
                String(urlAjax) +
                (String(urlAjax).includes("?") ? "&" : "?") +
                `idEvento=${encodeURIComponent(String(idEvento))}&` +
                `relevancia=${encodeURIComponent(String(relevancia || ""))}&` +
                `tipo=${encodeURIComponent(String(tipo || ""))}`;

            // AJAX seguro
            const xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4 && xhr.status === 200) {
                    console.log(
                        "✅ Requisição switchRelevanciaEvento bem-sucedida"
                    );

                    // MANTER FUNCIONALIDADE ORIGINAL: Atualizar visual da estrela
                    try {
                        const estrelaElement = document.querySelector(
                            `a[onclick*="${idEvento}"]`
                        );
                        if (estrelaElement) {
                            const icon =
                                estrelaElement.querySelector(".material-icons");
                            if (icon) {
                                // Alternar entre estrela vazia e cheia
                                icon.textContent =
                                    relevancia === "1" ? "star" : "star_border";
                                console.log(
                                    "✅ Visual da estrela atualizado:",
                                    relevancia === "1"
                                        ? "ativada"
                                        : "desativada"
                                );
                            }
                        }
                    } catch (updateError) {
                        console.warn(
                            "⚠️ Não foi possível atualizar visual da estrela:",
                            updateError
                        );
                    }
                }
            };
            xhr.send();

            return true;
        } catch (error) {
            console.error("❌ Erro na função segura final:", error);
            return false;
        }
    }

    // REMOVIDO: Interceptação final de switchRelevanciaEvento (causava erro)
    console.log("✅ INTERCEPTAÇÃO FINAL: Desabilitada para evitar erros");
    /*
    // SUBSTITUIR COM CONTROLE DE TEMPO - SEM LOOP INFINITO
    let tentativasSubstituicao = 0;
    const maxTentativas = 50; // Máximo 50 tentativas = ~250ms total

    const substituirComControle = () => {
        tentativasSubstituicao++;

        // PARAR após limite de tentativas
        if (tentativasSubstituicao > maxTentativas) {
            console.log("✅ INTERCEPTAÇÃO FINAL: Parada após 50 tentativas");
            return; // PARAR definitivamente
        }

        // REMOVIDO: window.switchRelevanciaEvento = switchRelevanciaEventoSegura;
        // REMOVIDO: window.switchRelevanciaEvento.__eprobeSeguraFinal = true;

        // Log apenas nas primeiras 5 tentativas
        if (tentativasSubstituicao <= 5) {
            console.log(
                "🔄 switchRelevanciaEvento substituída pela função segura final"
            );
        }

        // Continuar apenas se dentro do limite
        if (tentativasSubstituicao <= maxTentativas) {
            setTimeout(substituirComControle, 5);
        }
    };

    // INICIAR UMA VEZ
    substituirComControle();

    console.log(
        "🛡️ INTERCEPTAÇÃO FINAL ATIVADA: switchRelevanciaEvento protegida continuamente"
    );
    */
})();

// 🚨 INTERCEPTAÇÃO DEFINITIVA VIA Object.defineProperty - IMPOSSÍVEL DE QUEBRAR
(function interceptacaoDefinitiva() {
    console.log(
        "  INTERCEPTAÇÃO REMOVIDA: switchRelevanciaEvento não será mais interceptada"
    );

    // Função ultra-segura
    function switchRelevanciaEventoDefinitiva(
        idEvento,
        relevancia,
        tipo,
        urlAjax
    ) {
        console.log(
            "✅ FUNÇÃO DEFINITIVA: switchRelevanciaEvento executada via defineProperty"
        );

        // Validação extrema
        if (!idEvento || !urlAjax) {
            console.warn("⚠️ Parâmetros inválidos na função definitiva");
            return false;
        }

        try {
            // Construir URL segura
            const url =
                String(urlAjax) +
                (String(urlAjax).includes("?") ? "&" : "?") +
                `idEvento=${encodeURIComponent(String(idEvento))}&` +
                `relevancia=${encodeURIComponent(String(relevancia || ""))}&` +
                `tipo=${encodeURIComponent(String(tipo || ""))}`;

            // AJAX seguro
            const xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4 && xhr.status === 200) {
                    console.log("✅ AJAX definitivo bem-sucedido");

                    // Atualizar visual da estrela
                    try {
                        const estrelaElement = document.querySelector(
                            `a[onclick*="${idEvento}"]`
                        );
                        if (estrelaElement) {
                            const icon =
                                estrelaElement.querySelector(".material-icons");
                            if (icon) {
                                icon.textContent =
                                    relevancia === "1" ? "star" : "star_border";
                                console.log(
                                    "✅ Estrela atualizada:",
                                    relevancia === "1"
                                        ? "ativada"
                                        : "desativada"
                                );
                            }
                        }
                    } catch (err) {
                        console.warn("⚠️ Erro ao atualizar estrela:", err);
                    }
                }
            };
            xhr.send();
            return true;
        } catch (error) {
            console.error("❌ Erro na função definitiva:", error);
            return false;
        }
    }

    // DESABILITADO: Não redefinir switchRelevanciaEvento para preservar funcionalidade
    try {
        // DESABILITADO: Não deletar função original do eProc
        // delete window.switchRelevanciaEvento;

        // Redefinir com nossa função
        // REMOVIDO: Object.defineProperty para switchRelevanciaEvento
        /*
        Object.defineProperty(window, "switchRelevanciaEvento", {
            value: switchRelevanciaEventoDefinitiva,
            writable: false, // NÃO pode ser sobrescrita
            configurable: false, // NÃO pode ser redefinida
            enumerable: true,
        });
        */

        console.log(
            "✅ PERSONALIZAÇÃO: Apenas aparência das estrelas será customizada"
        );
    } catch (error) {
        console.error("❌ Erro ao aplicar defineProperty:", error);
        // REMOVIDO: Fallback de switchRelevanciaEvento (não mais necessário)
    }
})();

// 🎨 SISTEMA FUNCIONAL DE GRADIENTES - VERSÃO QUE FUNCIONA
(function criarSistemaGradientesCompleto() {
    console.log("🎨 SISTEMA FUNCIONAL: Iniciando gradientes + observer...");

    function aplicarGradientes() {
        let processadosTotal = 0;

        // 1. PROCESSAR LEGMINUTAS (como antes)
        const elementos = document.querySelectorAll(
            'legend[aria-label="Histórico"]#legMinutas.infraLegendObrigatorio'
        );

        const coresLegMinutas = {
            "rgb(152, 245, 255)": "linear-gradient(#AFCFFA, #8DC0F7)",
            "rgb(255, 160, 122)": "linear-gradient(#FFB8AF, #FF9C8D)",
            "rgb(255, 211, 155)": "linear-gradient(#FAD3AF, #F7C68D)",
            "rgb(255, 193, 37)": "linear-gradient(#FFDE8F, #FFB84D)",
            "rgb(205, 181, 205)": "linear-gradient(#D8C7D8, #C4A5C4)",
            "rgb(211, 211, 211)": "linear-gradient(#B5C9CF, #9CB0B7)",
            "rgb(238, 99, 99)": "linear-gradient(#FAAFAF, #F78D8D)",
            "rgb(255, 255, 0)": "linear-gradient(#FFFF8F, #F0F04D)",
            "rgb(255, 187, 255)": "linear-gradient(#FFC9FF, #FF9CFF)",
            "rgb(255, 246, 143)": "linear-gradient(#F9EFAF, #F7E98D)",
            "rgb(144, 238, 144)": "linear-gradient(#AFFAB6, #8DF792)",
        };

        elementos.forEach((el, i) => {
            const cor = window.getComputedStyle(el).backgroundColor;
            if (cor !== "rgba(0, 0, 0, 0)") {
                const gradiente =
                    coresLegMinutas[cor] || "linear-gradient(#FFDE8F, #FFB84D)";
                el.style.setProperty("background", gradiente, "important");
                console.log(
                    `✅ eProbe GRADIENTE: legMinutas ${i + 1} aplicado!`
                );
                processadosTotal++;
            }
        });

        // 2. PROCESSAR INFRATRCLARA E INFRATRESCU
        const containersMinutas = document.querySelectorAll(
            '[id^="conteudoInternoMinutas_"]'
        );

        // Mapeamento para infraTrClara (tons claros)
        const coresInfraTrClara = {
            "rgb(152, 245, 255)": "linear-gradient(#AFCFFA, #8DC0F7)", // AZUL
            "rgb(255, 160, 122)": "linear-gradient(#FFB8AF, #FF9C8D)", // LARANJA INTENSO
            "rgb(255, 211, 155)": "linear-gradient(#FAD3AF, #F7C68D)", // LARANJA CLARO
            "rgb(255, 193, 37)": "linear-gradient(#FFDE8F, #FFB84D)", // DOURADO
            "rgb(205, 181, 205)": "linear-gradient(#D8C7D8, #C4A5C4)", // LILÁS
            "rgb(211, 211, 211)": "linear-gradient(#B5C9CF, #9CB0B7)", // CINZA
            "rgb(238, 99, 99)": "linear-gradient(#FAAFAF, #F78D8D)", // VERMELHA
            "rgb(255, 255, 0)": "linear-gradient(#FFFF8F, #F0F04D)", // VERDE LIMÃO
            "rgb(255, 187, 255)": "linear-gradient(#FFC9FF, #FF9CFF)", // ROSA CLARO
            "rgb(255, 246, 143)": "linear-gradient(#F9EFAF, #F7E98D)", // AMARELA
            "rgb(144, 238, 144)": "linear-gradient(#AFFAB6, #8DF792)", // VERDE
        };

        // Mapeamento para infraTrEscura (tons escuros) - CONFORME DOCUMENTAÇÃO
        const coresInfraTrEscura = {
            "rgb(122, 197, 205)": "linear-gradient(#7AB5F3, #5A9DEF)", // AZUL #7AC5CD
            "rgb(205, 129, 98)": "linear-gradient(#FF8D7A, #FF6B58)", // LARANJA INTENSO #CD8162
            "rgb(205, 170, 125)": "linear-gradient(#F5B87A, #F2A558)", // LARANJA CLARO #CDAA7D
            "rgb(205, 155, 29)": "linear-gradient(#FFA93A, #FF9520)", // DOURADO #CD9B1D
            "rgb(139, 123, 139)": "linear-gradient(#B593B5, #A082A0)", // LILÁS #8B7B8B
            "rgb(169, 169, 169)": "linear-gradient(#8A9EA5, #778C93)", // CINZA #A9A9A9
            "rgb(205, 85, 85)": "linear-gradient(#F47A7A, #F15858)", // VERMELHA #CD5555
            "rgb(205, 205, 0)": "linear-gradient(#E6E63A, #CCCC20)", // VERDE LIMÃO #CDCD00
            "rgb(205, 150, 205)": "linear-gradient(#FF7AFF, #FF58FF)", // ROSA CLARO #CD96CD
            "rgb(205, 198, 115)": "linear-gradient(#F5DC7A, #F3D058)", // AMARELA #CDC673
            "rgb(124, 205, 124)": "linear-gradient(#7AF381, #58EF5F)", // VERDE #7CCD7C
            // 🎯 TRATAMENTO ESPECIAL PARA CORES TRANSPARENTES/CINZA CLARO
            "rgba(0, 0, 0, 0.05)": "linear-gradient(#F5F5F5, #E8E8E8)", // CINZA MUITO CLARO
        };

        containersMinutas.forEach((container, containerIndex) => {
            // Processar infraTrClara
            const linhasClaras = container.querySelectorAll("tr.infraTrClara");
            linhasClaras.forEach((linha, linhaIndex) => {
                const cor = window.getComputedStyle(linha).backgroundColor;
                if (cor !== "rgba(0, 0, 0, 0)" && coresInfraTrClara[cor]) {
                    linha.style.setProperty(
                        "background",
                        coresInfraTrClara[cor],
                        "important"
                    );
                    console.log(
                        `✅ eProbe CLARA: Container ${
                            containerIndex + 1
                        } linha ${linhaIndex + 1} aplicado!`
                    );
                    processadosTotal++;
                }
            });

            // Processar infraTrEscura
            const linhasEscuras =
                container.querySelectorAll("tr.infraTrEscura");
            linhasEscuras.forEach((linha, linhaIndex) => {
                const cor = window.getComputedStyle(linha).backgroundColor;
                if (cor !== "rgba(0, 0, 0, 0)" && coresInfraTrEscura[cor]) {
                    linha.style.setProperty(
                        "background",
                        coresInfraTrEscura[cor],
                        "important"
                    );
                    console.log(
                        `✅ eProbe ESCURA: Container ${
                            containerIndex + 1
                        } linha ${linhaIndex + 1} aplicado!`
                    );
                    processadosTotal++;
                }
            });
        });

        if (processadosTotal > 0) {
            console.log(
                `🎉 eProbe GRADIENTES: ${processadosTotal} elementos processados (legMinutas + tabelas)!`
            );
        }
        return processadosTotal;
    }

    // 🎨 FUNÇÃO PARA GRADIENTES DA CAPA DO PROCESSO - OTIMIZADA PARA PERFORMANCE
    function aplicarGradientesCapaProcesso() {
        // Early exit agressivo para performance
        const urlAtual = window.location.href;
        if (!urlAtual.includes("controlador.php?acao=processo_selecionar&")) {
            return 0;
        }

        // 🚀 THROTTLING: Verificar se já processamos recentemente
        if (!window.eProbeLastGradientRun) window.eProbeLastGradientRun = 0;
        const agora = Date.now();
        if (agora - window.eProbeLastGradientRun < 1000) {
            return 0; // Throttle de 1 segundo
        }
        window.eProbeLastGradientRun = agora;

        // Mapeamento das 4 cores específicas da capa
        const coresCapaProcesso = {
            "rgb(35, 110, 142)": "linear-gradient(#5A8DB5, #4A7DA5)", // AZUL
            "rgb(142, 53, 35)": "linear-gradient(#D6807A, #C26B58)", // VERMELHA
            "rgb(89, 89, 89)": "linear-gradient(#8A9EA5, #778C93)", // CINZA
            "rgb(105, 142, 35)": "linear-gradient(#8AAE85, #759B70)", // VERDE OLIVA
        };

        // Buscar APENAS elementos mais específicos para reduzir carga
        const areaGlobal = document.querySelector("#divInfraAreaGlobal");
        if (!areaGlobal) return 0;

        // 🚀 OTIMIZAÇÃO: Buscar apenas elementos com classes específicas
        const elementosEspecificos = areaGlobal.querySelectorAll(
            ".infraNomeParte, .infraEventoDescricao"
        );

        let processados = 0;
        const maxProcessamento = PERFORMANCE_CONFIG.maxElementsToProcess;

        // Early exit se muitos elementos
        if (elementosEspecificos.length > maxProcessamento) {
            return 0;
        }

        // 🚀 USAR REQUESTIDLECALLBACK PARA PROCESSAMENTO NÃO-BLOQUEANTE
        if (
            window.requestIdleCallback &&
            PERFORMANCE_CONFIG.enableLazyLoading
        ) {
            window.requestIdleCallback(
                (deadline) => {
                    for (
                        let i = 0;
                        i < elementosEspecificos.length && i < maxProcessamento;
                        i++
                    ) {
                        if (deadline.timeRemaining() <= 0) break;

                        const elemento = elementosEspecificos[i];
                        const cor =
                            window.getComputedStyle(elemento).backgroundColor;
                        if (coresCapaProcesso[cor]) {
                            elemento.style.setProperty(
                                "background",
                                coresCapaProcesso[cor],
                                "important"
                            );
                            processados++;
                        }
                    }
                },
                { timeout: PERFORMANCE_CONFIG.idleCallbackTimeout }
            );
        } else {
            // Fallback síncrono limitado
            for (
                let i = 0;
                i < elementosEspecificos.length && i < maxProcessamento;
                i++
            ) {
                const elemento = elementosEspecificos[i];
                const cor = window.getComputedStyle(elemento).backgroundColor;
                if (coresCapaProcesso[cor]) {
                    elemento.style.setProperty(
                        "background",
                        coresCapaProcesso[cor],
                        "important"
                    );
                    processados++;
                }
            }
        }

        return processados;
    }

    // Aplicar imediatamente
    aplicarGradientes();
    aplicarGradientesCapaProcesso();

    // Observer funcional
    const container = document.querySelector("#conteudoMinutas");
    if (container) {
        const observer = new MutationObserver(() => {
            console.log(
                "🔄 eProbe OBSERVER: Mudança detectada, reaplicando..."
            );
            aplicarGradientes();
            aplicarGradientesCapaProcesso(); // Aplicar também na capa
            setTimeout(aplicarGradientes, 50);
            setTimeout(aplicarGradientesCapaProcesso, 50);
            setTimeout(aplicarGradientes, 150);
            setTimeout(aplicarGradientesCapaProcesso, 150);
        });

        observer.observe(container, {
            childList: true,
            subtree: true,
            attributes: true,
        });

        // Observer adicional para toda a área global da página - OTIMIZADO PARA PERFORMANCE
        const areaGlobal = document.querySelector("#divInfraAreaGlobal");
        if (areaGlobal) {
            let capaDebounceTimer = null;
            let processandoCapa = false;
            let ultimaExecucao = 0;

            const observerCapa = new MutationObserver((mutations) => {
                // Early exit - evitar processamento desnecessário
                if (processandoCapa) return;

                // 🚀 THROTTLE ADICIONAL: Limitar frequência de execução
                const agora = Date.now();
                if (agora - ultimaExecucao < PERFORMANCE_CONFIG.debounceDelay) {
                    return;
                }

                // 🚀 FILTRAR MUTATIONS RELEVANTES: Reduzir processamento
                const mutationsRelevantes = mutations.filter(
                    (mutation) =>
                        mutation.type === "childList" &&
                        mutation.addedNodes.length > 0
                );

                if (mutationsRelevantes.length === 0) return;

                // Limpar timer anterior
                if (capaDebounceTimer) {
                    clearTimeout(capaDebounceTimer);
                }

                // Debounce obrigatório de 500ms (aumentado para melhor performance)
                capaDebounceTimer = setTimeout(() => {
                    processandoCapa = true;
                    aplicarGradientesCapaProcesso();
                    processandoCapa = false;
                    ultimaExecucao = Date.now();
                }, 500);
            });

            observerCapa.observe(areaGlobal, {
                childList: true,
                subtree: false, // 🚀 OTIMIZAÇÃO: Desabilitar observação em subárvore
                attributes: false,
                attributeOldValue: false,
                characterData: false,
                characterDataOldValue: false,
            });

            // 🚀 CLEANUP AUTOMÁTICO: Desconectar observer após 2 minutos
            setTimeout(() => {
                if (observerCapa) {
                    observerCapa.disconnect();
                    console.log(
                        "🧹 CLEANUP: Observer de gradientes desconectado automaticamente"
                    );
                }
            }, 120000);
        }

        // Click listener com debounce
        let clickDebounceTimer = null;
        document.addEventListener(
            "click",
            (e) => {
                if (
                    e.target.closest(
                        'input[type="image"][title*="Atualizar"]'
                    ) ||
                    e.target.closest('input[onclick*="atualizaMinutas"]')
                ) {
                    // Debounce para clicks
                    if (clickDebounceTimer) {
                        clearTimeout(clickDebounceTimer);
                    }

                    clickDebounceTimer = setTimeout(() => {
                        aplicarGradientes();
                    }, 100);
                }
            },
            { passive: true }
        );

        console.log("✅ eProbe GRADIENTES: Sistema completo configurado!");
        window.eProbeGradientesFuncional = {
            aplicar: aplicarGradientes,
            aplicarCapa: aplicarGradientesCapaProcesso,
            observer: observer,
            status: () => console.log("✅ Sistema de gradientes ativo!"),
        };
    }

    console.log("🚀 eProbe GRADIENTES: Sistema inicializado com sucesso!");
})();

// 🚀 FUNÇÃO GLOBAL INDEPENDENTE - SEMPRE DISPONÍVEL
// Esta função funciona independentemente do namespace SENT1_AUTO
window.aplicarGradientesLegMinutasGlobal = function () {
    console.log("🎨 GRADIENTES GLOBAL: Iniciando aplicação independente...");

    try {
        // Buscar TODOS os elementos legMinutas
        const elementosLegMinutas = document.querySelectorAll(
            'legend[aria-label="Histórico"]#legMinutas.infraLegendObrigatorio'
        );

        console.log(
            `🔍 GLOBAL: Encontrados ${elementosLegMinutas.length} elementos legMinutas`
        );

        if (elementosLegMinutas.length === 0) {
            console.log("❌ GLOBAL: Nenhum elemento legMinutas encontrado");
            return { sucesso: false, processados: 0 };
        }

        // Mapa de cores RGB para gradientes
        const cores = {
            "rgb(152, 245, 255)": "linear-gradient(#AFCFFA, #8DC0F7)", // AZUL #98F5FF
            "rgb(255, 160, 122)": "linear-gradient(#FFB8AF, #FF9C8D)", // LARANJA INTENSO #FFA07A
            "rgb(255, 211, 155)": "linear-gradient(#FAD3AF, #F7C68D)", // LARANJA CLARO #FFD39B
            "rgb(255, 193, 37)": "linear-gradient(#FFDE8F, #FFB84D)", // DOURADO #FFC125
            "rgb(205, 181, 205)": "linear-gradient(#D8C7D8, #C4A5C4)", // LILÁS #CDB5CD
            "rgb(211, 211, 211)": "linear-gradient(#B5C9CF, #9CB0B7)", // CINZA #D3D3D3
            "rgb(238, 99, 99)": "linear-gradient(#FAAFAF, #F78D8D)", // VERMELHA #EE6363
            "rgb(255, 255, 0)": "linear-gradient(#FFFF8F, #F0F04D)", // VERDE LIMÃO #FFFF00
            "rgb(255, 187, 255)": "linear-gradient(#FFC9FF, #FF9CFF)", // ROSA CLARO #FFBBFF
            "rgb(255, 246, 143)": "linear-gradient(#F9EFAF, #F7E98D)", // AMARELA #FFF68F
            "rgb(144, 238, 144)": "linear-gradient(#AFFAB6, #8DF792)", // VERDE #90EE90
        };

        let processados = 0;

        // Processar cada elemento
        elementosLegMinutas.forEach((legMinutas, index) => {
            const corAtual =
                window.getComputedStyle(legMinutas).backgroundColor;

            if (cores[corAtual]) {
                legMinutas.style.setProperty(
                    "background",
                    cores[corAtual],
                    "important"
                );
                console.log(
                    `✅ GLOBAL: legMinutas ${
                        index + 1
                    } - Gradiente aplicado para ${corAtual}!`
                );
                processados++;
            } else {
                console.log(
                    `⚠️ GLOBAL: legMinutas ${
                        index + 1
                    } - Cor não mapeada: ${corAtual}`
                );
            }
        });

        console.log(
            `🎉 GLOBAL: ${processados}/${elementosLegMinutas.length} elementos processados com sucesso!`
        );
        return { sucesso: processados > 0, processados: processados };
    } catch (error) {
        console.error("❌ GLOBAL: Erro:", error);
        return { sucesso: false, processados: 0, erro: error.message };
    }
};

console.log(
    "🚀 FUNÇÃO GLOBAL CRIADA: window.aplicarGradientesLegMinutasGlobal disponível!"
);
