// ‚ö° ANTI-FLASH RADICAL - INJE√á√ÉO NO HTML ANTES DO RENDER
(function antiFlashRadical() {
    const navbarDesabilitada =
        localStorage.getItem("eprobe_navbar_enabled") === "false";

    if (
        !navbarDesabilitada &&
        !window.location.href.includes("acao=minuta_editar")
    ) {
        // Detectar tema
        let tema = localStorage.getItem("eprobe_selected_theme") || "blue";
        if (!localStorage.getItem("eprobe_selected_theme")) {
            if (window.location.href.includes("eproc2g.tjsc.jus.br")) {
                tema = "green";
            } else if (window.location.href.includes("eproc1g.tjsc.jus.br")) {
                tema = "blue";
            }
        }

        const gradientes = {
            blue: "linear-gradient(to left, #0d1c2c, #007ebd)",
            dark: "linear-gradient(to left, #1a1a1a, #696363)",
            light: "linear-gradient(to left, #94A3B8, #475569)",
            violet: "linear-gradient(to left, #6b46c1, #4c1d95)",
            green: "linear-gradient(to left, #17a394, #0c4f5c)",
        };

        const gradiente = gradientes[tema];

        // ‚ö° T√âCNICA RADICAL: document.write para inje√ß√£o PR√â-RENDER
        if (document.readyState === "loading") {
            document.write(`
                <style id="eprobe-pre-render-anti-flash">
                /* ANTI-FLASH PR√â-RENDER - INJETADO NO HTML */
                #navbar.navbar.bg-instancia,
                .navbar.bg-instancia,
                nav.navbar.bg-instancia,
                .navbar.text-white.bg-instancia,
                .navbar.text-white.d-xl-flex.bg-instancia {
                    background: ${gradiente} !important;
                    background-image: ${gradiente} !important;
                    background-color: transparent !important;
                    display: flex !important;
                    align-items: center !important;
                    min-height: 50px !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    transition: none !important;
                    animation: none !important;
                }
                
                .d-none.d-md-flex,
                div.d-none.d-md-flex,
                .navbar .d-none.d-md-flex,
                #navbar .d-none.d-md-flex {
                    display: flex !important;
                    align-items: center !important;
                }
                </style>
            `);
            console.log("‚ö° PR√â-RENDER: CSS injetado via document.write");
        }
    }
})();

// ===== SISTEMA DE LOGGING CONTROLADO E PERFORMANCE =====
const DEBUG_MODE = false; // ‚ö° ATIVA/DESATIVA DEBUG DE DETEC√á√ÉO DE SESS√ÉO
const log = DEBUG_MODE ? console.log.bind(console) : () => {}; // Logs silenciosos por padr√£o
const logCritical = console.log.bind(console); // Apenas logs cr√≠ticos sempre vis√≠veis
const logError = console.error.bind(console); // Erros sempre vis√≠veis

// üöÄ SISTEMA DE PERFORMANCE CR√çTICA - OBRIGAT√ìRIO
const PERFORMANCE_CONFIG = {
    maxElementsToProcess: 1000, // M√°ximo de elementos por processamento
    debounceDelay: 300, // Delay de debounce em ms
    idleCallbackTimeout: 5000, // Timeout para requestIdleCallback
    enableLazyLoading: true, // Habilitar lazy loading
    cleanupInterval: 30000, // Interval de cleanup em ms
};

// üîß THROTTLE GLOBAL OBRIGAT√ìRIO
const throttleGlobal = (func, delay) => {
    let timeoutId;
    let lastExecTime = 0;
    return function (...args) {
        const currentTime = Date.now();
        if (currentTime - lastExecTime > delay) {
            func.apply(this, args);
            lastExecTime = currentTime;
        } else {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                func.apply(this, args);
                lastExecTime = Date.now();
            }, delay);
        }
    };
};

// üîß DEBOUNCE GLOBAL OBRIGAT√ìRIO
const debounceGlobal = (func, delay) => {
    let timeoutId;
    return function (...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
};

// üßπ SISTEMA DE CLEANUP GLOBAL - OTIMIZA√á√ÉO CR√çTICA PARA PERFORMANCE
const CLEANUP_SYSTEM = {
    timers: new Set(),
    observers: new Set(),
    intervals: new Set(),

    // Registrar timer para cleanup autom√°tico
    addTimer(timerId) {
        this.timers.add(timerId);
        return timerId;
    },

    // Registrar observer para cleanup autom√°tico
    addObserver(observer) {
        this.observers.add(observer);
        return observer;
    },

    // Registrar interval para cleanup autom√°tico
    addInterval(intervalId) {
        this.intervals.add(intervalId);
        return intervalId;
    },

    // Cleanup for√ßado de todos os recursos
    cleanupAll() {
        console.log("üßπ CLEANUP: Iniciando limpeza de recursos...");

        // Limpar timers
        this.timers.forEach((timerId) => clearTimeout(timerId));
        this.timers.clear();

        // Limpar intervals
        this.intervals.forEach((intervalId) => clearInterval(intervalId));
        this.intervals.clear();

        // Desconectar observers
        this.observers.forEach((observer) => {
            try {
                observer.disconnect();
            } catch (e) {}
        });
        this.observers.clear();

        console.log("‚úÖ CLEANUP: Recursos limpos com sucesso");
    },
};

// Auto-cleanup a cada 2 minutos para prevenir memory leaks
CLEANUP_SYSTEM.addInterval(
    setInterval(() => {
        CLEANUP_SYSTEM.cleanupAll();
    }, PERFORMANCE_CONFIG.cleanupInterval),
);

// üé≠ SISTEMA DE COORDENA√á√ÉO ANTI-FLASH - CONTROLA REVELA√á√ÉO DE ELEMENTOS
const AntiFlashCoordinator = {
    pendingElements: new Set(),
    batchGroups: new Map(),
    revealQueue: [],
    isProcessingQueue: false,

    // Registrar elemento para revela√ß√£o coordenada
    register(element, groupId = null) {
        if (!element) return;

        // Aplicar classe de loading
        element.classList.add("eprobe-loading");
        element.setAttribute("data-eprobe-state", "loading");

        if (groupId) {
            // Adicionar ao grupo para revela√ß√£o em lote
            if (!this.batchGroups.has(groupId)) {
                this.batchGroups.set(groupId, new Set());
            }
            this.batchGroups.get(groupId).add(element);
            element.classList.add("eprobe-batch-pending");
        } else {
            // Adicionar aos elementos pendentes individuais
            this.pendingElements.add(element);
        }

        logCritical(
            `üé≠ ANTIFLASH: Elemento registrado ${
                groupId ? `(grupo: ${groupId})` : "(individual)"
            }`,
        );
        return element;
    },

    // Revelar elemento individual (se pronto)
    reveal(element, immediate = false) {
        if (!element) return;

        const revealAction = () => {
            element.classList.remove("eprobe-loading", "eprobe-batch-pending");
            element.classList.add("eprobe-ready");
            element.setAttribute("data-eprobe-state", "ready");
            this.pendingElements.delete(element);
        };

        if (immediate) {
            revealAction();
        } else {
            // Usar requestAnimationFrame para timing otimizado
            requestAnimationFrame(revealAction);
        }

        logCritical("üéØ ANTIFLASH: Elemento revelado com sucesso");
    },

    // Revelar grupo completo em lote
    revealGroup(groupId, immediate = false) {
        const group = this.batchGroups.get(groupId);
        if (!group) return;

        const revealGroupAction = () => {
            group.forEach((element) => {
                element.classList.remove(
                    "eprobe-loading",
                    "eprobe-batch-pending",
                );
                element.classList.add("eprobe-ready", "eprobe-batch-ready");
                element.setAttribute("data-eprobe-state", "ready");
            });
            this.batchGroups.delete(groupId);
        };

        if (immediate) {
            revealGroupAction();
        } else {
            requestAnimationFrame(revealGroupAction);
        }

        logCritical(
            `üéâ ANTIFLASH: Grupo ${groupId} revelado (${group.size} elementos)`,
        );
    },

    // Revelar todos os elementos pendentes
    revealAll(immediate = false) {
        const revealAllAction = () => {
            // Revelar elementos individuais
            this.pendingElements.forEach((element) =>
                this.reveal(element, true),
            );

            // Revelar todos os grupos
            this.batchGroups.forEach((group, groupId) => {
                this.revealGroup(groupId, true);
            });
        };

        if (immediate) {
            revealAllAction();
        } else {
            requestAnimationFrame(revealAllAction);
        }

        logCritical("üåü ANTIFLASH: Todos os elementos revelados");
    },

    // Verificar status dos elementos pendentes
    getStatus() {
        return {
            pendingCount: this.pendingElements.size,
            batchGroupsCount: this.batchGroups.size,
            totalBatchElements: Array.from(this.batchGroups.values()).reduce(
                (sum, group) => sum + group.size,
                0,
            ),
        };
    },

    // Cleanup de elementos √≥rf√£os
    cleanup() {
        this.pendingElements.clear();
        this.batchGroups.clear();
        this.revealQueue = [];
        this.isProcessingQueue = false;
    },

    // üöÄ BATCH PROCESSING AVAN√áADO - ETAPA 4

    // Aguardar grupo estar completo e revelar automaticamente
    waitForGroupComplete(groupId, expectedCount, timeout = 3000) {
        return new Promise((resolve) => {
            const checkGroup = () => {
                const group = this.batchGroups.get(groupId);
                if (group && group.size >= expectedCount) {
                    this.revealGroup(groupId);
                    logCritical(
                        `‚è∞ BATCH: Grupo ${groupId} revelado ap√≥s atingir ${expectedCount} elementos`,
                    );
                    resolve(true);
                    return;
                }

                // Verificar novamente ap√≥s delay
                setTimeout(checkGroup, 100);
            };

            // Timeout de seguran√ßa
            setTimeout(() => {
                const group = this.batchGroups.get(groupId);
                if (group && group.size > 0) {
                    this.revealGroup(groupId);
                    logCritical(
                        `‚ö†Ô∏è BATCH: Grupo ${groupId} revelado por timeout (${group.size}/${expectedCount})`,
                    );
                }
                resolve(false);
            }, timeout);

            checkGroup();
        });
    },

    // Revelar grupos em sequ√™ncia com delay
    revealGroupsSequentially(groupIds, delay = 200) {
        groupIds.forEach((groupId, index) => {
            setTimeout(() => {
                this.revealGroup(groupId);
                logCritical(
                    `üé¨ BATCH: Grupo ${groupId} revelado em sequ√™ncia (${
                        index + 1
                    }/${groupIds.length})`,
                );
            }, index * delay);
        });
    },

    // Revelar todos os grupos simultaneamente com coordena√ß√£o
    revealAllGroupsCoordinated() {
        const allGroupIds = Array.from(this.batchGroups.keys());

        if (allGroupIds.length === 0) return;

        // Aguardar pr√≥ximo frame para coordenar revela√ß√£o
        requestAnimationFrame(() => {
            allGroupIds.forEach((groupId) => {
                this.revealGroup(groupId, true);
            });

            logCritical(
                `üéÜ BATCH: ${
                    allGroupIds.length
                } grupos revelados simultaneamente: ${allGroupIds.join(", ")}`,
            );
        });
    },

    // Auto-revelar grupos que ficam pendentes muito tempo
    setupAutoReveal(timeout = 5000) {
        setInterval(() => {
            this.batchGroups.forEach((group, groupId) => {
                // Verificar se elementos do grupo est√£o h√° muito tempo pendentes
                const firstElement = group.values().next().value;
                if (firstElement) {
                    const loadingTime =
                        Date.now() -
                        (firstElement.dataset.eprobeLoadingStart || Date.now());
                    if (loadingTime > timeout) {
                        this.revealGroup(groupId);
                        logCritical(
                            `üïí AUTO-REVEAL: Grupo ${groupId} revelado por timeout (${loadingTime}ms)`,
                        );
                    }
                }
            });
        }, 1000);
    },
};

// Registrar o AntiFlashCoordinator no sistema de cleanup
CLEANUP_SYSTEM.cleanup = (function (originalCleanup) {
    return function () {
        originalCleanup.call(this);
        AntiFlashCoordinator.cleanup();
        logCritical("üßπ CLEANUP: AntiFlashCoordinator limpo");
    };
})(CLEANUP_SYSTEM.cleanup);

// üéØ FUN√á√ïES HELPER GLOBAIS PARA ANTI-FLASH - ETAPA 4 COMPLETA
window.eProbeAntiFlash = {
    // Criar elemento com anti-flash autom√°tico
    createElement(tagName, options = {}) {
        const element = document.createElement(tagName);

        // Aplicar propriedades b√°sicas
        if (options.className) element.className = options.className;
        if (options.id) element.id = options.id;
        if (options.innerHTML) element.innerHTML = options.innerHTML;

        // üöÄ MARCAR TIMESTAMP DE CRIA√á√ÉO PARA AUTO-REVEAL
        element.dataset.eprobeLoadingStart = Date.now();

        // Registrar no sistema anti-flash
        AntiFlashCoordinator.register(element, options.groupId);

        return element;
    },

    // Revelar elemento quando pronto
    reveal: (element) => AntiFlashCoordinator.reveal(element),

    // Revelar grupo
    revealGroup: (groupId) => AntiFlashCoordinator.revealGroup(groupId),

    // Status do sistema
    status: () => AntiFlashCoordinator.getStatus(),

    // üöÄ FUNCIONALIDADES BATCH PROCESSING - ETAPA 4

    // Aguardar grupo completo
    waitForGroup: (groupId, expectedCount, timeout) =>
        AntiFlashCoordinator.waitForGroupComplete(
            groupId,
            expectedCount,
            timeout,
        ),

    // Revelar grupos em sequ√™ncia
    revealSequence: (groupIds, delay) =>
        AntiFlashCoordinator.revealGroupsSequentially(groupIds, delay),

    // Revelar todos coordenadamente
    revealAllCoordinated: () =>
        AntiFlashCoordinator.revealAllGroupsCoordinated(),

    // Criar m√∫ltiplos elementos em lote
    createBatch(configs, groupId) {
        const elements = configs.map((config) =>
            this.createElement(config.tagName, { ...config, groupId }),
        );

        logCritical(
            `üé≠ BATCH: Criados ${elements.length} elementos no grupo ${groupId}`,
        );
        return elements;
    },

    // Revelar lote quando todos estiverem prontos
    revealWhenComplete(groupId, expectedCount) {
        return this.waitForGroup(groupId, expectedCount);
    },
};

// Log de ativa√ß√£o do sistema
logCritical(
    "üé≠ ANTIFLASH COORDINATOR: Sistema ativado e dispon√≠vel globalmente",
);
logCritical(
    "üí° USO: window.eProbeAntiFlash.createElement() para elementos sem flash",
);

// ÔøΩ ATIVAR AUTO-REVEAL PARA GRUPOS QUE FICAM PENDENTES
AntiFlashCoordinator.setupAutoReveal(5000); // 5 segundos timeout
logCritical("‚è∞ AUTO-REVEAL: Ativado com timeout de 5 segundos");

// ÔøΩüö® FLAG GLOBAL - DESABILITAR SUBSTITUI√á√ÉO DE ESTRELAS
const DISABLE_STAR_REPLACEMENTS = true; // ‚õî PROTE√á√ÉO: Impede substitui√ß√£o de estrelas

// Interceptacao de switchRelevancia: desabilitada (funcionalidade eProc preservada).

// ===== PERSONALIZA√á√ÉO VISUAL DAS ESTRELAS - SEM INTERFERIR NAS FUN√á√ïES =====
(function personalizarEstrelasEventos() {
    logCritical(
        "üé® PERSONALIZA√á√ÉO: Iniciando customiza√ß√£o das estrelas de eventos...",
    );

    function aplicarPersonalizacaoEstrelas() {
        try {
            // Buscar fieldset de eventos especificamente
            const fieldsetEventos = document.querySelector(
                'fieldset.infraFieldset[aria-label="Eventos"]',
            );
            if (!fieldsetEventos) {
                log(
                    "‚ö†Ô∏è Fieldset de eventos n√£o encontrado ainda, tentando novamente...",
                );
                return false;
            }

            logCritical("‚úÖ FIELDSET: Fieldset de eventos encontrado");

            // DESABILITADO: Personaliza√ß√£o de estrelas para n√£o interferir na funcionalidade do eProc
            logCritical(
                "‚ö†Ô∏è PERSONALIZA√á√ÉO: Desabilitada para preservar funcionalidade das estrelas do eProc",
            );
            return true; // Retornar sucesso sem fazer modifica√ß√µes
        } catch (error) {
            logError("‚ùå Erro na personaliza√ß√£o das estrelas:", error);
            return false;
        }
    }

    // Tentar aplicar personaliza√ß√£o quando DOM estiver pronto
    let tentativas = 0;
    const maxTentativas = 10;

    function tentarPersonalizar() {
        if (aplicarPersonalizacaoEstrelas() || tentativas >= maxTentativas) {
            if (tentativas >= maxTentativas) {
                logCritical("‚ö†Ô∏è PERSONALIZA√á√ÉO: Limite de tentativas atingido");
            }
            return;
        }

        tentativas++;
        setTimeout(tentarPersonalizar, 1000);
    }

    // Executar quando DOM estiver pronto
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", tentarPersonalizar);
    } else {
        setTimeout(tentarPersonalizar, 500);
    }
})();

// ===== APLICA√á√ÉO INSTANT√ÇNEA DA NAVBAR - ANTES DE QUALQUER FLASH =====
(function aplicarNavbarInstantaneo() {
    // CSS da navbar aplicado IMEDIATAMENTE ao carregar o arquivo
    // Detectar dom√≠nio para tema padr√£o
    const currentUrl = window.location.href;

    // üö® VERIFICA√á√ÉO CR√çTICA: N√ÉO aplicar navbar na tela de edi√ß√£o de minutas
    if (currentUrl.includes("acao=minuta_editar")) {
        console.log(
            "üö´ eProbe: Navbar desabilitada na tela de edi√ß√£o de minutas",
        );
        return; // Sair imediatamente - n√£o aplicar navbar
    }

    let temaDefault = "blue"; // tema padr√£o geral

    if (currentUrl.includes("eproc2g.tjsc.jus.br")) {
        temaDefault = "green"; // Verde para eproc2g
    } else if (currentUrl.includes("eproc1g.tjsc.jus.br")) {
        temaDefault = "blue"; // Azul para eproc1g
    }

    const temaLocalStorage = localStorage.getItem("eprobe_selected_theme");
    const tema = temaLocalStorage || temaDefault;

    const gradientes = {
        blue: "linear-gradient(to left, #0d1c2c, #007ebd)",
        dark: "linear-gradient(to left, #1a1a1a, #696363)",
        light: "linear-gradient(to left, #94A3B8, #475569)",
        violet: "linear-gradient(to left, #6b46c1, #4c1d95)",
        green: "linear-gradient(to left, #17a394, #0c4f5c)",
    };
    const gradiente = gradientes[tema];

    const cssNavbarImediato = document.createElement("style");
    cssNavbarImediato.id = "eprobe-navbar-instant-immediate";
    cssNavbarImediato.textContent = `
        /* NAVBAR APLICADA IMEDIATAMENTE NO CARREGAMENTO DO SCRIPT */
        #navbar.navbar.bg-instancia,
        .navbar.bg-instancia,
        nav.navbar.bg-instancia,
        .navbar.text-white.bg-instancia,
        .navbar.text-white.d-xl-flex.bg-instancia {
            background-image: ${gradiente} !important;
            display: flex !important;
            align-items: center !important;
            min-height: 50px !important;
            opacity: 1 !important;
            visibility: visible !important;
            transition: none !important; /* Sem transi√ß√µes para evitar flash */
        }
        
        #navbar.navbar.bg-instancia > *,
        .navbar.bg-instancia > *,
        nav.navbar.bg-instancia > * {
            display: flex !important; 
            align-items: center !important;
            min-height: 50px !important;
        }
        
        /* üéØ REGRA CR√çTICA OBRIGAT√ìRIA: .d-none.d-md-flex SEMPRE FLEX */
        .d-none.d-md-flex,
        div.d-none.d-md-flex,
        .navbar .d-none.d-md-flex,
        #navbar .d-none.d-md-flex {
            display: flex !important;
            align-items: center !important;
        }
    `;

    // ‚ö° APLICA√á√ÉO ULTRA-INSTANT√ÇNEA - APLICAR PRIMEIRO, VERIFICAR DEPOIS
    const aplicarCSS = () => {
        // Remover CSS do anti-flash ultra se existir
        const cssAntiFlash = document.getElementById("eprobe-anti-flash-ultra");
        if (cssAntiFlash) {
            cssAntiFlash.remove();
            console.log(
                "üîÑ ANTI-FLASH: CSS tempor√°rio removido, aplicando definitivo",
            );
        }

        // Remover CSS anterior se existir
        const cssAnterior = document.getElementById(
            "eprobe-navbar-instant-immediate",
        );
        if (cssAnterior) {
            cssAnterior.remove();
        }

        const head =
            document.head ||
            document.getElementsByTagName("head")[0] ||
            document.documentElement;
        if (head) {
            head.insertBefore(cssNavbarImediato, head.firstChild);

            console.log(
                `‚ö° NAVBAR IMEDIATO: Tema ${tema} aplicado instantaneamente`,
            );
            return true;
        }
        return false;
    };

    // üöÄ APLICAR IMEDIATAMENTE - SEM VERIFICA√á√ïES QUE CAUSEM DELAY
    let cssAplicado = false;

    // Verifica√ß√£o r√°pida via localStorage (s√≠ncrona)
    const navbarStorageKey = "eprobe_navbar_enabled";
    const navbarEnabledLocal = localStorage.getItem(navbarStorageKey);

    // Se explicitamente desabilitada, n√£o aplicar
    if (navbarEnabledLocal === "false") {
        console.log(
            "üö´ eProbe: Navbar instant√¢nea desabilitada por configura√ß√£o salva",
        );

        return; // Sair imediatamente - n√£o aplicar navbar
    }

    // APLICAR CSS IMEDIATAMENTE (padr√£o = ativado se n√£o explicitamente desabilitado)
    if (!aplicarCSS()) {
        // Se falhou, tentar novamente em intervalos m√≠nimos
        const tentativas = 5;
        let tentativa = 0;

        const intervalo = setInterval(() => {
            if (aplicarCSS() || tentativa >= tentativas) {
                clearInterval(intervalo);
                if (tentativa < tentativas) {
                    cssAplicado = true;
                }
            }
            tentativa++;
        }, 1);
    } else {
        cssAplicado = true;
    }

    // üîÑ VERIFICA√á√ÉO ASS√çNCRONA PARA CLEANUP (sem afetar aplica√ß√£o inicial)
    if (
        typeof chrome !== "undefined" &&
        chrome.storage &&
        chrome.storage.sync
    ) {
        // Verificar chrome.storage de forma ass√≠ncrona para sincronizar com localStorage
        chrome.storage.sync.get(["customize-navbar"], function (result) {
            const navbarEnabled = result["customize-navbar"] !== false; // default true

            // Sincronizar localStorage com chrome.storage
            localStorage.setItem(navbarStorageKey, navbarEnabled.toString());

            if (!navbarEnabled && cssAplicado) {
                // Se CSS foi aplicado mas agora deve ser removido, remover
                const cssExistente = document.getElementById(
                    "eprobe-navbar-instant-immediate",
                );
                if (cssExistente) {
                    cssExistente.remove();
                    console.log(
                        "üö´ eProbe: Navbar instant√¢nea removida ap√≥s verifica√ß√£o do storage",
                    );
                }
            }
        });
    }

    // Listener para mudan√ßas de tema em tempo real
    window.addEventListener("storage", (e) => {
        if (e.key === "eprobe_selected_theme") {
            // Atualizar tema e reaplicar CSS
            const novoTema = e.newValue || "blue";
            const gradientes = {
                blue: "linear-gradient(to left, #0d1c2c, #007ebd)",
                dark: "linear-gradient(to left, #1a1a1a, #696363)",
                light: "linear-gradient(to left, #94A3B8, #475569)",
                violet: "linear-gradient(to left, #6b46c1, #4c1d95)",
                green: "linear-gradient(to left, #17a394, #0c4f5c)",
            };
            const novoGradiente = gradientes[novoTema];

            // Atualizar CSS instantaneamente
            const cssExistente = document.getElementById(
                "eprobe-navbar-instant-immediate",
            );
            if (cssExistente) {
                cssExistente.textContent = cssExistente.textContent.replace(
                    /background-image: [^;]+/g,
                    `background-image: ${novoGradiente}`,
                );
                console.log(
                    `‚ö° NAVBAR: Tema atualizado para ${novoTema} instantaneamente`,
                );
            }
        }
    });

    // Listener para evento customizado de mudan√ßa de tema
    window.addEventListener("eprobe-theme-changed", (e) => {
        // üö® VERIFICA√á√ÉO CR√çTICA: N√ÉO aplicar tema na tela de edi√ß√£o de minutas
        const currentUrl = window.location.href;
        if (currentUrl.includes("acao=minuta_editar")) {
            console.log(
                "üö´ eProbe: Event listener de tema desabilitado na tela de edi√ß√£o de minutas",
            );
            return; // Sair imediatamente - n√£o aplicar tema
        }

        const { theme, gradient } = e.detail;

        // For√ßar aplica√ß√£o imediata nos elementos da navbar
        const navbarElements = document.querySelectorAll(
            "#navbar.navbar.bg-instancia, .navbar.bg-instancia, nav.navbar.bg-instancia",
        );

        navbarElements.forEach((navbar) => {
            navbar.style.setProperty("background-image", gradient, "important");
        });

        console.log(`‚ö° NAVBAR: Evento customizado aplicou tema ${theme}`);
    });
})();

// ===== SISTEMA ANTI-FLASH UNIFICADO - SIMPLES E EFICIENTE =====
(function sistemaAntiFlashUnificado() {
    // Fun√ß√£o √∫nica para aplicar personaliza√ß√µes sem flash
    window.eprobeAntiFlash = {
        aplicado: false,

        // Aplicar CSS cr√≠tico uma √∫nica vez
        aplicarCSS: function () {
            if (this.aplicado) return;

            // CSS j√° est√° no ultraAntiFlash acima - apenas marcar como aplicado
            this.aplicado = true;
            console.log("‚úÖ ANTI-FLASH UNIFICADO: Sistema ativado");
        },

        // DESABILITADO: Revelar √≠cone personalizado (pode interferir com IDs do eProc)
        revelarIcone: function (elemento) {
            // DESABILITADO: N√£o modificar elementos para preservar funcionalidade do eProc
            /*
            if (elemento && elemento.tagName) {
                elemento.setAttribute("data-eprobe-icon-replaced", "true");
                elemento.style.setProperty(
                    "display",
                    "inline-block",
                    "important"
                );
                elemento.style.setProperty("opacity", "1", "important");
                elemento.style.setProperty(
                    "visibility",
                    "visible",
                    "important"
                );
            }
            */
            // FUN√á√ÉO DESABILITADA
        },

        // DESABILITADO: Ocultar √≠cone original (pode interferir com IDs do eProc)
        ocultarIcone: function (elemento) {
            // DESABILITADO: N√£o modificar elementos para preservar funcionalidade do eProc
            /*
            if (
                elemento &&
                elemento.classList &&
                elemento.classList.contains("material-icons")
            ) {
                elemento.style.setProperty("display", "none", "important");
                elemento.style.setProperty("opacity", "0", "important");
                elemento.style.setProperty("visibility", "hidden", "important");
            }
            */
            // FUN√á√ÉO DESABILITADA
        },

        // ‚ö° NOVO: Revelar elemento personalizado (navbar, bot√µes, etc.)
        revelarElemento: function (elemento) {
            if (elemento && elemento.tagName) {
                elemento.setAttribute("data-eprobe-processed", "true");
                elemento.style.setProperty("opacity", "1", "important");
                elemento.style.setProperty(
                    "visibility",
                    "visible",
                    "important",
                );
                elemento.style.removeProperty("transition");
            }
        },

        // ‚ö° NOVO: Ocultar elemento temporariamente
        ocultarElemento: function (elemento) {
            if (elemento && elemento.tagName) {
                elemento.style.setProperty("opacity", "0.5", "important");
                elemento.style.setProperty("transition", "none", "important");
            }
        },

        // ‚ö° NOVO: Aplicar anti-flash a navbar
        stabilizarNavbar: function () {
            const navbars = document.querySelectorAll(
                ".navbar, #navbar, .navbar-nav, .navbar-collapse",
            );
            navbars.forEach((navbar) => {
                navbar.style.setProperty("transition", "none", "important");
                navbar.style.setProperty("will-change", "auto", "important");
                navbar.style.setProperty(
                    "backface-visibility",
                    "hidden",
                    "important",
                );
                navbar.style.setProperty(
                    "transform",
                    "translateZ(0)",
                    "important",
                );
            });
        },

        // ‚ö° NOVO: Aplicar anti-flash a bot√µes (COM PROTE√á√ÉO PARA SELECT2)
        stabilizarBotoes: function () {
            const botoes = document.querySelectorAll(
                '.btn, button, .botaoLerMais, input[type="button"], input[type="submit"]',
            );
            botoes.forEach((botao) => {
                // üö´ EXCE√á√ÉO: N√£o interferir em bot√µes select2
                if (botao.classList.contains("select2-search-choice-close")) {
                    return; // Pular este bot√£o
                }

                botao.style.setProperty("transition", "none", "important");
                botao.style.setProperty("will-change", "auto", "important");
            });
        },

        // ‚ö° NOVO: Detectar p√°gina de processo e marcar body
        detectarPaginaProcesso: function () {
            const url = window.location.href;
            const isPaginaProcesso =
                url.includes("consultar_processo") ||
                url.includes("processo_selecionar") ||
                url.includes("acessar_documento") ||
                document.querySelector("#fldCapa") ||
                document.querySelector("#divInfraAreaProcesso");

            if (isPaginaProcesso) {
                document.body.setAttribute("data-eprobe-processo-page", "true");
                console.log(
                    "üéØ P√ÅGINA DE PROCESSO DETECTADA: Anti-flash aplicado",
                );
                return true;
            } else {
                document.body.removeAttribute("data-eprobe-processo-page");
                console.log(
                    "üìÑ P√°gina n√£o √© de processo: √çcones normais preservados",
                );
                return false;
            }
        },

        // ‚ö° NOVO: Anti-flash total
        aplicarAntiFlashTotal: function () {
            // Detectar p√°gina de processo primeiro
            const isPaginaProcesso = this.detectarPaginaProcesso();

            if (isPaginaProcesso) {
                this.aplicarCSS();
                this.stabilizarNavbar();
                this.stabilizarBotoes();

                // For√ßar estabilidade visual geral apenas em p√°ginas de processo
                document.documentElement.style.setProperty(
                    "backface-visibility",
                    "hidden",
                    "important",
                );

                console.log(
                    "üöÄ ANTI-FLASH TOTAL: Aplicado apenas em p√°gina de processo",
                );
            } else {
                console.log(
                    "‚è∏Ô∏è ANTI-FLASH: N√£o aplicado - p√°gina n√£o √© de processo",
                );
            }
        },
    };

    // Aplicar anti-flash total imediatamente
    window.eprobeAntiFlash.aplicarAntiFlashTotal();
})();

// ===== INTERCEPTA√á√ÉO PRECOCE DE FLASH - APLICAR ANTES DO DOM =====
(function antiFlashPrecoce() {
    // Executar no momento mais precoce poss√≠vel
    const aplicarAntiFlashImediato = () => {
        // Verificar se √© p√°gina de processo antes de aplicar
        const url = window.location.href;
        const isPaginaProcesso =
            url.includes("consultar_processo") ||
            url.includes("processo_selecionar") ||
            url.includes("acessar_documento");

        // S√≥ aplicar anti-flash se for p√°gina de processo
        if (!isPaginaProcesso) {
            console.log(
                "üìÑ P√°gina n√£o √© de processo: Anti-flash precoce n√£o aplicado",
            );
            return;
        }

        console.log(
            "üéØ P√°gina de processo detectada: Aplicando anti-flash precoce",
        );

        // 1. Ocultar elementos que podem causar flash APENAS em p√°ginas de processo
        const style = document.createElement("style");
        style.id = "eprobe-precoce-anti-flash";
        style.textContent = `
            /* ANTI-FLASH PRECOCE - REMOVER regras problem√°ticas */
            
            .navbar, #navbar, .navbar-nav { 
                transition: none !important; 
                backface-visibility: hidden !important; 
            }
            
            .btn, button, .botaoLerMais { 
                transition: none !important; 
                will-change: auto !important; 
            }
            
            /* üö´ EXCE√á√ÉO: Preservar funcionalidade dos elementos select2 */
            .select2-search-choice-close.btn,
            .select2-search-choice-close,
            .select2-container .btn,
            [class*="select2"] .btn,
            [class*="select2"] button {
                transition: all 0.15s ease !important;
                will-change: initial !important;
            }
            
            * { 
                backface-visibility: hidden !important; 
            }
        `;

        // Inserir no head como primeiro elemento
        if (document.head) {
            document.head.insertBefore(style, document.head.firstChild);
        } else {
            document.documentElement.appendChild(style);
        }
    };

    // Aplicar imediatamente se DOM j√° existir
    if (document.documentElement) {
        aplicarAntiFlashImediato();
    }

    // Tamb√©m aplicar quando DOM for criado
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", aplicarAntiFlashImediato);
    }
})();

// ===== ULTRA ANTI-FLASH - EXECU√á√ÉO IMEDIATA ANTES DE QUALQUER RENDERIZA√á√ÉO =====
(function ultraAntiFlash() {
    // Executar IMEDIATAMENTE - antes mesmo do DOM come√ßar
    const iniciarUltraAntiFlash = () => {
        log("‚ö° ULTRA ANTI-FLASH: Interceptando renderiza√ß√£o...");

        // 1. CSS CR√çTICO INLINE - Aplicado instantaneamente ANTES da renderiza√ß√£o
        const cssUltraCritico = document.createElement("style");
        cssUltraCritico.setAttribute("data-eprobe-ultra-critical", "true");
        cssUltraCritico.textContent = `
            /* ===== ULTRA ANTI-FLASH CRITICAL STYLES ===== */
            
            /* üéØ SISTEMA ANTI-FLASH PARA ELEMENTOS EPROBE - APLICADO PRIMEIRO */
            .eprobe-loading, 
            .eprobe-creating,
            [data-eprobe-state="loading"] {
                opacity: 0 !important;
                transition: opacity 0.15s ease-out !important;
                pointer-events: none !important;
                visibility: hidden !important;
            }

            .eprobe-ready {
                opacity: 1 !important;
                pointer-events: auto !important;
                visibility: visible !important;
            }

            /* üöÄ COORDENA√á√ÉO DE BATCH: Elementos aguardando revela√ß√£o coordenada */
            .eprobe-batch-pending {
                opacity: 0 !important;
                transition: opacity 0.2s ease-out !important;
            }

            .eprobe-batch-ready {
                opacity: 1 !important;
            }
            
            /* Prepara√ß√£o instant√¢nea do body */
            body {
                visibility: visible !important;
                opacity: 1 !important;
                transition: none !important;
            }
            
            /* INTERCEPTA√á√ÉO TOTAL: Divs de lembrete - estilos aplicados ANTES da renderiza√ß√£o */
            div.divLembrete[style*="background-color:#efef8f"],
            div.divLembrete[style*="background-color: #efef8f"],
            div[style*="background-color:#efef8f"]:not([data-eprobe-processed]) {
                background: linear-gradient(#F9EFAF, #F7E98D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            div.divLembrete[style*="background-color:#efef8f"]:hover,
            div.divLembrete[style*="background-color: #efef8f"]:hover,
            div[style*="background-color:#efef8f"]:not([data-eprobe-processed]):hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            div.divLembrete[style*="background-color:#efef8f"]:focus,
            div.divLembrete[style*="background-color: #efef8f"]:focus,
            div[style*="background-color:#efef8f"]:not([data-eprobe-processed]):focus {
                box-shadow: 0 5px 12px !important;
            }
            
            div.divLembrete[style*="background-color:#db8080"],
            div.divLembrete[style*="background-color: #db8080"],
            div[style*="background-color:#db8080"]:not([data-eprobe-processed]) {
                background: linear-gradient(#FAAFAF, #F78D8D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            div.divLembrete[style*="background-color:#db8080"]:hover,
            div.divLembrete[style*="background-color: #db8080"]:hover,
            div[style*="background-color:#db8080"]:not([data-eprobe-processed]):hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            div.divLembrete[style*="background-color:#db8080"]:focus,
            div.divLembrete[style*="background-color: #db8080"]:focus,
            div[style*="background-color:#db8080"]:not([data-eprobe-processed]):focus {
                box-shadow: 0 5px 12px !important;
            }
            
            div.divLembrete[style*="background-color:#87adcd"],
            div.divLembrete[style*="background-color: #87adcd"],
            div[style*="background-color:#87adcd"]:not([data-eprobe-processed]) {
                background: linear-gradient(#AFCFFA, #8DC0F7) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            div.divLembrete[style*="background-color:#87adcd"]:hover,
            div.divLembrete[style*="background-color: #87adcd"]:hover,
            div[style*="background-color:#87adcd"]:not([data-eprobe-processed]):hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            div.divLembrete[style*="background-color:#87adcd"]:focus,
            div.divLembrete[style*="background-color: #87adcd"]:focus,
            div[style*="background-color:#87adcd"]:not([data-eprobe-processed]):focus {
                box-shadow: 0 5px 12px !important;
            }
            
            div.divLembrete[style*="background-color:#a7eda7"],
            div.divLembrete[style*="background-color: #a7eda7"],
            div[style*="background-color:#a7eda7"]:not([data-eprobe-processed]) {
                background: linear-gradient(#AFFAB6, #8DF792) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            div.divLembrete[style*="background-color:#a7eda7"]:hover,
            div.divLembrete[style*="background-color: #a7eda7"]:hover,
            div[style*="background-color:#a7eda7"]:not([data-eprobe-processed]):hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            div.divLembrete[style*="background-color:#a7eda7"]:focus,
            div.divLembrete[style*="background-color: #a7eda7"]:focus,
            div[style*="background-color:#a7eda7"]:not([data-eprobe-processed]):focus {
                box-shadow: 0 5px 12px !important;
            }
            
            div.divLembrete[style*="background-color:#f5b574"],
            div.divLembrete[style*="background-color: #f5b574"],
            div[style*="background-color:#f5b574"]:not([data-eprobe-processed]) {
                background: linear-gradient(#FAD3AF, #F7C68D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            div.divLembrete[style*="background-color:#f5b574"]:hover,
            div.divLembrete[style*="background-color: #f5b574"]:hover,
            div[style*="background-color:#f5b574"]:not([data-eprobe-processed]):hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            div.divLembrete[style*="background-color:#f5b574"]:focus,
            div.divLembrete[style*="background-color: #f5b574"]:focus,
            div[style*="background-color:#f5b574"]:not([data-eprobe-processed]):focus {
                box-shadow: 0 5px 12px !important;
            }
            
            /* INTERCEPTA√á√ÉO DE ELEMENTOS LISTA: Para estruturas .lista-lembretes */
            .lista-lembretes .lembrete[style*="background-color:#efef8f"],
            .lista-lembretes .lembrete[style*="background-color: #efef8f"] {
                background: linear-gradient(#F9EFAF, #F7E98D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#efef8f"]:hover,
            .lista-lembretes .lembrete[style*="background-color: #efef8f"]:hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#efef8f"]:focus,
            .lista-lembretes .lembrete[style*="background-color: #efef8f"]:focus {
                box-shadow: 0 5px 12px !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#db8080"],
            .lista-lembretes .lembrete[style*="background-color: #db8080"] {
                background: linear-gradient(#FAAFAF, #F78D8D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#db8080"]:hover,
            .lista-lembretes .lembrete[style*="background-color: #db8080"]:hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#db8080"]:focus,
            .lista-lembretes .lembrete[style*="background-color: #db8080"]:focus {
                box-shadow: 0 5px 12px !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#87adcd"],
            .lista-lembretes .lembrete[style*="background-color: #87adcd"] {
                background: linear-gradient(#AFCFFA, #8DC0F7) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#87adcd"]:hover,
            .lista-lembretes .lembrete[style*="background-color: #87adcd"]:hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#87adcd"]:focus,
            .lista-lembretes .lembrete[style*="background-color: #87adcd"]:focus {
                box-shadow: 0 5px 12px !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#a7eda7"],
            .lista-lembretes .lembrete[style*="background-color: #a7eda7"] {
                background: linear-gradient(#AFFAB6, #8DF792) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#a7eda7"]:hover,
            .lista-lembretes .lembrete[style*="background-color: #a7eda7"]:hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#a7eda7"]:focus,
            .lista-lembretes .lembrete[style*="background-color: #a7eda7"]:focus {
                box-shadow: 0 5px 12px !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#f5b574"],
            .lista-lembretes .lembrete[style*="background-color: #f5b574"] {
                background: linear-gradient(#FAD3AF, #F7C68D) !important;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
                padding: 20px !important;
                min-width: 315px !important;
                min-height: 140px !important;
                transition: box-shadow 0.5s ease !important;
                -webkit-font-smoothing: subpixel-antialiased !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#f5b574"]:hover,
            .lista-lembretes .lembrete[style*="background-color: #f5b574"]:hover {
                box-shadow: 0 5px 8px rgba(0,0,0,0.15) !important;
            }
            
            .lista-lembretes .lembrete[style*="background-color:#f5b574"]:focus,
            .lista-lembretes .lembrete[style*="background-color: #f5b574"]:focus {
                box-shadow: 0 5px 12px !important;
            }
            
            /* Spacing fixes para lembretes - aplicados instantaneamente */
            .divLembretePara, .lblLembretePara {
                margin-bottom: 15px !important;
                justify-content: space-around !important;
                font-size: small !important;
                -webkit-font-smoothing: antialiased !important;
            }
            
            .divLembreteData, .lblLembreteData {
                /* margin-top removido - sem mais for√ßar margem superior */
            }
            
            /* Novos estilos para classes do eProc */
            .desLembrete {
                margin: 15px 15px 15px 15px !important;
                align-items: baseline !important;
            }
            
            .divLembretePara {
                justify-content: space-around !important;
                font-size: small !important;
                -webkit-font-smoothing: antialiased !important;
            }
            
            /* INTERCEPTA√á√ÉO TOTAL: Bot√µes de ler mais - ocultar ANTES da renderiza√ß√£o */
            div.botaoLerMais:not([data-eprobe-expandir-replaced]):not([data-eprobe-processed]) {
                visibility: hidden !important;
                opacity: 0 !important;
                position: absolute !important;
                left: -9999px !important;
                pointer-events: none !important;
                margin-bottom: inherit !important;
            }
            
            /* Bot√µes marcados para substitui√ß√£o - ocultar completamente */
            div.botaoLerMais[data-eprobe-will-replace="true"] {
                display: none !important;
                visibility: hidden !important;
            }
            
            /* Elementos eProbe - garantir visibilidade imediata */
            [id*="eprobe"], [class*="eprobe"], [data-eprobe-expandir-replaced] {
                visibility: visible !important;
                opacity: 1 !important;
                position: static !important;
                pointer-events: auto !important;
            }
            
            /* Navbar prepara√ß√£o - evitar interfer√™ncia */
            .navbar, #navbar, .infraBarraComandos {
                align-items: center !important;
            }
            
            /* NAVBAR ANTI-FLASH INSTANT√ÇNEO */
            #navbar.navbar.bg-instancia,
            .navbar.bg-instancia,
            nav.navbar.bg-instancia,
            .navbar.text-white.bg-instancia,
            .navbar.text-white.d-xl-flex.bg-instancia {
                display: flex !important;
                align-items: center !important;
                min-height: 50px !important;
            }
            
            /* Alinhamento instant√¢neo dos elementos internos da navbar */
            #navbar.navbar.bg-instancia > *,
            .navbar.bg-instancia > *,
            nav.navbar.bg-instancia > * {
                display: flex !important; 
                align-items: center !important;
                min-height: 50px !important;
            }
            
            /* ANTI-FLASH UNIVERSAL: Prevenir qualquer transi√ß√£o vis√≠vel */
            .divLembrete, .lista-lembretes .lembrete {
                will-change: auto !important;
                backface-visibility: hidden !important;
                transform: translateZ(0) !important;
            }
            
            /* üéØ REGRA CR√çTICA OBRIGAT√ìRIA: .d-none.d-md-flex SEMPRE FLEX - ULTRA PRIORIT√ÅRIO */
            .d-none.d-md-flex,
            div.d-none.d-md-flex,
            .navbar .d-none.d-md-flex,
            #navbar .d-none.d-md-flex,
            .navbar-nav .d-none.d-md-flex,
            .navbar-collapse .d-none.d-md-flex {
                display: flex !important;
                align-items: center !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            /* ===== SISTEMA ANTI-FLASH ESPEC√çFICO PARA P√ÅGINAS DE PROCESSO ===== */
            
            /* NOVA ABORDAGEM: APENAS ocultar √≠cones em div.divLembrete */
            .divLembrete .material-icons:not([data-eprobe-icon-replaced="true"]),
            .lista-lembretes .lembrete .material-icons:not([data-eprobe-icon-replaced="true"]) {
                display: none !important;
            }
            
            /* GARANTIR: Apenas √≠cones espec√≠ficos do eProbe permanecem vis√≠veis */
            .material-icons[data-eprobe-icon],
            .eprobe-icon .material-icons,
            [data-eprobe-container] .material-icons {
                display: inline-block !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            /* ===== ANTI-FLASH TOTAL PARA TODOS OS ELEMENTOS ===== */
            
            /* NAVBAR: Evitar flash da barra de navega√ß√£o */
            .navbar,
            #navbar,
            .navbar-nav,
            .navbar-collapse,
            .navbar-brand {
                transition: none !important;
                will-change: auto !important;
                backface-visibility: hidden !important;
                transform: translateZ(0) !important;
            }
            
            /* BOT√ïES: Evitar flash de bot√µes que ser√£o customizados */
            .botaoLerMais,
            .btn,
            button,
            input[type="button"],
            input[type="submit"] {
                transition: none !important;
                will-change: auto !important;
            }
            
            /* BOT√ïES ESPEC√çFICOS: Ocultar bot√µes que ser√£o substitu√≠dos */
            .botaoLerMais:not([data-eprobe-processed]) {
                opacity: 0.8 !important;
                transition: none !important;
            }
            
            /* ELEMENTOS EPROBE: Revelar apenas elementos processados */
            [data-eprobe-processed],
            [data-eprobe-personalized],
            .eprobe-custom-element {
                opacity: 1 !important;
                visibility: visible !important;
                transition: opacity 0.2s ease !important;
            }
            
          
            /* ESPEC√çFICO: Elementos do eProc que causam flash */
            .infraFieldset,
            .infraLegendObrigatorio,
            #divInfraAreaGlobal {
                transition: none !important;
            }
        `;

        // Inserir no head IMEDIATAMENTE
        if (document.head) {
            document.head.insertBefore(
                cssUltraCritico,
                document.head.firstChild,
            );
        } else {
            // Se head n√£o existe ainda, criar e inserir
            const head = document.createElement("head");
            head.appendChild(cssUltraCritico);
            if (document.documentElement) {
                document.documentElement.insertBefore(
                    head,
                    document.documentElement.firstChild,
                );
            }
        }

        log("‚úÖ ULTRA ANTI-FLASH: CSS cr√≠tico aplicado instantaneamente");
        logCritical(
            "üéØ ANTI-FLASH ELEMENTS: Sistema de coordena√ß√£o ativado (.eprobe-loading/.eprobe-ready)",
        );

        // 2. MARCAR BOT√ïES QUE SER√ÉO SUBSTITU√çDOS - Antes da renderiza√ß√£o
        const marcarBotoesParaSubstituicao = () => {
            const botoesLerMais = document.querySelectorAll(
                "div.botaoLerMais:not([data-eprobe-processed])",
            );
            botoesLerMais.forEach((botao) => {
                const texto = (botao.textContent || "").toLowerCase();
                if (
                    texto.includes("ler mais") ||
                    texto.includes("...ler mais")
                ) {
                    const lembreteParent = botao.closest(".divLembrete");
                    if (lembreteParent) {
                        const desLembrete =
                            lembreteParent.querySelector(".desLembrete");
                        if (desLembrete) {
                            const textoCompleto = desLembrete.textContent || "";
                            const temTextoTruncado =
                                textoCompleto.length > 150 ||
                                desLembrete.scrollHeight >
                                    desLembrete.clientHeight ||
                                textoCompleto.includes("...") ||
                                window.getComputedStyle(desLembrete)
                                    .textOverflow === "ellipsis";

                            if (temTextoTruncado) {
                                botao.setAttribute(
                                    "data-eprobe-will-replace",
                                    "true",
                                );
                                botao.style.display = "none";
                                botao.style.visibility = "hidden";
                            }
                        }
                    }
                }
                // Marcar como processado para evitar reprocessamento
                botao.setAttribute("data-eprobe-processed", "true");
            });
        };

        // FUN√á√ÉO ULTRA-OTIMIZADA: Marcar lembretes como processados instantaneamente
        const marcarLembretesComoProcessados = () => {
            const lembretes = document.querySelectorAll(
                'div.divLembrete:not([data-eprobe-processed]), .lista-lembretes .lembrete:not([data-eprobe-processed]), div[style*="background-color:#"]:not([data-eprobe-processed])',
            );

            lembretes.forEach((elemento) => {
                const style = elemento.getAttribute("style") || "";
                const coresLembrete = [
                    "#efef8f",
                    "#db8080",
                    "#87adcd",
                    "#a7eda7",
                    "#f5b574",
                ];

                // Verificar se √© um lembrete colorido
                const isLembrete =
                    coresLembrete.some((cor) => style.includes(cor)) ||
                    elemento.classList.contains("divLembrete") ||
                    elemento.classList.contains("lembrete");

                if (isLembrete) {
                    elemento.setAttribute("data-eprobe-processed", "true");
                    elemento.classList.add("eprobe-lembrete-processado");
                }
            });
        };

        // 3. OBSERVADOR ULTRARR√ÅPIDO para elementos que aparecem
        const observadorUltraRapido = new MutationObserver((mutations) => {
            let needsUpdate = false;
            let newLembretes = [];

            mutations.forEach((mutation) => {
                if (mutation.type === "childList") {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1) {
                            // Element node

                            // INTERCEPTA√á√ÉO INSTANT√ÇNEA: Aplicar estilos ANTES da renderiza√ß√£o
                            if (node.classList?.contains("divLembrete")) {
                                // √â um divLembrete direto
                                newLembretes.push(node);
                                needsUpdate = true;
                            } else if (node.querySelector?.(".divLembrete")) {
                                // Cont√©m divLembrete dentro
                                const innerLembretes =
                                    node.querySelectorAll(".divLembrete");
                                newLembretes.push(
                                    ...Array.from(innerLembretes),
                                );
                                needsUpdate = true;
                            }

                            // Verificar tamb√©m elementos com cores de fundo espec√≠ficas
                            const coresLembrete = [
                                "#efef8f",
                                "#db8080",
                                "#87adcd",
                                "#a7eda7",
                                "#f5b574",
                            ];
                            coresLembrete.forEach((cor) => {
                                const style =
                                    node.style?.backgroundColor ||
                                    node.getAttribute?.("style") ||
                                    "";
                                if (style.includes(cor)) {
                                    newLembretes.push(node);
                                    needsUpdate = true;
                                }
                            });
                        }
                    });
                }
            });

            if (needsUpdate && newLembretes.length > 0) {
                // APLICA√á√ÉO INSTANT√ÇNEA: Processar novos lembretes IMEDIATAMENTE
                newLembretes.forEach((elemento) => {
                    if (
                        !elemento.classList.contains(
                            "eprobe-lembrete-processado",
                        )
                    ) {
                        // Detectar cor e aplicar estilo instantaneamente
                        const style = elemento.getAttribute("style") || "";
                        let gradiente = "";

                        if (style.includes("#efef8f")) {
                            gradiente = "linear-gradient(#F9EFAF, #F7E98D)";
                        } else if (style.includes("#db8080")) {
                            gradiente = "linear-gradient(#FAAFAF, #F78D8D)";
                        } else if (style.includes("#87adcd")) {
                            gradiente = "linear-gradient(#AFCFFA, #8DC0F7)";
                        } else if (style.includes("#a7eda7")) {
                            gradiente = "linear-gradient(#AFFAB6, #8DF792)";
                        } else if (style.includes("#f5b574")) {
                            gradiente = "linear-gradient(#FAD3AF, #F7C68D)";
                        }

                        if (gradiente) {
                            // Aplicar todos os estilos instantaneamente
                            elemento.style.setProperty(
                                "background",
                                gradiente,
                                "important",
                            );
                            elemento.style.setProperty(
                                "padding",
                                "20px",
                                "important",
                            );
                            elemento.style.setProperty(
                                "min-width",
                                "315px",
                                "important",
                            );
                            elemento.style.setProperty(
                                "min-height",
                                "140px",
                                "important",
                            );
                            elemento.style.setProperty(
                                "box-shadow",
                                "0 4px 6px rgba(0, 0, 0, 0.1)",
                                "important",
                            );
                            elemento.style.setProperty(
                                "transition",
                                "box-shadow 0.2s ease",
                                "important",
                            );
                            elemento.style.setProperty(
                                "-webkit-font-smoothing",
                                "subpixel-antialiased",
                                "important",
                            );
                            elemento.style.setProperty(
                                "visibility",
                                "visible",
                                "important",
                            );
                            elemento.style.setProperty(
                                "opacity",
                                "1",
                                "important",
                            );
                            elemento.classList.add(
                                "eprobe-lembrete-processado",
                            );
                        }
                    }
                });

                // Marcar bot√µes para substitui√ß√£o tamb√©m
                setTimeout(marcarBotoesParaSubstituicao, 0);
            }
        });

        // Iniciar observa√ß√£o imediata
        if (document.documentElement) {
            observadorUltraRapido.observe(document.documentElement, {
                childList: true,
                subtree: true,
            });
        }

        // 4. APLICA√á√ÉO INICIAL se j√° h√° elementos - ULTRA-OTIMIZADA
        setTimeout(() => {
            marcarBotoesParaSubstituicao();
            marcarLembretesComoProcessados();
        }, 0);

        // APLICA√á√ÉO SECUND√ÅRIA para elementos que aparecem ap√≥s inicializa√ß√£o
        setTimeout(() => {
            marcarBotoesParaSubstituicao();
            marcarLembretesComoProcessados();
        }, 50);

        log("‚ö° ULTRA ANTI-FLASH: Sistema ativado - zero flash garantido");
    };

    // Executar IMEDIATAMENTE
    if (document.readyState === "loading") {
        // Ainda carregando - aplicar agora
        iniciarUltraAntiFlash();
    } else {
        // J√° carregado - aplicar agora mesmo assim
        iniciarUltraAntiFlash();
    }
})();

// ===== APLICA√á√ÉO INSTANT√ÇNEA DE ESTILOS - ELIMINAR FLASH =====
(function aplicarEstilosInstantaneos() {
    log("‚ö° INSTANT: Aplicando estilos cr√≠ticos instantaneamente...");

    // CSS cr√≠tico aplicado IMEDIATAMENTE para eliminar flash
    const cssInstantaneo = document.createElement("style");
    cssInstantaneo.id = "eprobe-instant-styles";
    cssInstantaneo.textContent = `
        /* ===== ESTILOS INSTANT√ÇNEOS ANTI-FLASH ===== */
        
        /* Ocultar flash inicial com transi√ß√£o suave */
        body {
            transition: opacity 0.1s ease-in-out !important;
        }
        
        /* Preparar containers para elementos eProbe */
        .navbar, #navbar {
            display: flex !important; 
            align-items: center !important;
        }
        
        /* ANTI-FLASH NAVBAR INSTANT√ÇNEO */
        #navbar.navbar.bg-instancia,
        .navbar.bg-instancia,
        nav.navbar.bg-instancia {
            display: flex !important;
            align-items: center !important;
            min-height: 50px !important;
        }
        
        #navbar.navbar.bg-instancia > *,
        .navbar.bg-instancia > *,
        nav.navbar.bg-instancia > * {
            display: flex !important; 
            align-items: center !important;
            min-height: 50px !important;
            
        }
        
        /* Fontes cr√≠ticas carregadas instantaneamente */
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@300;400;500;600;700&display=swap');
        
        /* üé® ALINHAMENTO PADRONIZADO DE √çCONES SVG - eProbe */
        span[data-eprobe-icon-container] {
            display: inline-flex !important;
            align-items: center !important;
            vertical-align: middle !important;
            margin-right: 4px !important;
        }
        
        span[data-eprobe-icon-container] svg {
            flex-shrink: 0 !important;
            vertical-align: middle !important;
            pointer-events: none !important;
        }
        
        /* Alinhamento espec√≠fico para √≠cones de a√ß√£o */
        .iconeAcao,
        span:has(> svg.iconeAcao) {
            display: inline-flex !important;
            align-items: center !important;
            vertical-align: middle !important;
        }
        
        /* Cards de sess√£o unificados */
        .session-card {
            opacity: 1;
            transform: translateX(0);
        }
        
        /* Navbar sem anima√ß√£o */
        #eprobe-navbar-element {
            display: flex !important; 
            align-items: center !important;
            transition: all 0.3s ease !important;
        }
        
        /* Efeito hover na logo eProbe */
        #eprobe-navbar-element:hover {
            background-color: rgba(255, 255, 255, 0.2784313725) !important;
            border-radius: 5px !important;
        }
        
        /* Bot√µes da extens√£o com transi√ß√£o suave */
        [id*="sent1"], [class*="eprobe"] {
            opacity: 0;
            animation: fadeInElement 0.5s ease-out 0.3s forwards;
        }
        
        @keyframes fadeInElement {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Tooltips preparados */
        .eprobe-tooltip {
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }
        
        /* ===== ESTILOS SVG FIGMA INSTANT√ÇNEOS ===== */
        .eprobe-figma-card-svg {
            display: inline-block;
            margin: 8px 0;
            position: relative;
            opacity: 0;
            animation: fadeInElement 0.5s ease-out 0.4s forwards;
        }
        
        .eprobe-figma-svg-container {
            position: relative;
            display: inline-block;
        }
        
        .eprobe-figma-svg-container svg {
            transition: all 0.2s ease;
            display: block;
        }
        
        .eprobe-figma-card-svg:hover .eprobe-figma-svg-container svg {
            transform: translateY(-1px);
            filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
        }
        
        .eprobe-figma-data-overlay {
            position: absolute;
            bottom: 12px;
            left: 24px;
            right: 24px;
            pointer-events: none;
            z-index: 10;
        }
        
        .eprobe-figma-data-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 11px;
            font-weight: 500;
            color: #1D1B20;
            opacity: 0.9;
            text-align: left;
            display: block;
            line-height: 1.2;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px 4px;
            border-radius: 4px;
            backdrop-filter: blur(4px);
        }
        
        /* ===== ELEMENTOS DE INTERFACE PREPARADOS ===== */
        #sent1-auto-button,
        .documento-relevante-button,
        .eprobe-button {
            opacity: 0;
            animation: fadeInElement 0.5s ease-out 0.3s forwards;
            margin-right: 3px !important;
        }
        
        /* ===== MODAL E NOTIFICA√á√ïES PREPARADAS ===== */
        .eprobe-modal,
        .eprobe-notification {
            opacity: 0;
            animation: fadeInElement 0.3s ease-out forwards;
        }
        
        /* ===== ESTILOS PARA ESTRELAS PERSONALIZADAS (SEM INTERFERIR NA FUNCIONALIDADE) ===== */
        .eprobe-estrela-personalizada:hover {
            transform: scale(1.1) !important;
            filter: brightness(1.5) contrast(1.3) drop-shadow(0 0 3px gold) !important;
        }
        
        /* ===== ESTILOS PARA LEMBRETES ===== */
        .divLembretePara {
            margin-bottom: 15px !important;
            justify-content: space-around !important;
            font-size: small !important;
            -webkit-font-smoothing: antialiased !important;
        }
        
        /* üéØ REGRA CR√çTICA OBRIGAT√ìRIA: .d-none.d-md-flex SEMPRE FLEX - INSTANT√ÇNEO */
        .d-none.d-md-flex,
        div.d-none.d-md-flex,
        .navbar .d-none.d-md-flex,
        #navbar .d-none.d-md-flex,
        .navbar-nav .d-none.d-md-flex,
        .navbar-collapse .d-none.d-md-flex {
            display: flex !important;
            align-items: center !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        /* Classe do eProc - desLembrete com novos estilos */
        .desLembrete {
            margin: 25px 25px 25px 25px !important;
            align-items: baseline !important;
        }
        
        /* Classe do eProc - divLembretePara com novos estilos */
        .divLembretePara {
            justify-content: space-around !important;
            font-size: small !important;
            -webkit-font-smoothing: antialiased !important;
        }
    `;

    // Inserir no head IMEDIATAMENTE - antes de qualquer outro script
    const head =
        document.head ||
        document.getElementsByTagName("head")[0] ||
        document.documentElement;
    if (head) {
        head.insertBefore(cssInstantaneo, head.firstChild);
        logCritical("‚úÖ INSTANT: CSS cr√≠tico aplicado no topo do head");
    }

    // ===== FUN√á√ÉO OBRIGAT√ìRIA: FOR√áAR FLEXBOX NA NAVBAR =====
    function forcarFlexboxNavbar() {
        // üö® VERIFICA√á√ÉO CR√çTICA: N√ÉO aplicar flexbox na tela de edi√ß√£o de minutas
        const currentUrl = window.location.href;
        if (currentUrl.includes("acao=minuta_editar")) {
            console.log(
                "üö´ eProbe: Flexbox navbar desabilitado na tela de edi√ß√£o de minutas",
            );
            return; // Sair imediatamente - n√£o aplicar flexbox
        }

        // Aplicar estilos inline obrigat√≥rios em todos os elementos .d-none.d-md-flex
        const elementosNavbar = document.querySelectorAll(".d-none.d-md-flex");
        elementosNavbar.forEach((elemento) => {
            elemento.style.setProperty("display", "flex", "important");
            elemento.style.setProperty("align-items", "center", "important");
            elemento.style.setProperty("visibility", "visible", "important");
            elemento.style.setProperty("opacity", "1", "important");
        });

        if (elementosNavbar.length > 0) {
            console.log(
                `üéØ NAVBAR OBRIGAT√ìRIO: Flexbox for√ßado em ${elementosNavbar.length} elementos`,
            );
        }
    }

    // ===== OBSERVADOR CR√çTICO PARA NAVBAR - OTIMIZADO PARA PERFORMANCE =====
    const observadorNavbar = new MutationObserver(
        debounceGlobal((mutations) => {
            let needsUpdate = false;

            // üöÄ FILTRAR MUTATIONS RELEVANTES: Reduzir processamento
            const mutationsRelevantes = mutations.filter(
                (mutation) =>
                    mutation.type === "childList" &&
                    mutation.addedNodes.length > 0,
            );

            if (mutationsRelevantes.length === 0) return;

            mutationsRelevantes.forEach((mutation) => {
                mutation.addedNodes.forEach((node) => {
                    if (node.nodeType === 1) {
                        // Element node
                        // Verificar se √© um elemento .d-none.d-md-flex ou cont√©m um
                        if (
                            node.classList?.contains("d-none") &&
                            node.classList?.contains("d-md-flex")
                        ) {
                            needsUpdate = true;
                        } else if (
                            node.querySelector &&
                            node.querySelector(".d-none.d-md-flex")
                        ) {
                            needsUpdate = true;
                        }

                        // Verificar se cont√©m elementos .d-none.d-md-flex
                        const elementosNavbar =
                            node.querySelectorAll?.(".d-none.d-md-flex");
                        if (elementosNavbar && elementosNavbar.length > 0) {
                            needsUpdate = true;
                        }
                    }
                });
            });

            if (needsUpdate) {
                // Aplicar com pequeno delay para garantir que DOM esteja atualizado
                setTimeout(forcarFlexboxNavbar, 1);
            }
        }, PERFORMANCE_CONFIG.debounceDelay),
    );

    // Iniciar observa√ß√£o IMEDIATA COM CLEANUP AUTOM√ÅTICO
    if (document.body) {
        // üöÄ REGISTRAR NO SISTEMA DE CLEANUP
        CLEANUP_SYSTEM.addObserver(observadorNavbar);

        observadorNavbar.observe(document.body, {
            childList: true,
            subtree: false, // üöÄ OTIMIZA√á√ÉO: Reduzir escopo de observa√ß√£o
            attributes: false, // üöÄ OTIMIZA√á√ÉO: Desabilitar observa√ß√£o de atributos
        });

        // Aplica√ß√£o inicial
        forcarFlexboxNavbar();

        console.log(
            "üîç NAVBAR OBSERVER: Monitoramento de flexbox obrigat√≥rio ativado",
        );
    } else {
        // Se body ainda n√£o existe, aplicar quando existir
        document.addEventListener("DOMContentLoaded", () => {
            observadorNavbar.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ["class", "style"],
            });
            forcarFlexboxNavbar();
            console.log(
                "üîç NAVBAR OBSERVER: Monitoramento de flexbox obrigat√≥rio ativado (DOMContentLoaded)",
            );
        });
    }

    // ===== APLICA√á√ÉO ULTRA-R√ÅPIDA DE ELEMENTOS CR√çTICOS =====
    // Executar imediatamente ap√≥s 1ms para garantir que DOM b√°sico est√° pronto
    setTimeout(() => {
        try {
            // Navbar j√° est√° com CSS completo aplicado - apenas verificar
            // Seletor unificado - .navbar.bg-instancia cobre todos os casos
            const navbar = document.querySelector(".navbar.bg-instancia");

            if (navbar) {
                log(
                    "‚ö° INSTANT: Navbar encontrada com CSS completo j√° aplicado",
                );
            }
        } catch (error) {
            console.warn("‚ö†Ô∏è INSTANT: Erro na verifica√ß√£o:", error);
        }
    }, 1);
})();

// ===== INTERCEPTA√á√ÉO √öNICA E SILENCIOSA =====
(function interceptarEventListenersUnico() {
    "use strict";

    const nativeAddEventListener = EventTarget.prototype.addEventListener;

    // Eventos que devem ser passivos (SEM LOGS)
    const passiveEvents = [
        "scroll",
        "wheel",
        "touchstart",
        "touchmove",
        "touchend",
        "mouseenter",
        "mouseleave",
        "mouseover",
        "mouseout",
        "mousedown",
        "mouseup",
        "mousemove",
        "pointermove",
        "pointerdown",
        "pointerup",
        "pointerenter",
        "pointerleave",
        "focus",
        "blur",
        "input",
        "change",
        "select",
        "resize",
        "orientationchange",
        "contextmenu",
        "dragstart",
        "dragover",
        "drop",
        "keydown",
        "keyup",
        "load",
        "DOMContentLoaded",
    ];

    // Intercepta√ß√£o SILENCIOSA - elimina viola√ß√µes sem spam de logs
    EventTarget.prototype.addEventListener = function (
        type,
        listener,
        options,
    ) {
        if (passiveEvents.includes(type)) {
            const newOptions =
                typeof options === "boolean"
                    ? { capture: options, passive: true }
                    : { ...(options || {}), passive: true };
            return nativeAddEventListener.call(
                this,
                type,
                listener,
                newOptions,
            );
        }
        return nativeAddEventListener.call(this, type, listener, options);
    };
})();

(async function () {
    "use strict";

    // SISTEMA DE PROTE√á√ÉO ABSOLUTA - Garantir namespace independente de erros
    let namespaceCreated = false;
    let mainExecutionCompleted = false;

    // Fun√ß√£o de emerg√™ncia para criar namespace m√≠nimo
    const garantirNamespace = () => {
        if (namespaceCreated || mainExecutionCompleted) return;

        try {
            console.log("üÜò EMERG√äNCIA: Criando namespace de fallback...");

            // Namespace m√≠nimo mas funcional - APENAS SE N√ÉO EXISTIR
            if (typeof window.SENT1_AUTO === "undefined") {
                window.SENT1_AUTO = {
                    // Funcoes de emergencia - nao tem acesso ao escopo da IIFE #10
                    detectarCardSessaoSimplificado: () => {
                        if (
                            typeof window.SENT1_AUTO
                                .detectarSessoesUnificado === "function"
                        ) {
                            return window.SENT1_AUTO.detectarSessoesUnificado();
                        }
                        console.log(
                            "detectarSessoesUnificado nao disponivel no modo emergencia",
                        );
                        return null;
                    },
                    testarDeteccaoRobusta: () => {
                        console.log(
                            "üß™ TESTE: Fun√ß√£o de emerg√™ncia - sistema em modo degradado",
                        );
                    },
                    forcarFlexboxNavbar: () => {
                        const elementosNavbar =
                            document.querySelectorAll(".d-none.d-md-flex");
                        elementosNavbar.forEach((elemento) => {
                            elemento.style.setProperty(
                                "display",
                                "flex",
                                "important",
                            );
                            elemento.style.setProperty(
                                "align-items",
                                "center",
                                "important",
                            );
                            elemento.style.setProperty(
                                "visibility",
                                "visible",
                                "important",
                            );
                            elemento.style.setProperty(
                                "opacity",
                                "1",
                                "important",
                            );
                        });

                        if (elementosNavbar.length > 0) {
                            console.log(
                                `üéØ NAVBAR CR√çTICO: Flexbox for√ßado em ${elementosNavbar.length} elementos via namespace`,
                            );
                        }
                        return elementosNavbar.length;
                    },

                    // Metadados de status
                    status: "namespace-emergencia",
                    versao: "1.0.0-emergencia",
                    erro: "Script principal n√£o completou, usando namespace de emerg√™ncia",
                    timestamp: new Date().toISOString(),
                    totalFuncoes: 5,
                };

                namespaceCreated = true;
                console.log(
                    "‚úÖ EMERG√äNCIA: Namespace de fallback criado com",
                    Object.keys(window.SENT1_AUTO).length,
                    "propriedades",
                );
            } else {
                console.log(
                    "‚úÖ EMERG√äNCIA: Namespace j√° existe, mantendo o atual",
                );
            }
        } catch (e) {
            console.error(
                "üí• CR√çTICO: Falha at√© mesmo no namespace de emerg√™ncia:",
                e,
            );
        }
    };

    // Timeout de seguran√ßa - criar namespace ap√≥s 3 segundos se script n√£o completar
    const timeoutSeguranca = setTimeout(garantirNamespace, 3000);

    // üö® VERIFICA√á√ÉO CR√çTICA - DETECTAR ERROS EARLY
    try {
        logCritical("üöÄ IIFE: Iniciando execu√ß√£o da IIFE principal");

        // üîç DIAGN√ìSTICO INICIAL
        logCritical("üîç IIFE: Verificando ambiente...");
        logCritical("üìç URL:", window.location.href);
        logCritical("üìÑ DOM Ready:", document.readyState);
        logCritical("‚è∞ Timestamp:", new Date().toISOString());

        // 2.5. FUN√á√ÉO DEBOUNCE GLOBAL PARA PERFORMANCE
        window.debounce = (func, delay) => {
            let timeoutId;
            const debounced = function (...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(this, args), delay);
            };

            // M√©todo para cancelar timeout pendente
            debounced.cancel = () => {
                clearTimeout(timeoutId);
                timeoutId = null;
            };

            return debounced;
        };

        // üîß AGUARDAR APIS DE EXTENS√ÉO (CORRE√á√ÉO PARA EDGE)
        function aguardarAPIsExtensao() {
            return new Promise((resolve) => {
                if (typeof chrome !== "undefined" && chrome.runtime) {
                    log("‚úÖ INIT: APIs de extens√£o j√° dispon√≠veis");
                    resolve(true);
                    return;
                }

                let tentativas = 0;
                const maxTentativas = 50; // 5 segundos m√°ximo

                function verificar() {
                    tentativas++;

                    if (typeof chrome !== "undefined" && chrome.runtime) {
                        log(
                            `‚úÖ INIT: APIs dispon√≠veis ap√≥s ${
                                tentativas * 100
                            }ms`,
                        );
                        resolve(true);
                        return;
                    }

                    if (tentativas >= maxTentativas) {
                        log(
                            "‚ö†Ô∏è INIT: Continuando sem APIs de extens√£o (pode afetar funcionalidades)",
                        );
                        resolve(false);
                        return;
                    }

                    setTimeout(verificar, 100);
                }

                verificar();
            });
        }

        // Aguardar APIs antes de continuar
        await aguardarAPIsExtensao();

        // ============================================================================
        // üîç FUN√á√ïES AUXILIARES GLOBAIS - DEFINIDAS PRIMEIRO
        // ============================================================================

        /**
         * üöÄ SISTEMA UNIFICADO DE DETEC√á√ÉO DE SESS√ïES - √öNICA IMPLEMENTA√á√ÉO
         * Consolida TODAS as fun√ß√µes de detec√ß√£o, extra√ß√£o e tooltip em um s√≥ local
         * Remove redund√¢ncias e conflitos entre fun√ß√µes duplicadas
         */

        // ========================================
        // üéØ FUN√á√ÉO √öNICA DE DETEC√á√ÉO DE SESS√ïES
        // ========================================

        function detectarSessoesUnificado(forcarDeteccao = false) {
            console.log(
                "üéØ DETEC√á√ÉO UNIFICADA: Iniciando detec√ß√£o √∫nica de sess√µes com nova estrutura DOM...",
            );

            // üõ°Ô∏è PROTE√á√ÉO ANTI-DUPLICA√á√ÉO ROBUSTA
            const processoAtual = obterNumeroProcesso();
            const chaveProtecao = `eprobe_deteccao_${processoAtual}`;

            // Verificar se j√° est√° em execu√ß√£o para este processo
            if (window[chaveProtecao] === "executando") {
                console.log(
                    "üö® PROTE√á√ÉO: Detec√ß√£o j√° em execu√ß√£o para este processo, ignorando chamada duplicada",
                );
                return null;
            }

            // Marcar como em execu√ß√£o
            if (!forcarDeteccao) {
                window[chaveProtecao] = "executando";
            }

            // 0. VERIFICAR SE J√Å TEMOS DADOS V√ÅLIDOS (anti-duplica√ß√£o)
            if (
                !forcarDeteccao &&
                hasDataSessaoPautado() &&
                processoComDataSessao === processoAtual
            ) {
                console.log(
                    "‚úÖ DETEC√á√ÉO: Dados j√° existem para este processo, retornando cache",
                );

                // Marcar como conclu√≠do
                window[chaveProtecao] = "concluido";

                return {
                    sessaoPrincipal: dataSessaoPautado,
                    todasSessoes: [dataSessaoPautado],
                    totalSessoes: 1,
                    processo: processoAtual,
                    timestamp: Date.now(),
                };
            }

            // 1. Verificar p√°gina correta
            if (
                !window.location.href.includes(
                    "controlador.php?acao=processo_selecionar",
                )
            ) {
                console.log("‚ùå DETEC√á√ÉO: P√°gina incorreta");
                // Limpar prote√ß√£o em caso de erro
                window[chaveProtecao] = "erro";
                return null;
            }

            // 2. NOVA ESTRUTURA: Buscar container principal de minutas
            const containerMinutas = document.querySelector("#conteudoMinutas");
            if (!containerMinutas) {
                console.log(
                    "‚ùå DETEC√á√ÉO: Container #conteudoMinutas n√£o encontrado",
                );
                // Limpar prote√ß√£o em caso de erro
                window[chaveProtecao] = "erro";
                return null;
            }

            console.log("‚úÖ DETEC√á√ÉO: Container #conteudoMinutas encontrado");

            // 3. BUSCAR TODAS AS MINUTAS: div[id^="conteudoMinutas_"] exceto conteudoMinutas_0
            const minutasEncontradas = containerMinutas.querySelectorAll(
                'div[id^="conteudoMinutas_"]:not([id="conteudoMinutas_0"])',
            );

            if (minutasEncontradas.length === 0) {
                console.log("‚ùå DETEC√á√ÉO: Nenhuma minuta encontrada");
                // Limpar prote√ß√£o em caso de erro
                window[chaveProtecao] = "erro";
                return null;
            }

            console.log(
                `üîç DETEC√á√ÉO: ${minutasEncontradas.length} minutas encontradas`,
            );

            // 4. PROCESSAR CADA MINUTA INDIVIDUALMENTE
            const sessoes = [];

            minutasEncontradas.forEach((minuta, index) => {
                const minutaId = minuta.id;
                console.log(`üìã PROCESSANDO MINUTA ${index + 1}: ${minutaId}`);

                // 5. NAVEGAR PARA O BOT√ÉO DE SESS√ÉO: fieldset#fldMinutas ‚Üí legend ‚Üí span#historico ‚Üí button
                const fieldsetMinuta = minuta.querySelector(
                    "fieldset#fldMinutas",
                );
                if (!fieldsetMinuta) {
                    console.log(
                        `   ‚ö†Ô∏è MINUTA ${
                            index + 1
                        }: fieldset#fldMinutas n√£o encontrado`,
                    );
                    return;
                }

                const spanHistorico = fieldsetMinuta.querySelector(
                    "legend span#historico",
                );
                if (!spanHistorico) {
                    console.log(
                        `   ‚ö†Ô∏è MINUTA ${
                            index + 1
                        }: span#historico n√£o encontrado`,
                    );
                    return;
                }

                const botaoSessao = spanHistorico.querySelector(
                    "button[id^='legMinutasMaisMenos_']",
                );
                if (!botaoSessao) {
                    console.log(
                        `   ‚ö†Ô∏è MINUTA ${
                            index + 1
                        }: bot√£o de sess√£o n√£o encontrado`,
                    );
                    return;
                }

                const textoCompleto = botaoSessao.textContent?.trim();
                if (!textoCompleto) {
                    console.log(`   ‚ö†Ô∏è MINUTA ${index + 1}: bot√£o sem texto`);
                    return;
                }

                console.log(
                    `   ‚úÖ MINUTA ${
                        index + 1
                    }: Texto encontrado: ${textoCompleto.substring(0, 100)}...`,
                );

                // 6. APLICAR PADR√ïES REGEX PARA ESTA MINUTA - CORRIGIDOS
                const padroesValidos = [
                    {
                        nome: "Inclu√≠do em Pauta",
                        regex: /^([A-Za-z√Ä-√ø\s]+?)\s*\(Inclu√≠do em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Inclu√≠do",
                    },
                    {
                        nome: "Inclu√≠do em Mesa",
                        regex: /^([A-Za-z√Ä-√ø\s]+?)\s*\(Inclu√≠do em Mesa em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Inclu√≠do",
                    },
                    {
                        nome: "Pedido de Vista em Pauta",
                        regex: /^([A-Za-z√Ä-√ø\s]+?)\s*\(Pedido de Vista em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Vista",
                    },
                    {
                        nome: "Pedido de Vista em Mesa",
                        regex: /^([A-Za-z√Ä-√ø\s]+?)\s*\(Pedido de Vista em Mesa em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Vista",
                    },
                    {
                        nome: "Convertido em Dilig√™ncia em Pauta",
                        regex: /^([A-Za-z√Ä-√ø\s]+?)\s*\(Convertido em Dilig√™ncia em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Dilig√™ncia",
                    },
                    {
                        nome: "Convertido em Dilig√™ncia em Mesa",
                        regex: /^([A-Za-z√Ä-√ø\s]+?)\s*\(Convertido em Dilig√™ncia em Mesa em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Dilig√™ncia",
                    },
                    {
                        nome: "Julgado em Pauta",
                        regex: /^([A-Za-z√Ä-√ø\s]+?)\s*\(Julgado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Julgado",
                    },
                    {
                        nome: "Julgado em Mesa",
                        regex: /^([A-Za-z√Ä-√ø\s]+?)\s*\(Julgado em Mesa em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Julgado",
                    },
                    {
                        nome: "Retirado em Pauta",
                        regex: /^([A-Za-z√Ä-√ø\s]+?)\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Retirado",
                    },
                    {
                        nome: "Retirado em Mesa",
                        regex: /^([A-Za-z√Ä-√ø\s]+?)\s*\(Retirado em Mesa em (\d{1,2}\/\d{1,2}\/\d{4})(?:\s+a\s+\d{1,2}\/\d{1,2}\/\d{4})?\s*-\s*([A-Z0-9]+)\)/gi,
                        status: "Retirado",
                    },
                ];

                padroesValidos.forEach((padrao) => {
                    console.log(
                        `   üîç MINUTA ${index + 1}: Testando padr√£o ${
                            padrao.nome
                        }`,
                    );
                    console.log(`   üìù REGEX: ${padrao.regex}`);
                    console.log(`   üìù TEXTO: "${textoCompleto}"`);

                    // Resetar regex para esta itera√ß√£o
                    padrao.regex.lastIndex = 0;

                    let match;
                    while (
                        (match = padrao.regex.exec(textoCompleto)) !== null
                    ) {
                        console.log(`   ‚úÖ MATCH ENCONTRADO:`, match);
                        const [textoMatchCompleto, tipoCapturado, data, orgao] =
                            match;

                        // üîß LIMPEZA DO TIPO: Extrair apenas o tipo real
                        let tipoLimpo = tipoCapturado.trim();

                        // Pegar apenas as √∫ltimas palavras que realmente s√£o o tipo
                        const tiposValidos = [
                            "Embargos de Declara√ß√£o",
                            "M√©rito",
                            "Preliminar",
                            "Cautelar",
                            "Agravo Interno",
                            "Agravo",
                            "Apela√ß√£o",
                            "Recurso",
                            "Ju√≠zo de Retrata√ß√£o",
                        ];

                        // Tentar encontrar um tipo v√°lido no final da string capturada
                        let tipoEncontrado = null;
                        for (const tipoValido of tiposValidos) {
                            if (
                                tipoLimpo
                                    .toLowerCase()
                                    .includes(tipoValido.toLowerCase())
                            ) {
                                const index = tipoLimpo
                                    .toLowerCase()
                                    .lastIndexOf(tipoValido.toLowerCase());
                                if (index !== -1) {
                                    tipoEncontrado = tipoLimpo.substring(
                                        index,
                                        index + tipoValido.length,
                                    );
                                    break;
                                }
                            }
                        }

                        // Se n√£o encontrou um tipo espec√≠fico, pegar as √∫ltimas palavras
                        if (!tipoEncontrado) {
                            const palavras = tipoLimpo
                                .split(/\s+/)
                                .filter((p) => p.length > 2);
                            if (palavras.length > 0) {
                                tipoEncontrado = palavras.slice(-3).join(" ");
                            } else {
                                tipoEncontrado = "Julgamento";
                            }
                        }

                        console.log(
                            `    LIMPEZA TIPO: "${tipoCapturado}" ‚Üí "${tipoEncontrado}"`,
                        );

                        const sessao = {
                            tipo: extrairTipoSessao(textoCompleto),
                            status: padrao.status,
                            data: data.trim(),
                            orgao: orgao.trim(),
                            textoCompleto: textoMatchCompleto,
                            cor: obterCorPorStatus(padrao.status),
                            minutaId: minutaId,
                        };

                        // üéØ EXTRAIR DADOS DE PAUTA/MESA PARA SESS√ïES "Inclu√≠do em Pauta"
                        if (padrao.status.toLowerCase().includes("inclu√≠do")) {
                            console.log(
                                "üîç PAUTA/MESA: Sess√£o 'Inclu√≠do' detectada, buscando dados de pauta/mesa...",
                            );
                            const dadosPautaMesa = extrairDadosPautaMesa(
                                data.trim(),
                            );
                            if (dadosPautaMesa) {
                                sessao.dadosPauta = dadosPautaMesa;
                                console.log(
                                    "‚úÖ PAUTA/MESA: Dados integrados √† sess√£o:",
                                    dadosPautaMesa,
                                );
                            } else {
                                console.log(
                                    "‚ùå PAUTA/MESA: Nenhum dado de pauta/mesa encontrado para esta data",
                                );
                            }
                        }

                        console.log(
                            `   ‚úÖ SESS√ÉO DETECTADA (${padrao.nome}):`,
                            sessao,
                        );
                        sessoes.push(sessao);
                    }
                });
            });

            if (sessoes.length === 0) {
                console.log("‚ùå DETEC√á√ÉO: Nenhuma sess√£o v√°lida encontrada");
                // Limpar prote√ß√£o em caso de erro
                window[chaveProtecao] = "erro";
                return null;
            }

            // 7. ORDENAR SESS√ïES POR DATA (mais recente primeiro)
            sessoes.sort((a, b) => {
                try {
                    // Converter datas para compara√ß√£o (DD/MM/YYYY -> YYYY-MM-DD)
                    const [diaA, mesA, anoA] = a.data.split("/");
                    const [diaB, mesB, anoB] = b.data.split("/");

                    const dataA = new Date(anoA, mesA - 1, diaA);
                    const dataB = new Date(anoB, mesB - 1, diaB);

                    return dataB - dataA; // Mais recente primeiro
                } catch (error) {
                    console.error(
                        "‚ùå ORDENA√á√ÉO: Erro ao comparar datas:",
                        error,
                    );
                    return 0;
                }
            });

            console.log(
                "üìä SESS√ïES ORDENADAS (mais recente primeiro):",
                sessoes.map((s) => `${s.tipo} (${s.status} em ${s.data})`),
            );

            // 8. Retornar dados estruturados - SESS√ÉO PRINCIPAL = MAIS RECENTE
            const resultado = {
                sessaoPrincipal: sessoes[0],
                todasSessoes: sessoes,
                totalSessoes: sessoes.length,
                processo: obterNumeroProcesso(),
                timestamp: Date.now(),
            };

            console.log("üéØ DETEC√á√ÉO CONCLU√çDA:", resultado);

            // 9. Salvar dados globais - CORRIGIDO: salvar objeto completo
            dataSessaoPautado = resultado.sessaoPrincipal; // Objeto completo, n√£o apenas a data
            processoComDataSessao = resultado.processo;
            window.dadosCompletosMinutas = resultado.sessaoPrincipal;
            window.SENT1_AUTO.todasSessoesDetectadas = sessoes;

            // 10. CRIAR CARD AUTOMATICAMENTE
            console.log("üé® AUTO-CRIA√á√ÉO: Criando card automaticamente...");
            try {
                // Aguardar um pouco para garantir que as vari√°veis globais est√£o definidas
                setTimeout(() => {
                    if (typeof inserirDataSessaoNaInterface === "function") {
                        const cardCriado = inserirDataSessaoNaInterface();
                        console.log(
                            "‚úÖ AUTO-CRIA√á√ÉO: Card criado:",
                            cardCriado,
                        );
                    } else {
                        console.error(
                            "‚ùå AUTO-CRIA√á√ÉO: Fun√ß√£o inserirDataSessaoNaInterface n√£o dispon√≠vel",
                        );
                    }
                }, 100);
            } catch (error) {
                console.error("‚ùå AUTO-CRIA√á√ÉO: Erro ao criar card:", error);
            }

            // üõ°Ô∏è MARCAR PROTE√á√ÉO COMO CONCLU√çDA
            window[chaveProtecao] = "concluido";
            console.log(
                "üõ°Ô∏è PROTE√á√ÉO: Detec√ß√£o conclu√≠da, marcando como finalizada",
            );

            return resultado;
        }

        // üß™ FUN√á√ÉO DE TESTE ESPEC√çFICA PARA O PROBLEMA ATUAL
        function testarRegexEspecifica() {
            console.log("üß™ TESTE ESPEC√çFICO: Validando regex com texto real");

            const textoReal =
                "M√©rito (Inclu√≠do em Pauta em 29/07/2025 - CAMPUB5)";

            const padraoCorrigido =
                /^([A-Za-z√Ä-√ø\s]+?)\s*\(Inclu√≠do em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi;

            console.log("üìù Texto real:", textoReal);
            console.log("üéØ Regex corrigida:", padraoCorrigido);

            const match = padraoCorrigido.exec(textoReal);

            if (match) {
                console.log("‚úÖ SUCESSO! Match encontrado:", match);
                console.log("   - Texto completo:", match[0]);
                console.log("   - Tipo capturado:", match[1]);
                console.log("   - Data capturada:", match[2]);
                console.log("   - √ìrg√£o capturado:", match[3]);
                return true;
            } else {
                console.log("‚ùå FALHA: Regex n√£o capturou o texto");
                return false;
            }
        }

        // üß™ FUN√á√ÉO DE TESTE PARA EXTRA√á√ÉO DE TIPOS
        function testarExtracaoTipos() {
            console.log("üß™ TESTE: Validando extra√ß√£o de tipos de sess√£o...");

            const exemplos = [
                "M√©rito (Julgado em Pauta em 01/07/2025 - CAMPUB5)",
                "Embargos de Declara√ß√£o (Julgado em Pauta em 19/03/2024 - CAMPUB5)",
                "Agravo Interno (Julgado em Pauta em 22/07/2025 - CAMPUB5)",
                "Preliminar (Inclu√≠do em Pauta em 15/08/2025 - CAMCIV2)",
                "Cautelar (Convertido em Dilig√™ncia em Pauta em 30/06/2025 - CAMCOM1)",
                "1. Recurso Especial (Retirado em Pauta em 10/09/2025 - SORGESP)",
                "Ju√≠zo de Retrata√ß√£o (Inclu√≠do em Mesa em 21/08/2025 - CAMPUB5)",
            ];

            exemplos.forEach((exemplo, index) => {
                const tipoExtraido = extrairTipoSessao(exemplo);
                console.log(`   ${index + 1}. "${exemplo}"`);
                console.log(`      ‚Üí Tipo extra√≠do: "${tipoExtraido}"`);
                console.log("");
            });

            return true;
        }

        // üîç FUN√á√ÉO DE DEBUG ESPEC√çFICA PARA TOOLTIP E TIPO
        function debugTooltipComTipo() {
            console.log(
                "üîç DEBUG: Verificando tooltip e exibi√ß√£o do tipo de sess√£o...",
            );

            // 1. Verificar se existe card
            const card = document.querySelector(
                "#eprobe-card-sessao-material, #eprobe-data-sessao",
            );
            console.log("üìã Card encontrado:", !!card);

            if (!card) {
                console.log(
                    "‚ùå Nenhum card encontrado. Execute primeiro window.SENT1_AUTO.detectarSessoesUnificado()",
                );
                return false;
            }

            // 2. Verificar dados de sess√£o
            const dadosSessoes = window.SENT1_AUTO.todasSessoesDetectadas;
            console.log("üìä Dados de sess√µes:", dadosSessoes);

            if (!dadosSessoes || dadosSessoes.length === 0) {
                console.log("‚ùå Nenhum dado de sess√£o encontrado");
                return false;
            }

            // 3. Verificar tooltip existente
            const tooltipExistente = document.getElementById(
                "eprobe-rich-tooltip",
            );
            console.log("üé® Tooltip existe:", !!tooltipExistente);

            // 4. Testar cria√ß√£o de tooltip com dados reais
            console.log("üß™ Testando cria√ß√£o de tooltip...");
            const resultadoTooltip = aplicarTooltipUnificado(
                card,
                dadosSessoes,
            );
            console.log("üìã Resultado aplica√ß√£o tooltip:", resultadoTooltip);

            // 5. Verificar se tooltip foi criado e cont√©m tipo
            setTimeout(() => {
                const novoTooltip = document.getElementById(
                    "eprobe-rich-tooltip",
                );
                if (novoTooltip) {
                    console.log("‚úÖ Tooltip criado com sucesso");
                    const conteudoTooltip = novoTooltip.innerHTML;
                    const contemTipo =
                        conteudoTooltip.includes("Tipo do Julgamento");
                    const contemIconeBalance =
                        conteudoTooltip.includes("balance") ||
                        conteudoTooltip.includes("M60.65-108.65");

                    console.log("üîç An√°lise do tooltip:");
                    console.log(
                        "  - Cont√©m se√ß√£o 'Tipo do Julgamento':",
                        contemTipo,
                    );
                    console.log(
                        "  - Cont√©m √≠cone balance:",
                        contemIconeBalance,
                    );

                    // Verificar tipos extra√≠dos
                    dadosSessoes.forEach((sessao, index) => {
                        console.log(`  - Sess√£o ${index + 1}:`);
                        console.log(
                            `    - Texto original: "${sessao.textoCompleto}"`,
                        );
                        console.log(`    - Tipo extra√≠do: "${sessao.tipo}"`);
                        console.log(
                            `    - Tipo no HTML: ${conteudoTooltip.includes(
                                sessao.tipo,
                            )}`,
                        );
                    });
                } else {
                    console.log("‚ùå Tooltip n√£o foi criado");
                }
            }, 100);

            return true;
        }

        /**
         * üéØ FUN√á√ÉO PARA EXTRAIR TIPO DE SESS√ÉO - REGRA: Tudo antes do primeiro par√™nteses
         * @param {string} textoCompleto - Texto completo da sess√£o
         * @returns {string} - Tipo da sess√£o limpo e formatado
         */
        function extrairTipoSessao(textoCompleto) {
            console.log(
                "üîç EXTRAIR TIPO: Iniciando extra√ß√£o de tipo de sess√£o...",
            );
            console.log("üìù EXTRAIR TIPO: Texto de entrada:", textoCompleto);

            if (!textoCompleto) {
                console.log(
                    "‚ùå EXTRAIR TIPO: Texto vazio, retornando padr√£o 'Julgamento'",
                );
                return "Julgamento";
            }

            // Extrair tudo antes do primeiro par√™nteses
            const partesTipo = textoCompleto.split("(")[0];
            console.log(
                "‚úÇÔ∏è EXTRAIR TIPO: Parte antes do par√™nteses:",
                partesTipo,
            );

            if (!partesTipo) {
                console.log(
                    "‚ùå EXTRAIR TIPO: Nenhuma parte encontrada antes do par√™nteses, retornando padr√£o",
                );
                return "Julgamento";
            }

            // Limpar e formatar
            let tipoLimpo = partesTipo.trim();
            console.log("üßπ EXTRAIR TIPO: Ap√≥s trim inicial:", tipoLimpo);

            // Remover prefixos comuns como n√∫meros, etc
            const tipoAntes = tipoLimpo;
            tipoLimpo = tipoLimpo.replace(/^\d+\s*[-.]?\s*/, ""); // Remove n√∫meros no in√≠cio
            tipoLimpo = tipoLimpo.replace(/^\W+/, ""); // Remove caracteres especiais no in√≠cio
            tipoLimpo = tipoLimpo.trim();

            if (tipoAntes !== tipoLimpo) {
                console.log(
                    "üîß EXTRAIR TIPO: Ap√≥s limpeza de prefixos:",
                    tipoAntes,
                    "‚Üí",
                    tipoLimpo,
                );
            }

            // Se ficou vazio, retornar padr√£o
            if (!tipoLimpo || tipoLimpo.length < 2) {
                console.log(
                    "‚ùå EXTRAIR TIPO: Tipo muito curto ou vazio ap√≥s limpeza, retornando padr√£o",
                );
                return "Julgamento";
            }

            // Aplicar formata√ß√£o de title case para tipos conhecidos
            const tiposEspeciais = {
                merito: "M√©rito",
                preliminar: "Preliminar",
                cautelar: "Cautelar",
                "embargos de declaracao": "Embargos de Declara√ß√£o",
                "agravo interno": "Agravo Interno",
                agravo: "Agravo",
                apelacao: "Apela√ß√£o",
                recurso: "Recurso",
                "recurso especial": "Recurso Especial",
                "recurso extraordinario": "Recurso Extraordin√°rio",
            };

            const tipoNormalizado = tipoLimpo
                .toLowerCase()
                .normalize("NFD")
                .replace(/[\u0300-\u036f]/g, ""); // Remove acentos para compara√ß√£o

            console.log(
                "üî§ EXTRAIR TIPO: Tipo normalizado para compara√ß√£o:",
                tipoNormalizado,
            );

            // Verificar se √© um tipo especial
            for (const [chave, valor] of Object.entries(tiposEspeciais)) {
                const chaveNormalizada = chave
                    .toLowerCase()
                    .normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, "");
                if (tipoNormalizado === chaveNormalizada) {
                    console.log(
                        `‚úÖ EXTRAIR TIPO: Match especial encontrado! "${tipoNormalizado}" ‚Üí "${valor}"`,
                    );
                    return valor;
                }
            }

            // Se n√£o √© um tipo especial, aplicar title case simples
            const tipoFormatado = tipoLimpo
                .split(" ")
                .map(
                    (palavra) =>
                        palavra.charAt(0).toUpperCase() +
                        palavra.slice(1).toLowerCase(),
                )
                .join(" ");

            console.log(
                `üé® EXTRAIR TIPO: Aplicando title case gen√©rico: "${tipoLimpo}" ‚Üí "${tipoFormatado}"`,
            );
            console.log(`‚úÖ EXTRAIR TIPO: Resultado final: "${tipoFormatado}"`);

            return tipoFormatado;
        }

        /**
         * üéØ FUN√á√ÉO PARA EXTRAIR DADOS DE PAUTA/MESA DOS EVENTOS
         * Busca na tabela de eventos do eProc informa√ß√µes sobre inclus√£o em pauta/mesa
         * @param {string} dataSessao - Data da sess√£o para comparar (formato DD/MM/YYYY)
         * @returns {Object|null} - Dados da pauta/mesa ou null se n√£o encontrado
         */
        function extrairDadosPautaMesa(dataSessao) {
            console.log(
                "üîç PAUTA/MESA: Iniciando extra√ß√£o de dados de pauta/mesa...",
            );
            console.log(
                "üìÖ PAUTA/MESA: Data da sess√£o para comparar:",
                dataSessao,
            );

            // Buscar tabela de eventos
            const tabelaEventos = document.querySelector("#tblEventos");
            if (!tabelaEventos) {
                console.log("‚ùå PAUTA/MESA: Tabela #tblEventos n√£o encontrada");
                return null;
            }

            console.log("‚úÖ PAUTA/MESA: Tabela de eventos encontrada");

            // Buscar todas as linhas de evento com ID trEvento + n√∫mero
            const linhasEvento =
                tabelaEventos.querySelectorAll('tr[id^="trEvento"]');
            console.log(
                `üî¢ PAUTA/MESA: ${linhasEvento.length} eventos encontrados`,
            );

            for (let i = 0; i < linhasEvento.length; i++) {
                const linha = linhasEvento[i];
                const eventoId = linha.id;

                console.log(`üîç PAUTA/MESA: Analisando evento ${eventoId}...`);

                // Buscar label com descri√ß√£o do evento
                const labelDescricao = linha.querySelector(
                    "label.infraEventoDescricao",
                );
                if (!labelDescricao) {
                    console.log(
                        `‚ö†Ô∏è PAUTA/MESA: ${eventoId} - Label de descri√ß√£o n√£o encontrado`,
                    );
                    continue;
                }

                const textoEvento = labelDescricao.textContent || "";
                console.log(
                    `üìù PAUTA/MESA: ${eventoId} - Texto: "${textoEvento}"`,
                );

                // Verificar se √© um evento de inclus√£o em pauta ou mesa
                const isInclusaoPauta = textoEvento.includes(
                    "Inclus√£o em pauta de julgamento pelo relator",
                );
                const isInclusaoMesa = textoEvento.includes(
                    "Inclu√≠do em mesa para julgamento",
                );

                if (!isInclusaoPauta && !isInclusaoMesa) {
                    console.log(
                        `‚è≠Ô∏è PAUTA/MESA: ${eventoId} - N√£o √© evento de pauta/mesa, continuando...`,
                    );
                    continue;
                }

                console.log(
                    `üéØ PAUTA/MESA: ${eventoId} - Evento de ${
                        isInclusaoPauta ? "PAUTA" : "MESA"
                    } encontrado!`,
                );

                // Extrair o HTML completo do evento para an√°lise
                const htmlCompleto = linha.innerHTML;

                // Padr√µes regex para extra√ß√£o
                const padroes = {
                    // Sess√£o Ordin√°ria F√≠sica - Data da sess√£o: 21/08/2025 14:00
                    sessaoFisica:
                        /<b>Sess√£o Ordin√°ria F√≠sica<\/b><br>Data da sess√£o: <b>(\d{1,2}\/\d{1,2}\/\d{4})/i,
                    // Sess√£o Virtual - Per√≠odo da sess√£o: 19/08/2025 00:00 a 19/08/2025 18:00
                    sessaoVirtual:
                        /<b>Sess√£o Virtual[^<]*<\/b><br>Per√≠odo da sess√£o: <b>(\d{1,2}\/\d{1,2}\/\d{4})/i,
                    // Sequencial: 18
                    sequencial: /Sequencial:\s*(\d+)/i,
                };

                let modalidade = null;
                let dataEncontrada = null;
                let sequencial = null;

                // Verificar modalidade f√≠sica
                const matchFisica = htmlCompleto.match(padroes.sessaoFisica);
                if (matchFisica) {
                    modalidade = "F√≠sica";
                    dataEncontrada = matchFisica[1];
                    console.log(
                        `üèõÔ∏è PAUTA/MESA: ${eventoId} - Sess√£o F√çSICA detectada, data: ${dataEncontrada}`,
                    );
                }

                // Verificar modalidade virtual
                const matchVirtual = htmlCompleto.match(padroes.sessaoVirtual);
                if (matchVirtual && !modalidade) {
                    // s√≥ se n√£o encontrou f√≠sica
                    modalidade = "Virtual";
                    dataEncontrada = matchVirtual[1];
                    console.log(
                        `üíª PAUTA/MESA: ${eventoId} - Sess√£o VIRTUAL detectada, data: ${dataEncontrada}`,
                    );
                }

                // üêõ DEBUG: Se n√£o encontrou modalidade, vamos analisar o HTML
                if (!modalidade) {
                    console.log(
                        `üêõ DEBUG: ${eventoId} - HTML completo:`,
                        htmlCompleto,
                    );
                    console.log(
                        `üêõ DEBUG: ${eventoId} - Texto do evento:`,
                        textoEvento,
                    );

                    // Tentar padr√µes alternativos mais flex√≠veis
                    const padraoFisicoAlternativo =
                        /[Ss]ess√£o.*[Ff]√≠sica.*?(\d{1,2}\/\d{1,2}\/\d{4})/i;
                    const padraoVirtualAlternativo =
                        /[Ss]ess√£o.*[Vv]irtual.*?(\d{1,2}\/\d{1,2}\/\d{4})/i;

                    const matchFisicoAlt = htmlCompleto.match(
                        padraoFisicoAlternativo,
                    );
                    const matchVirtualAlt = htmlCompleto.match(
                        padraoVirtualAlternativo,
                    );

                    if (matchFisicoAlt) {
                        modalidade = "F√≠sica";
                        dataEncontrada = matchFisicoAlt[1];
                        console.log(
                            `üîß DEBUG: ${eventoId} - Sess√£o F√çSICA detectada com padr√£o alternativo, data: ${dataEncontrada}`,
                        );
                    } else if (matchVirtualAlt) {
                        modalidade = "Virtual";
                        dataEncontrada = matchVirtualAlt[1];
                        console.log(
                            `üîß DEBUG: ${eventoId} - Sess√£o VIRTUAL detectada com padr√£o alternativo, data: ${dataEncontrada}`,
                        );
                    } else {
                        console.log(
                            `üêõ DEBUG: ${eventoId} - Nenhum padr√£o de modalidade encontrado`,
                        );
                    }
                }

                // Extrair sequencial
                const matchSequencial = htmlCompleto.match(padroes.sequencial);
                if (matchSequencial) {
                    sequencial = parseInt(matchSequencial[1]);
                    console.log(
                        `üî¢ PAUTA/MESA: ${eventoId} - Sequencial: ${sequencial}`,
                    );
                }

                // Verificar se a data coincide
                const dataCoincide =
                    dataEncontrada && dataEncontrada === dataSessao;
                console.log(
                    `üìÖ PAUTA/MESA: ${eventoId} - Compara√ß√£o de datas:`,
                );
                console.log(`   Data encontrada: "${dataEncontrada}"`);
                console.log(`   Data da sess√£o: "${dataSessao}"`);
                console.log(`   Coincidem: ${dataCoincide ? "‚úÖ" : "‚ùå"}`);

                if (dataCoincide && modalidade && sequencial !== null) {
                    const tipoInclusao = isInclusaoPauta
                        ? "Inclu√≠do em pauta"
                        : "Inclu√≠do em mesa";

                    const resultado = {
                        tipoInclusao,
                        modalidade,
                        sequencial,
                        dataEncontrada,
                        eventoId,
                    };

                    console.log(
                        `üéâ PAUTA/MESA: Dados completos encontrados:`,
                        resultado,
                    );
                    return resultado;
                }
            }

            console.log(
                "‚ùå PAUTA/MESA: Nenhum evento de pauta/mesa com data coincidente encontrado",
            );
            return null;
        }

        /**
         * √öNICA fun√ß√£o para obter cor por status - substitui todas as outras
         * @param {string} status - Status da sess√£o
         * @returns {string} - Cor hexadecimal
         */
        function obterCorPorStatus(status) {
            const cores = {
                Julgado: "#3AB795",
                Retirado: "#CE2D4F",
                Inclu√≠do: "#5C85B4",
                Pautado: "#5C85B4",
                Vista: "#FFBF46",
                Dilig√™ncia: "#00171F",
            };
            return cores[status] || "#6B7280";
        }

        // üß™ FUN√á√ÉO DE TESTE PARA A NOVA ESTRUTURA DOM
        function debugDeteccaoSessaoRapida() {
            console.log(
                "üß™ TESTE R√ÅPIDO: Nova estrutura DOM de detec√ß√£o de sess√µes",
            );

            try {
                // 1. Verificar container principal
                const containerMinutas =
                    document.querySelector("#conteudoMinutas");
                console.log(
                    "üìã Container #conteudoMinutas:",
                    !!containerMinutas,
                );

                if (!containerMinutas) {
                    console.log("‚ùå TESTE: Container n√£o encontrado");
                    return {
                        erro: "Container #conteudoMinutas n√£o encontrado",
                    };
                }

                // 2. Buscar minutas (exceto conteudoMinutas_0)
                const minutas = containerMinutas.querySelectorAll(
                    'div[id^="conteudoMinutas_"]:not([id="conteudoMinutas_0"])',
                );
                console.log(`üìÅ Minutas encontradas: ${minutas.length}`);

                const resultados = [];

                minutas.forEach((minuta, index) => {
                    const minutaId = minuta.id;
                    console.log(`\nüîç MINUTA ${index + 1}: ${minutaId}`);

                    const resultado = {
                        minutaId,
                        temFieldset: false,
                        temSpanHistorico: false,
                        temBotao: false,
                        textoEncontrado: null,
                    };

                    // Verificar fieldset (usar classe em vez de ID duplicado)
                    const fieldset = minuta.querySelector(
                        "fieldset.infraFieldset",
                    );
                    resultado.temFieldset = !!fieldset;
                    console.log(
                        `   üìÑ Fieldset .infraFieldset: ${resultado.temFieldset}`,
                    );

                    if (fieldset) {
                        // Verificar span historico
                        const spanHistorico = fieldset.querySelector(
                            "legend span#historico",
                        );
                        resultado.temSpanHistorico = !!spanHistorico;
                        console.log(
                            `   üìã Span #historico: ${resultado.temSpanHistorico}`,
                        );

                        if (spanHistorico) {
                            // Verificar bot√£o
                            const botao = spanHistorico.querySelector(
                                "button[id^='legMinutasMaisMenos_']",
                            );
                            resultado.temBotao = !!botao;
                            console.log(
                                `   üîò Bot√£o encontrado: ${resultado.temBotao}`,
                            );

                            if (botao) {
                                resultado.textoEncontrado =
                                    botao.textContent?.trim();
                                console.log(
                                    `   üìù Texto: ${resultado.textoEncontrado?.substring(
                                        0,
                                        80,
                                    )}...`,
                                );
                            }
                        }
                    }

                    resultados.push(resultado);
                });

                const resumo = {
                    totalMinutas: minutas.length,
                    comFieldset: resultados.filter((r) => r.temFieldset).length,
                    comSpanHistorico: resultados.filter(
                        (r) => r.temSpanHistorico,
                    ).length,
                    comBotao: resultados.filter((r) => r.temBotao).length,
                    comTexto: resultados.filter((r) => r.textoEncontrado)
                        .length,
                    resultados,
                };

                console.log("\nüìä RESUMO DO TESTE:", resumo);

                // 3. Testar detec√ß√£o unificada
                console.log("\nüéØ TESTANDO DETEC√á√ÉO UNIFICADA...");
                const deteccao = detectarSessoesUnificado(true);
                console.log("üìä RESULTADO DA DETEC√á√ÉO:", deteccao);

                return { resumo, deteccao };
            } catch (error) {
                console.error("‚ùå TESTE: Erro durante execu√ß√£o:", error);
                return { erro: error.message };
            }
        }

        // ========================================
        // üé® FUN√á√ÉO √öNICA DE TOOLTIP DIRETO NO CARD
        // ========================================

        /**
         * √öNICA fun√ß√£o para aplicar tooltip - substitui adicionarTooltipUnificado e todas as outras
         * @param {HTMLElement} cardElement - Elemento do card
         * @param {Array} sessoes - Array de sess√µes (opcional)
         * @returns {Object} - Status da opera√ß√£o
         */
        function aplicarTooltipUnificado(cardElement, sessoes = null) {
            console.log(
                "üé® TOOLTIP UNIFICADO: Aplicando tooltip direto no card",
            );

            if (!cardElement) {
                console.error("‚ùå TOOLTIP: Card element n√£o fornecido");
                return { status: "erro", motivo: "card_inexistente" };
            }

            // 1. Obter sess√µes se n√£o fornecidas
            if (!sessoes) {
                const dadosDetectados = detectarSessoesUnificado();
                sessoes = dadosDetectados ? dadosDetectados.todasSessoes : [];
            }

            if (!sessoes || sessoes.length === 0) {
                console.log(
                    "‚ö†Ô∏è TOOLTIP: Nenhuma sess√£o para mostrar no tooltip",
                );
                return { status: "aviso", motivo: "sem_sessoes" };
            }

            // 2. Remover tooltip existente APENAS UMA VEZ para evitar flash
            const tooltipExistente = document.getElementById(
                "eprobe-rich-tooltip",
            );
            if (tooltipExistente) {
                console.log(
                    "üîÑ TOOLTIP: Removendo tooltip existente para evitar duplica√ß√£o",
                );
                tooltipExistente.remove();
            }

            // 3. Criar tooltip HTML
            const tooltipHTML = criarHTMLTooltip(sessoes);

            // 4. Adicionar event listeners direto no card COM PASSIVE
            cardElement.addEventListener("mouseenter", mostrarTooltip, {
                passive: true,
            });
            cardElement.addEventListener("mouseleave", esconderTooltip, {
                passive: true,
            });

            // 5. Fun√ß√µes do tooltip
            let tooltipTimer = null; // Timer para controlar o escondimento

            function mostrarTooltip(e) {
                // üõ°Ô∏è CANCELAR TIMER DE ESCONDIMENTO SE EXISTIR
                if (tooltipTimer) {
                    clearTimeout(tooltipTimer);
                    tooltipTimer = null;
                    console.log("‚è∞ TOOLTIP: Timer de escondimento cancelado");
                }

                // üõ°Ô∏è PROTE√á√ÉO ANTI-FLASH: Verificar se j√° existe tooltip
                const tooltipExistente = document.getElementById(
                    "eprobe-rich-tooltip",
                );
                if (tooltipExistente) {
                    console.log(
                        "üîÑ TOOLTIP: Reutilizando tooltip existente para evitar flash",
                    );

                    // Apenas mostrar o tooltip existente
                    tooltipExistente.style.opacity = "1";
                    tooltipExistente.style.visibility = "visible";
                    return;
                }

                console.log(
                    "üé® TOOLTIP: Criando novo tooltip com tipos de sess√£o...",
                );

                // üé≠ CRIAR TOOLTIP COM SISTEMA ANTI-FLASH
                const tooltip = window.eProbeAntiFlash.createElement("div", {
                    id: "eprobe-rich-tooltip",
                    innerHTML: tooltipHTML,
                    groupId: "tooltips", // Agrupar tooltips
                });

                tooltip.style.cssText = `
                    position: fixed !important;
                    background: transparent !important;
                    border: none !important;
                    border-radius: 0 !important;
                    padding: 0 !important;
                    box-shadow: none !important;
                    z-index: 999999 !important;
                    max-width: none !important;
                    font-size: inherit !important;
                    line-height: inherit !important;
                    pointer-events: auto !important;
                    opacity: 0 !important;
                    transition: opacity 0.15s ease-in-out !important;
                    left: 0px !important;
                    top: 0px !important;
                    transform: none !important;
                    margin: 0 !important;
                    filter: none !important;
                    visibility: hidden !important;
                `;

                // Adicionar ao DOM primeiro para permitir medi√ß√£o
                document.body.appendChild(tooltip);

                // ÔøΩ REVELAR TOOLTIP AP√ìS INSER√á√ÉO NO DOM
                requestAnimationFrame(() => {
                    window.eProbeAntiFlash.reveal(tooltip);
                });

                // ÔøΩüéØ EVENT LISTENERS DO TOOLTIP PARA MANTER VIS√çVEL DURANTE HOVER
                tooltip.addEventListener(
                    "mouseenter",
                    () => {
                        console.log(
                            "üñ±Ô∏è TOOLTIP: Mouse sobre tooltip - mantendo vis√≠vel",
                        );
                        // Cancelar qualquer timer de escondimento
                        if (tooltipTimer) {
                            clearTimeout(tooltipTimer);
                            tooltipTimer = null;
                            console.log(
                                "‚è∞ TOOLTIP: Timer cancelado durante hover no tooltip",
                            );
                        }
                        tooltip.style.opacity = "1";
                    },
                    { passive: true },
                );

                tooltip.addEventListener(
                    "mouseleave",
                    () => {
                        console.log(
                            "üñ±Ô∏è TOOLTIP: Mouse saiu do tooltip - programando escondimento",
                        );
                        programarEscondimento();
                    },
                    { passive: true },
                );

                // üîß AGUARDAR RENDERIZA√á√ÉO PARA OBTER DIMENS√ïES REAIS
                requestAnimationFrame(() => {
                    // üéØ POSICIONAMENTO INTELIGENTE COM DIMENS√ïES REAIS
                    posicionarTooltipRelativoAoCard(tooltip, cardElement, e);

                    // ‚ú® ANIMA√á√ÉO DE ENTRADA ELEGANTE
                    requestAnimationFrame(() => {
                        tooltip.style.visibility = "visible";
                        tooltip.style.opacity = "1";
                    });
                });
            }

            function esconderTooltip() {
                console.log(
                    "üñ±Ô∏è TOOLTIP: Mouse saiu do card - programando escondimento",
                );
                programarEscondimento();
            }

            function programarEscondimento() {
                // Cancelar timer anterior se existir
                if (tooltipTimer) {
                    clearTimeout(tooltipTimer);
                }

                // Programar escondimento com delay
                tooltipTimer = setTimeout(() => {
                    const tooltip = document.getElementById(
                        "eprobe-rich-tooltip",
                    );
                    if (tooltip) {
                        console.log(
                            "üîÑ TOOLTIP: Escondendo tooltip ap√≥s delay",
                        );

                        // ‚ú® ANIMA√á√ÉO DE SA√çDA ELEGANTE
                        tooltip.style.opacity = "0";

                        // Remover ap√≥s anima√ß√£o
                        setTimeout(() => {
                            if (tooltip.parentNode) {
                                tooltip.remove();
                                console.log(
                                    "‚úÖ TOOLTIP: Removido do DOM com sucesso",
                                );
                            }
                        }, 200);
                    }
                    tooltipTimer = null;
                }, 300); // 300ms de delay
            }

            console.log("‚úÖ TOOLTIP: Aplicado com sucesso");
            return { status: "sucesso", sessoes: sessoes.length };
        }

        /**
         * üéØ FUN√á√ÉO √öNICA E EXCLUSIVA DE POSICIONAMENTO DO TOOLTIP
         * Esta √© a √öNICA fun√ß√£o respons√°vel por posicionar tooltips na extens√£o
         * Busca o card de sess√£o diretamente no DOM para posicionamento √≥timo
         * PRIORIDADES: 1) Abaixo 2) Direita 3) Esquerda 4) Acima
         * @param {HTMLElement} tooltip - Elemento do tooltip
         * @param {HTMLElement} cardElement - Card de refer√™ncia (opcional, ser√° ignorado)
         * @param {Event} mouseEvent - Evento do mouse para fallback
         */
        function posicionarTooltipRelativoAoCard(
            tooltip,
            cardElement,
            mouseEvent = null,
        ) {
            console.log(
                "üéØ POSICIONAMENTO: Buscando card no DOM para posicionamento inteligente",
            );

            // üîç BUSCAR CARD DIRETAMENTE NO DOM PELO ID
            const cardNoDOM = document.getElementById(
                "eprobe-card-sessao-material",
            );

            if (!cardNoDOM) {
                console.warn(
                    "‚ö†Ô∏è POSICIONAMENTO: Card n√£o encontrado no DOM, usando posicionamento do mouse",
                );

                // Fallback: usar posi√ß√£o do mouse ou posi√ß√£o fixa
                const mouseX = mouseEvent?.clientX || 200;
                const mouseY = mouseEvent?.clientY || 200;

                tooltip.style.left = mouseX + 15 + "px";
                tooltip.style.top = mouseY - 50 + "px";

                console.log(
                    `üéØ POSICIONAMENTO: Tooltip posicionado pr√≥ximo ao mouse (${
                        mouseX + 15
                    }, ${mouseY - 50})`,
                );
                return;
            }

            // 1. Obter dimens√µes da viewport
            const viewport = {
                width: window.innerWidth,
                height: window.innerHeight,
                scrollX: window.pageXOffset,
                scrollY: window.pageYOffset,
            };

            // 2. Obter posi√ß√£o e dimens√µes do card encontrado no DOM
            const cardRect = cardNoDOM.getBoundingClientRect();

            console.log("üîç CARD ENCONTRADO NO DOM:", {
                id: cardNoDOM.id,
                rect: cardRect,
                offsetDimensions: `${cardNoDOM.offsetWidth}x${cardNoDOM.offsetHeight}`,
                clientDimensions: `${cardNoDOM.clientWidth}x${cardNoDOM.clientHeight}`,
                isVisible:
                    cardNoDOM.offsetWidth > 0 && cardNoDOM.offsetHeight > 0,
                display: window.getComputedStyle(cardNoDOM).display,
                visibility: window.getComputedStyle(cardNoDOM).visibility,
            });

            // üö® VERIFICA√á√ÉO CR√çTICA: Card com dimens√µes v√°lidas?
            if (cardRect.width === 0 || cardRect.height === 0) {
                console.warn(
                    "‚ö†Ô∏è POSICIONAMENTO: Card encontrado mas sem dimens√µes v√°lidas, usando posicionamento do mouse",
                );

                // Fallback: usar posi√ß√£o do mouse ou posi√ß√£o fixa
                const mouseX = mouseEvent?.clientX || 200;
                const mouseY = mouseEvent?.clientY || 200;

                tooltip.style.left = mouseX + 15 + "px";
                tooltip.style.top = mouseY - 50 + "px";

                console.log(
                    `üéØ POSICIONAMENTO: Tooltip posicionado pr√≥ximo ao mouse (${
                        mouseX + 15
                    }, ${mouseY - 50})`,
                );
                return;
            }

            const cardInfo = {
                left: cardRect.left,
                top: cardRect.top,
                right: cardRect.right,
                bottom: cardRect.bottom,
                width: cardRect.width,
                height: cardRect.height,
                centerX: cardRect.left + cardRect.width / 2,
                centerY: cardRect.top + cardRect.height / 2,
            };

            // 3. Obter dimens√µes do tooltip - AGUARDAR RENDERIZA√á√ÉO COMPLETA
            const tooltipRect = tooltip.getBoundingClientRect();
            let tooltipInfo = {
                width: tooltipRect.width,
                height: tooltipRect.height,
            };

            // üö® VERIFICA√á√ÉO CR√çTICA: Se dimens√µes s√£o 0, aguardar renderiza√ß√£o
            if (tooltipInfo.width === 0 || tooltipInfo.height === 0) {
                console.warn(
                    "‚ö†Ô∏è POSICIONAMENTO: Aguardando renderiza√ß√£o para obter dimens√µes...",
                );

                // Aguardar um tick e tentar novamente
                setTimeout(() => {
                    const newRect = tooltip.getBoundingClientRect();
                    tooltipInfo = {
                        width: newRect.width || 320, // Fallback para largura padr√£o
                        height: newRect.height || 200, // Fallback para altura padr√£o
                    };
                    console.log("üìê DIMENS√ïES OBTIDAS:", tooltipInfo);
                    continuarPosicionamento();
                }, 16); // ~1 frame
                return;
            }

            continuarPosicionamento();

            function continuarPosicionamento() {
                // 4. Definir margem m√≠nima das bordas da tela
                const MARGEM_BORDA = 15;

                // 5. Calcular posi√ß√µes preferenciais (em ordem de prioridade)
                const posicoesCandidatas = [
                    // Posi√ß√£o 1: Abaixo do card (NOVA PREFERENCIAL)
                    {
                        name: "abaixo",
                        left: cardInfo.centerX - tooltipInfo.width / 2,
                        top: cardInfo.bottom + 12,
                        priority: 1,
                    },
                    // Posi√ß√£o 2: √Ä direita do card
                    {
                        name: "direita",
                        left: cardInfo.right + 12,
                        top: cardInfo.centerY - tooltipInfo.height / 2,
                        priority: 2,
                    },
                    // Posi√ß√£o 3: √Ä esquerda do card
                    {
                        name: "esquerda",
                        left: cardInfo.left - tooltipInfo.width - 12,
                        top: cardInfo.centerY - tooltipInfo.height / 2,
                        priority: 3,
                    },
                    // Posi√ß√£o 4: Acima do card (fallback)
                    {
                        name: "acima",
                        left: cardInfo.centerX - tooltipInfo.width / 2,
                        top: cardInfo.top - tooltipInfo.height - 12,
                        priority: 4,
                    },
                ];

                // 6. Verificar qual posi√ß√£o √© vi√°vel (n√£o sai da tela)
                let melhorPosicao = null;

                console.log(
                    "üîç POSICIONAMENTO: Avaliando posi√ß√µes candidatas:",
                );
                console.log("üìä Viewport:", viewport);
                console.log("üì¶ Card:", cardInfo);
                console.log("üéØ Tooltip:", tooltipInfo);

                for (const posicao of posicoesCandidatas.sort(
                    (a, b) => a.priority - b.priority,
                )) {
                    const dentroDoViewport =
                        posicao.left >= MARGEM_BORDA &&
                        posicao.left + tooltipInfo.width <=
                            viewport.width - MARGEM_BORDA &&
                        posicao.top >= MARGEM_BORDA &&
                        posicao.top + tooltipInfo.height <=
                            viewport.height - MARGEM_BORDA;

                    console.log(`üìç Testando posi√ß√£o "${posicao.name}":`, {
                        left: posicao.left,
                        top: posicao.top,
                        dentroDoViewport,
                        margens: {
                            esquerda: posicao.left >= MARGEM_BORDA,
                            direita:
                                posicao.left + tooltipInfo.width <=
                                viewport.width - MARGEM_BORDA,
                            topo: posicao.top >= MARGEM_BORDA,
                            baixo:
                                posicao.top + tooltipInfo.height <=
                                viewport.height - MARGEM_BORDA,
                        },
                    });

                    if (dentroDoViewport) {
                        melhorPosicao = posicao;
                        console.log(
                            `‚úÖ POSICIONAMENTO: Posi√ß√£o "${posicao.name}" selecionada`,
                        );
                        break;
                    }
                }

                // 7. Se nenhuma posi√ß√£o ideal, FOR√áAR posi√ß√£o abaixo com ajustes inteligentes
                if (!melhorPosicao) {
                    console.log(
                        "‚ö†Ô∏è POSICIONAMENTO: FOR√áANDO posi√ß√£o abaixo com ajustes inteligentes",
                    );

                    // SEMPRE usar posi√ß√£o abaixo como base
                    melhorPosicao = {
                        name: "abaixo_forcado",
                        left: cardInfo.centerX - tooltipInfo.width / 2,
                        top: cardInfo.bottom + 12,
                        priority: 1,
                    };

                    // Ajustar horizontalmente se necess√°rio (centralizado no card)
                    if (melhorPosicao.left < MARGEM_BORDA) {
                        melhorPosicao.left = MARGEM_BORDA;
                    } else if (
                        melhorPosicao.left + tooltipInfo.width >
                        viewport.width - MARGEM_BORDA
                    ) {
                        melhorPosicao.left =
                            viewport.width - tooltipInfo.width - MARGEM_BORDA;
                    }

                    // Se sair da tela por baixo, ajustar para posi√ß√£o superior APENAS se necess√°rio
                    if (
                        melhorPosicao.top + tooltipInfo.height >
                        viewport.height - MARGEM_BORDA
                    ) {
                        // Tentar posicionar acima do card apenas se realmente n√£o couber
                        const posicaoAcima =
                            cardInfo.top - tooltipInfo.height - 12;
                        if (posicaoAcima >= MARGEM_BORDA) {
                            melhorPosicao.top = posicaoAcima;
                            melhorPosicao.name = "acima_forcado";
                            console.log(
                                "üîÑ POSICIONAMENTO: Movido para acima por falta de espa√ßo",
                            );
                        } else {
                            // Se nem acima nem abaixo cabem, usar o m√°ximo poss√≠vel abaixo
                            melhorPosicao.top =
                                viewport.height -
                                tooltipInfo.height -
                                MARGEM_BORDA;
                            console.log(
                                "üîÑ POSICIONAMENTO: Ajustado para caber na tela (abaixo)",
                            );
                        }
                    }

                    console.log("‚úÖ POSICIONAMENTO FOR√áADO:", melhorPosicao);
                }

                // 8. Aplicar posi√ß√£o final com !important para for√ßar
                tooltip.style.setProperty(
                    "left",
                    Math.round(melhorPosicao.left) + "px",
                    "important",
                );
                tooltip.style.setProperty(
                    "top",
                    Math.round(melhorPosicao.top) + "px",
                    "important",
                );
                tooltip.style.setProperty("position", "fixed", "important");

                // üîß VERIFICA√á√ÉO IMEDIATA: For√ßar aplica√ß√£o e re-check
                setTimeout(() => {
                    const computedAfterSet = window.getComputedStyle(tooltip);
                    console.log("üîß VERIFICA√á√ÉO IMEDIATA CSS:", {
                        position: computedAfterSet.position,
                        left: computedAfterSet.left,
                        top: computedAfterSet.top,
                        styleLeft: tooltip.style.left,
                        styleTop: tooltip.style.top,
                        stylePosition: tooltip.style.position,
                    });

                    // Se ainda n√£o est√° correto, for√ßar novamente
                    if (computedAfterSet.position !== "fixed") {
                        console.warn("‚ö†Ô∏è FOR√áANDO POSITION: fixed novamente");
                        tooltip.style.position = "fixed";
                        tooltip.style.setProperty(
                            "position",
                            "fixed",
                            "important",
                        );
                    }
                }, 10);

                // üîç DEBUG: Verificar posicionamento final
                const tooltipFinalRect = tooltip.getBoundingClientRect();
                const cardFinalRect = cardNoDOM.getBoundingClientRect();

                console.log("üîç DEBUG POSICIONAMENTO FINAL:", {
                    tooltipComputedStyles: {
                        position: window.getComputedStyle(tooltip).position,
                        left: window.getComputedStyle(tooltip).left,
                        top: window.getComputedStyle(tooltip).top,
                        zIndex: window.getComputedStyle(tooltip).zIndex,
                        transform: window.getComputedStyle(tooltip).transform,
                    },
                    tooltipFinalRect: tooltipFinalRect,
                    cardFinalRect: cardFinalRect,
                    posicionamentoCalculado: {
                        left: Math.round(melhorPosicao.left),
                        top: Math.round(melhorPosicao.top),
                    },
                    distanciaRelativa: {
                        deltaX: tooltipFinalRect.left - cardFinalRect.left,
                        deltaY: tooltipFinalRect.top - cardFinalRect.top,
                    },
                    problemaPossivel: {
                        tooltipEstaOndeEsperado:
                            Math.abs(
                                tooltipFinalRect.left -
                                    Math.round(melhorPosicao.left),
                            ) < 5,
                        cardEstaVisivel:
                            cardFinalRect.width > 0 && cardFinalRect.height > 0,
                        tooltipEstaVisivel:
                            tooltipFinalRect.width > 0 &&
                            tooltipFinalRect.height > 0,
                    },
                    viewport: viewport,
                });

                console.log(
                    `üéØ POSICIONAMENTO: Tooltip posicionado em (${Math.round(
                        melhorPosicao.left,
                    )}, ${Math.round(melhorPosicao.top)}) relativo ao card`,
                );

                // üîç POSI√á√ÉO REAL vs ESPERADA
                console.log("üìä COMPARA√á√ÉO POSI√á√ïES:");
                console.log(
                    `   Esperado: (${Math.round(
                        melhorPosicao.left,
                    )}, ${Math.round(melhorPosicao.top)})`,
                );
                console.log(
                    `   Real: (${tooltipFinalRect.left}, ${tooltipFinalRect.top})`,
                );
                console.log(
                    `   Diferen√ßa: (${
                        tooltipFinalRect.left - Math.round(melhorPosicao.left)
                    }, ${tooltipFinalRect.top - Math.round(melhorPosicao.top)})`,
                );

                // üéØ VERIFICA√á√ÉO SE EST√Å ABAIXO DO CARD (NOVA POSI√á√ÉO PREFERENCIAL)
                const estaAbaixoDoCard =
                    tooltipFinalRect.top > cardFinalRect.bottom;
                const estaCentralizado =
                    Math.abs(
                        tooltipFinalRect.left +
                            tooltipFinalRect.width / 2 -
                            (cardFinalRect.left + cardFinalRect.width / 2),
                    ) < 10;

                console.log("üéØ VERIFICA√á√ÉO POSICIONAMENTO:", {
                    estaAbaixoDoCard,
                    estaCentralizado,
                    distanciaVertical:
                        tooltipFinalRect.top - cardFinalRect.bottom,
                    posicaoSelecionada: melhorPosicao.name,
                });

                console.log("‚úÖ POSICIONAMENTO FINAL:");
                console.log(`   Est√° abaixo do card: ${estaAbaixoDoCard}`);
                console.log(`   Est√° centralizado: ${estaCentralizado}`);
                console.log(
                    `   Dist√¢ncia do card: ${
                        tooltipFinalRect.top - cardFinalRect.bottom
                    }px`,
                );
            }
        }

        /**
         * Cria HTML do tooltip com dados das sess√µes - Material Symbols Design
         */
        function criarHTMLTooltip(sessoes) {
            console.log(
                "üé® TOOLTIP HTML: Iniciando cria√ß√£o do HTML do tooltip...",
            );
            console.log("üìä TOOLTIP HTML: Sess√µes recebidas:", sessoes);
            console.log(
                "üî¢ TOOLTIP HTML: Total de sess√µes:",
                sessoes?.length || 0,
            );

            // Log dos tipos das sess√µes
            if (sessoes && sessoes.length > 0) {
                console.log("üìã TOOLTIP HTML: Tipos das sess√µes encontradas:");
                sessoes.forEach((sessao, index) => {
                    console.log(
                        `   ${index + 1}. Tipo: "${
                            sessao.tipo || "N/A"
                        }" | Status: "${sessao.status}" | Data: "${
                            sessao.data
                        }"`,
                    );
                });
            }

            // Determinar cor do header baseada na sess√£o atual
            let corHeader = "#5C85B4"; // Azul padr√£o do Figma

            if (sessoes && sessoes.length > 0) {
                // Pegar a primeira sess√£o (atual) ou procurar por uma marcada como atual
                const sessaoAtual =
                    sessoes.find((s) => s.isAtual) || sessoes[0];
                if (sessaoAtual && sessaoAtual.status) {
                    const status = sessaoAtual.status.toLowerCase();
                    if (
                        status.includes("inclu√≠do") ||
                        status.includes("pautado")
                    ) {
                        corHeader = "#5C85B4"; // Azul padr√£o do Figma
                    } else if (status.includes("retirado")) {
                        corHeader = "#CE2D4F"; // Vermelho
                    } else if (status.includes("vista")) {
                        corHeader = "#FFBF46"; // Amarelo
                    } else if (status.includes("julgado")) {
                        corHeader = "#3AB795"; // Verde do Figma
                    } else if (status.includes("adiado")) {
                        corHeader = "#F55D3E"; // Laranja do Figma
                    } else if (status.includes("sobrestado")) {
                        corHeader = "#FCB0B3"; // Rosa do Figma
                    } else if (
                        status.includes("dilig√™ncia") ||
                        status.includes("diligencia")
                    ) {
                        corHeader = "#00171F"; // Preto oficial do Figma para Dilig√™ncia
                    }
                }
            }

            // üé® MATERIAL SYMBOLS TOOLTIP - Clean and professional com propor√ß√µes otimizadas
            let html = `
                <div style="
                    background: white;
                    border: 1px solid #e0e0e0;
                    border-radius: 12px;
                    width: 320px;
                    max-width: 90vw;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.08);
                    font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    overflow: hidden;
                    font-size: 14px;
                    line-height: 1.4;
                ">
                    <!-- Header com Material Symbols -->
                    <div style="
                        background: ${corHeader};
                        color: white;
                        padding: 16px 20px;
                        display: flex;
                        align-items: center;
                        gap: 12px;
                    ">
                        <span class="material-symbols-outlined" style="
                            font-size: 28px !important;
                            vertical-align: middle;
                            flex-shrink: 0;
                        ">event_repeat</span>
                        <div>
                            <div style="font-weight: 600; font-size: 16px; margin-bottom: 2px;">
                                Sess√µes de Julgamento
                            </div>
                            <div style="font-size: 13px; opacity: 0.9;">
                                ${sessoes.length} ${
                                    sessoes.length === 1
                                        ? "sess√£o encontrada"
                                        : "sess√µes encontradas"
                                }
                            </div>
                        </div>
                    </div>
                    
                    <!-- Conte√∫do das sess√µes -->
                    <div style="padding: 20px;">`;

            sessoes.forEach((sessao, index) => {
                const isAtual = index === 0 || sessao.isAtual;

                // Determinar cor baseada no status da sess√£o individual
                let corStatus = "#757575"; // Cinza padr√£o
                if (sessao.status) {
                    const status = sessao.status.toLowerCase();
                    if (
                        status.includes("inclu√≠do") ||
                        status.includes("pautado")
                    ) {
                        corStatus = "#007acc"; // Azul para atual
                    } else if (status.includes("retirado")) {
                        corStatus = "#CE2D4F"; // Vermelho
                    } else if (status.includes("vista")) {
                        corStatus = "#FFBF46"; // Amarelo
                    } else if (status.includes("julgado")) {
                        corStatus = "#10B981"; // Verde
                    } else if (status.includes("adiado")) {
                        corStatus = "#F59E0B"; // Laranja
                    } else if (status.includes("sobrestado")) {
                        corStatus = "#8B5CF6"; // Roxo
                    }
                }

                // Background e border tamb√©m usam a cor do status para sess√£o atual
                const backgroundCard = isAtual ? `${corStatus}15` : "#fafafa"; // 15 = ~8.5% opacity
                const borderCard = isAtual ? corStatus : "#e0e0e0";

                html += `
                    <div style="
                        background: ${backgroundCard};
                        border: 1px solid ${borderCard};
                        border-radius: 8px;
                        padding: 16px ${isAtual ? "50px" : "16px"} 16px 16px;
                        margin-bottom: ${
                            index < sessoes.length - 1 ? "12px" : "0"
                        };
                        position: relative;
                        transition: all 0.2s ease;
                        box-shadow: ${
                            isAtual
                                ? `0 4px 12px ${corStatus}20`
                                : "0 1px 3px rgba(0,0,0,0.08)"
                        };
                    ">
                        ${
                            isAtual
                                ? `
                        <div style="
                            position: absolute;
                            top: 8px;
                            right: 8px;
                            background: ${corStatus};
                            color: white;
                            padding: 3px 8px;
                            border-radius: 12px;
                            font-size: 9px;
                            font-weight: 600;
                            text-transform: uppercase;
                            letter-spacing: 0.5px;
                            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
                            z-index: 10;
                            min-width: 35px;
                            text-align: center;
                        ">ATUAL</div>
                        `
                                : ""
                        }
                        
                        <!-- Tipo de julgamento com Material Symbol -->
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 10px;
                            margin-bottom: 14px;
                        ">
                            <div style="
                                background: ${corStatus};
                                color: white;
                                padding: 6px 14px;
                                border-radius: 20px;
                                font-size: 11px;
                                font-weight: 600;
                                text-transform: uppercase;
                                letter-spacing: 0.5px;
                                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                                flex-shrink: 0;
                            ">
                                ${(() => {
                                    const tipoFinal =
                                        sessao.tipo || "Julgamento";
                                    console.log(
                                        `üéØ TOOLTIP HTML: Inserindo tipo na sess√£o ${
                                            index + 1
                                        }: "${tipoFinal}"`,
                                    );
                                    console.log(
                                        `üìã TOOLTIP HTML: Dados da sess√£o ${
                                            index + 1
                                        }:`,
                                        sessao,
                                    );
                                    return tipoFinal;
                                })()}
                            </div>
                        </div>
                        
                        <!-- Status e Data com √≠cone gavel -->
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 10px;
                            margin-bottom: 12px;
                            flex-wrap: wrap;
                            min-height: 24px;
                        ">
                            <span class="material-symbols-outlined" style="
                                font-size: 16px;
                                color: #64748B;
                                vertical-align: middle;
                                flex-shrink: 0;
                            ">gavel</span>
                            <div style="
                                color: ${corStatus};
                                font-weight: 600;
                                font-size: 14px;
                                line-height: 1.2;
                                flex-shrink: 1;
                                word-break: break-word;
                            ">${sessao.status}</div>
                            <div style="
                                background: ${corStatus}20;
                                color: ${corStatus};
                                padding: 4px 10px;
                                border-radius: 12px;
                                font-size: 12px;
                                font-weight: 500;
                                white-space: nowrap;
                                flex-shrink: 0;
                            ">
                                ${sessao.data}
                            </div>
                        </div>
                        
                        <!-- √ìrg√£o Julgador com √≠cone -->
                        <div style="
                            display: flex;
                            align-items: flex-start;
                            gap: 8px;
                            color: #64748B;
                            font-size: 12px;
                            margin-bottom: 8px;
                            line-height: 1.4;
                        ">
                            <span class="material-symbols-outlined" style="
                                font-size: 16px !important;
                                vertical-align: middle;
                                color: #64748B;
                                flex-shrink: 0;
                                margin-top: 1px;
                            ">account_balance</span>
                            <span style="
                                font-weight: 500;
                                word-break: break-word;
                            ">${
                                traduzirSiglaOrgao(sessao.orgao) ||
                                "√ìrg√£o n√£o identificado"
                            }</span>
                        </div>
                        
                        ${
                            sessao.dadosPauta
                                ? `
                        <!-- Modalidade da Sess√£o -->
                        <div style="
                            display: flex;
                            align-items: flex-start;
                            gap: 8px;
                            color: #64748B;
                            font-size: 12px;
                            margin-bottom: 8px;
                            line-height: 1.4;
                        ">
                            <span class="material-symbols-outlined" style="
                                font-size: 16px !important;
                                vertical-align: middle;
                                color: #64748B;
                                flex-shrink: 0;
                                margin-top: 1px;
                            ">${
                                sessao.dadosPauta.modalidade?.toLowerCase() ===
                                "virtual"
                                    ? "dvr"
                                    : "groups"
                            }</span>
                            <span style="
                                font-weight: 500;
                                word-break: break-word;
                            ">
                                ${
                                    sessao.dadosPauta.modalidade?.toLowerCase() ===
                                    "virtual"
                                        ? "Sess√£o Virtual"
                                        : "Sess√£o F√≠sica"
                                }
                            </span>
                        </div>
                        
                        <!-- Tipo de Inclus√£o + Sequencial -->
                        <div style="
                            display: flex;
                            align-items: flex-start;
                            gap: 8px;
                            color: #64748B;
                            font-size: 12px;
                            margin-bottom: 8px;
                            line-height: 1.4;
                        ">
                            <span class="material-symbols-outlined" style="
                                font-size: 16px !important;
                                vertical-align: middle;
                                color: #64748B;
                                flex-shrink: 0;
                                margin-top: 1px;
                            ">format_list_numbered</span>
                            <span style="
                                font-weight: 500;
                                word-break: break-word;
                            ">
                                ${
                                    sessao.dadosPauta.tipoInclusao ===
                                    "Inclu√≠do em mesa"
                                        ? "Mesa"
                                        : "Pauta"
                                } ${sessao.dadosPauta.sequencial}
                            </span>
                        </div>
                        `
                                : ""
                        }

                        ${
                            sessao.observacoes
                                ? `
                        <div style="
                            margin-top: 14px;
                            padding: 12px;
                            background: rgba(99, 102, 241, 0.06);
                            border-left: 3px solid #6366F1;
                            border-radius: 0 8px 8px 0;
                            font-size: 12px;
                            color: #4C4F69;
                            line-height: 1.5;
                        ">
                            <div style="display: flex; align-items: flex-start; gap: 8px;">
                                <span class="material-symbols-outlined" style="
                                    font-size: 16px;
                                    color: #6366F1;
                                    margin-top: 1px;
                                    flex-shrink: 0;
                                ">info</span>
                                <div>
                                    <strong>Observa√ß√µes:</strong> ${sessao.observacoes}
                                </div>
                            </div>
                        </div>
                        `
                                : ""
                        }
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;

            console.log("‚úÖ TOOLTIP HTML: HTML do tooltip criado com sucesso!");
            console.log(
                "üìè TOOLTIP HTML: Tamanho do HTML gerado:",
                html.length,
                "caracteres",
            );
            console.log("üéØ TOOLTIP HTML: Resumo do conte√∫do criado:");
            console.log(
                `   - ${sessoes.length} ${
                    sessoes.length === 1
                        ? "sess√£o processada"
                        : "sess√µes processadas"
                }`,
            );
            console.log(`   - Cor do header: ${corHeader}`);

            // Verificar se tipos foram inclu√≠dos no HTML
            const tiposIncluidos = sessoes.map((s) => s.tipo || "Julgamento");
            console.log(
                "üîç TOOLTIP HTML: Verificando inclus√£o dos tipos no HTML:",
            );
            tiposIncluidos.forEach((tipo, index) => {
                const incluido = html.includes(tipo);
                console.log(
                    `   ${index + 1}. "${tipo}": ${
                        incluido ? "‚úÖ Inclu√≠do" : "‚ùå N√£o encontrado"
                    }`,
                );
            });

            return html;
        }

        // ========================================
        // üîß FUN√á√ÉO √öNICA DE DIAGN√ìSTICO E CORRE√á√ÉO
        // ========================================

        /**
         * √öNICA fun√ß√£o de diagn√≥stico - substitui diagnosticarECorrigirTooltip e todas as outras
         */
        function diagnosticarSistemaCompleto() {
            console.log(
                "üîß DIAGN√ìSTICO COMPLETO: Verificando sistema unificado...",
            );

            // 1. Detectar sess√µes
            const dadosSessoes = detectarSessoesUnificado(true);

            // 2. Verificar card
            const card = document.getElementById("eprobe-data-sessao");

            // 3. Aplicar tooltip se card existir
            if (card && dadosSessoes) {
                aplicarTooltipUnificado(card, dadosSessoes.todasSessoes);
                console.log("‚úÖ DIAGN√ìSTICO: Sistema corrigido com sucesso");
                return true;
            } else {
                console.log(
                    "‚ùå DIAGN√ìSTICO: Card n√£o encontrado ou sem dados de sess√£o",
                );
                return false;
            }
        }

        // ============================================================================
        // üé® SISTEMA DE TEMAS INTEGRADO (ex-themeApply.js)
        // ============================================================================

        // Fun√ß√£o para controlar exibi√ß√£o da data da sess√£o
        function toggleSessionDateDisplay(isEnabled) {
            const sessionDateElement =
                document.getElementById("eprobe-data-sessao");

            if (sessionDateElement) {
                if (isEnabled) {
                    sessionDateElement.style.display = "flex";
                    log("‚úÖ Data da sess√£o exibida");
                } else {
                    sessionDateElement.style.display = "none";
                    logError("‚ùå Data da sess√£o ocultada");
                }
            } else {
                log("‚ÑπÔ∏è Elemento da data da sess√£o n√£o encontrado na p√°gina");
            }
        }

        // Fun√ß√£o para aplicar estilos do tema (definida globalmente)
        function applyThemeStyles(themeName) {
            log(`üé® Aplicando tema ${themeName}...`);

            // üö® VERIFICA√á√ÉO CR√çTICA: N√ÉO aplicar tema na tela de edi√ß√£o de minutas
            const currentUrl = window.location.href;
            if (currentUrl.includes("acao=minuta_editar")) {
                console.log(
                    "üö´ eProbe: Tema desabilitado na tela de edi√ß√£o de minutas",
                );
                return; // Sair imediatamente - n√£o aplicar tema
            }

            // üé® VERIFICA√á√ÉO: Se personaliza√ß√£o da navbar est√° desabilitada, n√£o aplicar
            if (!PERSONALIZACAO_NAVBAR_HABILITADA) {
                log(
                    "üö´ NAVBAR: Personaliza√ß√£o desabilitada - n√£o aplicando tema na navbar",
                );
                return;
            }

            // Salvar tema no localStorage
            localStorage.setItem("eprobe_selected_theme", themeName);

            // Definir gradientes dos temas
            const gradientes = {
                blue: "linear-gradient(to left, #0d1c2c, #007ebd)",
                dark: "linear-gradient(to left, #1a1a1a, #696363)",
                light: "linear-gradient(to left, #94A3B8, #475569)",
                violet: "linear-gradient(to left, #6b46c1, #4c1d95)",
                green: "linear-gradient(to left, #17a394, #0c4f5c)",
            };

            const gradiente = gradientes[themeName] || gradientes.blue;

            // Aplicar CSS imediatamente
            const cssNavbarTema = document.createElement("style");
            cssNavbarTema.id = "eprobe-navbar-instant-immediate";
            cssNavbarTema.textContent = `
                /* NAVBAR APLICADA IMEDIATAMENTE NO CARREGAMENTO DO SCRIPT */
                #navbar.navbar.bg-instancia,
                .navbar.bg-instancia,
                nav.navbar.bg-instancia,
                .navbar.text-white.bg-instancia,
                .navbar.text-white.d-xl-flex.bg-instancia {
                    background-image: ${gradiente} !important;
                    display: flex !important;
                    align-items: center !important;
                    min-height: 50px !important;
                    opacity: 1 !important;
                    visibility: visible !important;
                    transition: background-image 0.3s ease !important;
                }
                
                #navbar.navbar.bg-instancia > *,
                .navbar.bg-instancia > *,
                nav.navbar.bg-instancia > * {
                    display: flex !important; 
                    align-items: center !important;
                    min-height: 50px !important;
                }
                
                /* üéØ REGRA CR√çTICA OBRIGAT√ìRIA: .d-none.d-md-flex SEMPRE FLEX */
                .d-none.d-md-flex,
                div.d-none.d-md-flex,
                .navbar .d-none.d-md-flex,
                #navbar .d-none.d-md-flex {
                    display: flex !important;
                    align-items: center !important;
                }
            `;

            // Remover CSS anterior se existir
            const cssAnterior = document.getElementById(
                "eprobe-navbar-instant-immediate",
            );
            if (cssAnterior) {
                cssAnterior.remove();
            }

            // Aplicar novo CSS
            const head =
                document.head ||
                document.getElementsByTagName("head")[0] ||
                document.documentElement;
            if (head) {
                head.insertBefore(cssNavbarTema, head.firstChild);
                log(`üé® Tema ${themeName} aplicado com sucesso na navbar`);
            }

            // Disparar evento para notificar outros componentes
            window.dispatchEvent(
                new CustomEvent("eprobe-theme-changed", {
                    detail: { theme: themeName, gradient: gradiente },
                }),
            );
        }

        /**
         * üéØ FUN√á√ÉO PARA UNIFICAR ESTILOS DA NAVBAR
         * For√ßa a aplica√ß√£o dos estilos de navbar quando necess√°rio
         */
        function unificarNavbarStyles() {
            console.log("üîß NAVBAR: Unificando estilos da navbar...");

            try {
                // Obter tema atual
                const temaAtual =
                    localStorage.getItem("eprobe_selected_theme") || "blue";

                // Definir gradientes
                const gradientes = {
                    blue: "linear-gradient(to left, #0d1c2c, #007ebd)",
                    dark: "linear-gradient(to left, #1a1a1a, #696363)",
                    light: "linear-gradient(to left, #94A3B8, #475569)",
                    violet: "linear-gradient(to left, #6b46c1, #4c1d95)",
                    green: "linear-gradient(to left, #17a394, #0c4f5c)",
                };

                const gradiente = gradientes[temaAtual] || gradientes.blue;

                // Buscar elementos da navbar
                const navbarElements = document.querySelectorAll(
                    "#navbar.navbar.bg-instancia, .navbar.bg-instancia, nav.navbar.bg-instancia",
                );

                if (navbarElements.length > 0) {
                    navbarElements.forEach((navbar) => {
                        navbar.style.setProperty(
                            "background-image",
                            gradiente,
                            "important",
                        );
                        navbar.style.setProperty(
                            "display",
                            "flex",
                            "important",
                        );
                        navbar.style.setProperty(
                            "align-items",
                            "center",
                            "important",
                        );
                        navbar.style.setProperty(
                            "min-height",
                            "50px",
                            "important",
                        );
                    });

                    // For√ßar flexbox nos elementos .d-none.d-md-flex
                    const flexElements =
                        document.querySelectorAll(".d-none.d-md-flex");
                    flexElements.forEach((element) => {
                        element.style.setProperty(
                            "display",
                            "flex",
                            "important",
                        );
                        element.style.setProperty(
                            "align-items",
                            "center",
                            "important",
                        );
                    });

                    console.log(
                        `‚úÖ NAVBAR: Tema ${temaAtual} aplicado em ${navbarElements.length} elementos`,
                    );
                    return true;
                } else {
                    console.log(
                        "‚ö†Ô∏è NAVBAR: Nenhum elemento de navbar encontrado",
                    );
                    return false;
                }
            } catch (error) {
                console.error("‚ùå NAVBAR: Erro ao unificar estilos:", error);
                return false;
            }
        }

        /**
         * üé® ATIVAR PERSONALIZA√á√ÉO DA NAVBAR
         * Aplica os estilos personalizados da navbar
         */
        function ativarPersonalizacaoNavbar() {
            log("üé® NAVBAR: Ativando personaliza√ß√£o da navbar...");

            try {
                PERSONALIZACAO_NAVBAR_HABILITADA = true;

                // üíæ SINCRONIZAR COM LOCALSTORAGE para aplica√ß√£o instant√¢nea
                localStorage.setItem("eprobe_navbar_enabled", "true");

                // Verificar se n√£o estamos na tela de edi√ß√£o de minutas
                const currentUrl = window.location.href;
                if (currentUrl.includes("acao=minuta_editar")) {
                    log(
                        "üö´ NAVBAR: Personaliza√ß√£o desabilitada na tela de edi√ß√£o de minutas",
                    );
                    return false;
                }

                // Obter tema atual
                const temaAtual =
                    localStorage.getItem("eprobe_selected_theme") || "blue";

                // Aplicar tema usando a fun√ß√£o existente
                applyThemeStyles(temaAtual);

                // Garantir que a unifica√ß√£o seja aplicada
                setTimeout(() => {
                    unificarNavbarStyles();
                }, 100);

                log("‚úÖ NAVBAR: Personaliza√ß√£o ativada com sucesso");
                return true;
            } catch (error) {
                logError("‚ùå NAVBAR: Erro ao ativar personaliza√ß√£o:", error);
                return false;
            }
        }

        /**
         * üö´ DESATIVAR PERSONALIZA√á√ÉO DA NAVBAR
         * Remove os estilos personalizados da navbar
         */
        function desativarPersonalizacaoNavbar() {
            log("üö´ NAVBAR: Desativando personaliza√ß√£o da navbar...");

            try {
                PERSONALIZACAO_NAVBAR_HABILITADA = false;

                // üíæ SINCRONIZAR COM LOCALSTORAGE para aplica√ß√£o instant√¢nea
                localStorage.setItem("eprobe_navbar_enabled", "false");

                // Remover CSS personalizado da navbar
                const cssNavbar = document.getElementById(
                    "eprobe-navbar-instant-immediate",
                );
                if (cssNavbar) {
                    cssNavbar.remove();
                    log("üóëÔ∏è NAVBAR: CSS personalizado removido");
                }

                // Restaurar estilos originais da navbar
                const navbarElements = document.querySelectorAll(
                    "#navbar.navbar.bg-instancia, .navbar.bg-instancia, nav.navbar.bg-instancia",
                );

                navbarElements.forEach((navbar) => {
                    // Remover propriedades inline aplicadas
                    navbar.style.removeProperty("background-image");
                    navbar.style.removeProperty("background");

                    log(
                        `üîÑ NAVBAR: Estilos originais restaurados para elemento ${navbar.tagName}`,
                    );
                });

                // Restaurar elementos .d-none.d-md-flex ao estado original
                const flexElements =
                    document.querySelectorAll(".d-none.d-md-flex");
                flexElements.forEach((element) => {
                    // Manter display flex mas remover for√ßamento via style inline
                    if (element.style.display === "flex") {
                        element.style.removeProperty("display");
                    }
                });

                log("‚úÖ NAVBAR: Personaliza√ß√£o desativada com sucesso");

                // Disparar evento para notificar outros componentes
                window.dispatchEvent(
                    new CustomEvent("eprobe-navbar-customization-disabled", {
                        detail: { timestamp: Date.now() },
                    }),
                );

                return true;
            } catch (error) {
                logError("‚ùå NAVBAR: Erro ao desativar personaliza√ß√£o:", error);
                return false;
            }
        }

        /**
         * üîç VERIFICAR STATUS DA PERSONALIZA√á√ÉO DA NAVBAR
         * Retorna o estado atual da personaliza√ß√£o
         */
        function verificarStatusPersonalizacaoNavbar() {
            return {
                habilitada: PERSONALIZACAO_NAVBAR_HABILITADA,
                cssPresente: !!document.getElementById(
                    "eprobe-navbar-instant-immediate",
                ),
                temaAtual:
                    localStorage.getItem("eprobe_selected_theme") || "blue",
                elementosNavbar: document.querySelectorAll(
                    "#navbar.navbar.bg-instancia, .navbar.bg-instancia, nav.navbar.bg-instancia",
                ).length,
            };
        }

        /**
         * üöÄ INICIALIZAR CONFIGURA√á√ïES DE PERSONALIZA√á√ÉO
         * Carrega as configura√ß√µes salvas do chrome.storage e aplica
         */
        function inicializarConfiguracoesPersalizacao() {
            log("üöÄ PERSONALIZA√á√ÉO: Inicializando configura√ß√µes...");

            try {
                // Verificar se a API do Chrome est√° dispon√≠vel
                if (
                    typeof chrome !== "undefined" &&
                    chrome.storage &&
                    chrome.storage.sync
                ) {
                    // Carregar configura√ß√£o da navbar
                    chrome.storage.sync.get(
                        ["customize-navbar"],
                        function (result) {
                            const navbarEnabled =
                                result["customize-navbar"] !== false; // default true

                            log(
                                `üé® PERSONALIZA√á√ÉO: Estado inicial da navbar: ${navbarEnabled}`,
                            );

                            // üíæ SINCRONIZAR COM LOCALSTORAGE
                            localStorage.setItem(
                                "eprobe_navbar_enabled",
                                navbarEnabled.toString(),
                            );

                            if (navbarEnabled) {
                                // Ativar personaliza√ß√£o da navbar
                                setTimeout(() => {
                                    ativarPersonalizacaoNavbar();
                                }, 100);
                            } else {
                                // Desativar personaliza√ß√£o da navbar
                                PERSONALIZACAO_NAVBAR_HABILITADA = false;

                                // Remover CSS se j√° foi aplicado pela fun√ß√£o instant√¢nea
                                const cssExistente = document.getElementById(
                                    "eprobe-navbar-instant-immediate",
                                );
                                if (cssExistente) {
                                    cssExistente.remove();
                                    log(
                                        "üóëÔ∏è PERSONALIZA√á√ÉO: CSS instant√¢neo removido por configura√ß√£o",
                                    );
                                }

                                log(
                                    "üö´ PERSONALIZA√á√ÉO: Navbar desabilitada por configura√ß√£o",
                                );
                            }
                        },
                    );

                    // TODO: Carregar outras configura√ß√µes de personaliza√ß√£o quando implementadas
                    // chrome.storage.sync.get(["customize-icons"], ...);
                    // chrome.storage.sync.get(["customize-buttons"], ...);
                    // chrome.storage.sync.get(["customize-reminders"], ...);
                } else {
                    log(
                        "‚ö†Ô∏è PERSONALIZA√á√ÉO: API do Chrome n√£o dispon√≠vel - usando configura√ß√µes padr√£o",
                    );
                    // Usar configura√ß√µes padr√£o quando n√£o h√° acesso ao chrome.storage
                    PERSONALIZACAO_NAVBAR_HABILITADA = true;

                    setTimeout(() => {
                        ativarPersonalizacaoNavbar();
                    }, 100);
                }

                log(
                    "‚úÖ PERSONALIZA√á√ÉO: Configura√ß√µes inicializadas com sucesso",
                );
            } catch (error) {
                logError(
                    "‚ùå PERSONALIZA√á√ÉO: Erro ao inicializar configura√ß√µes:",
                    error,
                );

                // Fallback para configura√ß√µes padr√£o
                PERSONALIZACAO_NAVBAR_HABILITADA = true;
                setTimeout(() => {
                    ativarPersonalizacaoNavbar();
                }, 100);
            }
        }

        /**
         * üîç FUN√á√ÉO DE DEBUG PARA VERIFICAR CORES NA P√ÅGINA
         * Encontra elementos com cores espec√≠ficas para diagnosticar
         */
        function debugEncontrarCores() {
            console.log(
                "üîç DEBUG: Procurando elementos com cores espec√≠ficas...",
            );

            // Limitar escopo para area do processo (performance)
            const elementos = document.querySelectorAll(
                "#divInfraAreaProcesso *",
            );
            let elementosEncontrados = 0;
            let coresEncontradas = new Set();

            elementos.forEach((el) => {
                const style = window.getComputedStyle(el);
                const bgColor = style.backgroundColor;
                const bg = style.background;

                // Registrar todas as cores encontradas
                if (
                    bgColor &&
                    bgColor !== "rgba(0, 0, 0, 0)" &&
                    bgColor !== "transparent"
                ) {
                    coresEncontradas.add(bgColor);
                }

                // Procurar especificamente por nossa cor
                if (
                    bgColor.includes("235") &&
                    bgColor.includes("242") &&
                    bgColor.includes("223")
                ) {
                    elementosEncontrados++;

                    console.log(
                        `üéØ ELEMENTO ${elementosEncontrados} ENCONTRADO:`,
                        {
                            tag: el.tagName,
                            classe: el.className,
                            id: el.id,
                            backgroundColor: bgColor,
                            background: bg.substring(0, 100) + "...",
                            match: bgColor === "rgb(235, 242, 223)",
                        },
                    );
                }
            });

            console.log(`üìä RESUMO:`, {
                elementosComCorEspecifica: elementosEncontrados,
                totalCoresUnicas: coresEncontradas.size,
                amostrasCores: Array.from(coresEncontradas).slice(0, 10),
            });

            return {
                encontrados: elementosEncontrados,
                cores: Array.from(coresEncontradas),
            };
        }

        /**
         * üé® FUN√á√ÉO PARA CORRE√á√ÉO CONSERVADORA DE COR DE FUNDO
         * Altera APENAS background-color preservando background-image
         * Corrige elementos com rgb(235, 242, 223) para #C8E6C9
         */
        function corrigirCorDeFundoConservadora() {
            console.log("üé® CORRE√á√ÉO: Alterando cor de fundo dos elementos...");

            // Limitar escopo para area do processo (performance)
            const elementos = document.querySelectorAll(
                "#divInfraAreaProcesso *",
            );
            let elementosProcessados = 0;

            elementos.forEach((el) => {
                const style = window.getComputedStyle(el);
                const bgColor = style.backgroundColor;

                if (bgColor === "rgb(235, 242, 223)") {
                    elementosProcessados++;

                    console.log(`üì¶ ELEMENTO ${elementosProcessados}:`, {
                        tag: el.tagName,
                        classe: el.className,
                        corOriginal: bgColor,
                    });

                    try {
                        // Aplicar nova cor #C8E6C9
                        el.style.setProperty(
                            "background-color",
                            "#C8E6C9",
                            "important",
                        );

                        console.log(
                            `‚úÖ ELEMENTO ${elementosProcessados}: Cor alterada para #C8E6C9!`,
                        );
                    } catch (error) {
                        console.error(
                            `‚ùå ERRO no elemento ${elementosProcessados}:`,
                            error,
                        );
                    }
                }
            });

            console.log(`\nüìä RESUMO FINAL:`);
            console.log(`  ‚úÖ Elementos processados: ${elementosProcessados}`);
            console.log(`  üéØ Nova cor aplicada: #C8E6C9 (verde suave)`);

            return { processados: elementosProcessados };
        }

        // Fun√ß√£o para verificar e aplicar tema salvo - SIMPLIFICADA
        function loadAndApplyTheme() {
            // CSS instant√¢neo j√° cuida da aplica√ß√£o - apenas sincronizar storage
            try {
                const localTheme = localStorage.getItem(
                    "eprobe_selected_theme",
                );
                if (localTheme) {
                    log(
                        `‚ö° Tema local encontrado: ${localTheme} - CSS instant√¢neo j√° aplicado`,
                    );
                }
            } catch (e) {
                console.warn("‚ö†Ô∏è Erro ao acessar localStorage:", e);
            }

            // Sincronizar com chrome.storage sem reaplicar estilos
            if (typeof chrome !== "undefined" && chrome.storage) {
                chrome.storage.sync.get(["selectedTheme"], function (result) {
                    // Detectar tema padr√£o baseado no dom√≠nio
                    let temaDefault = "blue";
                    const currentUrl = window.location.href;

                    if (currentUrl.includes("eproc2g.tjsc.jus.br")) {
                        temaDefault = "green"; // Verde para eproc2g
                    } else if (currentUrl.includes("eproc1g.tjsc.jus.br")) {
                        temaDefault = "blue"; // Azul para eproc1g
                    }

                    const savedTheme = result.selectedTheme || temaDefault;
                    log(
                        `üíæ Tema determinado: ${savedTheme} (dom√≠nio padr√£o: ${temaDefault})`,
                    );

                    // Salvar no localStorage para pr√≥xima vez (CSS instant√¢neo usar√° isso)
                    try {
                        localStorage.setItem(
                            "eprobe_selected_theme",
                            savedTheme,
                        );
                        log(`‚úÖ Tema ${savedTheme} salvo no localStorage`);
                    } catch (e) {
                        console.warn("‚ö†Ô∏è Erro ao salvar no localStorage:", e);
                    }
                });
            } else {
                // Fallback: garantir tema baseado no dom√≠nio no localStorage
                const currentUrl = window.location.href;
                let temaDefault = "blue";

                if (currentUrl.includes("eproc2g.tjsc.jus.br")) {
                    temaDefault = "green"; // Verde para eproc2g
                } else if (currentUrl.includes("eproc1g.tjsc.jus.br")) {
                    temaDefault = "blue"; // Azul para eproc1g
                }

                log(
                    `üîÑ Chrome storage n√£o dispon√≠vel, garantindo tema ${temaDefault}`,
                );
                try {
                    localStorage.setItem("eprobe_selected_theme", temaDefault);
                } catch (e) {
                    console.warn("‚ö†Ô∏è Erro ao definir tema fallback:", e);
                }
            }
        }

        // Verifica configura√ß√£o inicial da data da sess√£o - OTIMIZADA
        if (typeof chrome !== "undefined" && chrome.storage) {
            chrome.storage.sync.get(
                ["highlightSessionDate"],
                function (result) {
                    const isEnabled = result.highlightSessionDate !== false; // default true
                    log(
                        `üíæ Configura√ß√£o inicial do destaque da data da sess√£o: ${
                            isEnabled ? "ATIVO" : "INATIVO"
                        }`,
                    );

                    // Aplica a configura√ß√£o imediatamente se o elemento j√° existir
                    toggleSessionDateDisplay(isEnabled);
                },
            );
        }

        // Escuta mudan√ßas no storage para sincronizar temas em tempo real
        if (typeof chrome !== "undefined" && chrome.storage) {
            chrome.storage.onChanged.addListener(function (changes, area) {
                log(
                    "üîÑ STORAGE: Mudan√ßa detectada no storage:",
                    changes,
                    "√°rea:",
                    area,
                );
                if (area === "sync") {
                    // Mudan√ßa de tema - apenas sincronizar localStorage
                    if (changes.selectedTheme) {
                        const newTheme = changes.selectedTheme.newValue;
                        log(
                            `üîÑ Tema alterado para: ${newTheme} - sincronizando localStorage`,
                        );
                        try {
                            localStorage.setItem(
                                "eprobe_selected_theme",
                                newTheme,
                            );
                            // CSS instant√¢neo detectar√° mudan√ßa via listener storage
                            log(
                                `‚úÖ Tema ${newTheme} sincronizado - CSS instant√¢neo aplicar√° automaticamente`,
                            );
                        } catch (e) {
                            console.warn("‚ö†Ô∏è Erro ao sincronizar tema:", e);
                        }
                    }

                    // Mudan√ßa no destaque da data da sess√£o
                    if (changes.highlightSessionDate) {
                        const isEnabled = changes.highlightSessionDate.newValue;
                        log(
                            `üîÑ Destaque da data da sess√£o alterado para: ${
                                isEnabled ? "ATIVO" : "INATIVO"
                            }`,
                        );
                        toggleSessionDateDisplay(isEnabled);
                    }
                }
            });
            log("‚úÖ STORAGE: Listener de mudan√ßas registrado");
        }

        // Aplica tema IMEDIATAMENTE para evitar delay visual
        logCritical("üé® eProbe Theme Script carregado");
        loadAndApplyTheme();

        // Exposi√ß√£o das fun√ß√µes globais para chamada direta (debugging)
        window.applyThemeStyles = applyThemeStyles;
        window.unificarNavbarStyles = unificarNavbarStyles;
        window.testVioletTheme = function () {
            log("üß™ TESTE: Aplicando tema violeta diretamente...");
            applyThemeStyles("violet");
        };
        log("üåê GLOBAL: Fun√ß√µes de tema expostas globalmente");
        log(
            "üß™ TESTE: Use window.testVioletTheme() para testar o tema violeta",
        );

        // ============================================================================
        // üé® FIM DO SISTEMA DE TEMAS INTEGRADO
        // ============================================================================

        // ============================================================================
        // üß† SEMANTIC KERNEL INTEGRADO (ex-semanticKernel.js)
        // ============================================================================

        /**
         * eProbe Semantic Kernel - M√≥dulo Experimental
         * Implementa√ß√£o controlada para testes iniciais
         * Foco: Detec√ß√£o inteligente de datas de sess√£o
         */

        // üß† CONFIGURA√á√ÉO EXPERIMENTAL DO SEMANTIC KERNEL
        class eProbeSemanticKernel {
            constructor() {
                this.isEnabled = false;
                this.testMode = true;
                this.fallbackToRegex = true;
                this.apiKey = null;
                this.requestCount = 0;
                this.maxRequests = 5; // Limite para testes

                log(
                    "üß† SEMANTIC KERNEL: M√≥dulo inicializado em modo experimental",
                );
            }

            // üîß CONFIGURA√á√ÉO E INICIALIZA√á√ÉO
            async initialize() {
                log("üß† SEMANTIC KERNEL: Tentando inicializar...");

                try {
                    // Verificar se h√° API key configurada
                    this.apiKey = await this.getApiKey();
                    if (!this.apiKey) {
                        log(
                            "‚ö†Ô∏è SEMANTIC KERNEL: API Key n√£o encontrada - usando modo fallback",
                        );
                        return false;
                    }

                    this.isEnabled = true;
                    logCritical("‚úÖ SEMANTIC KERNEL: Inicializado com sucesso");
                    return true;
                } catch (error) {
                    console.error(
                        "‚ùå SEMANTIC KERNEL: Erro na inicializa√ß√£o:",
                        error,
                    );
                    return false;
                }
            }

            async getApiKey() {
                // Reutilizar a mesma API key do eProbe
                if (typeof window.SENT1_AUTO?.getStoredApiKey === "function") {
                    return await window.SENT1_AUTO.getStoredApiKey();
                }
                return null;
            }

            // üéØ FUN√á√ÉO PRINCIPAL: Detec√ß√£o Inteligente de Datas
            async detectarDataSessaoIA(textoCompleto) {
                if (!this.isEnabled || this.requestCount >= this.maxRequests) {
                    log(
                        "üß† SEMANTIC KERNEL: Usando fallback (regex tradicional)",
                    );
                    return await this.fallbackDetection(textoCompleto);
                }

                log(
                    "üß† SEMANTIC KERNEL: Iniciando detec√ß√£o inteligente de data da sess√£o",
                );
                this.requestCount++;

                try {
                    const prompt =
                        this.createDateDetectionPrompt(textoCompleto);
                    const response = await this.callOpenAI(prompt);
                    const resultado = this.parseResponse(response);

                    if (resultado && resultado.dataEncontrada) {
                        log(
                            `‚úÖ SEMANTIC KERNEL: Data detectada via IA: ${resultado.dataEncontrada}`,
                        );
                        return {
                            dataEncontrada: resultado.dataEncontrada,
                            confianca: resultado.confianca || 0.8,
                            contexto: resultado.contexto || "",
                            metodo: "semantic-kernel",
                        };
                    } else {
                        log(
                            "‚ö†Ô∏è SEMANTIC KERNEL: IA n√£o encontrou data, usando fallback",
                        );
                        return await this.fallbackDetection(textoCompleto);
                    }
                } catch (error) {
                    console.error(
                        "‚ùå SEMANTIC KERNEL: Erro na detec√ß√£o IA:",
                        error,
                    );
                    return await this.fallbackDetection(textoCompleto);
                }
            }

            // üìù CRIA√á√ÉO DO PROMPT ESPECIALIZADO
            createDateDetectionPrompt(textoCompleto) {
                // Limitar o texto para evitar custos excessivos
                const textoLimitado = textoCompleto.substring(0, 2000);

                return `Voc√™ √© um especialista em documentos jur√≠dicos brasileiros do sistema eProc/TJSC.

    TAREFA: Encontrar a data da sess√£o de julgamento no texto fornecido.

    CONTEXTO: O texto vem de uma p√°gina do eProc que pode conter informa√ß√µes sobre quando um processo foi pautado para julgamento.

    PADR√ïES T√çPICOS A PROCURAR:
    - "Data da sess√£o: DD/MM/AAAA"
    - "Sess√£o de julgamento em DD/MM/AAAA"
    - "Julgamento para DD/MM/AAAA"
    - "Pautado em DD/MM/AAAA"
    - "Agendado para DD/MM/AAAA"

    FORMATO DE RESPOSTA OBRIGAT√ìRIO (JSON):
    {
    "dataEncontrada": "DD/MM/AAAA ou null",
    "confianca": 0.0-1.0,
    "contexto": "texto ao redor da data encontrada",
    "explicacao": "por que esta data foi escolhida"
    }

    REGRAS:
    1. Apenas datas no formato brasileiro DD/MM/AAAA
    2. Apenas datas entre 2020 e 2030
    3. Se n√£o encontrar com certeza, retorne dataEncontrada: null
    4. Priorize datas relacionadas a sess√µes/julgamentos
    5. Ignore datas de protocolo, autua√ß√£o ou outras n√£o relacionadas a julgamento

    TEXTO PARA AN√ÅLISE:
    ${textoLimitado}

    RESPOSTA (apenas JSON v√°lido):`;
            }

            // üîó CHAMADA PARA OPENAI API
            async callOpenAI(prompt) {
                const response = await fetch(
                    "https://api.openai.com/v1/chat/completions",
                    {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            Authorization: `Bearer ${this.apiKey}`,
                        },
                        body: JSON.stringify({
                            model: "gpt-3.5-turbo",
                            messages: [
                                {
                                    role: "user",
                                    content: prompt,
                                },
                            ],
                            max_tokens: 200,
                            temperature: 0.1, // Baixa temperatura para respostas mais consistentes
                            response_format: { type: "json_object" },
                        }),
                    },
                );

                if (!response.ok) {
                    throw new Error(
                        `API Error: ${response.status} ${response.statusText}`,
                    );
                }

                const data = await response.json();
                return data.choices[0].message.content;
            }

            // üìä PARSE DA RESPOSTA DA IA
            parseResponse(responseText) {
                try {
                    const response = JSON.parse(responseText);

                    // Validar estrutura da resposta
                    if (typeof response === "object" && response !== null) {
                        return {
                            dataEncontrada: response.dataEncontrada || null,
                            confianca: parseFloat(response.confianca) || 0.5,
                            contexto: response.contexto || "",
                            explicacao: response.explicacao || "",
                        };
                    }

                    return null;
                } catch (error) {
                    console.error(
                        "‚ùå SEMANTIC KERNEL: Erro ao fazer parse da resposta:",
                        error,
                    );
                    return null;
                }
            }

            // üîÑ FALLBACK PARA REGEX TRADICIONAL
            async fallbackDetection(textoCompleto) {
                log(
                    "üîÑ SEMANTIC KERNEL: Executando detec√ß√£o via regex (fallback)",
                );

                // Usar os mesmos padr√µes do sistema atual
                const padroes = [
                    /(?:data\s*da\s*sess[a√£]o|sess[a√£]o\s*(?:de|em|para|:)?)\s*:?\s*(\d{1,2}\/\d{1,2}\/\d{4})/i,
                    /(?:julgamento\s*(?:em|para|:)|para\s*julgamento)\s*:?\s*(\d{1,2}\/\d{1,2}\/\d{4})/i,
                    /(?:pautado|agendar|agendado|marcado).*?(\d{1,2}\/\d{1,2}\/\d{4})/i,
                ];

                for (const padrao of padroes) {
                    const match = textoCompleto.match(padrao);
                    if (match) {
                        return {
                            dataEncontrada: match[1],
                            confianca: 0.7,
                            contexto: match[0],
                            metodo: "regex-fallback",
                        };
                    }
                }

                return null;
            }

            // üìà FUN√á√ïES DE MONITORAMENTO E DEBUG
            getStats() {
                return {
                    enabled: this.isEnabled,
                    requestCount: this.requestCount,
                    maxRequests: this.maxRequests,
                    requestsRemaining: this.maxRequests - this.requestCount,
                    testMode: this.testMode,
                    fallbackEnabled: this.fallbackToRegex,
                };
            }

            reset() {
                this.requestCount = 0;
                log("üîÑ SEMANTIC KERNEL: Contador de requisi√ß√µes resetado");
            }

            disable() {
                this.isEnabled = false;
                log("üö´ SEMANTIC KERNEL: Desabilitado");
            }

            enable() {
                this.isEnabled = true;
                log("‚úÖ SEMANTIC KERNEL: Habilitado");
            }
        }

        // üåç INST√ÇNCIA GLOBAL DO SEMANTIC KERNEL
        window.eProbeSemanticKernel = new eProbeSemanticKernel();

        // üîó INTEGRA√á√ÉO COM O SISTEMA EXISTENTE
        // Fun√ß√£o melhorada que usa IA + fallback
        async function detectarDataSessaoComIA() {
            log("üß† INICIANDO: Detec√ß√£o de data da sess√£o com IA");

            const sk = window.eProbeSemanticKernel;

            // Verificar se o Semantic Kernel est√° dispon√≠vel
            if (!sk.isEnabled) {
                await sk.initialize();
            }

            // Obter texto da p√°gina
            const textoCompleto = document.body.innerText;

            try {
                // Tentar detec√ß√£o com IA
                const resultado = await sk.detectarDataSessaoIA(textoCompleto);

                if (resultado && resultado.dataEncontrada) {
                    // Validar a data usando a fun√ß√£o existente
                    if (
                        typeof window.SENT1_AUTO?.validarDataBrasileira ===
                        "function"
                    ) {
                        const dataValidada =
                            window.SENT1_AUTO.validarDataBrasileira(
                                resultado.dataEncontrada,
                            );

                        if (dataValidada) {
                            log(
                                `‚úÖ IA + VALIDA√á√ÉO: Data validada: ${dataValidada.dataFormatada}`,
                            );
                            log(
                                `üìä IA: M√©todo: ${resultado.metodo}, Confian√ßa: ${resultado.confianca}`,
                            );

                            return {
                                ...dataValidada,
                                metodoDeteccao: resultado.metodo,
                                confiancaIA: resultado.confianca,
                                contexto: resultado.contexto,
                            };
                        }
                    }
                }

                log(
                    "‚ö†Ô∏è IA: N√£o encontrou data v√°lida, usando sistema original",
                );
                return null;
            } catch (error) {
                console.error("‚ùå IA: Erro na detec√ß√£o:", error);
                return null;
            }
        }

        // ============================================================================
        // üß† FIM DO SEMANTIC KERNEL INTEGRADO
        // ============================================================================

        log("üöÄ INIT: Iniciando eProbe ap√≥s APIs ficarem prontas...");

        // üåê VARI√ÅVEIS GLOBAIS PARA DADOS DE SESS√ÉO - DECLARADAS NO TOPO
        var TipoJulgamentoProcessoPautado = null;
        var StatusJulgamento = null;
        var DataSessao = null;

        // Armazenar a data da sess√£o quando detectada
        let dataSessaoPautado = null;

        // Vari√°vel para armazenar qual processo tem a data da sess√£o detectada
        let processoComDataSessao = null;

        // Armazenar dados completos da sess√£o obtidos do cruzamento
        let dadosCompletosSessionJulgamento = null;

        // üé® CONTROLE DE ESTADO DOS CARDS MATERIAL DESIGN
        let materialDesignState = {
            cardAtivo: false,
            ultimaDeteccao: null,
            ultimoProcesso: null,
        };

        // üõ°Ô∏è CONTROLE DE REQUISI√á√ïES - Prevenir spam e logout
        let tentativasCruzamento = 0;
        let ultimaTentativaCruzamento = 0;
        let cruzamentoEmAndamento = false;
        let cacheResultadoSessoes = null;
        let cacheValidoAte = 0;

        // üîê CONTROLE √öNICO POR PROCESSO - Garantir apenas uma busca por processo
        let processosJaProcessados = new Set(); // Armazenar n√∫meros de processos j√° processados

        // üìä DECLARA√á√ïES ANTECIPADAS DE FUN√á√ïES ESSENCIAIS
        let obterNumeroProcesso,
            hasDataSessaoPautado,
            getDataSessaoPautado,
            resetDataSessaoPautado,
            resetControlesRequisicao;
        let inserirDataSessaoNaInterface,
            processoJaFoiProcessado,
            marcarProcessoComoProcessado;

        // üîß IMPLEMENTA√á√ÉO ANTECIPADA DAS FUN√á√ïES ESSENCIAIS
        obterNumeroProcesso = function () {
            try {
                // Estrat√©gias m√∫ltiplas para obter n√∫mero do processo
                const strategies = [
                    // 1. Meta tag espec√≠fica do eProc
                    () => {
                        const meta = document.querySelector(
                            'meta[name="NG_PROCESSO"]',
                        );
                        return meta ? meta.getAttribute("content") : null;
                    },
                    // 2. URL parameter
                    () => {
                        const params = new URLSearchParams(
                            window.location.search,
                        );
                        return params.get("num_processo");
                    },
                    // 2b. Extrair do dadosIconLink (base64)
                    () => {
                        try {
                            const params = new URLSearchParams(
                                window.location.search,
                            );
                            const dadosIconLink = params.get("dadosIconLink");
                            if (dadosIconLink) {
                                const decoded = atob(dadosIconLink);
                                const match = decoded.match(
                                    /numProcesso";s:\d+:"(\d{20})"/,
                                );
                                if (match) {
                                    // Converter para formato com separadores
                                    const num = match[1];
                                    return `${num.slice(0, 7)}-${num.slice(
                                        7,
                                        9,
                                    )}.${num.slice(9, 13)}.${num.slice(
                                        13,
                                        14,
                                    )}.${num.slice(14, 16)}.${num.slice(
                                        16,
                                        20,
                                    )}`;
                                }
                            }
                            return null;
                        } catch (error) {
                            console.error(
                                "‚ùå Erro ao decodificar dadosIconLink:",
                                error,
                            );
                            return null;
                        }
                    },
                    // 3. T√≠tulo da p√°gina
                    () => {
                        const match = document.title.match(
                            /(\d{7}-\d{2}\.\d{4}\.\d{1}\.\d{2}\.\d{4})/,
                        );
                        return match ? match[1] : null;
                    },
                    // 4. Breadcrumb ou elementos de navega√ß√£o
                    () => {
                        const breadcrumbs = document.querySelectorAll(
                            ".infraLocalizador, .breadcrumb",
                        );
                        for (const bc of breadcrumbs) {
                            const match = bc.textContent.match(
                                /(\d{7}-\d{2}\.\d{4}\.\d{1}\.\d{2}\.\d{4})/,
                            );
                            if (match) return match[1];
                        }
                        return null;
                    },
                ];

                for (const strategy of strategies) {
                    const result = strategy();
                    if (result) {
                        log(`‚úÖ PROCESSO: Encontrado: ${result}`);
                        return result;
                    }
                }

                logError("‚ö†Ô∏è PROCESSO: N√∫mero n√£o encontrado");
                return null;
            } catch (error) {
                console.error("‚ùå PROCESSO: Erro ao obter n√∫mero:", error);
                return null;
            }
        };

        hasDataSessaoPautado = function () {
            return (
                dataSessaoPautado !== null &&
                dataSessaoPautado !== undefined &&
                typeof dataSessaoPautado === "object" &&
                dataSessaoPautado.data && // Verificar se tem a propriedade data
                processoComDataSessao === obterNumeroProcesso()
            );
        };

        getDataSessaoPautado = function () {
            return hasDataSessaoPautado() ? dataSessaoPautado : null;
        };

        resetDataSessaoPautado = function () {
            dataSessaoPautado = null;
            processoComDataSessao = null;
            log("üîÑ RESET: Dados de sess√£o resetados");
            return true;
        };

        resetControlesRequisicao = function () {
            tentativasCruzamento = 0;
            ultimaTentativaCruzamento = 0;
            cruzamentoEmAndamento = false;
            log("üîÑ RESET: Controles de requisi√ß√£o resetados");
            return true;
        };

        inserirDataSessaoNaInterface = function () {
            try {
                log("üéØ INTERFACE: Iniciando inser√ß√£o de card de sess√£o...");
                logCritical(
                    "üö® INTERFACE: IN√çCIO - inserirDataSessaoNaInterface()",
                );

                // Remover cards existentes
                const cardsExistentes = [
                    document.getElementById("eprobe-data-sessao"),
                    document.getElementById("eprobe-card-sessao-material"),
                ];

                cardsExistentes.forEach((card) => {
                    if (card) {
                        card.remove();
                        log("üóëÔ∏è INTERFACE: Card anterior removido");
                    }
                });

                // Verificar se temos dados
                if (!hasDataSessaoPautado()) {
                    logError("‚ö†Ô∏è INTERFACE: Sem dados de sess√£o dispon√≠veis");

                    // Tentar detectar dados primeiro
                    log("  INTERFACE: Tentando detectar dados de sess√£o...");
                    const dadosDetectados =
                        typeof window.SENT1_AUTO !== "undefined" &&
                        typeof window.SENT1_AUTO.detectarSessoesUnificado ===
                            "function"
                            ? window.SENT1_AUTO.detectarSessoesUnificado()
                            : null;

                    if (!dadosDetectados) {
                        logError(
                            "‚ùå INTERFACE: N√£o foi poss√≠vel detectar dados de sess√£o",
                        );
                        return false;
                    }

                    log(
                        "‚úÖ INTERFACE: Dados detectados durante inser√ß√£o:",
                        dadosDetectados,
                    );
                }

                const dados = getDataSessaoPautado();
                log("üìä INTERFACE: Dados para cria√ß√£o do card:", dados);

                // Preparar dados para o card Material
                const cardInfo = {
                    data:
                        dados?.data ||
                        dados?.dataFormatada ||
                        "Data n√£o dispon√≠vel",
                    status: dados?.status || "PAUTADO",
                    orgao:
                        traduzirSiglaOrgao(dados?.orgao) ||
                        "√ìrg√£o n√£o informado",
                    tipo: dados?.tipo || "Tipo n√£o informado",
                    totalSessoes: dados?.totalSessoes || 1,
                    sessoes: dados?.sessoes || [],
                };

                log(
                    "üé® INTERFACE: Chamando criarCardSessaoMaterial com:",
                    cardInfo,
                );

                // Usar a fun√ß√£o Material Design
                const cardCriado = criarCardSessaoMaterial(cardInfo);

                if (cardCriado !== null) {
                    log(
                        "‚úÖ INTERFACE: Card Material Design criado com sucesso!",
                    );

                    // Verificar se o card foi inserido no DOM
                    setTimeout(() => {
                        const cardNoDOM = document.getElementById(
                            "eprobe-card-sessao-material",
                        );
                        if (cardNoDOM) {
                            logCritical(
                                "‚úÖ VERIFICA√á√ÉO: Card encontrado no DOM!",
                            );
                        } else {
                            logError(
                                "‚ùå VERIFICA√á√ÉO: Card N√ÉO encontrado no DOM!",
                            );
                        }
                    }, 100);

                    return true;
                } else {
                    logError(
                        "‚ùå INTERFACE: Falha ao criar card Material Design",
                    );
                    return false;
                }
            } catch (error) {
                console.error("‚ùå INTERFACE: Erro ao inserir card:", error);
                return false;
            }
        };

        // FUNCAO DE INSERCAO DE CARD - abordagem conservadora (nao move elementos do DOM original)
        function inserirCardNaInterface(card) {
            try {
                logCritical(
                    "üéØ INSER√á√ÉO: Procurando local para inserir card...",
                );

                // Buscar local de inser√ß√£o no eProc - txtMagistrado
                const txtMagistrado = document.getElementById("txtMagistrado");
                if (txtMagistrado) {
                    logCritical(
                        "üéØ INSER√á√ÉO: txtMagistrado encontrado, posicionando ao lado direito...",
                    );

                    // Obter o container pai para posicionamento (abordagem conservadora)
                    const parentContainer = txtMagistrado.parentNode;
                    if (parentContainer) {
                        // Aplicar flex no container pai SEM mover elementos
                        parentContainer.style.setProperty(
                            "display",
                            "flex",
                            "important",
                        );
                        parentContainer.style.setProperty(
                            "align-items",
                            "center",
                            "important",
                        );
                        parentContainer.style.setProperty(
                            "gap",
                            "12px",
                            "important",
                        );
                        parentContainer.style.setProperty(
                            "flex-wrap",
                            "wrap",
                            "important",
                        );

                        // Configurar o card para posicionamento
                        card.style.cssText += `
                            margin-left: auto !important;
                            flex-shrink: 0 !important;
                            position: static !important;
                        `;

                        // Inserir o card DEPOIS do txtMagistrado (lado direito)
                        txtMagistrado.parentNode.insertBefore(
                            card,
                            txtMagistrado.nextSibling,
                        );

                        logCritical(
                            "‚úÖ INSER√á√ÉO: Card posicionado ao lado direito do txtMagistrado",
                        );
                        return true;
                    }
                }

                // Fallback: inserir pr√≥ximo ao t√≠tulo
                const titulo = document.querySelector(
                    "h1, .infraTituloAutor, .infraAreaDados h2",
                );
                if (titulo) {
                    titulo.parentNode.insertBefore(card, titulo.nextSibling);
                    logCritical("‚úÖ INSER√á√ÉO: Card inserido pr√≥ximo ao t√≠tulo");
                    return true;
                }

                // Fallback final: inserir no in√≠cio do conte√∫do principal
                const main = document.querySelector(
                    "#divInfraAreaGlobal, #conteudo, main, body",
                );
                if (main) {
                    main.insertBefore(card, main.firstChild);
                    logCritical(
                        "‚úÖ INSER√á√ÉO: Card inserido no conte√∫do principal",
                    );
                    return true;
                }

                logError("‚ùå INSER√á√ÉO: Nenhum local de inser√ß√£o encontrado");
                return false;
            } catch (error) {
                console.error("‚ùå Erro ao inserir card na interface:", error);
                return false;
            }
        }

        // üß™ TESTE CR√çTICO PARA DETEC√á√ÉO DIN√ÇMICA DE FIELDSET
        function testarDeteccaoDinamicaFieldset() {
            logCritical(
                "üß™ TESTE CR√çTICO: Iniciando teste de detec√ß√£o din√¢mica de fieldset...",
            );

            // Testar detec√ß√£o em detectarCardSessaoSimplificado
            try {
                logCritical("TESTANDO: detectarSessoesUnificado...");
                const resultado1 =
                    typeof window.SENT1_AUTO !== "undefined" &&
                    typeof window.SENT1_AUTO.detectarSessoesUnificado ===
                        "function"
                        ? window.SENT1_AUTO.detectarSessoesUnificado()
                        : null;
                logCritical(
                    `üìä RESULTADO Card Sess√£o: ${JSON.stringify(resultado1)}`,
                );
            } catch (error) {
                logCritical(
                    `‚ùå ERRO em detectarCardSessaoSimplificado: ${error.message}`,
                );
            }

            // Testar detec√ß√£o em extrairLinkSessao
            try {
                logCritical("üîç TESTANDO: extrairLinkSessao...");
                const resultado2 = extrairLinkSessao(1);
                logCritical(`üìä RESULTADO Link Sess√£o: ${resultado2}`);
            } catch (error) {
                logCritical(`‚ùå ERRO em extrairLinkSessao: ${error.message}`);
            }

            // üö® REMOVIDO: Chamada duplicada desnecess√°ria de detectarSessoesUnificado()
            // Esta fun√ß√£o j√° √© chamada automaticamente pela detec√ß√£o unificada

            logCritical(
                "‚úÖ TESTE CR√çTICO: Detec√ß√£o din√¢mica de fieldset conclu√≠da!",
            );
        }

        // FUNCAO: CARD CLICAVEL - ABRE SESSAO DE JULGAMENTO COM 1 CLIQUE
        // Usa fetch silencioso para obter o link da sessao mais recente
        function tornarCardSessaoClicavel() {
            var card = document.getElementById("eprobe-card-sessao-material");
            if (!card) {
                log("CARD CLICAVEL: Card nao encontrado no DOM");
                return false;
            }

            // Evitar duplicacao
            if (card.dataset.eprobeClickable === "true") {
                log("CARD CLICAVEL: Card ja esta clicavel");
                return true;
            }

            // ESTRATEGIA: Extrair a URL completa do onclick do SVG/elemento
            // que ja existe no DOM com o hash correto para julgamento_historico_listar
            // (cada acao no eProc tem seu proprio hash - nao podemos reusar o da URL)
            var urlHistorico = null;
            var elementosOnclick = document.querySelectorAll(
                '[onclick*="julgamento_historico_listar"]',
            );
            for (var idx = 0; idx < elementosOnclick.length; idx++) {
                var onclickStr =
                    elementosOnclick[idx].getAttribute("onclick") || "";
                var urlMatch = onclickStr.match(
                    /exibirSubFrm\s*\(\s*'([^']+julgamento_historico_listar[^']*)'/,
                );
                if (urlMatch && urlMatch[1]) {
                    urlHistorico = urlMatch[1];
                    urlHistorico = urlHistorico.replace(/&amp;/g, "&");
                    logCritical(
                        "CARD CLICAVEL: URL do historico extraida do onclick do DOM",
                    );
                    break;
                }
            }

            if (!urlHistorico) {
                log(
                    "CARD CLICAVEL: Nenhum onclick com julgamento_historico_listar encontrado no DOM",
                );
                return false;
            }

            // Extrair id_julgamento da URL para registro
            var idJulgMatch = urlHistorico.match(/id_julgamento=(\d+)/);
            var idJulgamento = idJulgMatch ? idJulgMatch[1] : "desconhecido";

            // Aplicar cursor e estilo clicavel
            card.style.cursor = "pointer";
            card.dataset.eprobeClickable = "true";
            card.dataset.eprobeIdJulgamento = idJulgamento;
            card.title = "Clique para abrir a sessao de julgamento";

            // Evento de clique - injeta script no contexto MAIN da pagina
            // (necessario porque main.js roda no mundo ISOLATED e exibirSubFrm
            // so existe no mundo MAIN)
            card.addEventListener("click", function cardClickHandler(e) {
                // Nao interceptar cliques em links/botoes internos
                if (e.target.closest && e.target.closest("a, button")) {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();

                logCritical(
                    "CARD CLICAVEL: Clique detectado - disparando evento para MAIN world",
                );

                // Disparar CustomEvent para debug-bridge.js (mundo MAIN)
                // que ira chamar exibirSubFrm e navegar para a sessao
                document.dispatchEvent(
                    new CustomEvent("eprobe-abrir-sessao-julgamento", {
                        detail: { url: urlHistorico },
                    }),
                );
            });

            // Feedback visual no hover (passivo para performance)
            card.addEventListener(
                "mouseenter",
                function () {
                    card.style.transform = "translateY(-1px)";
                    card.style.transition =
                        "transform 0.15s ease, box-shadow 0.15s ease";
                },
                { passive: true },
            );

            card.addEventListener(
                "mouseleave",
                function () {
                    card.style.transform = "";
                },
                { passive: true },
            );

            logCritical(
                "CARD CLICAVEL: Card tornado clicavel (id_julgamento: " +
                    idJulgamento +
                    ")",
            );
            return true;
        }

        // üé® FUN√á√ÉO PARA CRIAR CARD MATERIAL DE SESS√ÉO - DESIGN FIGMA
        function criarCardSessaoMaterial(cardInfo) {
            try {
                // üö® LOG CR√çTICO: In√≠cio da cria√ß√£o do card
                logCritical(
                    "üö® CARD MATERIAL: Iniciando criarCardSessaoMaterial()",
                );
                logCritical(
                    `üïê TIMESTAMP: ${new Date().toLocaleString("pt-BR")}`,
                );
                logCritical("üìä DADOS RECEBIDOS:", cardInfo);
                logCritical(`üîç PROCESSO: ${obterNumeroProcesso() || "N/A"}`);

                log("üé® CRIANDO CARD MATERIAL FIGMA:", cardInfo);

                if (!cardInfo) {
                    logError("‚ùå CARD: cardInfo √© null ou undefined");
                    return null;
                }

                log(
                    "‚úÖ CARD: Valida√ß√£o inicial passou, verificando card existente...",
                );

                // Verificar se j√° existe um card
                const cardExistente = document.getElementById(
                    "eprobe-card-sessao-material",
                );
                if (cardExistente) {
                    log("‚ÑπÔ∏è CARD: Removendo card existente");
                    cardExistente.remove();
                }

                log("üé® CARD: Processando cores e status...");

                // Mapeamento de cores do Figma por status
                const coresFigma = {
                    PAUTADO: "#5C85B4",
                    INCLUIDO: "#5C85B4",
                    RETIRADO: "#CE2D4F",
                    VISTA: "#FFBF46",
                    JULGADO: "#3AB795",
                    ADIADO: "#F55D3E",
                    ADIADO_935: "#731963",
                    SOBRESTADO: "#FCB0B3",
                    DILIGENCIA: "#00171F",
                };

                // Determinar status e cor
                const status = cardInfo.status || "PAUTADO";
                const statusKey = status
                    .toUpperCase()
                    .replace(/\s+/g, "_")
                    .replace(/[()\.]/g, "")
                    .normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, ""); // Remove acentos
                const corIcon = coresFigma[statusKey] || coresFigma["PAUTADO"];

                log(
                    "üé® STATUS DETECTADO:",
                    status,
                    "‚Üí",
                    statusKey,
                    "‚Üí",
                    corIcon,
                );

                log("üì¶ CARD: Criando elemento DOM...");

                // üé≠ CRIAR CARD COM SISTEMA ANTI-FLASH
                const card = window.eProbeAntiFlash.createElement("div", {
                    id: "eprobe-card-sessao-material",
                    className: "session-card",
                    groupId: "session-cards", // Agrupar todos os cards de sess√£o
                });

                logCritical(
                    "üé≠ CARD: Elemento criado com sistema anti-flash ativo",
                );

                // Estilo do card Figma: Material Light pequeno - OTIMIZADO PARA POSICIONAMENTO
                card.style.cssText = `
                width: 190px !important;
                height: 60px !important;
                background: #FEF7FF !important;
                border: 0.75px solid #CAC4D0 !important;
                border-radius: 9px !important;
                box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15) !important;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif !important;
                display: flex !important;
                align-items: center !important;
                padding: 8px 12px !important;
                gap: 8px !important;
                cursor: pointer !important;
                transition: transform 0.2s ease !important;
                margin: 0 !important;
                flex-shrink: 0 !important;
                position: relative !important;
                z-index: 1000 !important;
                max-width: 190px !important;
                min-width: 190px !important;
            `;

                // √çcone de clock pequeno do Figma
                const iconSvg = `
                <svg width="25" height="25" viewBox="0 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2.48973 23.5714C1.80506 23.5714 1.21914 23.3408 0.731981 22.8796C0.244824 22.4184 0.00082991 21.8633 0 21.2143V4.71429C0 4.06607 0.243994 3.51136 0.731981 3.05014C1.21997 2.58893 1.80589 2.35793 2.48973 2.35714H3.7346V0H6.22433V2.35714H16.1833V0H18.673V2.35714H19.9179C20.6025 2.35714 21.1889 2.58814 21.6768 3.05014C22.1648 3.51214 22.4084 4.06686 22.4076 4.71429V10.2241C22.4076 10.558 22.2881 10.8381 22.0491 11.0644C21.81 11.2907 21.5146 11.4035 21.1627 11.4027C20.8108 11.4019 20.5154 11.2888 20.2764 11.0633C20.0374 10.8378 19.9179 10.558 19.9179 10.2241V9.42857H2.48973V21.2143H9.70995C10.0627 21.2143 10.3585 21.3274 10.5975 21.5537C10.8366 21.78 10.9556 22.0597 10.9548 22.3929C10.954 22.726 10.8345 23.0061 10.5963 23.2332C10.3581 23.4603 10.0627 23.573 9.70995 23.5714H2.48973ZM18.673 24.75C16.9509 24.75 15.4832 24.1753 14.2699 23.0258C13.0566 21.8763 12.4495 20.4867 12.4487 18.8571C12.4478 17.2276 13.0549 15.838 14.2699 14.6885C15.4849 13.539 16.9526 12.9643 18.673 12.9643C20.3934 12.9643 21.8615 13.539 23.0773 14.6885C24.2931 15.838 24.8998 17.2276 24.8973 18.8571C24.8948 20.4867 24.2877 21.8766 23.0761 23.0269C21.8644 24.1772 20.3967 24.7516 18.673 24.75ZM20.7581 21.6562L21.6295 20.8313L19.2954 18.6214V15.3214H18.0506V19.0929L20.7581 21.6562Z" fill="${corIcon}"/>
                </svg>
            `;

                // Texto do status mapeado
                const statusTextos = {
                    PAUTADO: "Pautado",
                    INCLUIDO: "Inclu√≠do em Pauta",
                    RETIRADO: "Retirado de Pauta",
                    VISTA: "Pedido de Vista",
                    JULGADO: "Julgado",
                    ADIADO: "Adiado",
                    ADIADO_935: "Adiado (art. 935)",
                    SOBRESTADO: "Sobrestado (art. 942)",
                    DILIGENCIA: "Conv. em Dilig√™ncia",
                };

                const statusTexto = statusTextos[statusKey] || status;
                const dataTexto = cardInfo.data || "getData()";

                card.innerHTML = `
                <style>
                    .session-card:hover {
                        box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.3), 0px 2px 6px 2px rgba(0, 0, 0, 0.15);
                    }
                </style>
                <div style="flex-shrink: 0;">
                    ${iconSvg}
                </div>
                <div style="flex: 1; min-width: 0;">
                    <div style="
                        font-size: 14px; 
                        font-weight: 500; 
                        color: #1C1B1F; 
                        line-height: 20px;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    ">${statusTexto}</div>
                    <div style="
                        font-size: 12px; 
                        color: #49454F; 
                        line-height: 16px;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    ">Sess√£o: ${dataTexto}</div>
                </div>
            `;

                // Sistema de tooltip agora usa apenas a fun√ß√£o unificada
                log(
                    "‚ÑπÔ∏è TOOLTIP: Tooltip ser√° configurado pela fun√ß√£o unificada ap√≥s inser√ß√£o do card",
                );

                // Inserir card usando a fun√ß√£o de interface espec√≠fica
                logCritical(
                    "üéØ INSER√á√ÉO: Tentando inserir card na interface...",
                );
                log("üìç CARD: Procurando local para inser√ß√£o...");

                const inserido = inserirCardNaInterface(card);
                if (!inserido) {
                    // Fallback: inserir no body se n√£o conseguir inserir na interface
                    logCritical(
                        "‚ö†Ô∏è FALLBACK: Inserindo card no body como fallback",
                    );
                    document.body.appendChild(card);
                    logError("‚ö†Ô∏è CARD FIGMA: Inserido como fallback no body");
                    log("üìç CARD: Posi√ß√£o fallback aplicada no body");
                } else {
                    logCritical(
                        "‚úÖ SUCESSO: Card inserido na interface com sucesso!",
                    );
                    log("üìç CARD: Inserido na posi√ß√£o correta da interface");
                }

                log("‚úÖ CARD FIGMA: Criado com design Material Light pequeno!");
                log("üé® COR APLICADA:", corIcon, "para status:", statusTexto);

                // Verifica√ß√£o final
                const cardNoDom = document.getElementById(
                    "eprobe-card-sessao-material",
                );
                const cardVisivel =
                    cardNoDom && cardNoDom.style.display !== "none";

                logCritical(
                    `üîç VERIFICA√á√ÉO FINAL: Card no DOM: ${!!cardNoDom}, Vis√≠vel: ${cardVisivel}`,
                );

                if (cardNoDom) {
                    const rect = cardNoDom.getBoundingClientRect();
                    log(
                        `üìê CARD: Posi√ß√£o final - x:${rect.x}, y:${rect.y}, width:${rect.width}, height:${rect.height}`,
                    );

                    // üéØ APLICAR TOOLTIP UNIFICADO DIRETAMENTE NO CARD
                    log(
                        "üéØ TOOLTIP: Aplicando tooltip unificado direto no card...",
                    );
                    try {
                        // ‚úÖ USAR APENAS A FUN√á√ÉO UNIFICADA PARA EVITAR DUPLICA√á√ÉO
                        const resultadoTooltip = aplicarTooltipUnificado(
                            cardNoDom,
                            window.SENT1_AUTO?.todasSessoesDetectadas || null,
                        );
                        if (
                            resultadoTooltip &&
                            resultadoTooltip.status === "sucesso"
                        ) {
                            logCritical(
                                "‚úÖ TOOLTIP: Tooltip aplicado diretamente no card!",
                            );
                        } else {
                            logError(
                                "‚ùå TOOLTIP: Falha ao aplicar tooltip no card",
                            );
                        }
                    } catch (tooltipError) {
                        logError(
                            "‚ùå TOOLTIP: Erro ao aplicar tooltip:",
                            tooltipError,
                        );
                    }
                }

                logCritical("‚úÖ CARD MATERIAL: Cria√ß√£o conclu√≠da com sucesso!");

                // Tornar card clicavel para abrir sessao de julgamento diretamente
                try {
                    tornarCardSessaoClicavel();
                } catch (errClick) {
                    logError(
                        "CARD CLICAVEL: Erro ao configurar clique:",
                        errClick,
                    );
                }

                // üé≠ REVELAR CARD AP√ìS TODAS AS CONFIGURA√á√ïES
                // Aguardar pr√≥ximo frame para garantir que tudo esteja pronto
                requestAnimationFrame(() => {
                    window.eProbeAntiFlash.reveal(card);
                    logCritical("üåü CARD: Revelado com sistema anti-flash");
                });

                return card;
            } catch (error) {
                logError("‚ùå CARD FIGMA: Erro ao criar card:", error);
                logError("üìç STACK TRACE:", error.stack);
                return null;
            }
        }

        // üèõÔ∏è MAPA OFICIAL DE √ìRG√ÉOS TJSC - Convers√£o Sigla ‚Üí Nome Completo
        const mapaOrgaosTJSC = {
            CAMCIV1: "1¬™ C√¢mara de Direito Civil",
            CAMCIV2: "2¬™ C√¢mara de Direito Civil",
            CAMCIV3: "3¬™ C√¢mara de Direito Civil",
            CAMCIV4: "4¬™ C√¢mara de Direito Civil",
            CAMCIV5: "5¬™ C√¢mara de Direito Civil",
            CAMCIV6: "6¬™ C√¢mara de Direito Civil",
            CAMCIV7: "7¬™ C√¢mara de Direito Civil",
            CAMCIV8: "8¬™ C√¢mara de Direito Civil",
            CAMCIV9: "9¬™ C√¢mara de Direito Civil",
            CAMCIV10: "10¬™ C√¢mara de Direito Civil",
            CAMCOM1: "1¬™ C√¢mara de Direito Comercial",
            CAMCOM2: "2¬™ C√¢mara de Direito Comercial",
            CAMCOM3: "3¬™ C√¢mara de Direito Comercial",
            CAMCOM4: "4¬™ C√¢mara de Direito Comercial",
            CAMCOM5: "5¬™ C√¢mara de Direito Comercial",
            CAMCOM6: "6¬™ C√¢mara de Direito Comercial",
            CAMCRI1: "1¬™ C√¢mara Criminal",
            CAMCRI2: "2¬™ C√¢mara Criminal",
            CAMCRI3: "3¬™ C√¢mara Criminal",
            CAMCRI4: "4¬™ C√¢mara Criminal",
            CAMCRI5: "5¬™ C√¢mara Criminal",
            CAMCRI6: "6¬™ C√¢mara Criminal",
            CAMEEA1S: "1¬™ C√¢mara Especial de Enfrentamento de Acervos",
            CAMEEA2S: "2¬™ C√¢mara Especial de Enfrentamento de Acervos",
            CAMEEA3S: "3¬™ C√¢mara Especial de Enfrentamento de Acervos",
            CAMPUB1: "1¬™ C√¢mara de Direito P√∫blico",
            CAMPUB2: "2¬™ C√¢mara de Direito P√∫blico",
            CAMPUB3: "3¬™ C√¢mara de Direito P√∫blico",
            CAMPUB4: "4¬™ C√¢mara de Direito P√∫blico",
            CAMPUB5: "5¬™ C√¢mara de Direito P√∫blico",
            SGRUCIV: "Grupo de C√¢maras de Direito Civil",
            SGRUCOM: "Grupo de C√¢maras de Direito Comercial",
            SGRUCRI1: "Primeiro Grupo de Direito Criminal",
            SGRUCRI2: "Segundo Grupo de Direito Criminal",
            SGRUPUB: "Grupo de C√¢maras de Direito P√∫blico",
            SORGESP: "√ìrg√£o Especial",
            SCAMRECD: "C√¢mara de Recursos Delegados",
            TPLTURUNIF: "Turma de Uniformiza√ß√£o",
            VPRES1: "1¬™ Vice-Presid√™ncia",
            VPRES2: "2¬™ Vice-Presid√™ncia",
            VPRES3: "3¬™ Vice-Presid√™ncia",
            SSECCRI: "Se√ß√£o Criminal",
        };

        // üîÑ TRADUZIR SIGLA DO √ìRG√ÉO
        function traduzirSiglaOrgao(sigla) {
            if (!sigla) return "√ìrg√£o n√£o identificado";

            // Limpar espa√ßos e converter para mai√∫sculo
            sigla = sigla.trim().toUpperCase();

            // Primeiro, tentar match exato no mapa oficial
            if (mapaOrgaosTJSC[sigla]) {
                return mapaOrgaosTJSC[sigla];
            }

            // Fallback para c√≥digos n√£o mapeados
            return `${sigla} (√ìrg√£o)`;
        }

        // üîó FUN√á√ÉO PARA EXTRAIR LINK DA SESS√ÉO - M√âTODO COM MODAL
        function extrairLinkSessao(indiceSessao = 1) {
            try {
                log(`üîó LINK: Extraindo link para sess√£o ${indiceSessao}`);

                // ETAPA 0: Detectar qual fieldset cont√©m as sess√µes
                logCritical(
                    "üîç LINK: Detectando fieldset correto para extra√ß√£o...",
                );
                let fieldsetCorreto = null;

                for (const fieldsetNum of [6, 7]) {
                    const xpathTeste = `/html/body/div[2]/div[3]/div[2]/div/div[1]/form[2]/div[3]/div/div/fieldset[${fieldsetNum}]/div/div[2]/fieldset/legend/span[1]/button`;
                    const elementoTeste = document.evaluate(
                        xpathTeste,
                        document,
                        null,
                        XPathResult.FIRST_ORDERED_NODE_TYPE,
                        null,
                    ).singleNodeValue;

                    if (elementoTeste) {
                        fieldsetCorreto = fieldsetNum;
                        logCritical(
                            `‚úÖ LINK: Fieldset[${fieldsetNum}] detectado como container das sess√µes`,
                        );
                        break;
                    }
                }

                if (!fieldsetCorreto) {
                    logCritical(
                        "‚ùå LINK: Nenhum fieldset com sess√µes encontrado",
                    );
                    return null;
                }

                // ETAPA 1: Primeiro precisamos abrir o modal clicando no SVG
                const indiceSessaoIndex = indiceSessao + 1;
                const xpathTriggerModal = `/html/body/div[2]/div[3]/div[2]/div/div[1]/form[2]/div[3]/div/div/fieldset[${fieldsetCorreto}]/div/div[${indiceSessaoIndex}]/fieldset/legend/span[3]/svg`;

                const triggerElement = document.evaluate(
                    xpathTriggerModal,
                    document,
                    null,
                    XPathResult.FIRST_ORDERED_NODE_TYPE,
                    null,
                ).singleNodeValue;

                if (!triggerElement) {
                    logCritical(
                        `‚ùå LINK: Elemento trigger do modal n√£o encontrado para sess√£o ${indiceSessao} em fieldset[${fieldsetCorreto}] - XPath: ${xpathTriggerModal}`,
                    );
                    return null;
                }

                // Clicar no elemento para abrir o modal
                logCritical(
                    `üñ±Ô∏è LINK: Clicando no elemento para abrir modal da sess√£o ${indiceSessao}`,
                );

                // Simular click no SVG que tem o onclick
                if (triggerElement.onclick) {
                    // Se tem onclick, executar diretamente
                    triggerElement.onclick();
                } else if (
                    triggerElement.parentElement &&
                    triggerElement.parentElement.onclick
                ) {
                    // Ou executar do elemento pai
                    triggerElement.parentElement.onclick();
                } else {
                    // Caso contr√°rio, simular click
                    triggerElement.click();
                }

                // ETAPA 2: Aguardar um pouco para o modal carregar
                return new Promise((resolve) => {
                    setTimeout(() => {
                        try {
                            // XPath para o link dentro do modal aberto
                            const xpathLinkModal = `/html/body/div[1]/div/div/div/div[1]/div/div/div/div[2]/div/form/div[2]/div/table/tbody/tr[${indiceSessao}]/td[1]/a`;

                            const linkElement = document.evaluate(
                                xpathLinkModal,
                                document,
                                null,
                                XPathResult.FIRST_ORDERED_NODE_TYPE,
                                null,
                            ).singleNodeValue;

                            if (linkElement && linkElement.href) {
                                // Obter o href completo
                                const linkCompleto = linkElement.href;
                                const hrefBruto =
                                    linkElement.getAttribute("href");

                                log(
                                    `üîç LINK: href decodificado:`,
                                    linkCompleto,
                                );
                                logCritical(
                                    `üîç LINK: href bruto do HTML:`,
                                    hrefBruto,
                                );

                                // Verificar se √© o link correto da sess√£o
                                const contemSessao =
                                    linkCompleto.includes(
                                        "sessao_julgamento_exibir_painel",
                                    ) ||
                                    hrefBruto.includes(
                                        "sessao_julgamento_exibir_painel",
                                    ) ||
                                    linkCompleto.includes(
                                        "julgamento_historico_listar",
                                    ) ||
                                    hrefBruto.includes(
                                        "julgamento_historico_listar",
                                    );

                                logCritical(
                                    `üîç LINK: Verificando se √© link de sess√£o:`,
                                    {
                                        linkCompleto: linkCompleto.substring(
                                            0,
                                            200,
                                        ),
                                        hrefBruto: hrefBruto
                                            ? hrefBruto.substring(0, 200)
                                            : null,
                                        contemSessao: contemSessao,
                                    },
                                );

                                if (contemSessao) {
                                    // Processar o link para extrair a URL correta
                                    let linkFinal = hrefBruto || linkCompleto;

                                    // Decodificar &amp; se necess√°rio
                                    if (linkFinal.includes("&amp;")) {
                                        linkFinal = linkFinal.replace(
                                            /&amp;/g,
                                            "&",
                                        );
                                    }

                                    // Verificar se tem os par√¢metros essenciais para sess√£o de julgamento
                                    const parametrosEssenciais = [
                                        "id_sessao_julgamento",
                                        "id_orgao_julgador",
                                        "txtNumProcesso",
                                    ];

                                    const temParametrosEssenciais =
                                        parametrosEssenciais.every((param) =>
                                            linkFinal.includes(param),
                                        );

                                    logCritical(
                                        `‚úÖ LINK: Encontrado e extra√≠do do modal para sess√£o ${indiceSessao}:`,
                                        linkFinal,
                                    );
                                    logCritical(
                                        `üìè LINK: Tamanho do link extra√≠do: ${linkFinal.length} caracteres`,
                                    );
                                    logCritical(
                                        `üìä LINK: Par√¢metros essenciais presentes: ${temParametrosEssenciais}`,
                                    );

                                    if (temParametrosEssenciais) {
                                        logCritical(
                                            `üéØ LINK: Link completo da sess√£o de julgamento encontrado!`,
                                        );
                                    } else {
                                        logCritical(
                                            `‚ö†Ô∏è LINK: Link pode estar incompleto - faltam par√¢metros essenciais`,
                                        );
                                    }

                                    resolve(linkFinal);
                                } else {
                                    logCritical(
                                        `‚ùå LINK: Formato inv√°lido encontrado no modal para sess√£o ${indiceSessao}:`,
                                        linkCompleto,
                                    );
                                    resolve(null);
                                }
                            } else {
                                logCritical(
                                    `‚ùå LINK: Link n√£o encontrado no modal para sess√£o ${indiceSessao} - XPath: ${xpathLinkModal}`,
                                );
                                resolve(null);
                            }
                        } catch (error) {
                            console.error(
                                `‚ùå LINK: Erro ao processar modal da sess√£o ${indiceSessao}:`,
                                error,
                            );
                            resolve(null);
                        }
                    }, 1000); // Aguardar 1 segundo para o modal carregar
                });
            } catch (error) {
                console.error(
                    `‚ùå LINK: Erro ao extrair link da sess√£o ${indiceSessao}:`,
                    error,
                );
                return null;
            }
        }

        // üåê FUN√á√ÉO PARA CONSTRUIR URL DA SESS√ÉO
        async function construirUrlSessao(dadosSessao) {
            try {
                logCritical("üåê URL: Construindo URL da sess√£o", dadosSessao);

                // VERIFICAR SE J√Å EST√Å NA P√ÅGINA DE SESS√ÉO
                const urlAtual = window.location.href;
                if (urlAtual.includes("sessao_julgamento_exibir_painel")) {
                    logCritical(
                        "‚úÖ URL: J√° est√° na p√°gina de sess√£o, usando URL atual:",
                        urlAtual,
                    );
                    return urlAtual;
                }

                // Se n√£o est√° na p√°gina de sess√£o, tentar extrair link real abrindo o modal
                logCritical(
                    "üîÑ URL: N√£o est√° na p√°gina de sess√£o, extraindo link do modal...",
                );
                const linkReal = await extrairLinkSessao(
                    dadosSessao.indice || 1,
                );

                if (linkReal) {
                    logCritical(
                        "üîó URL: Link real extra√≠do do modal:",
                        linkReal,
                    );

                    // Se encontrou link real, usar ele completamente
                    const baseUrl = window.location.origin;
                    let urlFinal;

                    if (linkReal.startsWith("http")) {
                        urlFinal = linkReal;
                    } else if (linkReal.startsWith("controlador.php")) {
                        urlFinal = `${baseUrl}/eproc/${linkReal}`;
                    } else if (linkReal.startsWith("/")) {
                        urlFinal = `${baseUrl}${linkReal}`;
                    } else {
                        urlFinal = `${baseUrl}/eproc/${linkReal}`;
                    }

                    logCritical(
                        "üöÄ URL: URL final constru√≠da para o card:",
                        urlFinal,
                    );
                    return urlFinal;
                }

                logCritical(
                    "‚ùå URL: extrairLinkSessao retornou null - n√£o foi poss√≠vel encontrar link real no modal",
                );

                // URL b√°sica como fallback - mas agora com mais par√¢metros se dispon√≠veis
                const baseUrl = window.location.origin;
                const urlBasica = `${baseUrl}/eproc/controlador.php?acao=sessao_julgamento_exibir_painel`;

                const numeroProcesso = obterNumeroProcesso();
                if (numeroProcesso) {
                    return `${urlBasica}&txtNumProcesso=${numeroProcesso}`;
                }

                return urlBasica;
            } catch (error) {
                console.error(
                    "‚ùå URL: Erro ao construir URL da sess√£o:",
                    error,
                );
                return null;
            }
        }

        // ‚ùå FUN√á√ÉO REMOVIDA: detectarCardSessaoSimplificado()
        // ‚úÖ USE AGORA: detectarSessoesUnificado()

        processoJaFoiProcessado = function (numeroProcesso) {
            return numeroProcesso && processosJaProcessados.has(numeroProcesso);
        };

        marcarProcessoComoProcessado = function (numeroProcesso) {
            if (numeroProcesso) {
                processosJaProcessados.add(numeroProcesso);
            }
        };

        // ‚ö° SISTEMA DE DEBOUNCE GLOBAL - Prevenir execu√ß√µes redundantes
        const debounceTimers = new Map();
        const domCache = new Map(); // Cache para elementos DOM
        const CACHE_EXPIRY = 60000; // Cache expira em 1 minuto

        function debounceGlobal(func, key, delay = 300) {
            if (debounceTimers.has(key)) {
                clearTimeout(debounceTimers.get(key));
            }

            const timerId = setTimeout(() => {
                func();
                debounceTimers.delete(key);
            }, delay);

            debounceTimers.set(key, timerId);
        }

        // üßπ LIMPEZA AUTOM√ÅTICA DO CACHE
        setInterval(() => {
            const now = Date.now();
            for (const [key, value] of domCache.entries()) {
                if (now - value.timestamp > CACHE_EXPIRY) {
                    domCache.delete(key);
                }
            }
        }, 10000); // Limpar a cada 10 segundos

        let processoAtual = null; // Processo atual sendo visualizado

        // üö´ CONTROLE GLOBAL DE REQUISI√á√ïES
        let REQUISICOES_AUTOMATICAS_DESABILITADAS = true; // DESABILITAR TODAS AS REQUISI√á√ïES AUTOM√ÅTICAS

        // üî• CONTROLE DE PERFORMANCE ULTRA
        let MODO_ULTRA_PERFORMANCE = false; // Controla opera√ß√µes custosas para otimizar performance

        // üé® CONTROLE DE PERSONALIZA√á√ïES
        let PERSONALIZACAO_NAVBAR_HABILITADA = true; // Controla se a personaliza√ß√£o da navbar est√° ativa

        // Configura√ß√µes de seguran√ßa MAIS RIGOROSAS
        const MAX_TENTATIVAS_CRUZAMENTO = 1; // REDUZIDO: M√°ximo 1 tentativa por processo
        const DELAY_ENTRE_TENTATIVAS = 60000; // AUMENTADO: 1 minuto entre tentativas
        const CACHE_DURATION = 600000; // AUMENTADO: Cache v√°lido por 10 minutos

        // Injetar CSS apenas para elementos da extens√£o eProbe
        const extensionStyle = document.createElement("style");
        extensionStyle.textContent = `
        @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap');
        
        /* Padroniza√ß√£o da fonte Roboto APENAS para elementos da extens√£o eProbe */
        [id*="sent1"], [id*="documento-relevante"], [class*="eprobe"], 
        #sent1-auto-button, #documento-relevante-options-menu,
        #documento-relevante-selection-modal, #documento-relevante-preview-modal,
        #api-config-modal, #error-logs-modal, #api-key-config,
        .eprobe-notification, .eprobe-tooltip, .eprobe-modal, .eprobe-button, .eprobe-menu {
            font-family: "Roboto", -apple-system, system-ui, sans-serif !important;
        }
        
        /* Estilo espec√≠fico para o bot√£o documento-relevante-auto-button */
        #documento-relevante-auto-button {
            margin-right: 3px !important;
        }
        
        /* Elementos criados dinamicamente pela extens√£o */
        [id*="sent1"] *, [id*="documento-relevante"] *, [class*="eprobe"] *,
        #sent1-auto-button *, #documento-relevante-options-menu *,
        #documento-relevante-selection-modal *, #documento-relevante-preview-modal *,
        #api-config-modal *, #error-logs-modal *, #api-key-config *,
        .eprobe-notification *, .eprobe-tooltip *, .eprobe-modal *, .eprobe-button *, .eprobe-menu * {
            font-family: "Roboto", -apple-system, system-ui, sans-serif !important;
        }
        
        /* CORRECAO: Icones substituidos nao devem interceptar cliques */
        .substituted-icon:not(.clickable-icon) {
            pointer-events: none !important;
        }
        
        /* Material Icons substituidos tambem nao devem interceptar cliques */
        .material-symbols-outlined.substituted-icon:not(.clickable-icon) {
            pointer-events: none !important;
        }

        /* Containers de icones NAO bloqueiam cliques - herdam pointer-events do pai */

        /* SVGs de icones eProbe */
        svg.substituted-icon:not(.clickable-icon) {
            pointer-events: none !important;
        }
        
        svg.iconeFerramentas:not(.clickable-icon) {
            pointer-events: none !important;
        }
        
        /* Elementos com data-eprobe-icon-replaced */
        [data-eprobe-icon-replaced="true"]:not(.clickable-icon) {
            pointer-events: none !important;
        }
        
        /* Containers de icones eProbe devem ser clicaveis (herdam do link pai) */
        span[data-eprobe-icon-container] {
            pointer-events: auto !important;
        }

        /* Links e botoes devem ser clicaveis */
        a,
        button,
        a[data-eprobe-intercepted],
        .infraLegendObrigatorio a,
        .infraLegendObrigatorio button {
            pointer-events: auto !important;
        }

        /* üìè DIMENSIONAMENTO ESPEC√çFICO: √çcones em divListaRecursosMinuta devem ter 17.59x17.59 */
        #divListaRecursosMinuta svg[data-eprobe-icon-replaced="true"],
        #divListaRecursosMinuta [data-eprobe-recursos-minuta-sized="true"] {
            width: 17.59px !important;
            height: 17.59px !important;
            min-width: 17.59px !important;
            min-height: 17.59px !important;
            max-width: 17.59px !important;
            max-height: 17.59px !important;
            vertical-align: middle !important;
            display: inline-block !important;
        }
        
        /* ALINHAMENTO CR√çTICO: Garantir que containers estejam perfeitamente alinhados */
        #divListaRecursosMinuta span:has(svg[data-eprobe-icon-replaced="true"]) {
            width: 17.59px !important;
            height: 17.59px !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            vertical-align: middle !important;
            line-height: 1 !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* CORRE√á√ÉO DE ALINHAMENTO: √çcones originais e personalizados na mesma linha */
        #divListaRecursosMinuta img,
        #divListaRecursosMinuta svg[data-eprobe-icon-replaced="true"] {
            vertical-align: middle !important;
            display: inline-block !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        
        /* GARANTIR consist√™ncia com √≠cones nativos do eProc */
        #divListaRecursosMinuta a,
        #divListaRecursosMinuta a img,
        #divListaRecursosMinuta a svg {
            vertical-align: middle !important;
            line-height: 1 !important;
            display: inline-flex !important;
            align-items: center !important;
        }

        /* Estilos para SVGs inline - permitir customiza√ß√£o */
        .eprobe-svg-icon {
            pointer-events: none !important;
            transition: all 0.2s ease;
        }
        
        .eprobe-svg-icon:hover {
            transform: scale(1.1);
            filter: brightness(1.2);
        }
        
        /* SVG espec√≠ficos por tipo */
        .eprobe-svg-bubble {
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
        }
        
        .eprobe-svg-config {
            opacity: 0.8;
        }
        
        .eprobe-svg-config:hover {
            opacity: 1;
            transform: rotate(15deg) scale(1.1);
        }
        
        /* ‚ö° OTIMIZA√á√ÉO PERFORMANCE: CSS hover substitui event listeners */
        .eprobe-button-hover:hover {
            background-color: rgb(19, 67, 119) !important;
            border-color: rgb(19, 67, 119) !important;
            transform: translateY(-1px) !important;
        }
        
        .eprobe-button-hover:focus {
            background-color: rgb(19, 67, 119) !important;
            border-color: rgb(19, 67, 119) !important;
            outline: 2px solid #ffffffff !important;
        }
        
        .eprobe-button-hover:active {
            background-color: #0a2d4f !important;
            transform: translateY(0) !important;
        }
        
        /* Bot√µes de cancelar otimizados */
        .eprobe-cancel-button:hover {
            background-color: #4b5563 !important;
        }
        
        .eprobe-process-button:hover {
            background-color: #059669 !important;
        }
        
        /* Bot√µes PDF otimizados */
        .eprobe-pdf-cancel-button:hover {
            background-color: #91433d !important;
            border-color: #91433d !important;
        }
        
        /* ‚ö° ANTI-FLASH TOTAL: Sistema robusto para eliminar completamente o flash visual */
        
        /* 1. Ocultar QUALQUER elemento de lembrete at√© ser processado */
        .lista-lembretes .lembrete:not(.eprobe-lembrete-processado),
        div.divLembrete:not(.eprobe-lembrete-processado) {
            visibility: hidden !important;
            opacity: 0 !important;
            position: relative !important;
            min-width: 315px !important;
            min-height: 140px !important;
        }
        
        /* 2. Mostrar apenas elementos processados */
        .lista-lembretes .lembrete.eprobe-lembrete-processado,
        div.divLembrete.eprobe-lembrete-processado {
            visibility: visible !important;
            opacity: 1 !important;
            transition: opacity 0.2s ease-in-out !important;
            min-width: 315px !important;
            min-height: 140px !important;
        }
        
        /* 3. Pr√©-aplicar estilos ANTES do elemento aparecer */
        .lista-lembretes .lembrete.eprobe-lembrete-processado,
        div.divLembrete.eprobe-lembrete-processado {
            padding: 20px !important;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
            transition: box-shadow 0.5s ease !important;
            -webkit-font-smoothing: subpixel-antialiased !important;
            min-width: 315px !important;
            min-height: 140px !important;


        }
        
        /* 4. Material Icons s√£o tratados pela regra global posterior */
        
        /* Bot√µes de abertura otimizados */
        .eprobe-open-button:hover {
            background-color: rgba(148, 163, 184, 0.1) !important;
        }
        
        /* Container e bot√£o de remo√ß√£o otimizados - M√öLTIPLAS ESPECIFICIDADES */
        .eprobe-container-hover .eprobe-remove-button {
            opacity: 0 !important;
            transition: opacity 0.2s ease !important;
        }
        
        /* For√ßar especificidade extra para garantir que funcione */
        div.eprobe-container-hover .eprobe-remove-button,
        .eprobe-container-hover button.eprobe-remove-button {
            opacity: 0 !important;
            transition: opacity 0.2s ease !important;
        }
        
        .eprobe-container-hover:hover .eprobe-remove-button {
            opacity: 1 !important;
        }
        
        /* Hover com especificidade extra */
        div.eprobe-container-hover:hover .eprobe-remove-button,
        .eprobe-container-hover:hover button.eprobe-remove-button {
            opacity: 1 !important;
        }
        
        /* Efeitos hover para o √≠cone SVG do bot√£o de remover */
        .eprobe-remove-button {
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            transition: all 0.2s ease !important;
        }
        
        .eprobe-remove-button svg {
            transition: all 0.2s ease !important;
        }
        
        .eprobe-remove-button:hover svg {
        fill: #dc2626 !important;
        transform: scale(1.1) !important;
        }
        
        /* Op√ß√µes de menu otimizadas */
        .eprobe-menu-option {
            background-color: transparent !important;
            transition: background-color 0.2s ease;
        }
        
        .eprobe-menu-option:hover {
            background-color: #f8f9fa !important;
        }
    `;
        document.head.appendChild(extensionStyle);

        // Adicionar Material Icons History e Chat Bubble com PRELOAD para carregamento instant√¢neo
        if (
            !document.querySelector('link[href*="Material+Symbols+Outlined"]')
        ) {
            // Usar preload para carregamento mais r√°pido
            const materialIconsHistory = document.createElement("link");
            materialIconsHistory.rel = "preload";
            materialIconsHistory.as = "style";
            materialIconsHistory.href =
                "https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=history_2,gavel";
            materialIconsHistory.onload = function () {
                this.onload = null;
                this.rel = "stylesheet";
            };
            document.head.appendChild(materialIconsHistory);

            // Carregar CSS dos Material Symbols com preload
            const materialIconsCSS = document.createElement("link");
            materialIconsCSS.rel = "preload";
            materialIconsCSS.as = "style";

            // Verificar se chrome.runtime est√° dispon√≠vel (contexto de extens√£o)
            if (
                typeof chrome !== "undefined" &&
                chrome.runtime &&
                chrome.runtime.getURL
            ) {
                materialIconsCSS.href = chrome.runtime.getURL(
                    "src/material-icons.css",
                );
            } else {
                // Fallback para teste local - usar caminho relativo
                materialIconsCSS.href = "src/material-icons.css";
            }

            materialIconsCSS.onload = function () {
                this.onload = null;
                this.rel = "stylesheet";
            };
            document.head.appendChild(materialIconsCSS);

            log(
                "‚ö° FONTS: Material Icons carregados com preload para velocidade m√°xima",
            );
        }

        // ===== IN√çCIO DO SISTEMA DE PROCESSAMENTO DE DOCUMENTOS =====
        (async function () {
            let debugMode = true;
            let isAutomationActive = false;

            // Fun√ß√£o auxiliar para normalizar texto (remover acentos)
            const normalizarTexto = (texto) => {
                return texto
                    .normalize("NFD")
                    .replace(/[\u0300-\u036f]/g, "")
                    .toUpperCase();
            };

            // Configura√ß√£o dos tipos de documentos relevantes - VERS√ÉO EXPANDIDA
            const TIPOS_DOCUMENTO_RELEVANTE = {
                SENT: { nome: "SENT", descricao: "Senten√ßa", dataNome: "SENT" },
                INIC: {
                    nome: "INIC",
                    descricao: "Peti√ß√£o Inicial",
                    dataNome: "INIC",
                },
                PET1: {
                    nome: "PET1",
                    descricao: "Peti√ß√£o 1",
                    dataNome: "PET1",
                },
                RAZAPELA1: {
                    nome: "RAZAPELA1",
                    descricao: "Raz√µes de Apela√ß√£o 1",
                    dataNome: "RAZAPELA1",
                },
                DENUNCIA1: {
                    nome: "DENUNCIA1",
                    descricao: "Den√∫ncia 1",
                    dataNome: "DENUNCIA1",
                },
                APELACAO1: {
                    nome: "APELACAO1",
                    descricao: "Apela√ß√£o 1",
                    dataNome: "APELACAO1",
                },
                RAZRECUR1: {
                    nome: "RAZRECUR1",
                    descricao: "Raz√µes de Recurso 1",
                    dataNome: "RAZRECUR1",
                },
                /*          DECI: {
                nome: "DESPADEC",
                descricao: "Decis√£o",
                dataNome: "DESPADEC",
            }, */
            };

            function logDebug(message, ...args) {
                if (debugMode) {
                    console.log("PROCESSAR DOCUMENTO:", message, ...args);
                }
            }

            // Detectar tipo de p√°gina e formato de documento - usando express√£o de fun√ß√£o
            const detectPageType = function () {
                const url = window.location.href;
                logDebug("üîç Detectando tipo de p√°gina. URL:", url);

                if (url.includes("processo_selecionar")) {
                    return "lista_documentos";
                } else if (url.includes("sessao_julgamento_exibir_painel")) {
                    logDebug("üìä P√°gina de sess√£o de julgamento detectada");
                    return "sessao_julgamento";
                } else if (
                    url.includes("acessar_documento") ||
                    url.includes("processo_consultar_externo_documento")
                ) {
                    // üîß DETEC√á√ÉO MELHORADA PARA EPROC
                    logDebug("üîç Detectando tipo de documento no eProc...");

                    // ‚úÖ ESTRAT√âGIA 1: Verificar MimeType=pdf na URL (mais confi√°vel)
                    const urlParams = new URLSearchParams(
                        window.location.search,
                    );
                    const dadosIconLink = urlParams.get("dadosIconLink");

                    let isPdfByUrl = false;
                    if (dadosIconLink) {
                        try {
                            // Decodificar base64 e verificar MimeType
                            const decoded = atob(dadosIconLink);
                            isPdfByUrl =
                                decoded.includes('"MimeType";s:3:"pdf"') ||
                                decoded.includes("MimeType=pdf");
                            logDebug(
                                `‚úÖ MimeType detectado na URL: ${
                                    isPdfByUrl ? "PDF" : "Outro"
                                }`,
                            );
                        } catch (e) {
                            logDebug(
                                "‚ö†Ô∏è Erro ao decodificar dadosIconLink:",
                                e.message,
                            );
                        }
                    }

                    // ‚úÖ ESTRAT√âGIA 2: Verificar URL diretamente
                    const isPdfByUrlDirect =
                        url.toLowerCase().includes("pdf") ||
                        url.includes("MimeType");

                    // Detectar se √© documento HTML (senten√ßa) ou PDF (peti√ß√£o inicial)
                    const sectionSentenca = document.querySelector(
                        'section[data-nome="sentenca"]',
                    );

                    // ‚úÖ DETEC√á√ÉO ESPEC√çFICA PARA EPROC PDFs
                    const eprocPdfSelectors = [
                        // eProc usa principalmente estes padr√µes
                        'iframe[src*="acessar_documento"]',
                        'iframe[src*="processo_consultar"]',
                        'iframe[src*="pdf"]',
                        'iframe[title*="PDF"]',
                        'iframe[type*="pdf"]',
                        'embed[type="application/pdf"]',
                        'embed[src*="pdf"]',
                        'object[type="application/pdf"]',
                        'object[data*="pdf"]',
                        "#plugin", // Comum no eProc
                        'iframe[name="plugin"]',
                        'embed[name="plugin"]',
                        // Chrome PDF viewer espec√≠fico
                        'embed[type="application/x-google-chrome-pdf"]',
                    ];

                    let pdfViewer = null;
                    let foundWith = null;

                    // Testar cada seletor espec√≠fico para eProc
                    for (const selector of eprocPdfSelectors) {
                        pdfViewer = document.querySelector(selector);
                        if (pdfViewer) {
                            foundWith = selector;
                            logDebug(
                                `‚úÖ PDF eProc encontrado com: ${selector}`,
                            );
                            break;
                        }
                    }

                    // Se n√£o encontrou com seletores espec√≠ficos, analisar todos os elementos
                    if (!pdfViewer) {
                        const allElements = [
                            ...document.querySelectorAll("iframe"),
                            ...document.querySelectorAll("embed"),
                            ...document.querySelectorAll("object"),
                        ];

                        for (const element of allElements) {
                            const src = element.src || element.data || "";
                            const type = element.type || "";
                            const title = element.title || "";
                            const name = element.name || "";

                            // ‚úÖ L√ìGICA ESPEC√çFICA PARA EPROC
                            const isPdfElement =
                                // URL cont√©m par√¢metros de documento eProc
                                src.includes("acessar_documento") ||
                                src.includes("processo_consultar") ||
                                // Tipo espec√≠fico de PDF
                                type.toLowerCase().includes("pdf") ||
                                type.includes(
                                    "application/x-google-chrome-pdf",
                                ) ||
                                // Nome comum no eProc
                                name === "plugin" ||
                                // T√≠tulo indica PDF
                                title.toLowerCase().includes("pdf") ||
                                // URL explicitamente PDF
                                src.toLowerCase().includes(".pdf");

                            if (isPdfElement) {
                                pdfViewer = element;
                                foundWith = `An√°lise de ${
                                    element.tagName
                                }: ${src.substring(0, 50)}...`;
                                logDebug(
                                    `‚úÖ PDF eProc detectado por an√°lise: ${foundWith}`,
                                );
                                break;
                            }
                        }
                    }

                    // Debug detalhado
                    logDebug("üîç An√°lise completa de elementos:", {
                        url: url.substring(0, 100),
                        isPdfByUrl: isPdfByUrl,
                        isPdfByUrlDirect: isPdfByUrlDirect,
                        sectionSentenca: !!sectionSentenca,
                        pdfViewer: !!pdfViewer,
                        foundWith: foundWith,
                        totalIframes:
                            document.querySelectorAll("iframe").length,
                        totalEmbeds: document.querySelectorAll("embed").length,
                        totalObjects:
                            document.querySelectorAll("object").length,
                        dadosIconLink: dadosIconLink
                            ? dadosIconLink.substring(0, 50) + "..."
                            : "N/A",
                    });

                    // ‚úÖ DECIS√ÉO FINAL: PDF detectado por qualquer estrat√©gia
                    const isPdfDocument =
                        isPdfByUrl || isPdfByUrlDirect || !!pdfViewer;

                    // Determinar tipo final
                    if (sectionSentenca && !isPdfDocument) {
                        logDebug("üìÑ Documento HTML detectado (senten√ßa)");
                        return "documento_html";
                    } else if (isPdfDocument) {
                        logDebug(
                            `üìÑ Documento PDF detectado! M√©todo: ${
                                isPdfByUrl
                                    ? "URL MimeType"
                                    : isPdfByUrlDirect
                                      ? "URL Direct"
                                      : foundWith
                            }`,
                        );
                        return "documento_pdf";
                    } else {
                        logDebug(
                            "üìÑ Documento espec√≠fico (tipo indefinido) - verificando conte√∫do...",
                        );

                        // Verificar se h√° conte√∫do t√≠pico de documento
                        const hasDocumentContent =
                            document.querySelector(".documento") ||
                            document.querySelector(".conteudo") ||
                            document.querySelector(".texto") ||
                            document.querySelector("main") ||
                            document.querySelector("article") ||
                            document.body.textContent.length > 1000;

                        if (hasDocumentContent) {
                            logDebug(
                                "üìÑ Conte√∫do de documento detectado - assumindo documento espec√≠fico",
                            );
                            return "documento_especifico";
                        } else {
                            logDebug(
                                "‚ùå Nenhum conte√∫do de documento detectado",
                            );
                            return "desconhecida";
                        }
                    }
                }

                return "desconhecida";
            };
            function isValidPageForButton() {
                // Verificar se est√° na p√°gina do processo (formul√°rio frmProcessoLista + t√≠tulo espec√≠fico)
                const formProcessoLista =
                    document.querySelector("#frmProcessoLista");
                const tituloConsultaProcessual = document.querySelector("h1");

                const hasTituloCorreto =
                    tituloConsultaProcessual &&
                    tituloConsultaProcessual.textContent.includes(
                        "Consulta Processual - Detalhes do Processo",
                    );

                if (formProcessoLista && hasTituloCorreto) {
                    log(
                        "P√°gina v√°lida detectada: formul√°rio #frmProcessoLista E t√≠tulo 'Consulta Processual - Detalhes do Processo' encontrados (p√°gina do processo)",
                    );
                    return true;
                }

                // Para compatibilidade com documento espec√≠fico (p√°gina de visualiza√ß√£o do documento)
                const pageType = detectPageType();
                if (
                    pageType === "documento_especifico" ||
                    pageType === "documento_html" ||
                    pageType === "documento_pdf"
                ) {
                    log("P√°gina v√°lida detectada: documento espec√≠fico");
                    return true;
                }

                // Verificar URLs espec√≠ficas do eProc que podem conter documentos
                const url = window.location.href;
                if (
                    url.includes("eproc") &&
                    (url.includes("documento") || url.includes("processo"))
                ) {
                    log(
                        "P√°gina v√°lida detectada: URL cont√©m eproc e documento/processo",
                    );
                    return true;
                }

                // Verificar se h√° tabelas com links de documentos relevantes (SENT, INIC, etc.)
                const hasDocumentLinks = !!(
                    document.querySelector('[href*="SENT"]') ||
                    document.querySelector('[href*="INIC"]') ||
                    document.querySelector('[href*="DECI"]') ||
                    document.querySelector('[href*="DESP"]')
                );

                if (hasDocumentLinks) {
                    log(
                        "P√°gina v√°lida detectada: cont√©m links de documentos relevantes",
                    );
                    return true;
                }

                log("P√°gina n√£o √© v√°lida para o bot√£o:", {
                    url: url,
                    pageType: pageType,
                    hasFormProcessoLista: !!formProcessoLista,
                    hasTituloCorreto: hasTituloCorreto,
                    tituloAtual: tituloConsultaProcessual
                        ? tituloConsultaProcessual.textContent
                        : "n√£o encontrado",
                    hasTable: !!document.querySelector("table"),
                    hasDocumentLinks: hasDocumentLinks,
                    hasEventDesc: !!document.querySelector(
                        ".infraEventoDescricao",
                    ),
                });
                return false;
            }

            // üìã FUN√á√ïES DE DETEC√á√ÉO E PROCESSAMENTO DA P√ÅGINA "MEUS LOCALIZADORES"

            // Fun√ß√£o para salvar separadores no localStorage
            function salvarSeparadores(separadores) {
                try {
                    const chave = "eprobe_separadores_localizadores";
                    localStorage.setItem(chave, JSON.stringify(separadores));
                    log("üíæ LOCALIZADORES: Separadores salvos no localStorage");
                } catch (error) {
                    console.error(
                        "‚ùå LOCALIZADORES: Erro ao salvar separadores:",
                        error,
                    );
                }
            }

            // Fun√ß√£o para carregar separadores do localStorage
            function carregarSeparadores() {
                try {
                    const chave = "eprobe_separadores_localizadores";
                    const dados = localStorage.getItem(chave);
                    if (dados) {
                        const separadores = JSON.parse(dados);
                        log(
                            "üìÇ LOCALIZADORES: Separadores carregados do localStorage:",
                            separadores.length,
                        );
                        return separadores;
                    }
                } catch (error) {
                    console.error(
                        "‚ùå LOCALIZADORES: Erro ao carregar separadores:",
                        error,
                    );
                }
                return [];
            }

            // Fun√ß√£o para salvar lista de separadores removidos
            function salvarSeparadoresRemovidos(removidos) {
                try {
                    const chave = "eprobe_separadores_removidos";
                    localStorage.setItem(chave, JSON.stringify(removidos));
                    log(
                        "üóëÔ∏è LOCALIZADORES: Lista de removidos salva no localStorage",
                    );
                } catch (error) {
                    console.error(
                        "‚ùå LOCALIZADORES: Erro ao salvar removidos:",
                        error,
                    );
                }
            }

            // Fun√ß√£o para carregar lista de separadores removidos
            function carregarSeparadoresRemovidos() {
                try {
                    const chave = "eprobe_separadores_removidos";
                    const dados = localStorage.getItem(chave);
                    if (dados) {
                        const removidos = JSON.parse(dados);
                        log(
                            "üìÇ LOCALIZADORES: Separadores removidos carregados:",
                            removidos.length,
                        );
                        return removidos;
                    }
                } catch (error) {
                    console.error(
                        "‚ùå LOCALIZADORES: Erro ao carregar removidos:",
                        error,
                    );
                }
                return [];
            }

            // Fun√ß√£o para detectar e processar p√°gina "Meus Localizadores"
            function detectarPaginaLocalizadores() {
                const currentUrl = window.location.href;

                // Verifica se est√° na p√°gina de Meus Localizadores
                if (
                    !currentUrl.includes(
                        "acao=usuario_tipo_monitoramento_localizador_listar",
                    )
                ) {
                    return false;
                }

                console.log(
                    "üìã LOCALIZADORES: P√°gina 'Meus Localizadores' detectada",
                );

                // Processa a tabela de localizadores
                processarTabelaLocalizadores();

                return true;
            }

            // Fun√ß√£o para processar a tabela de localizadores
            function processarTabelaLocalizadores() {
                console.log(
                    "üîç LOCALIZADORES: Iniciando processamento da tabela",
                );

                // Busca a tabela de localizadores
                const tabela = document.querySelector(
                    'table.infraTable[summary*="Localizadores"]',
                );

                if (!tabela) {
                    console.log(
                        "‚ö†Ô∏è LOCALIZADORES: Tabela de localizadores n√£o encontrada",
                    );
                    return;
                }

                console.log(
                    "‚úÖ LOCALIZADORES: Tabela encontrada, processando...",
                );

                // Destaca localizadores urgentes
                destacarLocalizadoresUrgentes(tabela);

                // ‚ùå DESABILITADO: Adiciona interface de separadores
                // adicionarInterfaceSeparadores(tabela);

                // Restaurar separadores salvos
                restaurarSeparadores(tabela);
            } // Fun√ß√£o para restaurar separadores salvos
            function restaurarSeparadores(tabela) {
                log("üîÑ LOCALIZADORES: Restaurando separadores salvos");

                // Verificar se j√° existem separadores na p√°gina para evitar duplica√ß√£o
                const separadoresExistentes = tabela.querySelectorAll(
                    ".eprobe-divisor-linha",
                );
                if (separadoresExistentes.length > 0) {
                    log(
                        "‚ÑπÔ∏è LOCALIZADORES: Separadores j√° existem na p√°gina, evitando duplica√ß√£o",
                    );
                    return;
                }

                const separadoresSalvos = carregarSeparadores();

                if (separadoresSalvos.length === 0) {
                    log("‚ÑπÔ∏è LOCALIZADORES: Nenhum separador salvo encontrado");
                    return;
                }

                const tbody = tabela.querySelector("tbody");
                if (!tbody) {
                    log(
                        "‚ö†Ô∏è LOCALIZADORES: tbody n√£o encontrado para restaurar separadores",
                    );
                    return;
                }

                const linhasOriginais = Array.from(
                    tbody.querySelectorAll("tr:not(.eprobe-divisor-linha)"),
                );

                // Ordenar separadores por posi√ß√£o para inserir na ordem correta
                separadoresSalvos.sort((a, b) => a.posicao - b.posicao);

                separadoresSalvos.forEach((separadorData) => {
                    let linhaReferencia = null;

                    // Encontrar linha de refer√™ncia pela posi√ß√£o
                    if (
                        separadorData.posicao > 0 &&
                        separadorData.posicao <= linhasOriginais.length
                    ) {
                        linhaReferencia =
                            linhasOriginais[separadorData.posicao - 1];
                    }

                    // Criar o separador com flag de restaura√ß√£o para evitar salvar novamente
                    const separadorCriado = criarDivisorEditavel(
                        tabela,
                        linhaReferencia,
                        separadorData.texto,
                        true,
                    );

                    // Adicionar ID do separador salvo ao elemento restaurado
                    if (separadorCriado) {
                        separadorCriado.setAttribute(
                            "data-separador-id",
                            separadorData.id,
                        );
                        log(
                            `‚úÖ LOCALIZADORES: Separador "${separadorData.texto}" restaurado na posi√ß√£o ${separadorData.posicao}`,
                        );
                    }
                });

                log(
                    `üîÑ LOCALIZADORES: ${separadoresSalvos.length} separador(es) restaurado(s)`,
                );
            }

            // Fun√ß√£o para destacar localizadores com palavra "urgente"
            function destacarLocalizadoresUrgentes(tabela) {
                log("üî¥ LOCALIZADORES: Destacando localizadores urgentes");

                const linhas = tabela.querySelectorAll("tbody tr");
                let urgentesEncontrados = 0;

                linhas.forEach((linha, index) => {
                    const primeiraColuna =
                        linha.querySelector("td:first-child");

                    if (primeiraColuna) {
                        const textoLocalizador =
                            primeiraColuna.textContent.toLowerCase();

                        // Verifica se cont√©m a palavra "urgente" (case insensitive)
                        if (textoLocalizador.includes("urgente")) {
                            // Aplica estilo de destaque vermelho suave
                            linha.style.backgroundColor = "#fecaca";
                            linha.style.border = "1px solid #f87171";
                            linha.style.transition = "all 0.2s ease";

                            urgentesEncontrados++;
                            log(
                                `üî¥ LOCALIZADORES: Linha ${
                                    index + 1
                                } marcada como urgente: "${primeiraColuna.textContent.trim()}"`,
                            );
                        }
                    }
                });

                if (urgentesEncontrados > 0) {
                    log(
                        `‚úÖ LOCALIZADORES: ${urgentesEncontrados} localizador(es) urgente(s) destacado(s)`,
                    );
                } else {
                    log(
                        "‚ÑπÔ∏è LOCALIZADORES: Nenhum localizador urgente encontrado",
                    );
                }
            }

            // Fun√ß√£o para criar divisores edit√°veis na tabela de localizadores
            function criarDivisorEditavel(
                tabela,
                linhaPosicao,
                textoInicial = "Se√ß√£o",
                isRestoracao = false,
            ) {
                log("üìù LOCALIZADORES: Criando divisor edit√°vel");
                log("üîß DEBUG: Par√¢metros recebidos:", {
                    tabela,
                    linhaPosicao,
                    textoInicial,
                    isRestoracao,
                });

                if (!tabela) {
                    log(
                        "‚ö†Ô∏è LOCALIZADORES: Tabela n√£o fornecida para criar divisor",
                    );
                    return null;
                }

                const tbody = tabela.querySelector("tbody");
                log("üîß DEBUG: tbody encontrado:", tbody);

                if (!tbody) {
                    logError(
                        "‚ö†Ô∏è LOCALIZADORES: tbody n√£o encontrado na tabela",
                    );
                    return null;
                }

                // Contar colunas da tabela para criar divisor do tamanho correto
                const primeiraLinhaComCelulas =
                    tbody.querySelector("tr") ||
                    tabela.querySelector("thead tr");
                let totalColunas = 2; // Padr√£o para localizadores

                if (primeiraLinhaComCelulas) {
                    const celulas =
                        primeiraLinhaComCelulas.querySelectorAll("td, th");
                    totalColunas = celulas.length;
                }

                log(`üîß DEBUG: N√∫mero de colunas detectado: ${totalColunas}`);

                // Criar nova linha divisor
                const linhaDivisor = document.createElement("tr");
                linhaDivisor.className = "eprobe-divisor-linha";
                linhaDivisor.style.backgroundColor = "#f3f4f6";
                linhaDivisor.style.borderTop = "2px solid #6b7280";
                linhaDivisor.style.borderBottom = "1px solid #d1d5db";

                // Criar c√©lula que ocupa todas as colunas
                const celulaDivisor = document.createElement("td");
                celulaDivisor.colSpan = totalColunas;
                celulaDivisor.style.padding = "12px";
                celulaDivisor.style.textAlign = "center";
                celulaDivisor.style.position = "relative";

                // Criar container para o t√≠tulo edit√°vel
                const containerTitulo = document.createElement("div");
                containerTitulo.style.position = "relative";
                containerTitulo.style.display = "inline-flex";
                containerTitulo.style.alignItems = "center";
                containerTitulo.style.justifyContent = "center";

                // Criar √≠cone do separador
                const iconeSeparador = document.createElement("span");
                iconeSeparador.style.cssText = `
                display: grid !important;
                margin-right: 10px !important;
                vertical-align: middle !important;
                width: 16px !important;
                height: 16px !important;
            `;
                iconeSeparador.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 3px !important; vertical-align: middle;">
                    <path d="m16 16-4 4-4-4"/>
                    <path d="M3 12h18"/>
                    <path d="m8 8 4-4 4 4"/>
                </svg>
            `;

                // Criar t√≠tulo edit√°vel (sem caixa, apenas texto)
                const tituloEditavel = document.createElement("span");
                tituloEditavel.textContent = textoInicial;
                tituloEditavel.contentEditable = true;
                tituloEditavel.style.cssText = `
            font-weight: bold;
            color: #374151;
            font-size: 14px;
            cursor: text;
            outline: none;
            border: none;
            background: transparent;
            min-width: 100px;
            display: inline-block;
            text-align: center;
            transition: background-color 0.2s ease;
        `;

                // Adicionar eventos para edi√ß√£o
                tituloEditavel.addEventListener("focus", function () {
                    this.style.backgroundColor = "#f3f4f6";
                    this.style.borderRadius = "4px";
                    this.style.padding = "2px 6px";
                });

                tituloEditavel.addEventListener("blur", function () {
                    this.style.backgroundColor = "transparent";
                    this.style.padding = "0";

                    // Salvar altera√ß√£o na persist√™ncia
                    salvarAlteracaoSeparador(
                        linhaDivisor,
                        this.textContent.trim(),
                    );
                });

                tituloEditavel.addEventListener("keydown", function (e) {
                    if (e.key === "Enter") {
                        e.preventDefault();
                        this.blur(); // For√ßa o blur para salvar
                    }
                    if (e.key === "Escape") {
                        e.preventDefault();
                        this.textContent = textoInicial; // Restaura valor original
                        this.blur();
                    }
                });

                // Adicionar tooltip com instru√ß√µes
                tituloEditavel.title =
                    "Clique para editar o nome do separador\n‚Ä¢ Enter: Salvar\n‚Ä¢ Escape: Cancelar";

                // Criar bot√£o para remover divisor (discreto, s√≥ aparece no hover)
                const botaoRemover = document.createElement("button");
                botaoRemover.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" height="16px" viewBox="0 -960 960 960" width="16px" fill="#374151"><path d="m350-281 130.19-130.19L610.37-281 679-349.63 548.81-479.81 679-610l-69-69-130.19 130.19L349.63-679 281-610.37l130.19 130.18L281-350l69 69ZM218.87-113.7q-43.63 0-74.4-30.77-30.77-30.77-30.77-74.4v-522.26q0-43.63 30.77-74.4 30.77-30.77 74.4-30.77h522.26q43.63 0 74.4 30.77 30.77 30.77 30.77 74.4v522.26q0 43.63-30.77 74.4-30.77 30.77-74.4 30.77H218.87Zm0-105.17h522.26v-522.26H218.87v522.26Zm0-522.26v522.26-522.26Z"/></svg>`;
                botaoRemover.style.cssText = `
            position: relative;
            top: 0;
            margin-left: 8px;
            border: none;
            background: transparent;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            line-height: 1;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            vertical-align: middle;
            padding: 4px;
        `;
                botaoRemover.title = "Remover divisor";

                // ‚ö° OTIMIZA√á√ÉO: CSS hover em vez de event listeners
                containerTitulo.classList.add("eprobe-container-hover");
                botaoRemover.classList.add("eprobe-remove-button");

                // Evento para remover divisor
                botaoRemover.addEventListener("click", function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    // Remover da persist√™ncia antes de remover do DOM
                    removerSeparadorDoPersistencia(linhaDivisor);

                    linhaDivisor.remove();
                    log("üóëÔ∏è LOCALIZADORES: Divisor removido");
                });

                // Adicionar elementos ao container
                containerTitulo.appendChild(iconeSeparador);
                containerTitulo.appendChild(tituloEditavel);
                containerTitulo.appendChild(botaoRemover);
                celulaDivisor.appendChild(containerTitulo);
                linhaDivisor.appendChild(celulaDivisor);

                // Inserir divisor na posi√ß√£o especificada
                log("üîß DEBUG: Inserindo divisor. linhaPosicao:", linhaPosicao);
                if (linhaPosicao && linhaPosicao.nextSibling) {
                    tbody.insertBefore(linhaDivisor, linhaPosicao.nextSibling);
                    log("üîß DEBUG: Divisor inserido ap√≥s linha espec√≠fica");
                } else {
                    tbody.appendChild(linhaDivisor);
                    log("üîß DEBUG: Divisor inserido no final da tabela");
                }

                logCritical("‚úÖ LOCALIZADORES: Divisor criado com sucesso");

                // Salvar separador na persist√™ncia (apenas se n√£o for uma restaura√ß√£o)
                if (!isRestoracao) {
                    salvarSeparadorNaPersistencia(
                        linhaDivisor,
                        textoInicial,
                        linhaPosicao,
                    );
                }

                return linhaDivisor;
            }

            // Fun√ß√£o para salvar separador na persist√™ncia
            function salvarSeparadorNaPersistencia(
                linhaDivisor,
                texto,
                linhaPosicao,
            ) {
                const tabela = linhaDivisor.closest("table");
                if (!tabela) return;

                const tbody = tabela.querySelector("tbody");
                const todasLinhas = Array.from(
                    tbody.querySelectorAll("tr:not(.eprobe-divisor-linha)"),
                );

                // Calcular posi√ß√£o baseada na linha de refer√™ncia
                let posicao = todasLinhas.length; // Por padr√£o, no final

                if (linhaPosicao) {
                    const indice = todasLinhas.findIndex(
                        (linha) => linha === linhaPosicao,
                    );
                    if (indice !== -1) {
                        posicao = indice + 1; // Posi√ß√£o ap√≥s a linha de refer√™ncia
                    }
                }

                const separadoresSalvos = carregarSeparadores();

                const novoSeparador = {
                    id: Date.now(), // ID √∫nico baseado em timestamp
                    texto: texto,
                    posicao: posicao,
                    criadoEm: new Date().toISOString(),
                };

                separadoresSalvos.push(novoSeparador);
                salvarSeparadores(separadoresSalvos);

                // Adicionar ID ao elemento para facilitar remo√ß√£o
                linhaDivisor.setAttribute(
                    "data-separador-id",
                    novoSeparador.id,
                );

                log(
                    "üíæ LOCALIZADORES: Separador salvo na persist√™ncia:",
                    novoSeparador,
                );
            }

            // Fun√ß√£o para remover separador da persist√™ncia
            function removerSeparadorDoPersistencia(linhaDivisor) {
                const separadorId =
                    linhaDivisor.getAttribute("data-separador-id");
                if (!separadorId) return;

                const separadoresSalvos = carregarSeparadores();
                const separadoresFiltrados = separadoresSalvos.filter(
                    (sep) => sep.id != separadorId,
                );

                salvarSeparadores(separadoresFiltrados);
                log(
                    "üóëÔ∏è LOCALIZADORES: Separador removido da persist√™ncia:",
                    separadorId,
                );
            }

            // Fun√ß√£o para salvar altera√ß√£o no texto do separador
            function salvarAlteracaoSeparador(linhaDivisor, novoTexto) {
                const separadorId =
                    linhaDivisor.getAttribute("data-separador-id");
                if (!separadorId || !novoTexto) return;

                const separadoresSalvos = carregarSeparadores();
                const separadorIndex = separadoresSalvos.findIndex(
                    (sep) => sep.id == separadorId,
                );

                if (separadorIndex !== -1) {
                    separadoresSalvos[separadorIndex].texto = novoTexto;
                    separadoresSalvos[separadorIndex].modificadoEm =
                        new Date().toISOString();

                    salvarSeparadores(separadoresSalvos);
                    log(
                        `üìù LOCALIZADORES: Separador ${separadorId} atualizado para: "${novoTexto}"`,
                    );
                }
            }

            // Fun√ß√£o para limpar todos os separadores salvos (√∫til para debug/reset)
            function limparTodosSeparadores() {
                try {
                    const chave = "eprobe_separadores_localizadores";
                    const chaveRemovidos = "eprobe_separadores_removidos";

                    localStorage.removeItem(chave);
                    localStorage.removeItem(chaveRemovidos);

                    log(
                        "üßπ LOCALIZADORES: Todos os separadores e lista de removidos foram limpos do localStorage",
                    );

                    // Remover tamb√©m do DOM se estiver na p√°gina
                    const separadoresExistentes = document.querySelectorAll(
                        ".eprobe-divisor-linha",
                    );
                    separadoresExistentes.forEach((separador) =>
                        separador.remove(),
                    );

                    return true;
                } catch (error) {
                    console.error(
                        "‚ùå LOCALIZADORES: Erro ao limpar separadores:",
                        error,
                    );
                    return false;
                }
            }

            // Sistema robusto de cria√ß√£o de bot√£o com m√∫ltiplas tentativas
            let buttonCreationAttempts = 0;
            const MAX_BUTTON_CREATION_ATTEMPTS = 5;

            function ensureButtonExists() {
                // Verificar se j√° existe algum bot√£o
                const existingButton =
                    document.getElementById(
                        "documento-relevante-auto-button",
                    ) || document.getElementById("sent1-auto-button");

                if (existingButton) {
                    log("‚úÖ BOT√ÉO: J√° existe, cancelando verifica√ß√£o");
                    buttonCreationAttempts = 0;
                    return true;
                }

                // Incrementar tentativas
                buttonCreationAttempts++;

                if (buttonCreationAttempts > MAX_BUTTON_CREATION_ATTEMPTS) {
                    log(
                        "‚ö†Ô∏è BOT√ÉO: M√°ximo de tentativas atingido, parando verifica√ß√£o",
                    );
                    return false;
                }

                log(
                    `üîÑ BOT√ÉO: Tentativa ${buttonCreationAttempts}/${MAX_BUTTON_CREATION_ATTEMPTS} de cria√ß√£o`,
                );

                // Verificar se a p√°gina atende aos crit√©rios
                let shouldShowIntegrated = false;
                let shouldShowFloating = false;

                try {
                    if (typeof shouldShowIntegratedButton === "function") {
                        shouldShowIntegrated = shouldShowIntegratedButton();
                    }
                    if (typeof shouldShowFloatingButton === "function") {
                        shouldShowFloating = shouldShowFloatingButton();
                    }
                } catch (e) {
                    console.warn(
                        "‚ö†Ô∏è Erro ao verificar crit√©rios dos bot√µes:",
                        e.message,
                    );
                }

                log("üîç BOT√ÉO: Crit√©rios de valida√ß√£o:", {
                    shouldShowIntegrated,
                    shouldShowFloating,
                    pageUrl: window.location.href,
                });

                if (shouldShowIntegrated || shouldShowFloating) {
                    createAutomationButton();

                    // Verificar se foi criado com sucesso ap√≥s um pequeno delay
                    setTimeout(() => {
                        const buttonAfterCreation =
                            document.getElementById(
                                "documento-relevante-auto-button",
                            ) || document.getElementById("sent1-auto-button");

                        if (buttonAfterCreation) {
                            logCritical("‚úÖ BOT√ÉO: Criado com sucesso");
                            buttonCreationAttempts = 0;
                        } else {
                            log(
                                "‚ö†Ô∏è BOT√ÉO: Falha na cria√ß√£o, tentando novamente com backoff",
                            );
                            // Backoff exponencial baseado nas tentativas
                            const backoffDelay = Math.min(
                                1000 *
                                    Math.pow(1.5, buttonCreationAttempts - 1),
                                5000,
                            );
                            setTimeout(ensureButtonExists, backoffDelay);
                        }
                    }, 200);
                } else {
                    log(
                        "‚ùå BOT√ÉO: P√°gina n√£o atende aos crit√©rios, tentando novamente com backoff",
                    );
                    // Backoff exponencial para p√°ginas que ainda est√£o carregando
                    const backoffDelay = Math.min(
                        2000 * Math.pow(1.2, buttonCreationAttempts - 1),
                        8000,
                    );
                    setTimeout(ensureButtonExists, backoffDelay);
                }

                return false;
            }

            // Fun√ß√£o melhorada para verificar se deve mostrar o bot√£o integrado
            function shouldShowIntegratedButton() {
                // Verifica√ß√µes b√°sicas de URL
                const url = window.location.href;
                if (
                    !url.includes("eproc") ||
                    (!url.includes("processo") && !url.includes("documento"))
                ) {
                    log(
                        "‚ùå BOT√ÉO INTEGRADO: URL n√£o cont√©m eproc + processo/documento",
                    );
                    return false;
                }

                // Verificar t√≠tulo da p√°gina
                const h1Element = document.querySelector("h1");
                if (h1Element) {
                    const titleText = h1Element.textContent.trim();
                    const hasCorrectTitle =
                        titleText ===
                        "Consulta Processual - Detalhes do Processo";

                    log("üîç BOT√ÉO INTEGRADO: Verificando t√≠tulo:", {
                        titleFound: titleText,
                        isCorrect: hasCorrectTitle,
                    });

                    if (hasCorrectTitle) {
                        return true;
                    }
                }

                // Verifica√ß√µes alternativas para p√°ginas de documento
                const hasFormProcesso =
                    !!document.querySelector("#frmProcessoLista");
                const hasDocumentContent = !!document.querySelector(
                    '[href*="acessar_documento"]',
                );
                const hasMinutasContent = !!document.querySelector(
                    "#conteudoMinutas, #fldMinutas",
                );

                log("üîç BOT√ÉO INTEGRADO: Verifica√ß√µes alternativas:", {
                    hasFormProcesso,
                    hasDocumentContent,
                    hasMinutasContent,
                });

                return (
                    hasFormProcesso || hasDocumentContent || hasMinutasContent
                );
            }

            // Fun√ß√£o melhorada para verificar se deve mostrar o bot√£o flutuante
            function shouldShowFloatingButton() {
                // Se deve mostrar bot√£o integrado, n√£o mostrar flutuante
                try {
                    if (
                        typeof shouldShowIntegratedButton === "function" &&
                        shouldShowIntegratedButton()
                    ) {
                        return false;
                    }
                } catch (e) {
                    console.warn(
                        "‚ö†Ô∏è Erro ao verificar shouldShowIntegratedButton:",
                        e.message,
                    );
                }

                const url = window.location.href;

                // Verificar se √© uma p√°gina de documento espec√≠fico
                if (
                    url.includes("acessar_documento") ||
                    url.includes("processo_consultar_externo_documento")
                ) {
                    log(
                        "‚úÖ BOT√ÉO FLUTUANTE: P√°gina de documento espec√≠fico detectada",
                    );
                    return true;
                }

                // Verificar conte√∫do da p√°gina
                const pageHTML = document.documentElement.outerHTML;
                const hasDocumentHtml = pageHTML.includes(
                    "acessar_documento&id",
                );
                const hasDocumentPdf = pageHTML.includes(
                    "acessar_documento&amp",
                );
                const hasDocumentLinks = !!document.querySelector(
                    '[href*="SENT"], [href*="INIC"], [href*="DECI"]',
                );

                log("üîç BOT√ÉO FLUTUANTE: Verificando crit√©rios:", {
                    hasDocumentHtml,
                    hasDocumentPdf,
                    hasDocumentLinks,
                    shouldShow:
                        hasDocumentHtml || hasDocumentPdf || hasDocumentLinks,
                    url,
                });

                return hasDocumentHtml || hasDocumentPdf || hasDocumentLinks;
            }

            // Fun√ß√£o aprimorada para encontrar descri√ß√£o do evento
            function findEventDescription(linkElement) {
                const strategies = [
                    () => findEventDescriptionInSameRow(linkElement),
                    () => findEventDescriptionInPreviousRows(linkElement),
                    () => findEventDescriptionByTextPattern(linkElement),
                    () => findEventDescriptionInTableStructure(linkElement),
                    () => findEventDescriptionByProximity(linkElement),
                ];

                for (let i = 0; i < strategies.length; i++) {
                    try {
                        log(`Executando estrat√©gia ${i + 1} para descri√ß√£o...`);
                        const result = strategies[i]();
                        if (result && result.trim().length > 3) {
                            log(`Estrat√©gia ${i + 1} bem-sucedida:`, result);
                            return result.trim();
                        }
                    } catch (e) {
                        log(`Erro na estrat√©gia ${i + 1}:`, e);
                    }
                }

                log("Nenhuma estrat√©gia encontrou descri√ß√£o v√°lida");
                return "";
            }

            // Estrat√©gia 1: Buscar na mesma linha do link
            function findEventDescriptionInSameRow(linkElement) {
                const currentRow = linkElement.closest("tr");
                if (!currentRow) return "";

                log("Buscando na linha atual...");

                // Buscar por seletores conhecidos
                const selectors = [
                    "td.infraEventoDescricao",
                    "label.infraEventoDescricao",
                    "td[class*='evento'][class*='descricao']",
                    "td[class*='Evento'][class*='Descricao']",
                ];

                for (const selector of selectors) {
                    const element = currentRow.querySelector(selector);
                    if (element) {
                        const text = element.textContent.trim();
                        if (text && !text.toLowerCase().includes("sent")) {
                            log(`Encontrado via seletor ${selector}:`, text);
                            return text;
                        }
                    }
                }

                return "";
            }

            // Estrat√©gia 2: Buscar em linhas anteriores (evento pode estar em linha separada)
            function findEventDescriptionInPreviousRows(linkElement) {
                const currentRow = linkElement.closest("tr");
                if (!currentRow) return "";

                log("Buscando em linhas anteriores...");

                let previousRow = currentRow.previousElementSibling;
                let attempts = 0;

                while (previousRow && attempts < 10) {
                    attempts++;

                    // Verificar se esta linha cont√©m descri√ß√£o de evento
                    const eventDescSelectors = [
                        "td.infraEventoDescricao",
                        "label.infraEventoDescricao",
                        "td[class*='evento']",
                        "td[class*='Evento']",
                    ];

                    for (const selector of eventDescSelectors) {
                        const element = previousRow.querySelector(selector);
                        if (element) {
                            const text = element.textContent.trim();
                            if (
                                text &&
                                text.length > 5 &&
                                !text.toLowerCase().includes("sent")
                            ) {
                                log(
                                    `Encontrado em linha anterior (${attempts}):`,
                                    text,
                                );
                                return text;
                            }
                        }
                    }

                    previousRow = previousRow.previousElementSibling;
                }

                return "";
            }

            // Estrat√©gia 3: Buscar por padr√µes de texto t√≠picos de descri√ß√£o de evento
            function findEventDescriptionByTextPattern(linkElement) {
                const currentRow = linkElement.closest("tr");
                if (!currentRow) return "";

                log("Buscando por padr√µes de texto...");

                // Expandir busca para linhas pr√≥ximas
                const rowsToCheck = [];

                // Adicionar linha atual
                rowsToCheck.push(currentRow);

                // Adicionar linhas anteriores
                let prevRow = currentRow.previousElementSibling;
                for (let i = 0; i < 5 && prevRow; i++) {
                    rowsToCheck.unshift(prevRow);
                    prevRow = prevRow.previousElementSibling;
                }

                // Adicionar linhas posteriores
                let nextRow = currentRow.nextElementSibling;
                for (let i = 0; i < 2 && nextRow; i++) {
                    rowsToCheck.push(nextRow);
                    nextRow = nextRow.nextElementSibling;
                }

                // Padr√µes que indicam descri√ß√£o de evento judicial
                const eventPatterns = [
                    /julgamento/i,
                    /decis√£o/i,
                    /senten√ßa/i,
                    /prola√ß√£o/i,
                    /publica√ß√£o/i,
                    /audi√™ncia/i,
                    /despacho/i,
                    /determina√ß√£o/i,
                    /intima√ß√£o/i,
                    /cita√ß√£o/i,
                    /distribui√ß√£o/i,
                    /remessa/i,
                    /devolu√ß√£o/i,
                    /conclus√£o/i,
                ];

                for (const row of rowsToCheck) {
                    const cells = row.querySelectorAll("td");
                    for (const cell of cells) {
                        const text = cell.textContent.trim();

                        // Verificar se o texto tem tamanho razo√°vel e cont√©m padr√µes de evento
                        if (text.length > 10 && text.length < 200) {
                            for (const pattern of eventPatterns) {
                                if (
                                    pattern.test(text) &&
                                    !text.toLowerCase().includes("sent1")
                                ) {
                                    log(
                                        `Encontrado por padr√£o "${pattern}":`,
                                        text,
                                    );
                                    return text;
                                }
                            }
                        }
                    }
                }

                return "";
            }

            // Estrat√©gia 4: Analisar estrutura da tabela para encontrar coluna de descri√ß√£o
            function findEventDescriptionInTableStructure(linkElement) {
                const table = linkElement.closest("table");
                if (!table) return "";

                log("Analisando estrutura da tabela...");

                const currentRow = linkElement.closest("tr");
                const linkCellIndex = Array.from(currentRow.cells).findIndex(
                    (cell) => cell.contains(linkElement),
                );

                // Buscar na mesma linha, mas em c√©lulas que podem conter descri√ß√£o
                for (let i = 0; i < currentRow.cells.length; i++) {
                    if (i === linkCellIndex) continue; // Pular c√©lula do link

                    const cell = currentRow.cells[i];
                    const text = cell.textContent.trim();

                    // Verificar se parece uma descri√ß√£o (texto m√©dio, n√£o apenas n√∫meros/datas)
                    if (text.length > 15 && text.length < 150) {
                        // Verificar se n√£o √© apenas data, n√∫meros ou links
                        if (
                            !/^\d+[\d\/\-\s]*$/.test(text) &&
                            !text.toLowerCase().includes("sent") &&
                            !/^https?:\/\//.test(text)
                        ) {
                            log(
                                `Encontrado na estrutura da tabela (c√©lula ${i}):`,
                                text,
                            );
                            return text;
                        }
                    }
                }

                return "";
            }

            // Estrat√©gia 5: Buscar por proximidade usando XPath-like logic
            function findEventDescriptionByProximity(linkElement) {
                log("Buscando por proximidade...");

                // Buscar elementos pr√≥ximos que podem conter descri√ß√£o
                const parent =
                    linkElement.closest("td") || linkElement.closest("tr");
                if (!parent) return "";

                // Buscar em elementos irm√£os
                const siblings = parent.parentElement
                    ? Array.from(parent.parentElement.children)
                    : [];

                for (const sibling of siblings) {
                    if (sibling === parent) continue;

                    const text = sibling.textContent.trim();
                    if (
                        text.length > 20 &&
                        text.length < 200 &&
                        !text.toLowerCase().includes("sent") &&
                        !/^\d+[\d\/\-\s]*$/.test(text)
                    ) {
                        // Verificar se cont√©m palavras t√≠picas de processo judicial
                        if (
                            /julgamento|decis√£o|senten√ßa|audi√™ncia|despacho|intima√ß√£o|publica√ß√£o|prola√ß√£o/i.test(
                                text,
                            )
                        ) {
                            log(`Encontrado por proximidade:`, text);
                            return text;
                        }
                    }
                }

                return "";
            } // Encontrar documentos relevantes com informa√ß√µes detalhadas
            function findDocumentosRelevantes() {
                const pageType = detectPageType();
                log(` Tipo de p√°gina detectado: ${pageType}`);

                // DEBUG: Mostrar tipos configurados
                const tiposConfigurados = Object.values(
                    TIPOS_DOCUMENTO_RELEVANTE,
                ).map((t) => t.nome);
                console.log(
                    `üîç DEBUG FIND: Tipos configurados:`,
                    tiposConfigurados,
                );

                // Estrat√©gias m√∫ltiplas para encontrar documentos relevantes
                const estrategias = [
                    // Estrat√©gia 1: Seletores espec√≠ficos do eProc com data-nome
                    () => {
                        const selectors = Object.values(
                            TIPOS_DOCUMENTO_RELEVANTE,
                        )
                            .map((tipo) => [
                                `a.infraLinkDocumento[data-nome="${tipo.dataNome}"]`,
                                `a[data-nome="${tipo.dataNome}"]`,
                                `a.infraLinkDocumento[data-nome*="${tipo.dataNome}"]`,
                            ])
                            .flat()
                            .join(", ");

                        console.log(
                            `üîç DEBUG ESTRAT√âGIA 1: Seletores:`,
                            selectors.substring(0, 200) + "...",
                        );
                        const elementos = document.querySelectorAll(selectors);
                        console.log(
                            `üîç DEBUG ESTRAT√âGIA 1: Encontrou ${elementos.length} elementos`,
                        );

                        return elementos;
                    },

                    // Estrat√©gia 2: Buscar por texto dos links que COMECE com os tipos esperados
                    () => {
                        const tiposValidos = Object.values(
                            TIPOS_DOCUMENTO_RELEVANTE,
                        ).map((t) => t.nome);
                        const todosLinks = document.querySelectorAll(
                            'a.infraLinkDocumento, a[href*="documento"]',
                        );

                        console.log(
                            `üîç DEBUG ESTRAT√âGIA 2: Encontrados ${todosLinks.length} links para testar`,
                        );

                        const filtrados = Array.from(todosLinks).filter(
                            (link) => {
                                const texto = link.textContent.trim();
                                const textoNormalizado = normalizarTexto(texto);

                                // DEBUG: Mostrar todos os textos dos links
                                if (texto.length < 50) {
                                    // Evitar logs muito longos
                                    console.log(
                                        `  üìù Testando link: "${texto}" -> normalizado: "${textoNormalizado}"`,
                                    );
                                }

                                // Verificar se o texto COME√áA com algum dos tipos v√°lidos
                                const resultado = tiposValidos.some((tipo) => {
                                    const tipoNormalizado =
                                        normalizarTexto(tipo);
                                    const match =
                                        textoNormalizado.startsWith(
                                            tipoNormalizado,
                                        ) ||
                                        new RegExp(
                                            `^[\\s\\-_]*${tipoNormalizado}\\d*`,
                                            "i",
                                        ).test(textoNormalizado);

                                    if (match) {
                                        console.log(
                                            `    ‚úÖ MATCH com tipo "${tipo}": "${texto}"`,
                                        );
                                    }

                                    return match;
                                });

                                return resultado;
                            },
                        );

                        console.log(
                            `üîç DEBUG ESTRAT√âGIA 2: ${filtrados.length} links passaram no filtro`,
                        );
                        return filtrados;
                    },

                    // Estrat√©gia 3: Buscar em tabelas de eventos com valida√ß√£o estrita do texto
                    () => {
                        const linksEmTabelas = document.querySelectorAll(
                            'table a[href*="documento"], table a.infraLinkDocumento',
                        );
                        const tiposValidos = Object.values(
                            TIPOS_DOCUMENTO_RELEVANTE,
                        ).map((t) => t.nome);
                        return Array.from(linksEmTabelas).filter((link) => {
                            const texto = link.textContent.trim().toUpperCase();
                            // Valida√ß√£o estrita: texto deve come√ßar com um dos tipos v√°lidos
                            return tiposValidos.some(
                                (tipo) =>
                                    texto.startsWith(tipo) ||
                                    new RegExp(
                                        `^[\\s\\-_]*${tipo}\\d*`,
                                        "i",
                                    ).test(texto),
                            );
                        });
                    },
                ];

                let links = [];
                let estrategiaUsada = 0;

                // Testar TODAS as estrat√©gias e combinar resultados (sem duplicatas)
                const todosLinks = [];
                const linksSeen = new Set(); // Para evitar duplicatas

                for (let i = 0; i < estrategias.length; i++) {
                    try {
                        console.log(
                            `üîç DEBUG: Testando Estrat√©gia ${i + 1}...`,
                        );
                        const resultados = estrategias[i]();
                        console.log(
                            `üîç DEBUG: Estrat√©gia ${i + 1} retornou ${
                                resultados ? resultados.length : 0
                            } resultados`,
                        );

                        if (resultados && resultados.length > 0) {
                            // Adicionar resultados sem duplicatas
                            Array.from(resultados).forEach((link) => {
                                const href = link.getAttribute("href");
                                if (href && !linksSeen.has(href)) {
                                    linksSeen.add(href);
                                    todosLinks.push(link);
                                }
                            });

                            if (estrategiaUsada === 0) {
                                estrategiaUsada = i + 1; // Registrar primeira estrat√©gia que encontrou algo
                            }
                        }
                    } catch (error) {
                        console.log(
                            `‚ùå DEBUG: Estrat√©gia ${i + 1} ERRO:`,
                            error,
                        );
                        log(`‚ùå Estrat√©gia ${i + 1} falhou:`, error);
                    }
                }

                links = todosLinks;
                console.log(
                    `‚úÖ DEBUG: Total de ${links.length} links √öNICOS encontrados de todas as estrat√©gias`,
                );
                log(
                    `‚úÖ Total de ${links.length} links encontrados (estrat√©gia prim√°ria: ${estrategiaUsada})`,
                );

                log(
                    ` Links de documentos relevantes encontrados: ${links.length} (estrat√©gia ${estrategiaUsada})`,
                );

                if (links.length === 0) {
                    // Debug detalhado quando n√£o encontrar nada
                    log(
                        "üîç DEBUG: Nenhum documento encontrado. Analisando p√°gina...",
                    );
                    log("üìä AN√ÅLISE DA P√ÅGINA:");
                    log(
                        "  - Todos os links:",
                        document.querySelectorAll("a").length,
                    );
                    log(
                        "  - Links com classe infraLinkDocumento:",
                        document.querySelectorAll("a.infraLinkDocumento")
                            .length,
                    );
                    log(
                        "  - Links com href contendo 'documento':",
                        document.querySelectorAll('a[href*="documento"]')
                            .length,
                    );
                    log(
                        "  - Elementos com data-nome:",
                        document.querySelectorAll("[data-nome]").length,
                    );

                    // Buscar patterns espec√≠ficos no DOM
                    const todosLinks = Array.from(
                        document.querySelectorAll("a"),
                    );
                    const linksSuspeitos = todosLinks.filter((link) => {
                        const texto = link.textContent.trim().toUpperCase();
                        const href = link.getAttribute("href") || "";
                        return ["SENT", "INIC", "DECI", "DESP", "PETI"].some(
                            (tipo) =>
                                texto.includes(tipo) ||
                                href.toUpperCase().includes(tipo),
                        );
                    });

                    log(
                        "üìã Links suspeitos encontrados:",
                        linksSuspeitos.length,
                    );
                    linksSuspeitos.forEach((link, i) => {
                        log(
                            `  ${
                                i + 1
                            }. "${link.textContent.trim()}" -> ${link.getAttribute(
                                "href",
                            )}`,
                        );
                    });
                }

                const documentosData = [];

                // PRIMEIRA ETAPA: Coletar informa√ß√µes b√°sicas dos links
                links.forEach((link, i) => {
                    const texto = link.textContent.trim();
                    const href = link.getAttribute("href");

                    log(` DOC ${i + 1}:`, {
                        texto: texto,
                        href: href,
                        dataId: link.getAttribute("data-id"),
                        onClick: link.getAttribute("onclick"),
                        element: link,
                    });

                    // Verificar se √© um dos tipos configurados - valida√ß√£o ESTRITA
                    const tipoEncontrado = Object.values(
                        TIPOS_DOCUMENTO_RELEVANTE,
                    ).find((tipo) => {
                        const textoNormalizado = normalizarTexto(texto);
                        const tipoNormalizado = normalizarTexto(tipo.nome);
                        // Aceitar apenas se:
                        // 1. Texto √© exatamente o tipo (ex: "SENT", "RAZAPELA1", "APELACAO1")
                        // 2. Texto come√ßa com o tipo seguido de espa√ßo (ex: "SENT - ", "APELACAO1 - ")
                        // 3. Texto come√ßa com o tipo seguido de n√∫mero (ex: "SENT1", "APELACAO1")
                        // Regex ajustada para aceitar qualquer quantidade de letras mai√∫sculas + d√≠gitos
                        return (
                            textoNormalizado === tipoNormalizado ||
                            textoNormalizado.startsWith(
                                tipoNormalizado + " ",
                            ) ||
                            (/^[A-Z]+\d+/.test(textoNormalizado) &&
                                textoNormalizado.startsWith(tipoNormalizado))
                        );
                    });

                    if (tipoEncontrado) {
                        // Extrair informa√ß√µes do tooltip para diferenciar as senten√ßas
                        const onmouseover =
                            link.getAttribute("onmouseover") || "";
                        const dadosIconLink =
                            href.match(/dadosIconLink=([^&]+)/)?.[1] || "";

                        // Tentar extrair n√∫mero do evento da URL
                        const eventoMatch = href.match(/evento=([^&]+)/);
                        const docMatch = href.match(/doc=([^&]+)/);
                        const seqEventoMatch =
                            href.match(/numSeqEvento.*?(\d+)/);

                        // Extrair informa√ß√µes do tooltip se dispon√≠vel
                        let tipoDocumento = "";
                        let tamanho = "";
                        let seqEvento = "";

                        if (onmouseover.includes("infraTooltipMostrar")) {
                            const tooltipMatch = onmouseover.match(
                                /infraTooltipMostrar\('([^']+)'/,
                            );
                            if (tooltipMatch) {
                                const tooltipContent = tooltipMatch[1];
                                const tipoMatch = tooltipContent.match(
                                    /Tipo Documento:.*?<font[^>]*>([^<]+)/,
                                );
                                const tamanhoMatch = tooltipContent.match(
                                    /Tamanho:.*?<font[^>]*>([^<]+)/,
                                );

                                if (tipoMatch)
                                    tipoDocumento = tipoMatch[1].trim();
                                if (tamanhoMatch)
                                    tamanho = tamanhoMatch[1].trim();
                            }
                        }

                        // Tentar extrair sequ√™ncia do evento dos dados codificados
                        if (dadosIconLink) {
                            try {
                                const decoded = atob(dadosIconLink);
                                const seqMatch = decoded.match(
                                    /"numSeqEvento";s:\d+:"(\d+)"/,
                                );
                                if (seqMatch) seqEvento = seqMatch[1];
                            } catch (e) {
                                log(" Erro ao decodificar dadosIconLink:", e);
                            }
                        }

                        // Armazenar dados b√°sicos do link
                        documentosData.push({
                            element: link,
                            href: href,
                            texto: texto,
                            tipo: tipoEncontrado,
                            eventoId: eventoMatch?.[1] || "",
                            docId: docMatch?.[1] || "",
                            seqEvento: seqEvento || seqEventoMatch?.[1] || "",
                            tipoDocumento:
                                tipoDocumento || tipoEncontrado.descricao,
                            tamanho: tamanho || "",
                            index: i + 1,
                        });

                        log(
                            ` Documento encontrado: ${texto} (${tipoEncontrado.descricao})!`,
                            {
                                index: i + 1,
                                url: href,
                                eventoId: eventoMatch?.[1],
                                seqEvento: seqEvento,
                                tipoDocumento: tipoDocumento,
                                tamanho: tamanho,
                            },
                        );
                    }
                });

                // SEGUNDA ETAPA: Se estivermos na p√°gina da lista de documentos, buscar as descri√ß√µes dos eventos
                if (
                    pageType === "lista_documentos" &&
                    documentosData.length > 0
                ) {
                    log(
                        " P√°gina da lista de documentos detectada - buscando descri√ß√µes dos eventos...",
                    );

                    // Para cada documento relevante, encontrar a descri√ß√£o na mesma linha (tr)
                    documentosData.forEach((linkData, index) => {
                        log(
                            ` Buscando descri√ß√£o para documento #${
                                index + 1
                            }...`,
                        );

                        let eventoDescricao = "";
                        let eventoData = "";
                        let eventoMagistrado = "";
                        const linkElement = linkData.element; // Encontrar a linha (tr) do evento que cont√©m o link
                        // O link est√° em uma tabela aninhada, ent√£o precisamos buscar o tr principal
                        const eventRow =
                            linkElement.closest("tr[id^='trEvento']") ||
                            linkElement.closest("tr[id*='Evento']") ||
                            linkElement.closest("tr[data-parte]");

                        if (eventRow) {
                            log(
                                ` Link est√° na linha do evento: ${
                                    eventRow.id ||
                                    eventRow.getAttribute("data-parte") ||
                                    "identificador n√£o encontrado"
                                }`,
                            );

                            // Buscar a c√©lula de descri√ß√£o do evento na mesma linha
                            const eventDescCell = eventRow.querySelector(
                                "td.infraEventoDescricao",
                            );

                            if (eventDescCell) {
                                eventoDescricao =
                                    eventDescCell.textContent.trim();
                                log(
                                    `üìù Descri√ß√£o encontrada na linha do evento: "${eventoDescricao}"`,
                                );
                            } else {
                                log(
                                    "‚ö†Ô∏è C√©lula td.infraEventoDescricao n√£o encontrada na linha do evento",
                                );

                                // Fallback: buscar qualquer elemento com classe infraEventoDescricao na linha
                                const fallbackDescElement =
                                    eventRow.querySelector(
                                        ".infraEventoDescricao",
                                    );
                                if (fallbackDescElement) {
                                    eventoDescricao =
                                        fallbackDescElement.textContent.trim();
                                    log(
                                        `üìù Descri√ß√£o encontrada via fallback: "${eventoDescricao}"`,
                                    );
                                } else {
                                    // Debug: mostrar todas as c√©lulas da linha para entender a estrutura
                                    const allCells =
                                        eventRow.querySelectorAll("td");
                                    log(
                                        `üîç Debug - Total de c√©lulas na linha: ${allCells.length}`,
                                    );
                                    allCells.forEach((cell, index) => {
                                        log(
                                            `üìã C√©lula ${
                                                index + 1
                                            }: "${cell.textContent
                                                .trim()
                                                .substring(0, 50)}" (classe: ${
                                                cell.className
                                            })`,
                                        );
                                    });
                                }
                            }

                            // Buscar informa√ß√µes do magistrado/vara
                            // DOM real: td > div > label.infraEventoUsuario (classe esta na label, nao na td)
                            const magistradoCell =
                                eventRow.querySelector(
                                    "label.infraEventoUsuario",
                                ) ||
                                eventRow.querySelector(
                                    "td:has(label.infraEventoUsuario)",
                                );

                            log(
                                `üîç Debug Magistrado - C√©lula encontrada: ${!!magistradoCell} (${
                                    magistradoCell
                                        ? magistradoCell.tagName.toLowerCase()
                                        : "N/A"
                                })`,
                            );
                            if (magistradoCell) {
                                log(
                                    `üîç Debug Magistrado - Elemento: <${magistradoCell.tagName.toLowerCase()}> com classe: ${
                                        magistradoCell.className
                                    }`,
                                );
                                log(
                                    `üîç Debug Magistrado - Conte√∫do da c√©lula: "${magistradoCell.textContent.trim()}"`,
                                );

                                const onmouseoverAttr =
                                    magistradoCell.getAttribute("onmouseover");
                                const titleAttr =
                                    magistradoCell.getAttribute("title");
                                const tooltipAttr =
                                    magistradoCell.getAttribute("data-tooltip");

                                log(
                                    `üîç Debug Magistrado - Atributo onmouseover: ${!!onmouseoverAttr}`,
                                );
                                log(
                                    `üîç Debug Magistrado - Atributo title: ${!!titleAttr}`,
                                );
                                log(
                                    `üîç Debug Magistrado - Atributo data-tooltip: ${!!tooltipAttr}`,
                                );

                                // Tentar extrair de onmouseover primeiro
                                if (onmouseoverAttr) {
                                    log(
                                        `üîç Debug Magistrado - Conte√∫do onmouseover: "${onmouseoverAttr}"`,
                                    );

                                    // Estrat√©gias m√∫ltiplas para extrair o texto do magistrado
                                    let magistradoEncontrado = false;

                                    // Estrat√©gia 1 ESPEC√çFICA: carregarInfoUsuarioOutroGrau com estrutura HTML
                                    if (
                                        onmouseoverAttr.includes(
                                            "carregarInfoUsuarioOutroGrau",
                                        )
                                    ) {
                                        const carregarMatch =
                                            onmouseoverAttr.match(
                                                /carregarInfoUsuarioOutroGrau\(['"]([^'"]+)['"][\)\;]/,
                                            );
                                        if (carregarMatch && carregarMatch[1]) {
                                            let textoCompleto =
                                                carregarMatch[1];

                                            // Decodificar HTML entities
                                            textoCompleto =
                                                textoCompleto.replace(
                                                    /&lt;/g,
                                                    "<",
                                                );
                                            textoCompleto =
                                                textoCompleto.replace(
                                                    /&gt;/g,
                                                    ">",
                                                );
                                            textoCompleto =
                                                textoCompleto.replace(
                                                    /&amp;/g,
                                                    "&",
                                                );

                                            // Dividir por <br/> para obter partes estruturadas
                                            const partes = textoCompleto
                                                .split(/<br\s*\/?>/i)
                                                .map((p) => p.trim())
                                                .filter((p) => p);

                                            log(
                                                `üîç Estrat√©gia 1 ESPEC√çFICA - Partes encontradas: ${JSON.stringify(
                                                    partes,
                                                )}`,
                                            );

                                            // Estrutura t√≠pica: [NOME, TIPO, VARA]
                                            if (partes.length >= 3) {
                                                const nome = partes[0].trim();
                                                const tipo = partes[1].trim();
                                                const vara = partes[2].trim();

                                                // Criar objeto estruturado com informa√ß√µes corretas
                                                eventoMagistrado = {
                                                    nome: nome,
                                                    tipo: tipo.toLowerCase(), // ‚úÖ Normalizar para min√∫sculo
                                                    vara: vara,
                                                    textoCompleto: `${nome} (${tipo}) - ${vara}`,
                                                };

                                                magistradoEncontrado = true;
                                                log(
                                                    `üîç Estrat√©gia 1 ESPEC√çFICA - Magistrado estruturado: ${JSON.stringify(
                                                        eventoMagistrado,
                                                    )}`,
                                                );
                                            } else if (partes.length >= 2) {
                                                // Fallback: pelo menos nome e uma informa√ß√£o adicional
                                                eventoMagistrado = {
                                                    nome: partes[0].trim(),
                                                    tipo: partes[1]
                                                        .trim()
                                                        .toLowerCase(), // ‚úÖ Normalizar para min√∫sculo
                                                    vara: null,
                                                    textoCompleto:
                                                        partes.join(" - "),
                                                };
                                                magistradoEncontrado = true;
                                                log(
                                                    `üîç Estrat√©gia 1 ESPEC√çFICA - Magistrado parcial: ${JSON.stringify(
                                                        eventoMagistrado,
                                                    )}`,
                                                );
                                            }
                                        }
                                    }

                                    // Estrat√©gia 2: Texto entre aspas simples ou duplas (fallback)
                                    if (!magistradoEncontrado) {
                                        const magistradoMatch1 =
                                            onmouseoverAttr.match(
                                                /['"]([^'"]+)['"]/,
                                            );
                                        if (
                                            magistradoMatch1 &&
                                            magistradoMatch1[1]
                                        ) {
                                            eventoMagistrado =
                                                magistradoMatch1[1].trim();
                                            magistradoEncontrado = true;
                                            log(
                                                `üîç Estrat√©gia 2 - Magistrado/Vara encontrado: "${eventoMagistrado}"`,
                                            );
                                        }
                                    }

                                    // Estrat√©gia 3: Texto ap√≥s "infraTooltipMostrar"
                                    // Estrat√©gia 3: Texto ap√≥s "infraTooltipMostrar"
                                    if (!magistradoEncontrado) {
                                        const magistradoMatch2 =
                                            onmouseoverAttr.match(
                                                /infraTooltipMostrar\(['"]([^'"]+)['"]\)/,
                                            );
                                        if (
                                            magistradoMatch2 &&
                                            magistradoMatch2[1]
                                        ) {
                                            eventoMagistrado =
                                                magistradoMatch2[1].trim();
                                            magistradoEncontrado = true;
                                            log(
                                                `üîç Estrat√©gia 3 - Magistrado/Vara encontrado: "${eventoMagistrado}"`,
                                            );
                                        }
                                    }

                                    // Estrat√©gia 4: Qualquer texto que pare√ßa nome/cargo entre par√™nteses ou tags
                                    // Estrat√©gia 4: Qualquer texto que pare√ßa nome/cargo entre par√™nteses ou tags
                                    if (!magistradoEncontrado) {
                                        const magistradoMatch3 =
                                            onmouseoverAttr.match(
                                                />\s*([^<>]+(?:juiz|magistrad|vara|gabinete)[^<>]*)\s*</i,
                                            );
                                        if (
                                            magistradoMatch3 &&
                                            magistradoMatch3[1]
                                        ) {
                                            eventoMagistrado =
                                                magistradoMatch3[1].trim();
                                            magistradoEncontrado = true;
                                            log(
                                                `üîç Estrat√©gia 4 - Magistrado/Vara encontrado: "${eventoMagistrado}"`,
                                            );
                                        }
                                    }

                                    // Estrat√©gia 5: Fallback - qualquer texto substancial
                                    // Estrat√©gia 5: Fallback - qualquer texto substancial
                                    if (!magistradoEncontrado) {
                                        const magistradoMatch4 =
                                            onmouseoverAttr.match(
                                                />\s*([A-Za-z√Ä-√ø\s]{10,})\s*</,
                                            );
                                        if (
                                            magistradoMatch4 &&
                                            magistradoMatch4[1]
                                        ) {
                                            eventoMagistrado =
                                                magistradoMatch4[1].trim();
                                            magistradoEncontrado = true;
                                            log(
                                                `üîç Estrat√©gia 5 - Magistrado/Vara encontrado: "${eventoMagistrado}"`,
                                            );
                                        }
                                    }

                                    if (!magistradoEncontrado) {
                                        log(
                                            `‚ùå Nenhuma estrat√©gia conseguiu extrair texto do onmouseover`,
                                        );
                                    }
                                }

                                // Se n√£o conseguiu pelo onmouseover, tentar title
                                if (!eventoMagistrado && titleAttr) {
                                    log(
                                        `üîç Tentando extrair do atributo title: "${titleAttr}"`,
                                    );
                                    if (titleAttr.length > 5) {
                                        eventoMagistrado = titleAttr.trim();
                                        log(
                                            `üîç Magistrado/Vara encontrado no title: "${eventoMagistrado}"`,
                                        );
                                    }
                                }

                                // Se n√£o conseguiu pelo title, tentar data-tooltip
                                if (!eventoMagistrado && tooltipAttr) {
                                    log(
                                        `üîç Tentando extrair do atributo data-tooltip: "${tooltipAttr}"`,
                                    );
                                    if (tooltipAttr.length > 5) {
                                        eventoMagistrado = tooltipAttr.trim();
                                        log(
                                            `üîç Magistrado/Vara encontrado no data-tooltip: "${eventoMagistrado}"`,
                                        );
                                    }
                                }

                                // Fallback final: usar o texto da pr√≥pria c√©lula se tiver conte√∫do
                                if (!eventoMagistrado) {
                                    const cellText =
                                        magistradoCell.textContent.trim();
                                    if (
                                        cellText &&
                                        cellText.length > 3 &&
                                        !cellText.match(/^\d+$/)
                                    ) {
                                        eventoMagistrado = cellText;
                                        log(
                                            `üîç Magistrado/Vara encontrado no texto da c√©lula: "${eventoMagistrado}"`,
                                        );
                                    }
                                }

                                // Formatar informa√ß√µes do magistrado/advogado
                                if (eventoMagistrado) {
                                    // Verificar se j√° temos dados estruturados da nova estrat√©gia
                                    if (
                                        typeof eventoMagistrado === "object" &&
                                        eventoMagistrado.nome
                                    ) {
                                        // Dados j√° estruturados da estrat√©gia espec√≠fica
                                        linkData.magistradoInfo = {
                                            tipo:
                                                eventoMagistrado.tipo ||
                                                "magistrado",
                                            nome: eventoMagistrado.nome,
                                            vara: eventoMagistrado.vara,
                                        };
                                        linkData.eventoMagistrado =
                                            eventoMagistrado.nome; // Para compatibilidade

                                        log(
                                            `‚úÖ Magistrado estruturado: Nome="${eventoMagistrado.nome}", Tipo="${eventoMagistrado.tipo}", Vara="${eventoMagistrado.vara}"`,
                                        );
                                    } else {
                                        // Formato antigo - processar com a fun√ß√£o existente
                                        const magistradoFormatado =
                                            formatarMagistradoAdvogado(
                                                eventoMagistrado,
                                            );
                                        if (
                                            typeof magistradoFormatado ===
                                                "object" &&
                                            magistradoFormatado.tipo
                                        ) {
                                            // Armazenar informa√ß√µes estruturadas
                                            linkData.magistradoInfo =
                                                magistradoFormatado;
                                            eventoMagistrado =
                                                magistradoFormatado.nome;
                                        } else {
                                            eventoMagistrado =
                                                magistradoFormatado;
                                        }

                                        log(
                                            `üîç Informa√ß√µes formatadas (m√©todo antigo): "${eventoMagistrado}"`,
                                        );
                                    }
                                }

                                if (!eventoMagistrado) {
                                    log(
                                        `‚ùå Nenhuma informa√ß√£o de magistrado/advogado encontrada`,
                                    );
                                }
                            } else {
                                log(
                                    `‚ùå Elemento label.infraEventoUsuario OU td.infraEventoUsuario n√£o encontrado`,
                                );

                                // Debug: verificar todas as c√©lulas da linha para encontrar poss√≠veis alternativas
                                const allCells =
                                    eventRow.querySelectorAll("td, label");
                                log(
                                    `üîç Debug - Verificando todos os ${allCells.length} elementos (td/label) da linha:`,
                                );
                                allCells.forEach((cell, idx) => {
                                    log(
                                        `üìã Elemento ${
                                            idx + 1
                                        }: <${cell.tagName.toLowerCase()}> classe="${
                                            cell.className
                                        }", texto="${cell.textContent
                                            .trim()
                                            .substring(
                                                0,
                                                30,
                                            )}", onmouseover="${!!cell.getAttribute(
                                            "onmouseover",
                                        )}"`,
                                    );
                                });
                            }

                            // Buscar a c√©lula de data do evento na mesma linha (geralmente √© a 3¬™ coluna)
                            const eventCells = eventRow.querySelectorAll("td");
                            if (eventCells.length >= 3) {
                                // A data geralmente est√° na 3¬™ c√©lula (√≠ndice 2)
                                const dateCell = eventCells[2];
                                if (dateCell) {
                                    const dateText =
                                        dateCell.textContent.trim();
                                    // Verificar se parece uma data (formato XX/XX/XXXX)
                                    if (dateText.match(/\d{2}\/\d{2}\/\d{4}/)) {
                                        eventoData = dateText;
                                        log(
                                            `üìÖ Data encontrada na linha do evento: "${eventoData}"`,
                                        );
                                    }
                                }
                            }

                            if (!eventoData) {
                                // Fallback: buscar qualquer texto que pare√ßa uma data na linha
                                const allText = eventRow.textContent;
                                const dateMatch = allText.match(
                                    /(\d{2}\/\d{2}\/\d{4}[\s\d:]*)/,
                                );
                                if (dateMatch) {
                                    eventoData = dateMatch[1].trim();
                                    log(
                                        `üìÖ Data encontrada via fallback: "${eventoData}"`,
                                    );
                                }
                            }
                        } else {
                            log(
                                " N√£o foi poss√≠vel encontrar a linha (tr) do evento que cont√©m o link do documento",
                            );

                            // Debug: verificar estrutura ao redor do link
                            log(" Debug - Estrutura ao redor do link:");
                            let parent = linkElement.parentElement;
                            let level = 0;
                            while (parent && level < 5) {
                                log(
                                    ` N√≠vel ${level}: ${parent.tagName} (id: ${
                                        parent.id || "N/A"
                                    }, classe: ${parent.className || "N/A"})`,
                                );
                                parent = parent.parentElement;
                                level++;
                            }
                        }

                        // Adicionar a descri√ß√£o, data e magistrado encontrados ao objeto do link
                        linkData.eventoDescricao =
                            eventoDescricao || linkData.tipo.descricao;
                        linkData.eventoData = eventoData || "";

                        // Tratar eventoMagistrado corretamente (pode ser string ou objeto)
                        if (
                            typeof eventoMagistrado === "object" &&
                            eventoMagistrado.nome
                        ) {
                            // Se √© objeto estruturado, usar o nome
                            linkData.eventoMagistrado = eventoMagistrado.nome;
                        } else {
                            // Se √© string, usar diretamente
                            linkData.eventoMagistrado = eventoMagistrado || "";
                        }

                        log(
                            `üìã Dados finais para documento #${
                                index + 1
                            }: Descri√ß√£o: "${
                                linkData.eventoDescricao
                            }", Data: "${linkData.eventoData}", Magistrado: "${
                                linkData.eventoMagistrado
                            }"`,
                        );
                    });
                } else {
                    log(
                        " N√£o √© p√°gina de lista de documentos ou n√£o h√° documentos relevantes - descri√ß√µes n√£o ser√£o buscadas",
                    );
                    // Se n√£o estivermos na lista de documentos, usar descri√ß√£o padr√£o do tipo
                    documentosData.forEach((linkData) => {
                        linkData.eventoDescricao = linkData.tipo.descricao;
                        linkData.eventoData = "";
                        linkData.eventoMagistrado = "";
                    });
                }

                // Converter dados coletados para o formato final
                const documentosRelevantes = documentosData.map((linkData) => ({
                    element: linkData.element,
                    href: linkData.href,
                    texto: linkData.texto,
                    tipo: linkData.tipo,
                    eventoId: linkData.eventoId,
                    docId: linkData.docId,
                    seqEvento: linkData.seqEvento,
                    tipoDocumento: linkData.tipoDocumento,
                    tamanho: linkData.tamanho,
                    eventoDescricao: linkData.eventoDescricao,
                    eventoData: linkData.eventoData,
                    eventoMagistrado: linkData.eventoMagistrado,
                    magistradoInfo: linkData.magistradoInfo, // Informa√ß√µes estruturadas
                    index: linkData.index,
                }));

                // VERIFICA√á√ÉO FINAL E FALLBACK
                if (documentosRelevantes.length === 0) {
                    log(
                        "‚ö†Ô∏è NENHUM DOCUMENTO ENCONTRADO - Tentando estrat√©gias de fallback...",
                    );

                    // Fallback 1: Buscar qualquer link que tenha padr√µes suspeitos
                    const linksSuspeitos = Array.from(
                        document.querySelectorAll("a"),
                    ).filter((link) => {
                        const texto = link.textContent.trim().toUpperCase();
                        const href = link.getAttribute("href") || "";

                        // Padr√µes mais amplos
                        const padroesSuspeitos = [
                            /SENT\d*/i,
                            /INIC\d*/i,
                            /DECI\d*/i,
                            /DESP\d*/i,
                            /PETI\d*/i,
                            /DOCUMENTO\s*\d+/i,
                            /SENTEN√áA/i,
                            /PETI√á√ÉO/i,
                            /DECIS√ÉO/i,
                            /DESPACHO/i,
                        ];

                        const temPadraoTexto = padroesSuspeitos.some((padrao) =>
                            padrao.test(texto),
                        );
                        const temPadraoHref = padroesSuspeitos.some((padrao) =>
                            padrao.test(href),
                        );

                        return (
                            temPadraoTexto ||
                            temPadraoHref ||
                            (href.includes("documento") && texto.length > 2)
                        );
                    });

                    if (linksSuspeitos.length > 0) {
                        log(
                            `‚úÖ FALLBACK: Encontrados ${linksSuspeitos.length} links suspeitos`,
                        );

                        // Converter para o formato esperado
                        const documentosFallback = linksSuspeitos
                            .slice(0, 10)
                            .map((link, index) => {
                                // Limitado a 10 para performance
                                const texto = link.textContent.trim();
                                const href = link.getAttribute("href") || "";

                                // Determinar tipo baseado no texto
                                let tipoDetectado = null;
                                const tiposDisponiveis = Object.values(
                                    TIPOS_DOCUMENTO_RELEVANTE,
                                );

                                for (const tipo of tiposDisponiveis) {
                                    if (
                                        texto
                                            .toUpperCase()
                                            .includes(tipo.nome) ||
                                        href
                                            .toUpperCase()
                                            .includes(tipo.dataNome)
                                    ) {
                                        tipoDetectado = tipo;
                                        break;
                                    }
                                }

                                // Fallback para tipo gen√©rico
                                if (!tipoDetectado) {
                                    tipoDetectado = {
                                        nome: texto.substring(0, 8) || "DOC",
                                        descricao: "Documento Relevante",
                                        dataNome: "DOC",
                                    };
                                }

                                return {
                                    element: link,
                                    href: href,
                                    texto: texto,
                                    tipo: tipoDetectado,
                                    eventoId: "",
                                    docId: "",
                                    seqEvento: "",
                                    tipoDocumento: tipoDetectado.descricao,
                                    tamanho: "",
                                    eventoDescricao: tipoDetectado.descricao,
                                    eventoData: "",
                                    eventoMagistrado: "",
                                    magistradoInfo: null,
                                    index: index + 1,
                                    origem: "fallback",
                                };
                            });

                        log(
                            `‚úÖ FALLBACK: Retornando ${documentosFallback.length} documentos`,
                        );
                        return documentosFallback;
                    }
                }

                log(
                    `‚úÖ RESULTADO FINAL: ${documentosRelevantes.length} documentos relevantes encontrados`,
                );
                return documentosRelevantes;
            }

            // Abrir documento relevante automaticamente (com suporte a m√∫ltiplos documentos) - usando express√£o de fun√ß√£o
            const autoOpenDocumentoRelevante = async function () {
                const pageType = detectPageType();
                log(" Tipo de p√°gina:", pageType);

                if (pageType !== "lista_documentos") {
                    log(" N√£o est√° na p√°gina de lista de documentos");
                    return false;
                }

                const documentosRelevantes = findDocumentosRelevantes();

                if (documentosRelevantes.length === 0) {
                    log(" Nenhum documento relevante encontrado");
                    showNotification(
                        "Nenhum documento relevante encontrado nesta p√°gina",
                        "error",
                    );
                    return false;
                }

                let selectedDocument;

                if (documentosRelevantes.length === 1) {
                    // Apenas um documento encontrado
                    selectedDocument = documentosRelevantes[0];
                    log(
                        " Um documento encontrado, selecionando automaticamente",
                    );
                } else {
                    // M√∫ltiplos documentos encontrados
                    log(
                        ` ${documentosRelevantes.length} documentos encontrados, solicitando sele√ß√£o do usu√°rio`,
                    );

                    log(
                        " DEBUG: documentosRelevantes antes do modal:",
                        documentosRelevantes.map((doc) => ({
                            index: doc.index,
                            tipo: doc.tipo.descricao,
                            eventoDescricao: doc.eventoDescricao,
                            seqEvento: doc.seqEvento,
                        })),
                    );
                    selectedDocument =
                        await showDocumentSelectionModal(documentosRelevantes);

                    if (!selectedDocument) {
                        log(" Usu√°rio cancelou a sele√ß√£o");
                        return false;
                    }
                }

                log(" Abrindo documento selecionado:", selectedDocument.href);
                showNotification(
                    `Abrindo ${selectedDocument.tipo.descricao} selecionada...`,
                    "info",
                );

                // Abrir em uma nova aba
                window.open(selectedDocument.href, "_blank");

                return true;
            };

            // Extrair texto do documento - usando express√£o de fun√ß√£o
            const autoExtractText = async function () {
                const pageType = detectPageType();
                log("üîç Tipo de p√°gina detectado:", pageType);

                // ‚úÖ Extra√ß√£o autom√°tica de PDF
                if (pageType === "documento_pdf") {
                    log("üìÑ Iniciando extra√ß√£o autom√°tica de PDF...");

                    try {
                        const textoExtraido = await extractTextFromPDF();

                        if (!textoExtraido || textoExtraido.length < 100) {
                            throw new Error(
                                "Texto extra√≠do √© muito pequeno ou vazio",
                            );
                        }

                        return textoExtraido;
                    } catch (error) {
                        console.error("‚ùå Falha na extra√ß√£o de PDF:", error);
                        showNotification(
                            `‚ùå Erro ao extrair PDF: ${error.message}`,
                            "error",
                        );
                        return null;
                    }
                }

                // Aceitar m√∫ltiplos tipos de p√°gina de documento HTML
                const validDocumentTypes = [
                    "documento_especifico",
                    "documento_html",
                ];

                if (!validDocumentTypes.includes(pageType)) {
                    // Se n√£o √© um tipo de documento reconhecido, verificar se h√° documentos na p√°gina
                    const pageHTML = document.documentElement.outerHTML;
                    const hasDocumentHtml = pageHTML.includes(
                        "acessar_documento&id",
                    );
                    const hasDocumentPdf = pageHTML.includes(
                        "acessar_documento&amp",
                    );

                    log(
                        "‚ö†Ô∏è Verifica√ß√£o adicional para p√°gina n√£o reconhecida:",
                        {
                            pageType: pageType,
                            hasDocumentHtml: hasDocumentHtml,
                            hasDocumentPdf: hasDocumentPdf,
                        },
                    );

                    if (!hasDocumentHtml && !hasDocumentPdf) {
                        log("‚ùå N√£o est√° na p√°gina do documento espec√≠fico");
                        showNotification(
                            "Execute na p√°gina do documento, n√£o na lista",
                            "error",
                        );
                        return null;
                    } else {
                        log(
                            "‚úÖ P√°gina cont√©m documentos, prosseguindo com extra√ß√£o...",
                        );
                    }
                }

                // Aguardar documento carregar completamente
                await waitForDocumentLoad();

                // ‚úÖ NOVA L√ìGICA: PDF j√° foi processado acima
                // SE N√ÉO √â PDF, PROCESSAR COMO DOCUMENTO HTML NORMAL
                log("üìÑ Documento HTML detectado, processando...");

                // Verificar se h√° se√ß√£o do documento (para senten√ßas HTML)
                const sectionDocumento = document.querySelector(
                    'section[data-nome="sentenca"]',
                );
                if (!sectionDocumento) {
                    log("‚ö†Ô∏è Section do documento n√£o encontrada");

                    // Buscar texto alternativo
                    const allText =
                        document.body.textContent ||
                        document.body.innerText ||
                        "";
                    if (allText.length < 100) {
                        log("‚ùå Pouco conte√∫do encontrado na p√°gina");
                        showNotification(
                            "Pouco conte√∫do encontrado. Verifique se est√° na p√°gina correta.",
                            "error",
                        );
                        return null;
                    }

                    log(
                        "‚úÖ Texto encontrado no body da p√°gina:",
                        allText.length,
                        "caracteres",
                    );
                    return allText;
                }

                // Extrair texto da se√ß√£o do documento HTML
                log("‚úÖ Section do documento encontrada, processando...");

                // Extrair usando classes espec√≠ficas do eProc
                const seletorParagrafos = [
                    "p.paragrafoPadrao",
                    "p.paragrafoComRecuo",
                    "p.paragrafoCentralizado",
                    "p.paragrafoSemRecuo",
                    "p.citacao",
                    "p.citacao2",
                    "span.dispositivo",
                    "div.paragrafoPadrao",
                    "div.paragrafoComRecuo",
                    "div.paragrafoCentralizado",
                    "div.paragrafoSemRecuo",
                ].join(", ");

                const paragrafosTexto =
                    sectionDocumento.querySelectorAll(seletorParagrafos);
                log(
                    ` Encontrados ${paragrafosTexto.length} par√°grafos com classes espec√≠ficas`,
                );

                let textosPar√°grafos = [];

                if (paragrafosTexto.length > 0) {
                    // Extrair texto dos par√°grafos com classes espec√≠ficas
                    paragrafosTexto.forEach((paragrafo, idx) => {
                        const textoP =
                            paragrafo.innerText || paragrafo.textContent || "";
                        if (textoP.trim().length > 0) {
                            textosPar√°grafos.push(textoP.trim());
                            log(
                                ` P${idx + 1} (${
                                    paragrafo.className
                                }): ${textoP.substring(0, 100)}...`,
                            );
                        }
                    });
                } else {
                    log(" Nenhum par√°grafo com classes espec√≠ficas encontrado");
                    log(" Tentando extra√ß√£o da se√ß√£o completa...");

                    // Fallback: extrair texto completo da se√ß√£o (limpo)
                    const elementoLimpo = sectionDocumento.cloneNode(true);

                    // Remover elementos indesejados
                    const elementosParaRemover = elementoLimpo.querySelectorAll(
                        "nav, header, footer, .menu, .navbar, .breadcrumb, .navigation, " +
                            '[class*="link"], [class*="menu"], [class*="nav"], [class*="toolbar"], ' +
                            '[class*="button"], [class*="btn"], [id*="menu"], [id*="nav"], ' +
                            "a, button, input, select, textarea, script, style, " +
                            '[class*="infra"], [id*="infra"], [class*="processo"], [id*="processo"], ' +
                            '[class*="evento"], [id*="evento"], [class*="documento"], [id*="documento"], ' +
                            ".fechar, .copiar, .print, .imprimir, .voltar, .close",
                    );

                    elementosParaRemover.forEach((el) => el.remove());

                    const textoCompleto =
                        elementoLimpo.innerText ||
                        elementoLimpo.textContent ||
                        "";
                    if (textoCompleto.trim().length > 0) {
                        textosPar√°grafos.push(textoCompleto.trim());
                    }
                }

                if (textosPar√°grafos.length === 0) {
                    log(" Nenhum texto v√°lido encontrado");
                    showNotification(
                        " Nenhum texto v√°lido encontrado no documento",
                        "error",
                    );
                    return null;
                }

                const textoFinal = textosPar√°grafos.join("\n\n");

                // Limpeza final de metadados residuais
                const texto = textoFinal
                    .replace(/processo\s+\d+[-\d.]+\/\w+/gi, "") // Remove n√∫meros de processo
                    .replace(/evento\s+\d+/gi, "") // Remove refer√™ncias a eventos
                    .replace(/SENT\d+/gi, "") // Remove refer√™ncias SENT
                    .replace(/DOC\d+/gi, "") // Remove refer√™ncias DOC
                    .replace(/\d+\.\d+/g, "") // Remove n√∫meros de se√ß√£o
                    .replace(/Fechar|Copiar|Print|Imprimir|Voltar/gi, "") // Remove textos de bot√µes
                    .replace(/Copiar link para documento:/gi, "") // Remove texto espec√≠fico
                    .replace(/^\s*[^\w\s]*\s*/, "") // Remove caracteres especiais do in√≠cio
                    .replace(/\s+/g, " ") // Normaliza espa√ßos
                    .trim();

                log(" Texto extra√≠do:", texto.length, "caracteres");
                log(" Pr√©via do texto:", texto.substring(0, 200) + "...");

                if (texto.trim().length < 100) {
                    log(" Texto muito pequeno");
                    showNotification(
                        "Texto extra√≠do √© muito pequeno",
                        "warning",
                    );
                    return null;
                }

                showNotification(
                    ` Texto extra√≠do: ${texto.length} caracteres`,
                    "success",
                );
                return texto.trim();
            };

            // üîß FUN√á√ÉO DE DEBUG PARA PDF DO EPROC - MOVIDA PARA ESCOPO CORRETO
            function debugPDFExtracao() {
                console.log("üîç DEBUG PDF EPROC: Analisando p√°gina atual...");

                const info = {
                    url: window.location.href,
                    isEprocDocument:
                        window.location.href.includes("acessar_documento"),
                    urlParams: Object.fromEntries(
                        new URLSearchParams(window.location.search),
                    ),

                    // Elementos PDF na p√°gina
                    elementos: {},

                    // Estado do PDF.js
                    pdfjs: {
                        carregado: typeof pdfjsLib !== "undefined",
                        versao:
                            typeof pdfjsLib !== "undefined"
                                ? pdfjsLib.version
                                : null,
                    },

                    // Informa√ß√µes da p√°gina
                    titulo: document.title,
                    temIframes: document.querySelectorAll("iframe").length,
                    temEmbeds: document.querySelectorAll("embed").length,
                    temObjects: document.querySelectorAll("object").length,
                };

                // Analisar elementos PDF
                const selectors = [
                    'iframe[src*="pdf"]',
                    'embed[type="application/pdf"]',
                    'object[type="application/pdf"]',
                    'iframe[src*="acessar_documento"]',
                    "#plugin",
                    'embed[type="application/x-google-chrome-pdf"]',
                ];

                selectors.forEach((selector) => {
                    const elemento = document.querySelector(selector);
                    info.elementos[selector] = elemento
                        ? {
                              encontrado: true,
                              src: elemento.src || elemento.data || "N/A",
                              type: elemento.type || "N/A",
                              id: elemento.id || "N/A",
                              className: elemento.className || "N/A",
                          }
                        : { encontrado: false };
                });

                // Listar todos os iframes para debug
                info.todosIframes = Array.from(
                    document.querySelectorAll("iframe"),
                ).map((iframe, i) => ({
                    indice: i,
                    src: iframe.src || "N/A",
                    title: iframe.title || "N/A",
                    id: iframe.id || "N/A",
                    className: iframe.className || "N/A",
                }));

                console.log("üìä RELAT√ìRIO COMPLETO:", info);
                return info;
            }

            // üéØ EXTRA√á√ÉO DE PDF - M√âTODO SIMPLIFICADO E EFICAZ
            async function extractTextFromPDF() {
                console.log("üéØ Extraindo texto do PDF...");

                // Verifica√ß√£o de p√°gina
                const pageType = detectPageType();
                if (pageType !== "documento_pdf") {
                    throw new Error("N√£o √© uma p√°gina de documento PDF");
                }

                // Buscar elemento PDF
                const pdfElement = document.querySelector(
                    'embed[type*="pdf"], iframe[src*="acessar_documento"]',
                );

                if (!pdfElement) {
                    throw new Error("Elemento PDF n√£o encontrado");
                }

                console.log("‚úÖ Elemento PDF encontrado:", pdfElement.tagName);

                // Limpar clipboard ANTES de come√ßar a monitorar
                try {
                    await navigator.clipboard.writeText("");
                    console.log("üßπ Clipboard limpo - aguardando nova c√≥pia");
                } catch (e) {
                    console.log(
                        "‚ö†Ô∏è N√£o foi poss√≠vel limpar clipboard:",
                        e.message,
                    );
                }

                // Focar no PDF automaticamente
                try {
                    pdfElement.focus();
                    pdfElement.click();
                    await new Promise((resolve) => setTimeout(resolve, 200));
                } catch (e) {
                    console.log("‚ö†Ô∏è Erro ao focar PDF:", e.message);
                }

                // Instruir usu√°rio de forma clara e direta com anima√ß√£o
                const notification = showNotification(
                    "üîÑ MONITORANDO CLIPBOARD...\n\n1Ô∏è‚É£ Clique no PDF\n2Ô∏è‚É£ Ctrl+A (selecionar)\n3Ô∏è‚É£ Ctrl+C (copiar)\n\n‚ö° O sistema detectar√° AUTOMATICAMENTE!\n‚ùå N√ÉO clique novamente no bot√£o!",
                    "info",
                    0, // N√£o desaparece automaticamente
                );

                // Adicionar indicador de monitoramento piscante
                if (notification) {
                    const pulseIndicator = document.createElement("div");
                    pulseIndicator.textContent = "üëÅÔ∏è Monitorando...";
                    pulseIndicator.style.cssText = `
                        margin-top: 8px;
                        padding: 8px;
                        background: #e3f2fd;
                        border-radius: 4px;
                        font-weight: bold;
                        text-align: center;
                        animation: pulse 1.5s ease-in-out infinite;
                    `;

                    // Adicionar anima√ß√£o CSS
                    if (!document.getElementById("eprobe-pulse-animation")) {
                        const style = document.createElement("style");
                        style.id = "eprobe-pulse-animation";
                        style.textContent = `
                            @keyframes pulse {
                                0%, 100% { opacity: 1; transform: scale(1); }
                                50% { opacity: 0.7; transform: scale(0.98); }
                            }
                        `;
                        document.head.appendChild(style);
                    }

                    notification.appendChild(pulseIndicator);
                }

                console.log("‚è≥ Aguardando que o usu√°rio copie o texto...");

                // Usar listener de eventos do clipboard (funciona sempre!)
                return new Promise((resolve) => {
                    let timeoutId;
                    let pulseInterval;

                    // Listener para evento de c√≥pia
                    const handleCopy = async (e) => {
                        // Aguardar um pouco para garantir que o texto est√° no clipboard
                        await new Promise((r) => setTimeout(r, 100));

                        try {
                            const text = await navigator.clipboard.readText();

                            if (text && text.length > 100) {
                                console.log(
                                    `‚úÖ Texto copiado detectado: ${text.length} caracteres`,
                                );

                                // Limpar listeners e timers
                                document.removeEventListener(
                                    "copy",
                                    handleCopy,
                                );
                                window.removeEventListener(
                                    "focus",
                                    handleWindowFocus,
                                );
                                clearTimeout(timeoutId);
                                clearInterval(pulseInterval);

                                // Fechar notifica√ß√£o
                                const existingNotifications =
                                    document.querySelectorAll(
                                        ".eprobe-notification",
                                    );
                                existingNotifications.forEach((n) =>
                                    n.remove(),
                                );

                                // Mostrar modal
                                const confirmed =
                                    await showConfirmationModal(text);

                                if (confirmed) {
                                    resolve(text.trim());
                                } else {
                                    console.log("‚ö†Ô∏è Usu√°rio cancelou o envio");
                                    showNotification(
                                        "‚ùå Envio cancelado pelo usu√°rio",
                                        "warning",
                                    );
                                    resolve(null);
                                }
                            }
                        } catch (err) {
                            console.log(
                                "‚ö†Ô∏è Erro ao ler clipboard ap√≥s c√≥pia:",
                                err.message,
                            );
                        }
                    };

                    // Listener para quando a janela ganha foco (ap√≥s Ctrl+C no PDF)
                    const handleWindowFocus = async () => {
                        await new Promise((r) => setTimeout(r, 100));

                        try {
                            const text = await navigator.clipboard.readText();

                            if (text && text.length > 100) {
                                console.log(
                                    `‚úÖ Texto detectado ao recuperar foco: ${text.length} caracteres`,
                                );

                                // Limpar listeners e timers
                                document.removeEventListener(
                                    "copy",
                                    handleCopy,
                                );
                                window.removeEventListener(
                                    "focus",
                                    handleWindowFocus,
                                );
                                clearTimeout(timeoutId);
                                clearInterval(pulseInterval);

                                // Fechar notifica√ß√£o
                                const existingNotifications =
                                    document.querySelectorAll(
                                        ".eprobe-notification",
                                    );
                                existingNotifications.forEach((n) =>
                                    n.remove(),
                                );

                                // Mostrar modal
                                const confirmed =
                                    await showConfirmationModal(text);

                                if (confirmed) {
                                    resolve(text.trim());
                                } else {
                                    console.log("‚ö†Ô∏è Usu√°rio cancelou o envio");
                                    showNotification(
                                        "‚ùå Envio cancelado pelo usu√°rio",
                                        "warning",
                                    );
                                    resolve(null);
                                }
                            }
                        } catch (err) {
                            // Silenciar
                        }
                    };

                    // Adicionar listeners
                    document.addEventListener("copy", handleCopy);
                    window.addEventListener("focus", handleWindowFocus);

                    // Atualizar contador a cada 5 segundos
                    let elapsed = 0;
                    pulseInterval = setInterval(() => {
                        elapsed += 5;
                        if (notification) {
                            const pulseIndicator = notification.querySelector(
                                'div[style*="Monitorando"]',
                            );
                            if (pulseIndicator) {
                                pulseIndicator.textContent = `üëÅÔ∏è Monitorando... ${elapsed}s`;
                            }
                        }
                    }, 5000);

                    // Timeout de 60 segundos
                    timeoutId = setTimeout(() => {
                        document.removeEventListener("copy", handleCopy);
                        window.removeEventListener("focus", handleWindowFocus);
                        clearInterval(pulseInterval);

                        console.log("‚è∞ Timeout: usu√°rio n√£o copiou texto");
                        showNotification(
                            "‚è∞ Tempo esgotado (60s).\n\nClique no bot√£o novamente para tentar.",
                            "error",
                            5000,
                        );
                        resolve(null);
                    }, 60000);
                });
            }

            // Modal de confirma√ß√£o com preview do texto
            async function showConfirmationModal(texto) {
                return new Promise((resolve) => {
                    // Criar overlay
                    const overlay = document.createElement("div");
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.7);
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        z-index: 999999;
                        backdrop-filter: blur(3px);
                    `;

                    // Criar modal
                    const modal = document.createElement("div");
                    modal.style.cssText = `
                        background: white;
                        border-radius: 12px;
                        padding: 24px;
                        max-width: 700px;
                        width: 90%;
                        max-height: 80vh;
                        display: flex;
                        flex-direction: column;
                        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                    `;

                    // T√≠tulo
                    const title = document.createElement("h2");
                    title.textContent = "Texto Copiado - Confirmar Envio";
                    title.style.cssText = `
                        margin: 0 0 16px 0;
                        font-size: 20px;
                        font-weight: 600;
                        color: #333;
                    `;

                    // Info
                    const info = document.createElement("p");
                    info.textContent = `${texto.length} caracteres detectados. Deseja enviar para an√°lise do Perplexity?`;
                    info.style.cssText = `
                        margin: 0 0 16px 0;
                        font-size: 14px;
                        color: #666;
                    `;

                    // Textarea com o texto
                    const textarea = document.createElement("textarea");
                    textarea.value = texto;
                    textarea.readOnly = true;
                    textarea.style.cssText = `
                        width: 100%;
                        height: 300px;
                        padding: 12px;
                        border: 1px solid #ddd;
                        border-radius: 6px;
                        font-family: monospace;
                        font-size: 12px;
                        resize: vertical;
                        margin-bottom: 16px;
                        background: #f9f9f9;
                    `;

                    // Container de bot√µes
                    const buttonContainer = document.createElement("div");
                    buttonContainer.style.cssText = `
                        display: flex;
                        gap: 12px;
                        justify-content: flex-end;
                    `;

                    // Bot√£o Cancelar
                    const cancelBtn = document.createElement("button");
                    cancelBtn.textContent = "Cancelar";
                    cancelBtn.style.cssText = `
                        padding: 10px 24px;
                        border: 1px solid #ddd;
                        background: white;
                        color: #666;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 500;
                        transition: all 0.2s;
                    `;
                    cancelBtn.onmouseover = () => {
                        cancelBtn.style.background = "#f5f5f5";
                    };
                    cancelBtn.onmouseout = () => {
                        cancelBtn.style.background = "white";
                    };
                    cancelBtn.onclick = () => {
                        document.body.removeChild(overlay);
                        resolve(false);
                    };

                    // Bot√£o Enviar
                    const sendBtn = document.createElement("button");
                    sendBtn.textContent = "Enviar ao Perplexity";
                    sendBtn.style.cssText = `
                        padding: 10px 24px;
                        border: none;
                        background: #0066cc;
                        color: white;
                        border-radius: 6px;
                        cursor: pointer;
                        font-size: 14px;
                        font-weight: 500;
                        transition: all 0.2s;
                    `;
                    sendBtn.onmouseover = () => {
                        sendBtn.style.background = "#0052a3";
                    };
                    sendBtn.onmouseout = () => {
                        sendBtn.style.background = "#0066cc";
                    };
                    sendBtn.onclick = () => {
                        document.body.removeChild(overlay);
                        resolve(true);
                    };

                    // Montar estrutura
                    buttonContainer.appendChild(cancelBtn);
                    buttonContainer.appendChild(sendBtn);

                    modal.appendChild(title);
                    modal.appendChild(info);
                    modal.appendChild(textarea);
                    modal.appendChild(buttonContainer);

                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);

                    // Fechar com ESC
                    const escHandler = (e) => {
                        if (e.key === "Escape") {
                            document.body.removeChild(overlay);
                            document.removeEventListener("keydown", escHandler);
                            resolve(false);
                        }
                    };
                    document.addEventListener("keydown", escHandler);
                });
            }

            // ü§ñ FUN√á√ÉO DE AUTOMA√á√ÉO COMPLETA - Ctrl+A + Ctrl+C autom√°ticos
            async function tentarSelecaoAutomaticaCompleta() {
                console.log("ü§ñ Iniciando automa√ß√£o completa de sele√ß√£o...");

                try {
                    // 1. Encontrar elemento PDF
                    const pdfElements = [
                        document.querySelector(
                            'iframe[src*="acessar_documento"]',
                        ),
                        document.querySelector('iframe[src*="pdf"]'),
                        document.querySelector('embed[type="application/pdf"]'),
                        document.querySelector(
                            'object[type="application/pdf"]',
                        ),
                        document.querySelector("#plugin"),
                        document.querySelector(
                            'embed[type="application/x-google-chrome-pdf"]',
                        ),
                    ].filter((el) => el !== null);

                    if (pdfElements.length === 0) {
                        console.log("‚ùå Nenhum elemento PDF encontrado");
                        return null;
                    }

                    const pdfElement = pdfElements[0];
                    console.log(
                        "üìÑ Elemento PDF encontrado:",
                        pdfElement.tagName,
                    );

                    // 2. Focar no elemento PDF - VERS√ÉO ROBUSTA PARA IFRAMES EPROC
                    try {
                        pdfElement.focus();
                        pdfElement.click(); // Garantir foco

                        // ESTRAT√âGIA ESPECIAL PARA IFRAME EPROC
                        if (
                            pdfElement.tagName === "IFRAME" &&
                            pdfElement.src.includes("acessar_documento")
                        ) {
                            console.log(
                                "üéØ Iframe eProc detectado - aplicando estrat√©gias especiais...",
                            );

                            // M√∫ltiplos cliques para garantir foco
                            pdfElement.click();
                            await new Promise((resolve) =>
                                setTimeout(resolve, 200),
                            );
                            pdfElement.click();
                            await new Promise((resolve) =>
                                setTimeout(resolve, 200),
                            );

                            // Tentar focar na janela do iframe se poss√≠vel
                            try {
                                if (
                                    pdfElement.contentWindow &&
                                    !pdfElement.contentWindow.closed
                                ) {
                                    pdfElement.contentWindow.focus();
                                    console.log(
                                        "‚úÖ Foco aplicado na janela do iframe",
                                    );
                                }
                            } catch (corsError) {
                                console.log(
                                    "‚ö†Ô∏è CORS bloqueou acesso ao iframe - isso √© normal para eProc",
                                );
                            }
                        }

                        console.log("‚úÖ Foco aplicado no PDF");
                    } catch (e) {
                        console.log("‚ö†Ô∏è Erro ao focar no PDF:", e.message);
                    }

                    // 3. Aguardar um momento MAIOR para o PDF carregar completamente (iframes eProc demoram mais)
                    console.log("‚è≥ Aguardando PDF carregar completamente...");
                    await new Promise((resolve) => setTimeout(resolve, 3000)); // 3 segundos para eProc

                    // 4. ESTRAT√âGIA ESPECIAL: Tentar m√∫ltiplas abordagens para selecionar texto
                    console.log(
                        "üéØ Iniciando m√∫ltiplas estrat√©gias de sele√ß√£o...",
                    );

                    // ESTRAT√âGIA A: KeyboardEvent padr√£o
                    console.log("üéØ Estrat√©gia A: KeyboardEvent padr√£o...");
                    let textoSelecionado =
                        await tentarSelecaoKeyboard(pdfElement);
                    if (textoSelecionado) {
                        console.log("‚úÖ Sucesso com KeyboardEvent!");
                        return textoSelecionado;
                    }

                    // ESTRAT√âGIA B: execCommand (mais compat√≠vel com iframes)
                    console.log("üéØ Estrat√©gia B: execCommand...");
                    textoSelecionado =
                        await tentarSelecaoExecCommand(pdfElement);
                    if (textoSelecionado) {
                        console.log("‚úÖ Sucesso com execCommand!");
                        return textoSelecionado;
                    }

                    // ESTRAT√âGIA C: Eventos nativos do browser
                    console.log("üéØ Estrat√©gia C: Eventos nativos...");
                    textoSelecionado =
                        await tentarSelecaoEventosNativos(pdfElement);
                    if (textoSelecionado) {
                        console.log("‚úÖ Sucesso com eventos nativos!");
                        return textoSelecionado;
                    }

                    console.log("‚ùå Todas as estrat√©gias de sele√ß√£o falharam");
                    return null;
                } catch (error) {
                    console.log(
                        "‚ùå Erro na automa√ß√£o completa:",
                        error.message,
                    );
                    return null;
                }
            }

            // Fun√ß√£o auxiliar para validar texto jur√≠dico
            async function validarTextoJuridico(texto) {
                if (!texto || texto.length < 100) {
                    return null;
                }

                const textLower = texto.toLowerCase();

                // Rejeitar notifica√ß√µes do eProbe
                const eProbeIndicators = [
                    "resumir documento",
                    "pdf detectado",
                    "clique dentro do pdf",
                    "aguarde o pdf carregar",
                    "selecione todo o texto do pdf",
                ];

                const hasEProbeContent = eProbeIndicators.some((indicator) =>
                    textLower.includes(indicator),
                );

                if (hasEProbeContent) {
                    console.log(
                        "‚ùå Texto rejeitado: cont√©m notifica√ß√µes eProbe",
                    );
                    return null;
                }

                // Verificar termos jur√≠dicos
                const termosJuridicos = [
                    "tribunal",
                    "juiz",
                    "processo",
                    "senten√ßa",
                    "decis√£o",
                    "despacho",
                    "ac√≥rd√£o",
                    "recurso",
                    "requerente",
                    "requerido",
                ];

                const termosEncontrados = termosJuridicos.filter((termo) =>
                    textLower.includes(termo),
                ).length;

                if (termosEncontrados >= 2) {
                    console.log(
                        `‚úÖ Texto jur√≠dico validado (${termosEncontrados} termos)`,
                    );
                    return texto;
                }

                console.log("‚ö†Ô∏è Texto n√£o parece ser documento jur√≠dico");
                return null;
            }

            // Fun√ß√£o de valida√ß√£o FLEX√çVEL para debug e casos dif√≠ceis
            async function validarTextoJuridicoFlexivel(texto) {
                if (!texto || texto.length < 50) {
                    // Reduzido de 100 para 50
                    console.log("‚ùå Texto muito pequeno:", texto?.length);
                    return null;
                }

                const textLower = texto.toLowerCase();

                // üö® CR√çTICO: Rejeitar apenas notifica√ß√µes √ìBVIAS do eProbe
                const eProbeIndicatorsObvios = [
                    "resumir documento",
                    "executando automa√ß√£o:",
                    "clique no bot√£o eprobe",
                    "estrat√©gia de automa√ß√£o",
                    "aguarde pdf carregar",
                ];

                const hasEProbeObvio = eProbeIndicatorsObvios.some(
                    (indicator) => textLower.includes(indicator),
                );

                if (hasEProbeObvio) {
                    console.log(
                        "‚ùå Valida√ß√£o flex√≠vel: cont√©m notifica√ß√µes √≥bvias eProbe",
                    );
                    return null;
                }

                // Verificar termos jur√≠dicos - MUITO MAIS FLEX√çVEL
                const termosJuridicos = [
                    // Termos b√°sicos
                    "tribunal",
                    "juiz",
                    "processo",
                    "senten√ßa",
                    "decis√£o",
                    "despacho",
                    // Termos processuais
                    "ac√≥rd√£o",
                    "recurso",
                    "apela√ß√£o",
                    "embargos",
                    // Partes processuais
                    "requerente",
                    "requerido",
                    "autor",
                    "r√©u",
                    "demandante",
                    "demandado",
                    // Documentos
                    "peti√ß√£o",
                    "contesta√ß√£o",
                    "agravo",
                    "mandado",
                    "cita√ß√£o",
                    // Outros termos jur√≠dicos
                    "advogado",
                    "defesa",
                    "a√ß√£o",
                    "causa",
                    "direito",
                    "lei",
                    "c√≥digo",
                    "artigo",
                    "par√°grafo",
                    "inciso",
                    "jurisprud√™ncia",
                    "precedente",
                    // Termos do eProc espec√≠ficos
                    "tjsc",
                    "santa catarina",
                    "comarca",
                    "vara",
                    "ju√≠zo",
                ];

                const termosEncontrados = termosJuridicos.filter((termo) =>
                    textLower.includes(termo),
                ).length;

                console.log(
                    `üîç Valida√ß√£o flex√≠vel: ${termosEncontrados} termos jur√≠dicos encontrados`,
                );

                // CRIT√âRIO MUITO MAIS FLEX√çVEL: apenas 1 termo j√° basta
                if (termosEncontrados >= 1) {
                    console.log(
                        `‚úÖ Valida√ß√£o flex√≠vel passou com ${termosEncontrados} termos`,
                    );
                    return texto;
                }

                // Se n√£o tem termos jur√≠dicos, verificar se pelo menos parece ser texto estruturado
                const pareceBemFormatado =
                    texto.length > 200 &&
                    (texto.includes("\n") ||
                        texto.includes(".") ||
                        texto.includes(",")) &&
                    !textLower.includes("console.log") &&
                    !textLower.includes("error") &&
                    !textLower.includes("function");

                if (pareceBemFormatado) {
                    console.log(
                        "‚úÖ Valida√ß√£o flex√≠vel: parece texto bem formatado, aprovando",
                    );
                    return texto;
                }

                console.log(
                    "‚ùå Valida√ß√£o flex√≠vel: n√£o atende crit√©rios m√≠nimos",
                );
                console.log(
                    "üîç Debug: Texto preview:",
                    texto.substring(0, 200),
                );
                return null;
            }

            // üéØ NOVA FUN√á√ÉO: Automa√ß√£o com Valida√ß√£o RIGOROSA para eProc
            async function tentarAutomacaoComValidacaoRigorosa() {
                console.log(
                    "üîç Iniciando automa√ß√£o com valida√ß√£o rigorosa de conte√∫do eProc...",
                );

                try {
                    // 1. Limpar clipboard antes de come√ßar
                    await navigator.clipboard.writeText("");
                    console.log("üßπ Clipboard limpo para automa√ß√£o rigorosa");

                    // 2. Encontrar elemento PDF espec√≠fico do eProc
                    const pdfElement = document.querySelector(
                        'iframe[src*="acessar_documento"]',
                    );
                    if (!pdfElement) {
                        console.log(
                            "‚ùå Iframe eProc espec√≠fico n√£o encontrado",
                        );
                        return null;
                    }

                    console.log("üìÑ Iframe eProc encontrado:", pdfElement.src);

                    // 3. Foco agressivo no iframe
                    pdfElement.focus();
                    pdfElement.click();
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // 4. Tentar m√∫ltiplas abordagens de sele√ß√£o
                    const estrategias = [
                        () => tentarSelecaoComValidacao("execCommand"),
                        () => tentarSelecaoComValidacao("keyboardEvent"),
                        () => tentarSelecaoComValidacao("eventosNativos"),
                    ];

                    for (const [index, estrategia] of estrategias.entries()) {
                        console.log(
                            `üéØ Tentativa ${
                                index + 1
                            }/3 com valida√ß√£o rigorosa...`,
                        );

                        const resultado = await estrategia();
                        if (resultado) {
                            console.log(
                                `‚úÖ Sucesso na tentativa ${index + 1}!`,
                            );
                            return resultado;
                        }

                        // Aguardar antes da pr√≥xima tentativa
                        await new Promise((resolve) =>
                            setTimeout(resolve, 1500),
                        );
                    }

                    console.log(
                        "‚ùå Todas as tentativas de automa√ß√£o rigorosa falharam",
                    );
                    return null;
                } catch (error) {
                    console.log(
                        "‚ùå Erro na automa√ß√£o rigorosa:",
                        error.message,
                    );
                    return null;
                }
            }

            // Fun√ß√£o auxiliar: Tentar sele√ß√£o com valida√ß√£o espec√≠fica
            async function tentarSelecaoComValidacao(metodo) {
                try {
                    const pdfElement = document.querySelector(
                        'iframe[src*="acessar_documento"]',
                    );
                    if (!pdfElement) return null;

                    // Re-focar
                    pdfElement.focus();
                    pdfElement.click();

                    if (metodo === "execCommand") {
                        // M√©todo execCommand
                        document.execCommand("selectAll");
                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000),
                        );
                        document.execCommand("copy");
                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000),
                        );
                    } else if (metodo === "keyboardEvent") {
                        // M√©todo KeyboardEvent
                        const selectEvent = new KeyboardEvent("keydown", {
                            key: "a",
                            code: "KeyA",
                            ctrlKey: true,
                            bubbles: true,
                        });
                        pdfElement.dispatchEvent(selectEvent);
                        document.dispatchEvent(selectEvent);

                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000),
                        );

                        const copyEvent = new KeyboardEvent("keydown", {
                            key: "c",
                            code: "KeyC",
                            ctrlKey: true,
                            bubbles: true,
                        });
                        pdfElement.dispatchEvent(copyEvent);
                        document.dispatchEvent(copyEvent);

                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000),
                        );
                    } else if (metodo === "eventosNativos") {
                        // M√©todo eventos nativos - triplo clique
                        const tripleClick = new MouseEvent("click", {
                            detail: 3,
                            bubbles: true,
                            cancelable: true,
                        });
                        pdfElement.dispatchEvent(tripleClick);
                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000),
                        );
                    }

                    // Verificar clipboard com valida√ß√£o RIGOROSA
                    const clipboardText = await navigator.clipboard.readText();
                    if (clipboardText && clipboardText.length > 50) {
                        console.log(
                            `üîç ${metodo}: Texto obtido:`,
                            clipboardText.length,
                            "chars",
                        );
                        console.log(
                            `üîç ${metodo}: Preview:`,
                            clipboardText.substring(0, 200),
                        );

                        // VALIDA√á√ÉO RIGOROSA: Verificar se √© realmente conte√∫do eProc/jur√≠dico
                        const isConteudoEproc =
                            validarConteudoEprocRigoroso(clipboardText);
                        if (isConteudoEproc) {
                            console.log(
                                `‚úÖ ${metodo}: Conte√∫do eProc v√°lido detectado!`,
                            );
                            return clipboardText;
                        } else {
                            console.log(
                                `‚ùå ${metodo}: Conte√∫do N√ÉO √© eProc - rejeitado`,
                            );
                            // Limpar clipboard inv√°lido
                            await navigator.clipboard.writeText("");
                        }
                    }

                    return null;
                } catch (error) {
                    console.log(`‚ùå Erro no m√©todo ${metodo}:`, error.message);
                    return null;
                }
            }

            // Fun√ß√£o de valida√ß√£o RIGOROSA espec√≠fica para conte√∫do eProc
            function validarConteudoEprocRigoroso(texto) {
                if (!texto || texto.length < 100) {
                    console.log("‚ùå Valida√ß√£o rigorosa: texto muito pequeno");
                    return false;
                }

                const textLower = texto.toLowerCase();

                // üö® REJEITAR IMEDIATAMENTE conte√∫do obviamente n√£o-eProc
                const indicadoresNaoEproc = [
                    "mercadolivre.com",
                    "produto.mercadolivre",
                    "polycard_client",
                    "facebook.com",
                    "google.com",
                    "youtube.com",
                    "amazon.com",
                    "tracking_id",
                    "search_layout",
                    "boneco",
                    "action figure",
                    "cavaleiros do zodiaco",
                    "bandai",
                    "cloth myth",
                    "whatsapp",
                    "instagram",
                    "twitter",
                    "linkedin",
                ];

                const temConteudoNaoEproc = indicadoresNaoEproc.some(
                    (indicador) => textLower.includes(indicador),
                );

                if (temConteudoNaoEproc) {
                    console.log(
                        "‚ùå Valida√ß√£o rigorosa: conte√∫do n√£o-eProc detectado",
                    );
                    return false;
                }

                // ‚úÖ ACEITAR APENAS conte√∫do com indicadores ESPEC√çFICOS do eProc
                const indicadoresEproc = [
                    // Sistema eProc
                    "eproc",
                    "tjsc",
                    "tribunal de justica",
                    "santa catarina",
                    // Termos processuais espec√≠ficos
                    "senten√ßa",
                    "processo",
                    "decis√£o",
                    "despacho",
                    "ac√≥rd√£o",
                    "comarca",
                    "vara",
                    "ju√≠zo",
                    "magistrado",
                    "juiz",
                    // Documentos espec√≠ficos
                    "peti√ß√£o inicial",
                    "contesta√ß√£o",
                    "recurso",
                    "agravo",
                    "mandado",
                    "cita√ß√£o",
                    "intima√ß√£o",
                    "audi√™ncia",
                    // Partes processuais
                    "requerente",
                    "requerido",
                    "autor",
                    "r√©u",
                    "apelante",
                    "apelado",
                    // Assinaturas e autentica√ß√£o
                    "assinatura digital",
                    "certificado digital",
                    "mp 2.200",
                    "documento assinado",
                    "hash",
                    "validacao",
                    // Conte√∫do jur√≠dico estruturado
                    "artigo",
                    "lei",
                    "c√≥digo",
                    "constitui√ß√£o",
                    "jurisprud√™ncia",
                ];

                const termosEprocEncontrados = indicadoresEproc.filter(
                    (termo) => textLower.includes(termo),
                ).length;

                console.log(
                    `üîç Valida√ß√£o rigorosa: ${termosEprocEncontrados} indicadores eProc encontrados`,
                );

                // Crit√©rio rigoroso: pelo menos 2 termos espec√≠ficos do eProc
                if (termosEprocEncontrados >= 2) {
                    console.log(
                        "‚úÖ Valida√ß√£o rigorosa: conte√∫do eProc aut√™ntico confirmado",
                    );
                    return true;
                }

                // Fallback: verificar se parece estrutura de documento jur√≠dico
                const pareceDocumentoJuridico =
                    texto.length > 500 &&
                    textLower.includes("tribunal") &&
                    (textLower.includes("processo") ||
                        textLower.includes("a√ß√£o")) &&
                    !textLower.includes("http://") &&
                    !textLower.includes("www.");

                if (pareceDocumentoJuridico) {
                    console.log(
                        "‚úÖ Valida√ß√£o rigorosa: aprovado como documento jur√≠dico estruturado",
                    );
                    return true;
                }

                console.log(
                    "‚ùå Valida√ß√£o rigorosa: n√£o atende crit√©rios eProc espec√≠ficos",
                );
                return false;
            }

            // ü§ê NOVA FUN√á√ÉO: Automa√ß√£o SILENCIOSA sem interfer√™ncias visuais
            async function tentarAutomacaoSilenciosa() {
                console.log(
                    "ü§ê Iniciando automa√ß√£o SILENCIOSA focada no PDF...",
                );

                try {
                    // 1. LIMPAR COMPLETAMENTE o clipboard
                    await navigator.clipboard.writeText("");
                    console.log("üßπ Clipboard totalmente limpo");

                    // 2. Encontrar APENAS o iframe do PDF (mais espec√≠fico)
                    const iframePDF =
                        document.querySelector(
                            'iframe[src*="acessar_documento_implementacao"]',
                        ) ||
                        document.querySelector(
                            'iframe[src*="acessar_documento"]',
                        );

                    if (!iframePDF) {
                        console.log("‚ùå Iframe PDF espec√≠fico n√£o encontrado");
                        return null;
                    }

                    console.log("üìÑ Iframe PDF encontrado (silencioso)");

                    // 3. FOCO TOTAL no iframe - m√∫ltiplas tentativas
                    for (let i = 0; i < 3; i++) {
                        iframePDF.focus();
                        iframePDF.click();

                        // Tentar focar dentro do iframe se poss√≠vel
                        try {
                            if (
                                iframePDF.contentWindow &&
                                !iframePDF.contentWindow.closed
                            ) {
                                iframePDF.contentWindow.focus();
                                if (
                                    iframePDF.contentWindow.document &&
                                    iframePDF.contentWindow.document.body
                                ) {
                                    iframePDF.contentWindow.document.body.focus();
                                }
                            }
                        } catch (corsError) {
                            // CORS esperado - ignorar silenciosamente
                        }

                        await new Promise((resolve) =>
                            setTimeout(resolve, 500),
                        );
                    }

                    console.log("üìç Foco exclusivo aplicado no PDF");

                    // 4. AGUARDAR PDF carregar COMPLETAMENTE
                    await new Promise((resolve) => setTimeout(resolve, 3000));

                    // 5. SELE√á√ÉO DIRETA no iframe (m√©todo mais direto)
                    console.log("üéØ Executando sele√ß√£o direta...");

                    // M√©todo A: execCommand direto
                    const selectSuccess = document.execCommand("selectAll");
                    console.log("üìã SelectAll resultado:", selectSuccess);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    const copySuccess = document.execCommand("copy");
                    console.log("üìã Copy resultado:", copySuccess);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // 6. VERIFICAR clipboard com valida√ß√£o M√ÅXIMA
                    const clipboardText = await navigator.clipboard.readText();

                    if (clipboardText && clipboardText.length > 100) {
                        console.log(
                            "üîç Texto obtido (silencioso):",
                            clipboardText.length,
                            "chars",
                        );

                        // VALIDA√á√ÉO EXTREMA: deve ser conte√∫do PDF real
                        const isConteudoPDFReal =
                            validarConteudoPDFReal(clipboardText);
                        if (isConteudoPDFReal) {
                            console.log("‚úÖ Conte√∫do PDF real validado!");
                            return clipboardText;
                        } else {
                            console.log("‚ùå Ainda n√£o √© conte√∫do PDF real");
                            // Limpar clipboard inv√°lido
                            await navigator.clipboard.writeText("");
                        }
                    }

                    // M√©todo B: KeyboardEvent se execCommand falhou
                    console.log("üîÑ Tentando KeyboardEvent...");

                    const selectEvent = new KeyboardEvent("keydown", {
                        key: "a",
                        code: "KeyA",
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                    });

                    iframePDF.dispatchEvent(selectEvent);
                    document.dispatchEvent(selectEvent);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    const copyEvent = new KeyboardEvent("keydown", {
                        key: "c",
                        code: "KeyC",
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                    });

                    iframePDF.dispatchEvent(copyEvent);
                    document.dispatchEvent(copyEvent);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // Verificar novamente
                    const clipboardText2 = await navigator.clipboard.readText();
                    if (
                        clipboardText2 &&
                        clipboardText2 !== clipboardText &&
                        clipboardText2.length > 100
                    ) {
                        console.log(
                            "üîç Novo texto obtido:",
                            clipboardText2.length,
                            "chars",
                        );

                        const isConteudoPDFReal2 =
                            validarConteudoPDFReal(clipboardText2);
                        if (isConteudoPDFReal2) {
                            console.log(
                                "‚úÖ Conte√∫do PDF real validado (KeyboardEvent)!",
                            );
                            return clipboardText2;
                        }
                    }

                    console.log(
                        "‚ùå Automa√ß√£o silenciosa n√£o conseguiu extrair conte√∫do v√°lido",
                    );
                    return null;
                } catch (error) {
                    console.log(
                        "‚ùå Erro na automa√ß√£o silenciosa:",
                        error.message,
                    );
                    return null;
                }
            }

            // Valida√ß√£o EXTREMA: apenas conte√∫do que √© REALMENTE de PDF jur√≠dico
            function validarConteudoPDFReal(texto) {
                if (!texto || texto.length < 200) {
                    console.log("‚ùå Valida√ß√£o PDF: texto muito pequeno");
                    return false;
                }

                const textLower = texto.toLowerCase();

                // üö® REJEITAR IMEDIATAMENTE conte√∫do que N√ÉO √© PDF real
                const indicadoresNaoPDF = [
                    // Notifica√ß√µes eProbe
                    "resumir documento",
                    "problema detectado",
                    "solu√ß√£o garantida",
                    "feche outras abas",
                    "clique dentro",
                    "aguarde carregar",
                    "pressione ctrl",
                    "bot√£o eprobe",
                    "automa√ß√£o",

                    // Logs do console
                    "main.js:",
                    "console.log",
                    "error:",
                    "warning:",
                    "debug:",
                    "intercepta√ß√£o",
                    "navbar",
                    "observer",
                    "fun√ß√£o",
                    "‚úÖ",
                    "‚ùå",
                    "üîç",
                    "üéØ",
                    "üìÑ",
                    "üöÄ",
                    "‚ö°",

                    // URLs e conte√∫do web
                    "http://",
                    "https://",
                    "www.",
                    ".com",
                    ".br",
                    "mercadolivre",
                    "polycard_client",
                    "tracking_id",

                    // Conte√∫do de outras abas
                    "search_layout",
                    "boneco",
                    "cloth myth",
                    "bandai",
                    "cavaleiros",
                    "action figure",
                ];

                const temConteudoNaoPDF = indicadoresNaoPDF.some((indicador) =>
                    textLower.includes(indicador),
                );

                if (temConteudoNaoPDF) {
                    console.log("‚ùå Valida√ß√£o PDF: cont√©m conte√∫do n√£o-PDF");
                    return false;
                }

                // ‚úÖ ACEITAR APENAS se tem M√öLTIPLOS indicadores de documento jur√≠dico real
                const indicadoresPDFJuridico = [
                    // Assinaturas digitais t√≠picas de PDF
                    "assinado digitalmente",
                    "certificado digital",
                    "hash",
                    "documento assinado eletr√¥nicamente",
                    "valida√ß√£o",

                    // Estrutura t√≠pica de documentos jur√≠dicos
                    "tribunal de justi√ßa",
                    "poder judici√°rio",
                    "comarca",
                    "processo n",
                    "autos n",
                    "vara c√≠vel",
                    "vara criminal",

                    // Conte√∫do jur√≠dico estruturado
                    "vistos",
                    "relat√≥rio",
                    "fundamenta√ß√£o",
                    "dispositivo",
                    "isto posto",
                    "julgo",
                    "condeno",
                    "declaro",
                    "determino",
                    "defiro",
                    "indefiro",

                    // Partes processuais claras
                    "autor:",
                    "r√©u:",
                    "requerente:",
                    "requerido:",
                    "apelante:",
                    "apelado:",

                    // Cita√ß√µes legais
                    "c√≥digo civil",
                    "c√≥digo penal",
                    "constitui√ß√£o federal",
                    "lei n",
                    "artigo",
                    "par√°grafo",
                    "inciso",

                    // Datas e protocolos processuais
                    "audi√™ncia",
                    "prazo",
                    "cita√ß√£o",
                    "intima√ß√£o",
                    "recurso",
                ];

                const indicadoresEncontrados = indicadoresPDFJuridico.filter(
                    (indicador) => textLower.includes(indicador),
                ).length;

                console.log(
                    `üîç Valida√ß√£o PDF: ${indicadoresEncontrados} indicadores jur√≠dicos encontrados`,
                );

                // Crit√©rio R√çGIDO: pelo menos 3 indicadores espec√≠ficos
                if (indicadoresEncontrados >= 3) {
                    console.log(
                        "‚úÖ Valida√ß√£o PDF: documento jur√≠dico aut√™ntico confirmado",
                    );
                    return true;
                }

                // Fallback: verificar estrutura t√≠pica de senten√ßa/decis√£o
                const temEstruturaSentenca =
                    textLower.includes("tribunal") &&
                    textLower.includes("processo") &&
                    (textLower.includes("senten√ßa") ||
                        textLower.includes("decis√£o") ||
                        textLower.includes("despacho")) &&
                    texto.length > 1000 &&
                    !textLower.includes("main.js");

                if (temEstruturaSentenca) {
                    console.log(
                        "‚úÖ Valida√ß√£o PDF: estrutura de senten√ßa detectada",
                    );
                    return true;
                }

                console.log(
                    "‚ùå Valida√ß√£o PDF: n√£o atende crit√©rios de documento jur√≠dico real",
                );
                return false;
            }

            // üñ±Ô∏è NOVA FUN√á√ÉO: Simula√ß√£o F√çSICA de intera√ß√£o com plugin PDF
            async function simularInteracaoFisicaPDF() {
                console.log("üñ±Ô∏è Iniciando simula√ß√£o f√≠sica no plugin PDF...");

                try {
                    // 1. Limpar clipboard completamente
                    await navigator.clipboard.writeText("");
                    console.log("üßπ Clipboard limpo para simula√ß√£o f√≠sica");

                    // 2. Encontrar o container do PDF (iframe ou embed)
                    const pdfContainer =
                        document.querySelector(
                            'iframe[src*="acessar_documento"]',
                        ) ||
                        document.querySelector(
                            'embed[type="application/pdf"]',
                        ) ||
                        document.querySelector(
                            'object[type="application/pdf"]',
                        );

                    if (!pdfContainer) {
                        console.log("‚ùå Container PDF n√£o encontrado");
                        return null;
                    }

                    console.log(
                        "üìÑ Container PDF encontrado:",
                        pdfContainer.tagName,
                    );

                    // 3. Obter dimens√µes e posi√ß√£o do container
                    const rect = pdfContainer.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    console.log(
                        `üìê Dimens√µes PDF: ${rect.width}x${rect.height}`,
                    );
                    console.log(
                        `üéØ Centro calculado: (${centerX}, ${centerY})`,
                    );

                    // 4. SIMULA√á√ÉO F√çSICA: Clique no centro do PDF
                    console.log(
                        "üñ±Ô∏è Simulando clique f√≠sico no centro do PDF...",
                    );

                    // Criar e disparar evento de clique no centro exato
                    const clickEvent = new MouseEvent("click", {
                        view: window,
                        bubbles: true,
                        cancelable: true,
                        clientX: centerX,
                        clientY: centerY,
                        button: 0,
                        buttons: 1,
                    });

                    pdfContainer.dispatchEvent(clickEvent);

                    // Tamb√©m tentar foco direto
                    pdfContainer.focus();

                    // Aguardar o plugin responder ao clique
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // 5. SIMULA√á√ÉO F√çSICA: Ctrl+A (Selecionar tudo)
                    console.log("‚å®Ô∏è Simulando Ctrl+A f√≠sico...");

                    const selectAllEvent = new KeyboardEvent("keydown", {
                        key: "a",
                        code: "KeyA",
                        keyCode: 65,
                        which: 65,
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                        view: window,
                    });

                    // Disparar em m√∫ltiplos alvos
                    document.dispatchEvent(selectAllEvent);
                    pdfContainer.dispatchEvent(selectAllEvent);
                    window.dispatchEvent(selectAllEvent);

                    // Aguardar sele√ß√£o
                    await new Promise((resolve) => setTimeout(resolve, 1500));

                    // 6. SIMULA√á√ÉO F√çSICA: Ctrl+C (Copiar)
                    console.log("‚å®Ô∏è Simulando Ctrl+C f√≠sico...");

                    const copyEvent = new KeyboardEvent("keydown", {
                        key: "c",
                        code: "KeyC",
                        keyCode: 67,
                        which: 67,
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                        view: window,
                    });

                    // Disparar em m√∫ltiplos alvos
                    document.dispatchEvent(copyEvent);
                    pdfContainer.dispatchEvent(copyEvent);
                    window.dispatchEvent(copyEvent);

                    // Aguardar c√≥pia
                    await new Promise((resolve) => setTimeout(resolve, 1500));

                    // 7. Verificar clipboard
                    const clipboardText = await navigator.clipboard.readText();

                    if (clipboardText && clipboardText.length > 100) {
                        console.log(
                            "üîç Texto obtido via simula√ß√£o f√≠sica:",
                            clipboardText.length,
                            "chars",
                        );
                        console.log(
                            "üîç Preview:",
                            clipboardText.substring(0, 300),
                        );

                        // Validar se √© conte√∫do PDF real
                        const isConteudoPDFReal =
                            validarConteudoPDFReal(clipboardText);
                        if (isConteudoPDFReal) {
                            console.log(
                                "‚úÖ Simula√ß√£o f√≠sica extraiu conte√∫do PDF v√°lido!",
                            );
                            return clipboardText;
                        } else {
                            console.log(
                                "‚ùå Simula√ß√£o f√≠sica: conte√∫do n√£o √© PDF v√°lido",
                            );
                        }
                    } else {
                        console.log(
                            "‚ùå Simula√ß√£o f√≠sica: clipboard vazio ou muito pequeno",
                        );
                    }

                    // 8. TENTATIVA ALTERNATIVA: Usar execCommand
                    console.log("üîÑ Tentativa alternativa: execCommand...");

                    const selectSuccess = document.execCommand("selectAll");
                    console.log("üìã execCommand selectAll:", selectSuccess);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    const copySuccess = document.execCommand("copy");
                    console.log("üìã execCommand copy:", copySuccess);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    const clipboardText2 = await navigator.clipboard.readText();
                    if (
                        clipboardText2 &&
                        clipboardText2 !== clipboardText &&
                        clipboardText2.length > 100
                    ) {
                        console.log(
                            "üîç Novo texto via execCommand:",
                            clipboardText2.length,
                            "chars",
                        );

                        const isConteudoPDF2 =
                            validarConteudoPDFReal(clipboardText2);
                        if (isConteudoPDF2) {
                            console.log(
                                "‚úÖ execCommand extraiu conte√∫do PDF v√°lido!",
                            );
                            return clipboardText2;
                        }
                    }

                    console.log(
                        "‚ùå Simula√ß√£o f√≠sica n√£o conseguiu extrair conte√∫do v√°lido",
                    );
                    return null;
                } catch (error) {
                    console.log("‚ùå Erro na simula√ß√£o f√≠sica:", error.message);
                    return null;
                }
            }

            //  FUN√á√ÉO: Instru√ß√£o para sele√ß√£o manual do PDF (SEM DOWNLOADS)
            async function instruirSelecaoManualPDF() {
                console.log(
                    "üìÑ Instruindo sele√ß√£o manual do PDF (sem downloads)...",
                );

                try {
                    // Instru√ß√µes para sele√ß√£o manual
                    showNotification(
                        "üìÑ Para extrair texto do PDF:\n\n‚úÖ INSTRU√á√ïES:\n1. Pressione Ctrl+A para selecionar todo o texto\n2. Pressione Ctrl+C para copiar\n3. Clique no bot√£o eProbe novamente\n\nüéØ O texto ser√° detectado automaticamente!",
                        "info",
                        8000,
                    );

                    // Aguardar um pouco e verificar clipboard
                    setTimeout(async () => {
                        const clipboardCheck =
                            await navigator.clipboard.readText();
                        if (clipboardCheck && clipboardCheck.length > 200) {
                            const isValid =
                                validarConteudoPDFReal(clipboardCheck);
                            if (isValid) {
                                showNotification(
                                    "‚úÖ Texto detectado automaticamente!",
                                    "success",
                                    3000,
                                );
                            }
                        }
                    }, 5000);

                    return null; // Aguardar a√ß√£o manual
                } catch (error) {
                    console.log("‚ùå Erro na instru√ß√£o manual:", error.message);
                    return null;
                }
            }

            // ESTRAT√âGIA A: KeyboardEvent padr√£o melhorado
            async function tentarSelecaoKeyboard(pdfElement) {
                try {
                    // Re-focar antes de tentar
                    pdfElement.focus();
                    pdfElement.click();

                    const selectAllEvent = new KeyboardEvent("keydown", {
                        key: "a",
                        code: "KeyA",
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                    });

                    // Disparar em m√∫ltiplos alvos
                    pdfElement.dispatchEvent(selectAllEvent);
                    document.dispatchEvent(selectAllEvent);
                    window.dispatchEvent(selectAllEvent);

                    await new Promise((resolve) => setTimeout(resolve, 2000)); // Mais tempo

                    // Verificar sele√ß√£o
                    const selection = window.getSelection();
                    const selectedText = selection.toString();

                    if (selectedText && selectedText.length > 100) {
                        console.log(
                            "‚úÖ Texto selecionado via KeyboardEvent:",
                            selectedText.length,
                            "chars",
                        );
                        return await validarTextoJuridico(selectedText);
                    }

                    // Se n√£o conseguiu via getSelection, tentar Ctrl+C
                    const copyEvent = new KeyboardEvent("keydown", {
                        key: "c",
                        code: "KeyC",
                        ctrlKey: true,
                        bubbles: true,
                        cancelable: true,
                    });

                    pdfElement.dispatchEvent(copyEvent);
                    document.dispatchEvent(copyEvent);
                    window.dispatchEvent(copyEvent);

                    await new Promise((resolve) => setTimeout(resolve, 1500));

                    const clipboardText = await navigator.clipboard.readText();
                    if (clipboardText && clipboardText.length > 100) {
                        console.log(
                            "‚úÖ Texto do clipboard via KeyboardEvent:",
                            clipboardText.length,
                            "chars",
                        );

                        // üîç DEBUG: Mostrar conte√∫do real
                        console.log(
                            "üîç DEBUG KeyboardEvent: Primeiros 500 chars:",
                            clipboardText.substring(0, 500),
                        );

                        const textoValidado =
                            await validarTextoJuridicoFlexivel(clipboardText);
                        if (textoValidado) {
                            return textoValidado;
                        } else {
                            console.log(
                                "‚ö†Ô∏è KeyboardEvent: Retornando texto bruto",
                            );
                            return clipboardText;
                        }
                    }

                    return null;
                } catch (error) {
                    console.log(
                        "‚ùå Erro na sele√ß√£o KeyboardEvent:",
                        error.message,
                    );
                    return null;
                }
            }

            // ESTRAT√âGIA B: execCommand (mais compat√≠vel)
            async function tentarSelecaoExecCommand(pdfElement) {
                try {
                    pdfElement.focus();
                    pdfElement.click();

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // Selecionar tudo
                    const selectAllSuccess = document.execCommand("selectAll");
                    console.log(
                        "üìã execCommand selectAll resultado:",
                        selectAllSuccess,
                    );

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // Verificar se h√° sele√ß√£o
                    const selection = window.getSelection();
                    const selectedText = selection.toString();

                    if (selectedText && selectedText.length > 100) {
                        console.log(
                            "‚úÖ Texto selecionado via execCommand:",
                            selectedText.length,
                            "chars",
                        );
                        return await validarTextoJuridico(selectedText);
                    }

                    // Copiar
                    const copySuccess = document.execCommand("copy");
                    console.log("üìã execCommand copy resultado:", copySuccess);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    const clipboardText = await navigator.clipboard.readText();
                    if (clipboardText && clipboardText.length > 100) {
                        console.log(
                            "‚úÖ Texto do clipboard via execCommand:",
                            clipboardText.length,
                            "chars",
                        );

                        // üîç DEBUG: Mostrar conte√∫do real para diagn√≥stico
                        console.log(
                            "üîç DEBUG: Primeiros 500 chars do clipboard:",
                            clipboardText.substring(0, 500),
                        );
                        console.log(
                            "üîç DEBUG: √öltimos 200 chars do clipboard:",
                            clipboardText.slice(-200),
                        );

                        // Tentar valida√ß√£o menos restritiva
                        const textoValidado =
                            await validarTextoJuridicoFlexivel(clipboardText);
                        if (textoValidado) {
                            console.log("‚úÖ Valida√ß√£o flex√≠vel passou!");
                            return textoValidado;
                        } else {
                            // Se falhou na valida√ß√£o flex√≠vel, tentar retornar texto bruto
                            console.log(
                                "‚ö†Ô∏è Valida√ß√£o flex√≠vel falhou, retornando texto bruto para an√°lise",
                            );
                            return clipboardText; // Retornar mesmo assim para debug
                        }
                    }

                    return null;
                } catch (error) {
                    console.log(
                        "‚ùå Erro na sele√ß√£o execCommand:",
                        error.message,
                    );
                    return null;
                }
            }

            // ESTRAT√âGIA C: Eventos nativos do browser
            async function tentarSelecaoEventosNativos(pdfElement) {
                try {
                    pdfElement.focus();
                    pdfElement.click();

                    // Simular clique triplo para sele√ß√£o (funciona em muitos casos)
                    const clickEvent = new MouseEvent("click", {
                        detail: 3, // Triplo clique
                        bubbles: true,
                        cancelable: true,
                    });

                    pdfElement.dispatchEvent(clickEvent);

                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    // Verificar sele√ß√£o
                    const selection = window.getSelection();
                    const selectedText = selection.toString();

                    if (selectedText && selectedText.length > 100) {
                        console.log(
                            "‚úÖ Texto selecionado via eventos nativos:",
                            selectedText.length,
                            "chars",
                        );
                        return await validarTextoJuridico(selectedText);
                    }

                    // Tentar Range API para sele√ß√£o manual de todo o documento
                    try {
                        const range = document.createRange();
                        range.selectNodeContents(pdfElement);
                        selection.removeAllRanges();
                        selection.addRange(range);

                        await new Promise((resolve) =>
                            setTimeout(resolve, 500),
                        );

                        const rangeText = selection.toString();
                        if (rangeText && rangeText.length > 100) {
                            console.log(
                                "‚úÖ Texto selecionado via Range API:",
                                rangeText.length,
                                "chars",
                            );
                            return await validarTextoJuridico(rangeText);
                        }
                    } catch (rangeError) {
                        console.log("‚ö†Ô∏è Range API falhou:", rangeError.message);
                    }

                    return null;
                } catch (error) {
                    console.log(
                        "‚ùå Erro na sele√ß√£o com eventos nativos:",
                        error.message,
                    );
                    return null;
                }
            }

            // ‚ùå FUN√á√ÉO DESABILITADA: Fetch direto do PDF (violava pol√≠ticas do eProc)
            async function tryFetchPDFExtraction() {
                console.log(
                    "‚ùå FETCH PDF DESABILITADO: Esta fun√ß√£o foi desabilitada por viola√ß√£o √†s pol√≠ticas do eProc",
                );
                return null; // Sempre retorna null
            }

            // Estrat√©gia 3: Automa√ß√£o de sele√ß√£o FOCADA NO PDF
            async function tryAutomaticSelection() {
                try {
                    console.log(
                        "ü§ñ Iniciando sele√ß√£o autom√°tica FOCADA no PDF...",
                    );

                    // 1. Encontrar elemento PDF espec√≠fico
                    const pdfContainer = findPDFContainer();
                    if (!pdfContainer) {
                        console.log(
                            "‚ùå Container do PDF n√£o encontrado - abortando sele√ß√£o autom√°tica",
                        );
                        return null;
                    }

                    console.log(
                        "üìç Container do PDF encontrado:",
                        pdfContainer.tagName,
                        pdfContainer.className || pdfContainer.id,
                    );

                    // 2. ESTRAT√âGIA ESPEC√çFICA PARA IFRAME EPROC
                    if (
                        pdfContainer.tagName === "IFRAME" &&
                        pdfContainer.src.includes("acessar_documento")
                    ) {
                        console.log(
                            "üéØ IFRAME eProc detectado - usando estrat√©gia espec√≠fica",
                        );

                        try {
                            // Tentar acessar conte√∫do do iframe
                            const iframeDoc =
                                pdfContainer.contentDocument ||
                                pdfContainer.contentWindow.document;
                            if (iframeDoc) {
                                console.log(
                                    "‚úÖ Iframe acess√≠vel - tentando sele√ß√£o interna",
                                );

                                // Focar no iframe primeiro
                                pdfContainer.focus();
                                await new Promise((resolve) =>
                                    setTimeout(resolve, 300),
                                );

                                // Selecionar conte√∫do do iframe
                                const iframeSelection =
                                    iframeDoc.getSelection();
                                iframeSelection.removeAllRanges();

                                const range = iframeDoc.createRange();
                                range.selectNodeContents(
                                    iframeDoc.body || iframeDoc.documentElement,
                                );
                                iframeSelection.addRange(range);

                                await new Promise((resolve) =>
                                    setTimeout(resolve, 500),
                                );

                                // Tentar copiar conte√∫do do iframe
                                let copySuccess = false;
                                try {
                                    copySuccess = iframeDoc.execCommand("copy");
                                } catch (e) {
                                    console.log(
                                        "‚ö†Ô∏è execCommand no iframe falhou:",
                                        e.message,
                                    );
                                }

                                if (copySuccess) {
                                    await new Promise((resolve) =>
                                        setTimeout(resolve, 500),
                                    );
                                    const clipboardText =
                                        await navigator.clipboard.readText();
                                    if (
                                        clipboardText &&
                                        clipboardText.length > 100
                                    ) {
                                        console.log(
                                            "‚úÖ Texto extra√≠do do iframe:",
                                            clipboardText.length,
                                            "chars",
                                        );
                                        return await validarTextoJuridicoFlexivel(
                                            clipboardText,
                                        );
                                    }
                                }
                            }
                        } catch (iframeError) {
                            console.log(
                                "‚ö†Ô∏è Iframe n√£o acess√≠vel (CORS):",
                                iframeError.message,
                            );
                        }

                        // Fallback para iframe: simular teclas diretamente no iframe
                        console.log(
                            "üîÑ Fallback: simula√ß√£o de teclas no iframe",
                        );
                        return await simularTeclasNoElemento(pdfContainer);
                    }

                    // 3. ESTRAT√âGIA PARA ELEMENTOS EMBED/OBJECT
                    if (
                        pdfContainer.tagName === "EMBED" ||
                        pdfContainer.tagName === "OBJECT"
                    ) {
                        console.log(
                            "üéØ Elemento EMBED/OBJECT detectado - usando estrat√©gia de plugin",
                        );
                        return await simularTeclasNoElemento(pdfContainer);
                    }

                    // 4. FALLBACK: Tentar sele√ß√£o no container geral
                    console.log("  Usando estrat√©gia geral para container");
                    return await simularTeclasNoElemento(pdfContainer);
                } catch (error) {
                    console.log(
                        "‚ùå Erro na sele√ß√£o autom√°tica:",
                        error.message,
                    );
                    return null;
                }
            }

            // Fun√ß√£o auxiliar: Simular teclas Ctrl+A e Ctrl+C em elemento espec√≠fico
            async function simularTeclasNoElemento(elemento) {
                try {
                    console.log(
                        "‚å®Ô∏è Simulando teclas no elemento:",
                        elemento.tagName,
                    );

                    // ESTRAT√âGIA ESPECIAL PARA IFRAME EPROC
                    if (
                        elemento.tagName === "IFRAME" &&
                        elemento.src.includes("acessar_documento")
                    ) {
                        console.log(
                            "üéØ IFRAME eProc - usando estrat√©gia especializada",
                        );

                        // 1. M√∫ltiplos focos para garantir ativa√ß√£o
                        for (let i = 0; i < 3; i++) {
                            elemento.focus();
                            elemento.click();
                            await new Promise((resolve) =>
                                setTimeout(resolve, 200),
                            );
                        }

                        // 2. Tentar estrat√©gias m√∫ltiplas de sele√ß√£o
                        let resultado = await tentarSelecaoViaEventos(elemento);
                        if (resultado) return resultado;

                        resultado = await tentarSelecaoViaExecCommand(elemento);
                        if (resultado) return resultado;

                        // 3. Fallback: Aguardar a√ß√£o manual com instru√ß√µes espec√≠ficas
                        return await aguardarAcaoManualEproc(elemento);
                    }

                    // ESTRAT√âGIA PADR√ÉO PARA OUTROS ELEMENTOS
                    return await simularTeclasPadrao(elemento);
                } catch (error) {
                    console.log(
                        "‚ùå Erro na simula√ß√£o de teclas:",
                        error.message,
                    );
                    return null;
                }
            }

            // Estrat√©gia 1: Eventos de teclado diretos no iframe
            // Limpar texto extraido de PDF - remover caracteres invisveis e normalizar
            function cleanExtractedText(text) {
                if (!text) return text;
                return text
                    .replace(/[\u200B-\u200D\uFEFF]/g, "")
                    .replace(/[\u00A0]/g, " ")
                    .replace(/[\u2000-\u200A]/g, " ")
                    .replace(/[\u2028\u2029]/g, "\n")
                    .replace(/\n{3,}/g, "\n\n")
                    .trim();
            }

            async function tentarSelecaoViaEventos(iframe) {
                console.log("üîÑ Tentando sele√ß√£o via eventos de teclado...");

                // Focar iframe
                iframe.focus();
                await new Promise((resolve) => setTimeout(resolve, 500));

                // Simular Ctrl+A no iframe
                const selectEvent = new KeyboardEvent("keydown", {
                    key: "a",
                    code: "KeyA",
                    ctrlKey: true,
                    bubbles: true,
                    cancelable: true,
                });

                iframe.dispatchEvent(selectEvent);
                document.dispatchEvent(selectEvent);

                await new Promise((resolve) => setTimeout(resolve, 800));

                // Simular Ctrl+C no iframe
                const copyEvent = new KeyboardEvent("keydown", {
                    key: "c",
                    code: "KeyC",
                    ctrlKey: true,
                    bubbles: true,
                    cancelable: true,
                });

                iframe.dispatchEvent(copyEvent);
                document.dispatchEvent(copyEvent);

                await new Promise((resolve) => setTimeout(resolve, 1000));

                // Verificar clipboard
                const texto = await navigator.clipboard.readText();
                if (texto && texto.length > 200) {
                    console.log(
                        "‚úÖ Texto obtido via eventos:",
                        texto.length,
                        "chars",
                    );
                    const textoValidado =
                        await validarTextoJuridicoFlexivel(texto);
                    if (textoValidado) {
                        return cleanExtractedText(textoValidado);
                    }
                }

                console.log("‚ùå Sele√ß√£o via eventos falhou");
                return null;
            }

            // Estrat√©gia 2: execCommand no contexto global
            async function tentarSelecaoViaExecCommand(iframe) {
                console.log("üîÑ Tentando sele√ß√£o via execCommand...");

                iframe.focus();
                await new Promise((resolve) => setTimeout(resolve, 500));

                // Tentar selectAll global
                const selectSuccess = document.execCommand("selectAll");
                console.log("üìã execCommand selectAll:", selectSuccess);

                if (selectSuccess) {
                    await new Promise((resolve) => setTimeout(resolve, 800));

                    const copySuccess = document.execCommand("copy");
                    console.log("üìã execCommand copy:", copySuccess);

                    if (copySuccess) {
                        await new Promise((resolve) =>
                            setTimeout(resolve, 1000),
                        );

                        const texto = await navigator.clipboard.readText();
                        if (texto && texto.length > 200) {
                            console.log(
                                "‚úÖ Texto obtido via execCommand:",
                                texto.length,
                                "chars",
                            );
                            const textoValidado =
                                await validarTextoJuridicoFlexivel(texto);
                            if (textoValidado) {
                                return cleanExtractedText(textoValidado);
                            }
                        }
                    }
                }

                console.log("‚ùå Sele√ß√£o via execCommand falhou");
                return null;
            }

            // Estrat√©gia 3: Aguardar a√ß√£o manual espec√≠fica para eProc
            async function aguardarAcaoManualEproc(iframe) {
                console.log(
                    "üîÑ Iniciando aguardo de a√ß√£o manual para eProc...",
                );

                // Instru√ß√µes espec√≠ficas para PDF do eProc
                showNotification(
                    "INSTRUCOES PARA PDF EPROC:\n\n" +
                        "1. CLIQUE dentro da area do PDF (documento azul)\n" +
                        "2. Pressione CTRL+A (selecionar tudo)\n" +
                        "3. Pressione CTRL+C (copiar)\n" +
                        "4. Clique no botao eProbe novamente\n\n" +
                        "O sistema detectara automaticamente o texto copiado!",
                    "info",
                    15000,
                );

                // Aguardar e verificar clipboard periodicamente
                for (let i = 0; i < 20; i++) {
                    // 20 segundos max
                    await new Promise((resolve) => setTimeout(resolve, 1000));

                    try {
                        const texto = await navigator.clipboard.readText();
                        if (texto && texto.length > 200) {
                            console.log(
                                "üîç Verificando texto do clipboard:",
                                texto.length,
                                "chars",
                            );

                            const textoValidado =
                                await validarTextoJuridicoFlexivel(texto);
                            if (textoValidado) {
                                console.log(
                                    "‚úÖ Texto jur√≠dico v√°lido detectado!",
                                );
                                showNotification(
                                    "Texto extraido com sucesso!",
                                    "success",
                                    3000,
                                );
                                return cleanExtractedText(textoValidado);
                            }
                        }
                    } catch (e) {
                        // Continuar tentando
                    }
                }

                console.log("‚è∞ Timeout: aguardo de a√ß√£o manual expirou");
                return null;
            }

            // Estrat√©gia padr√£o para elementos n√£o-iframe
            async function simularTeclasPadrao(elemento) {
                console.log(
                    "‚å®Ô∏è Usando simula√ß√£o padr√£o para:",
                    elemento.tagName,
                );

                // 1. Focar elemento e aguardar
                elemento.focus();
                elemento.click();
                await new Promise((resolve) => setTimeout(resolve, 300));

                // 2. Simular Ctrl+A
                const selectAllEvent = new KeyboardEvent("keydown", {
                    key: "a",
                    code: "KeyA",
                    ctrlKey: true,
                    bubbles: true,
                    cancelable: true,
                });

                elemento.dispatchEvent(selectAllEvent);
                await new Promise((resolve) => setTimeout(resolve, 500));

                // 3. Simular Ctrl+C
                const copyEvent = new KeyboardEvent("keydown", {
                    key: "c",
                    code: "KeyC",
                    ctrlKey: true,
                    bubbles: true,
                    cancelable: true,
                });

                elemento.dispatchEvent(copyEvent);
                await new Promise((resolve) => setTimeout(resolve, 500));

                // 4. Verificar clipboard
                const clipboardText = await navigator.clipboard.readText();
                if (clipboardText && clipboardText.length > 100) {
                    console.log(
                        "‚úÖ Texto extra√≠do via simula√ß√£o:",
                        clipboardText.length,
                        "chars",
                    );

                    // Validar se √© conte√∫do jur√≠dico v√°lido
                    const textoValidado =
                        await validarTextoJuridicoFlexivel(clipboardText);
                    if (textoValidado) {
                        return cleanExtractedText(textoValidado);
                    }
                }

                console.log("‚ùå Simula√ß√£o padr√£o n√£o obteve texto v√°lido");
                return null;
            }

            // Fun√ß√£o auxiliar: Detectar URL do PDF
            function getPDFUrl() {
                // 1. Buscar elementos PDF incorporados
                const pdfSelectors = [
                    'iframe[src*="pdf"]',
                    'embed[type="application/pdf"]',
                    'object[type="application/pdf"]',
                    'iframe[src*="acessar_documento"]',
                    "#plugin",
                    'embed[type="application/x-google-chrome-pdf"]',
                ];

                for (const selector of pdfSelectors) {
                    const element = document.querySelector(selector);
                    if (element && (element.src || element.data)) {
                        return element.src || element.data;
                    }
                }

                // 2. Usar URL atual se for documento do eProc
                if (window.location.href.includes("acessar_documento")) {
                    return window.location.href;
                }

                return null;
            }

            // Fun√ß√£o auxiliar: Encontrar container do PDF com foco preciso
            function findPDFContainer() {
                // 1. PRIORIDADE: Elementos PDF diretos (n√£o body como fallback)
                const pdfElements = [
                    'iframe[src*="acessar_documento"]',
                    'embed[type="application/pdf"]',
                    'object[type="application/pdf"]',
                    'iframe[src*="pdf"]',
                    'embed[type="application/x-google-chrome-pdf"]',
                    "#plugin",
                ];

                for (const selector of pdfElements) {
                    const element = document.querySelector(selector);
                    if (element) {
                        console.log(
                            "üìç Container PDF espec√≠fico encontrado:",
                            selector,
                        );
                        return element;
                    }
                }

                // 2. Buscar por divs que podem conter PDF
                const pdfContainerSelectors = [
                    'div[class*="pdf"]',
                    'div[id*="pdf"]',
                    'div[class*="document"]',
                    'div[id*="document"]',
                ];

                for (const selector of pdfContainerSelectors) {
                    const element = document.querySelector(selector);
                    if (element && element.offsetHeight > 400) {
                        // Garantir que √© um container significativo
                        console.log(
                            "üìç Container documento encontrado:",
                            selector,
                        );
                        return element;
                    }
                }

                console.log("‚ùå Nenhum container PDF espec√≠fico encontrado");
                return null; // NUNCA usar body como fallback
            }

            // Fun√ß√£o auxiliar: Extrair texto com PDF.js
            async function extractWithPDFJS(arrayBuffer) {
                try {
                    console.log("üìö Extraindo com PDF.js...");

                    const pdf = await pdfjsLib.getDocument({
                        data: arrayBuffer,
                    }).promise;
                    console.log("üìÑ PDF carregado, p√°ginas:", pdf.numPages);

                    let fullText = "";
                    const maxPages = Math.min(pdf.numPages, 15); // Limite de 15 p√°ginas

                    for (let i = 1; i <= maxPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items
                            .map((item) => item.str)
                            .join(" ");
                        fullText += pageText + "\n\n";
                    }

                    if (fullText.trim().length > 100) {
                        return cleanExtractedText(fullText);
                    }

                    return null;
                } catch (error) {
                    console.log(
                        "‚ùå Erro na extra√ß√£o com PDF.js:",
                        error.message,
                    );
                    return null;
                }
            }

            // Fun√ß√£o auxiliar: Carregar PDF.js local (CSP-safe)
            async function loadLocalPDFJS() {
                try {
                    // Verificar se PDF.js j√° est√° dispon√≠vel
                    if (typeof pdfjsLib !== "undefined") {
                        return true;
                    }

                    // Tentar carregar PDF.js do navegador (se dispon√≠vel)
                    if (typeof window.pdfjsLib !== "undefined") {
                        window.pdfjsLib = window.pdfjsLib;
                        return true;
                    }

                    console.log(
                        "‚ö†Ô∏è PDF.js n√£o dispon√≠vel - usando apenas sele√ß√£o autom√°tica",
                    );
                    return false;
                } catch (error) {
                    console.log("‚ùå Erro ao carregar PDF.js:", error.message);
                    return false;
                }
            }

            // Fun√ß√£o auxiliar: Validar se √© documento jur√≠dico
            function isValidLegalDocument(text) {
                if (!text || text.length < 100) return false;

                // Detectar logs do console
                const logPatterns = [
                    /main\.js:/,
                    /üö®/,
                    /VM\d+/,
                    /üìÑ|üîç|‚úÖ|‚ùå|‚ö†Ô∏è|üéØ|üìã|üîß|üåê|üìä/,
                    /console\./,
                    /ERROR|WARNING|INFO|DEBUG/i,
                    /Intercepta√ß√£o|INTERCEPTA√á√ÉO/i,
                ];

                for (const pattern of logPatterns) {
                    if (pattern.test(text)) {
                        console.log("‚ùå Detectado log do console no texto");
                        return false;
                    }
                }

                // Validar palavras-chave jur√≠dicas
                const legalKeywords = [
                    /\b(senten√ßa|decis√£o|despacho|ac√≥rd√£o)\b/i,
                    /\b(processo|requerente|requerido|autor|r√©u)\b/i,
                    /\b(tribunal|juiz|desembargador|ministro)\b/i,
                    /\b(peti√ß√£o|inicial|contesta√ß√£o|recurso)\b/i,
                    /\b(dispositivo|fundamenta√ß√£o|relat√≥rio)\b/i,
                    /\b(artigo|lei|c√≥digo|norma)\b/i,
                    /\b(julgo|decreto|determino|defiro|indefiro)\b/i,
                ];

                let keywordCount = 0;
                for (const keyword of legalKeywords) {
                    if (keyword.test(text)) {
                        keywordCount++;
                    }
                }

                return keywordCount >= 2; // Pelo menos 2 palavras-chave jur√≠dicas
            }

            // üîß FUN√á√ÉO ALTERNATIVA PARA PDF (SEM PDF.JS EXTERNO - CSP SAFE)
            async function loadPDFJS() {
                return new Promise((resolve, reject) => {
                    // ‚ùå CSP n√£o permite carregar PDF.js externo
                    // ‚úÖ SOLU√á√ÉO: Usar estrat√©gias nativas do navegador

                    console.log("üì¶ Usando estrat√©gias nativas (CSP safe)...");

                    // ‚úÖ ESTRAT√âGIA 1: Verificar se o texto j√° est√° no clipboard
                    checkClipboardForPDFText()
                        .then((clipboardText) => {
                            if (clipboardText && clipboardText.length > 500) {
                                console.log(
                                    "‚úÖ Texto encontrado no clipboard, usando essa estrat√©gia",
                                );
                                resolve({
                                    type: "clipboard",
                                    text: clipboardText,
                                });
                                return;
                            }

                            // ‚úÖ ESTRAT√âGIA 2: Instruir usu√°rio para sele√ß√£o manual
                            console.log(
                                "üéØ Estrat√©gia de sele√ß√£o manual ativada",
                            );

                            // Aguardar um pouco e verificar novamente o clipboard
                            setTimeout(async () => {
                                try {
                                    const newClipboardText =
                                        await checkClipboardForPDFText();
                                    if (
                                        newClipboardText &&
                                        newClipboardText.length > 500
                                    ) {
                                        resolve({
                                            type: "clipboard-delayed",
                                            text: newClipboardText,
                                        });
                                    } else {
                                        resolve({
                                            type: "manual-instruction",
                                            instructions: [
                                                "1. Selecione todo o texto do PDF (Ctrl+A)",
                                                "2. Copie o texto (Ctrl+C)",
                                                "3. Clique novamente no bot√£o eProbe",
                                            ],
                                        });
                                    }
                                } catch (error) {
                                    resolve({
                                        type: "fallback",
                                        message:
                                            "Use sele√ß√£o manual (Ctrl+A, Ctrl+C)",
                                    });
                                }
                            }, 2000);
                        })
                        .catch((error) => {
                            console.log(
                                "‚ö†Ô∏è Erro ao verificar clipboard:",
                                error,
                            );
                            resolve({
                                type: "fallback",
                                message: "Use sele√ß√£o manual (Ctrl+A, Ctrl+C)",
                            });
                        });
                });
            }

            // Aguardar documento carregar completamente
            function waitForDocumentLoad() {
                return new Promise((resolve) => {
                    if (document.readyState === "complete") {
                        resolve();
                    } else {
                        window.addEventListener("load", resolve);
                    }
                });
            }

            // Copiar para clipboard - usando express√£o de fun√ß√£o
            const copyToClipboard = async function (text) {
                try {
                    await navigator.clipboard.writeText(text);
                    log(" Texto copiado para clipboard");
                    showNotification(
                        "Texto copiado para clipboard!",
                        "success",
                    );
                    return true;
                } catch (error) {
                    log(" Erro ao copiar:", error);
                    showNotification("Erro ao copiar texto", "error");
                    return false;
                }
            };

            // Limpar caracteres invis√≠veis que podem causar problemas no clipboard
            function cleanInvisibleChars(text) {
                return text
                    .replace(/[\u200B-\u200D\uFEFF]/g, "") // Remove zero-width chars
                    .replace(/[\u00A0]/g, " ") // Replace non-breaking space with regular space
                    .replace(/[\u2000-\u200A]/g, " ") // Replace various unicode spaces
                    .replace(/[\u2028\u2029]/g, "\n") // Replace line/paragraph separators
                    .trim();
            }

            // Copiar texto para clipboard com prefixo para IA
            async function copyToClipboardWithPrefix(texto) {
                try {
                    const prefixo = `Fa√ßa um resumo extremamente sucinto do documento, em formato de apontamentos diretos (bullet points), para constar na capa do processo digital. Indique: tipo de a√ß√£o, partes, pedido(s) do autor, decis√£o (improcedente/procedente/parcialmente procedente), fundamentos centrais, condena√ß√£o (custas/honor√°rios se houver) Seja objetivo e direto, sem reda√ß√£o em texto corrido. 
                
                DOCUMENTO:`;

                    const textoLimpo = cleanInvisibleChars(texto);

                    // ‚úÖ VERIFICAR SE O TEXTO J√Å CONT√âM O PREFIXO
                    let textoCompleto;
                    if (
                        textoLimpo.includes(
                            "Fa√ßa um resumo extremamente sucinto",
                        ) ||
                        textoLimpo.includes("DOCUMENTO:")
                    ) {
                        console.log(
                            "‚ö†Ô∏è Texto j√° cont√©m prefixo, usando apenas o texto limpo",
                        );
                        textoCompleto = textoLimpo;
                    } else {
                        console.log("‚úÖ Adicionando prefixo ao texto");
                        textoCompleto = cleanInvisibleChars(
                            prefixo + textoLimpo,
                        );
                    }

                    log(" Debug - Texto que ser√° copiado:");
                    log(" Tamanho:", textoCompleto.length, "caracteres");
                    log(
                        " Pr√©via (primeiros 200 chars):",
                        textoCompleto.substring(0, 200),
                    );
                    log(
                        " Final (√∫ltimos 200 chars):",
                        textoCompleto.substring(textoCompleto.length - 200),
                    );

                    await navigator.clipboard.writeText(textoCompleto);

                    // Verificar se realmente foi copiado
                    setTimeout(async () => {
                        try {
                            const clipboardContent =
                                await navigator.clipboard.readText();
                            log(
                                " Verifica√ß√£o: Texto no clipboard:",
                                clipboardContent.length,
                                "caracteres",
                            );
                            log(
                                " Conte√∫do real no clipboard:",
                                clipboardContent.substring(0, 200),
                            );

                            if (clipboardContent === textoCompleto) {
                                log(" Clipboard confirmado: Texto correto!");
                            } else {
                                log(
                                    " ERRO: Texto no clipboard √© diferente do enviado!",
                                );
                                log(" Debug diferen√ßa:");
                                log(
                                    " Esperado:",
                                    textoCompleto.length,
                                    "caracteres",
                                );
                                log(
                                    " Real:",
                                    clipboardContent.length,
                                    "caracteres",
                                );
                                log(
                                    " Diferen√ßa:",
                                    Math.abs(
                                        clipboardContent.length -
                                            textoCompleto.length,
                                    ),
                                    "caracteres",
                                );

                                // Verificar se √© apenas uma diferen√ßa de caracteres invis√≠veis
                                const textoLimpo = textoCompleto.replace(
                                    /[\u200B-\u200D\uFEFF]/g,
                                    "",
                                );
                                const clipboardLimpo = clipboardContent.replace(
                                    /[\u200B-\u200D\uFEFF]/g,
                                    "",
                                );

                                if (textoLimpo === clipboardLimpo) {
                                    log(
                                        " Clipboard OK (apenas caracteres invis√≠veis diferentes)",
                                    );
                                } else {
                                    log(" Clipboard realmente diferente");
                                    // Encontrar primeiro caractere diferente
                                    for (
                                        let i = 0;
                                        i <
                                        Math.min(
                                            textoCompleto.length,
                                            clipboardContent.length,
                                        );
                                        i++
                                    ) {
                                        if (
                                            textoCompleto[i] !==
                                            clipboardContent[i]
                                        ) {
                                            log(
                                                ` Primeira diferen√ßa na posi√ß√£o ${i}:`,
                                            );
                                            log(
                                                `Esperado: "${textoCompleto.substring(
                                                    i - 5,
                                                    i + 5,
                                                )}"`,
                                            );
                                            log(
                                                `Real: "${clipboardContent.substring(
                                                    i - 5,
                                                    i + 5,
                                                )}"`,
                                            );
                                            break;
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            log(" N√£o foi poss√≠vel verificar o clipboard:", e);
                        }
                    }, 100);

                    log(
                        ` Texto copiado com prefixo (${textoCompleto.length} caracteres)`,
                    );
                    showNotification(
                        ` Texto copiado com prefixo!\n${textoCompleto.length} caracteres prontos para IA`,
                        "success",
                    );
                    return true;
                } catch (error) {
                    log(" Erro ao copiar texto com prefixo:", error);
                    showNotification(" Erro ao copiar texto", "error");
                    return false;
                }
            }

            // Fun√ß√£o gen√©rica para abrir IA com texto e prompt espec√≠fico
            async function openAIWithText(aiName, url, texto) {
                try {
                    log(`üöÄ Abrindo ${aiName} para an√°lise manual...`);

                    // Preparar o prompt espec√≠fico para an√°lise judicial
                    const prompt = `Voc√™ √© um assistente especializado em resumir documentos judiciais de forma extremamente objetiva e sucinta para capas de processos digitais. Sempre responda em bullet points diretos.

    Fa√ßa um resumo extremamente sucinto do documento, em formato de apontamentos diretos (bullet points), para constar na capa do processo digital. Indique: tipo de a√ß√£o, partes, pedido(s) do autor, decis√£o (improcedente/procedente/parcialmente procedente), fundamentos centrais, condena√ß√£o (custas/honor√°rios se houver). Seja objetivo e direto, sem reda√ß√£o em texto corrido.

    DOCUMENTO:
    ${texto}`;

                    // Copiar para √°rea de transfer√™ncia
                    await navigator.clipboard.writeText(prompt);

                    log(
                        `‚úÖ Texto preparado para ${aiName} (${prompt.length} caracteres)`,
                    );

                    // Abrir IA em nova aba
                    window.open(url, "_blank");

                    showNotification(
                        `${aiName} aberto!\n\nO prompt com o documento est√° na √°rea de transfer√™ncia.\nCole no ${aiName} (Ctrl+V) para an√°lise.`,
                        "success",
                    );

                    log(`‚úÖ ${aiName} aberto com sucesso em nova aba`);
                    return true;
                } catch (error) {
                    log(`‚ùå Erro ao abrir ${aiName}:`, error);
                    showNotification(`‚ùå Erro ao abrir ${aiName}`, "error");
                    return false;
                }
            }

            // Fun√ß√£o para abrir IA com prompt personalizado
            async function openAIWithCustomPrompt(aiName, url, prompt) {
                try {
                    log(
                        `üöÄ Abrindo ${aiName} para an√°lise com prompt personalizado...`,
                    );

                    // Copiar prompt para √°rea de transfer√™ncia
                    await navigator.clipboard.writeText(prompt);

                    log(
                        `‚úÖ Prompt preparado para ${aiName} (${prompt.length} caracteres)`,
                    );

                    // Abrir IA em nova aba
                    window.open(url, "_blank");

                    showNotification(
                        `${aiName} aberto!\n\nO prompt com o documento est√° na √°rea de transfer√™ncia.\nCole no ${aiName} (Ctrl+V) para an√°lise.`,
                        "success",
                    );

                    log(`‚úÖ ${aiName} aberto com sucesso em nova aba`);
                    return true;
                } catch (error) {
                    log(`‚ùå Erro ao abrir ${aiName}:`, error);
                    showNotification(`‚ùå Erro ao abrir ${aiName}`, "error");
                    return false;
                }
            }

            // Fun√ß√£o para Perplexity com prompt personalizado
            async function sendToPerplexityWithPrompt(texto, promptType) {
                const requestId = Date.now().toString();

                try {
                    debugApiCall(requestId, "IN√çCIO", {
                        textoLength: texto.length,
                        promptType: promptType,
                    });
                    log(
                        ` Enviando texto para Perplexity via API com prompt ${promptType}...`,
                    );
                    showNotification("Enviando para Perplexity...", "info");

                    const apiKey = await getStoredApiKey();
                    if (!apiKey) {
                        debugApiCall(
                            requestId,
                            "ERRO",
                            "API key n√£o encontrada",
                        );
                        showNotification(" Erro ao obter chave API", "error");
                        return false;
                    }

                    // Definir prompts baseado no tipo
                    let prompt;
                    if (promptType === "resumir") {
                        prompt = `Fa√ßa um resumo extremamente sucinto do documento, em formato de apontamentos diretos (bullet points), para constar na capa do processo digital. Indique: tipo de a√ß√£o, partes, pedido(s) do autor, decis√£o (improcedente/procedente/parcialmente procedente), fundamentos centrais, condena√ß√£o (custas/honor√°rios se houver). Seja objetivo e direto, sem reda√ß√£o em texto corrido. DOCUMENTO: ${texto}`;
                    } else if (promptType === "relatorio") {
                        prompt = `Atue como um assessor de desembargador do Tribunal de Justi√ßa de Santa Catarina que est√° redigindo uma minuta de ac√≥rd√£o sobre o caso relatado na peti√ß√£o fornecida. Considerando o que consta na peti√ß√£o, transforme-a em um pequeno relat√≥rio com a seguinte estrutura:

Alega a parte ("apelante" ou "impetrante" ou "agravante" ou "embargante" etc., a depender do tipo de recurso) que...

Afirma que...

Requer a concess√£o de ("antecipa√ß√£o dos efeitos da tutela recursal" ou "efeito suspensivo" ou "liminar" etc., dependendo do pedido) para...

No m√©rito, postula a...

Use: linguagem impessoal ("entende-se" ao inv√©s de "entendo", por exemplo) e seja sucinto.

Evite utilizar o nome real das partes. Refira-se √†s partes sempre como "apelante"/"apelada" ou "impetrante"/"impetrada" ou "agravante"/"agravada" ou "embargante"/"embargada" etc., a depender do tipo de recurso.

Utilize uma estrutura de texto, sem s√≠mbolos ou caracteres especiais no in√≠cio dos par√°grafos.

Regras de escrita:

Use linguagem objetiva, evitando termos excessivamente rebuscados.

N√£o inicie frases com "com efeito" ou "destarte".

N√£o utilize "fulcro" ou "com fulcro".

N√£o empregue "resta" com sentido de "est√°".

Utilize a express√£o "celebrar contrato" ao inv√©s de "firmar contrato".

Utilize o formato de data DD/MM/AAAA e abrevie "n√∫mero" como "n.", nunca "n¬∫", "n¬∫." ou outra forma que n√£o "n.".

IMPORTANTE: sempre use colchetes ao inv√©s de par√™nteses.

S√≥ descreva informa√ß√µes reais presentes no documento.

Ao citar dispositivos legais, utilize exclusivamente esse padr√£o: "conforme determina o ¬ß 2¬∫ do art. 86 da Lei n. 8.213/1991". Sempre indique primeiro o par√°grafo (se houver), depois o artigo, seguido do n√∫mero e ano da lei, exatamente neste formato.

DOCUMENTO: ${texto}`;
                    } else if (promptType === "lembrete") {
                        prompt = `Voc√™ √© um assistente especializado em resumir documentos judiciais de forma extremamente objetiva e sucinta para capas de processos digitais. Sua tarefa √© fazer um resumo extremamente sucinto do documento, em formato de apontamentos diretos (bullet points), para constar na capa do processo digital. Seja objetivo e direto, sem reda√ß√£o em texto corrido. Voc√™ dever√° OBRIGATORIAMENTE MANTER os c√≥digos html na vers√£o entregue ao usu√°rio.

SEMPRE responda em bullet points diretos, com seguinte formato:

__________________________________

<b>Apelante/Recorrente/Embargante/Agravante/Impetrante</b>: Nome da Parte (usar plural em caso de mais de um apelante/recorrente etc.)<p>
<b>Paciente</b>: Nome da Parte (incluir SOMENTE se tratar de Habeas Corpus), usar plural em caso de mais de um apelante/recorrente etc.)<p>
<b>A√ß√£o</b>: Tipo de A√ß√£o na origem ("anulat√≥ria de d√©bito fiscal", "a√ß√£o por danos morais e materiais", "a√ß√£o penal p√∫blica condicionada ou incondicionada ou a√ß√£o penal privada", "inqu√©rito policial", "pedido de busca e apreens√£o", "pedido de pris√£o tempor√°ria formulado pelo MP ou formulado pelo Delegado de Pol√≠cia", "mandado de seguran√ßa", etc.; caso a informa√ß√£o n√£o consiga ser extra√≠da da pe√ßa enviada pelo usu√°rio, n√£o inclua este item; a "a√ß√£o da origem" √© aquela referente ao processo de primeiro grau, n√£o √© o recurso que a parte est√° interpondo agora<p>
<b>Objeto do Recurso</b>: resumo da decis√£o contra a qual a parte est√° se insurgindo (ex: "senten√ßa que condenou o apelante ao pagamento de danos morais no valor de...", "senten√ßa que condenou o apelante pela pr√°tica dos crimes do art. 121 do C√≥digo Penal e do art. 33 da Lei n. 11.343/2006, em concurso material", "decis√£o que pronunciou o recorrente pela pr√°tica do crime do art. 121, ¬ß 2¬∫, inciso II c/c art. 14, inciso II, ambos do C√≥digo Penal", "ac√≥rd√£o proferido na sess√£o de DD/MM/AAAA", "ac√≥rd√£o que deu parcial provimento ao recurso do autor/r√©u", etc.)
<b>Pedidos</b>: pedidos formulados no recurso pela parte, separados por ";" caso sejam mais de um (ex: "reforma da senten√ßa para absolver o acusado"; "reforma da senten√ßa para afastar a condena√ß√£o ao pagamento de compensa√ß√£o por danos morais"; "concess√£o da ordem para determinar a soltura do paciente, com base nos arts. XXX", "acolhimento dos embargos de declara√ß√£o para sanar a omiss√£o, com efeito infringente para desprover/prover o recurso", etc); caso o objeto seja uma decis√£o de pron√∫ncia, N√ÉO UTILIZE a estrutura "decis√£o de pron√∫ncia que pronunciou...", UTILIZE a estrutura "decis√£o que pronunciou o/a...",)<p>
<b>Pedidos</b>: pedidos formulados pela parte no recurso, separados por ";" caso sejam mais de um (ex: "reforma da senten√ßa para absolver o acusado"; "reforma da senten√ßa para afastar a condena√ß√£o ao pagamento de compensa√ß√£o por danos morais"; "concess√£o da ordem para determinar a soltura do paciente, com base nos arts. XXX", "acolhimento dos embargos de declara√ß√£o para sanar a omiss√£o, com efeitos infringentes para desprover/prover o recurso", etc.)

__________________________________

OBSERVA√á√ÉO IMPORTANTE E CR√çTICA, REGRA IMPRESCIND√çVEL: Quando devolver qualquer conte√∫do que contenha tags HTML (ex.: <b>, <p>, <a>), sempre coloque-o entre tr√™s crases (\`\`\`), sem especificar linguagem. N√£o renderize HTML. Mostre literalmente.

DOCUMENTO: ${texto}`;
                    } else {
                        // Fallback para o prompt padr√£o
                        prompt = `Fa√ßa um resumo extremamente sucinto do documento, em formato de apontamentos diretos (bullet points), para constar na capa do processo digital. Indique: tipo de a√ß√£o, partes, pedido(s) do autor, decis√£o (improcedente/procedente/parcialmente procedente), fundamentos centrais, condena√ß√£o (custas/honor√°rios se houver). Seja objetivo e direto, sem reda√ß√£o em texto corrido. DOCUMENTO: ${texto}`;
                    }

                    const requestBody = {
                        model: "sonar",
                        messages: [
                            {
                                role: "system",
                                content:
                                    "Voc√™ √© um assistente especializado em resumir documentos judiciais de forma extremamente objetiva e sucinta para capas de processos digitais. Sempre responda em bullet points diretos.",
                            },
                            {
                                role: "user",
                                content: prompt,
                            },
                        ],
                        max_tokens: 1200,
                        temperature: 0.1,
                        top_p: 0.9,
                    };

                    debugApiCall(requestId, "REQUEST_BODY", {
                        model: requestBody.model,
                        promptLength: prompt.length,
                        maxTokens: requestBody.max_tokens,
                    });

                    const response = await fetch(
                        "https://api.perplexity.ai/chat/completions",
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                Authorization: `Bearer ${apiKey}`,
                                "User-Agent": "eProbe-Extension/1.0",
                            },
                            body: JSON.stringify(requestBody),
                        },
                    );

                    if (!response.ok) {
                        const errorText = await response.text();
                        debugApiCall(requestId, "ERRO_HTTP", {
                            status: response.status,
                            statusText: response.statusText,
                            error: errorText,
                        });
                        throw new Error(
                            `HTTP ${response.status}: ${response.statusText} - ${errorText}`,
                        );
                    }

                    const data = await response.json();
                    debugApiCall(requestId, "RESPONSE", {
                        choices: data.choices?.length || 0,
                        usage: data.usage,
                    });

                    if (
                        data.choices &&
                        data.choices.length > 0 &&
                        data.choices[0].message
                    ) {
                        const resultado = data.choices[0].message.content;

                        log("‚úÖ Resposta recebida do Perplexity:", {
                            length: resultado.length,
                            promptLength: prompt.length,
                            usage: data.usage,
                        });

                        // Copiar resultado para √°rea de transfer√™ncia
                        await navigator.clipboard.writeText(resultado);

                        showNotification(
                            `‚úÖ Resumo gerado pelo Perplexity!\n\nResposta copiada para √°rea de transfer√™ncia.\nUse Ctrl+V para colar.`,
                            "success",
                        );

                        debugApiCall(requestId, "SUCESSO", {
                            resultLength: resultado.length,
                            usage: data.usage,
                        });

                        return true;
                    } else {
                        debugApiCall(
                            requestId,
                            "ERRO",
                            "Resposta sem conte√∫do v√°lido",
                        );
                        showNotification(
                            "‚ùå Resposta vazia do Perplexity",
                            "error",
                        );
                        return false;
                    }
                } catch (error) {
                    debugApiCall(requestId, "ERRO_CATCH", error.message);
                    log("‚ùå Erro ao chamar Perplexity:", error);

                    const errorMessage = error.message.includes("401")
                        ? "‚ùå Erro de autentica√ß√£o. Verifique sua API key."
                        : error.message.includes("429")
                          ? "‚ùå Limite de requisi√ß√µes excedido. Tente novamente em alguns minutos."
                          : error.message.includes("timeout")
                            ? "‚ùå Timeout na requisi√ß√£o. Tente novamente."
                            : `‚ùå Erro ao chamar Perplexity: ${error.message}`;

                    showNotification(errorMessage, "error");
                    return false;
                }
            }

            // Modal para sele√ß√£o de prompt para Perplexity (retorna apenas o tipo selecionado)
            async function showPerplexityPromptModal() {
                return new Promise((resolve) => {
                    // Remover modal existente se houver
                    const existingModal = document.getElementById(
                        "perplexity-prompt-modal",
                    );
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Criar overlay do modal
                    const overlay = document.createElement("div");
                    overlay.id = "perplexity-prompt-modal";
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        z-index: 10003;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        font-family: "Roboto", -apple-system, system-ui, sans-serif;
                    `;

                    // Criar conte√∫do do modal
                    const modal = document.createElement("div");
                    modal.style.cssText = `
                        background: #134377;
                        border-radius: 12px;
                        padding: 32px;
                        max-width: 600px;
                        width: 90%;
                        max-height: 80vh;
                        overflow-y: auto;
                        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.4);
                        border: 1px solid rgba(82, 82, 82, 0.3);
                    `;

                    modal.innerHTML = `
                        <div style="text-align: center; margin-bottom: 24px;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 8px;">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="#22B8CD">
                                    <path d="M19.785 0v7.272H22.5V17.62h-2.935V24l-7.037-6.194v6.145h-1.091v-6.152L4.392 24v-6.465H1.5V7.188h2.884V0l7.053 6.494V.19h1.09v6.49L19.786 0zm-7.257 9.044v7.319l5.946 5.234V14.44l-5.946-5.397zm-1.099-.08l-5.946 5.398v7.235l5.946-5.234V8.965zm8.136 7.58h1.844V8.349H13.46l6.105 5.54v2.655zm-8.982-8.28H2.59v8.195h1.8v-2.576l6.192-5.62zM5.475 2.476v4.71h5.115l-5.115-4.71zm13.219 0l-5.115 4.71h5.115v-4.71z"/>
                                </svg>
                                <h2 style="color: white; margin: 0; font-size: 24px; font-weight: 600;">
                                    Escolha o prompt para Perplexity
                                </h2>
                            </div>
                            <p style="color: rgb(203 213 225); margin: 0; font-size: 16px;">
                                Selecione qual tipo de an√°lise deseja fazer no documento
                            </p>
                        </div>

                        <div style="display: grid; gap: 16px; margin-bottom: 24px;">
                            <button id="perplexity-prompt-resumir" class="prompt-option" style="
                                display: flex;
                                flex-direction: column;
                                align-items: flex-start;
                                gap: 8px;
                                padding: 20px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                text-align: left;
                            ">
                                <div style="display: flex; align-items: center; gap: 12px; width: 100%;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M8 6h13"/>
                                        <path d="M8 12h13"/>
                                        <path d="M8 18h13"/>
                                        <path d="M3 6h.01"/>
                                        <path d="M3 12h.01"/>
                                        <path d="M3 18h.01"/>
                                    </svg>
                                    <div style="font-size: 18px; font-weight: 600;">Resumir em t√≥picos curtos</div>
                                </div>
                                <div style="font-size: 14px; color: rgb(203 213 225); line-height: 1.4;">
                                    Gera um resumo objetivo em bullet points para capa do processo digital, indicando tipo de a√ß√£o, partes, pedidos, decis√£o e fundamentos.
                                </div>
                            </button>

                            <button id="perplexity-prompt-relatorio" class="prompt-option" style="
                                display: flex;
                                flex-direction: column;
                                align-items: flex-start;
                                gap: 8px;
                                padding: 20px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                text-align: left;
                            ">
                                <div style="display: flex; align-items: center; gap: 12px; width: 100%;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                        <polyline points="14,2 14,8 20,8"/>
                                        <line x1="16" y1="13" x2="8" y2="13"/>
                                        <line x1="16" y1="17" x2="8" y2="17"/>
                                        <polyline points="10,9 9,9 8,9"/>
                                    </svg>
                                    <div style="font-size: 18px; font-weight: 600;">Gerar relat√≥rio para ac√≥rd√£o</div>
                                </div>
                                <div style="font-size: 14px; color: rgb(203 213 225); line-height: 1.4;">
                                    Transforma a peti√ß√£o em relat√≥rio estruturado para minuta de ac√≥rd√£o, seguindo linguagem t√©cnica impessoal e formato espec√≠fico do tribunal.
                                </div>
                            </button>

                            <button id="perplexity-prompt-lembrete" class="prompt-option" style="
                                display: flex;
                                flex-direction: column;
                                align-items: flex-start;
                                gap: 8px;
                                padding: 20px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                text-align: left;
                            ">
                                <div style="display: flex; align-items: center; gap: 12px; width: 100%;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                                    </svg>
                                    <div style="font-size: 18px; font-weight: 600;">Criar lembrete</div>
                                </div>
                                <div style="font-size: 14px; color: rgb(203 213 225); line-height: 1.4;">
                                    Gera resumo estruturado com formata√ß√£o HTML para capa do processo, incluindo partes, a√ß√£o, objeto do recurso e pedidos.
                                </div>
                            </button>
                        </div>

                        <div style="display: flex; justify-content: center; gap: 12px;">
                            <button id="cancel-perplexity-prompt" style="
                                padding: 12px 24px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 1px solid rgba(255, 255, 255, 0.2);
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                font-size: 14px;
                                transition: all 0.2s ease;
                            ">
                                Cancelar
                            </button>
                        </div>
                    `;

                    // Adicionar CSS hover via JavaScript
                    const style = document.createElement("style");
                    style.textContent = `
                        .prompt-option:hover {
                            background: rgba(255, 255, 255, 0.2) !important;
                            border-color: rgba(255, 255, 255, 0.3) !important;
                            transform: translateY(-1px);
                        }
                        #cancel-perplexity-prompt:hover {
                            background: rgba(255, 255, 255, 0.2) !important;
                        }
                    `;
                    document.head.appendChild(style);

                    // Adicionar eventos aos bot√µes
                    modal
                        .querySelector("#perplexity-prompt-resumir")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve("resumir");
                        });

                    modal
                        .querySelector("#perplexity-prompt-relatorio")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve("relatorio");
                        });

                    modal
                        .querySelector("#perplexity-prompt-lembrete")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve("lembrete");
                        });

                    modal
                        .querySelector("#cancel-perplexity-prompt")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(null);
                        });

                    // Fechar ao clicar no overlay
                    overlay.addEventListener("click", (e) => {
                        if (e.target === overlay) {
                            overlay.remove();
                            style.remove();
                            resolve(null);
                        }
                    });

                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);
                });
            }

            // Modal para usu√°rio colar texto manualmente e enviar para Perplexity
            async function showPerplexityTextInputModal(promptType) {
                return new Promise((resolve) => {
                    // Remover modal existente se houver
                    const existingModal = document.getElementById(
                        "perplexity-text-input-modal",
                    );
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Criar overlay do modal (transparente para permitir intera√ß√£o com o fundo)
                    const overlay = document.createElement("div");
                    overlay.id = "perplexity-text-input-modal";
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.3);
                        z-index: 10003;
                        display: flex;
                        justify-content: flex-end;
                        align-items: flex-start;
                        padding: 20px;
                        font-family: "Roboto", -apple-system, system-ui, sans-serif;
                        pointer-events: none;
                    `;

                    // Criar conte√∫do do modal (posicionado √† direita, tamanho reduzido)
                    const modal = document.createElement("div");
                    modal.style.cssText = `
                        background: #134377;
                        border-radius: 12px;
                        padding: 24px;
                        max-width: 500px;
                        width: 100%;
                        max-height: 90vh;
                        overflow-y: auto;
                        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.4);
                        border: 1px solid rgba(82, 82, 82, 0.3);
                        pointer-events: auto;
                    `;

                    const promptDescription =
                        promptType === "resumir"
                            ? "Resumir em t√≥picos curtos"
                            : "Gerar relat√≥rio para ac√≥rd√£o";

                    modal.innerHTML = `
                        <div style="text-align: center; margin-bottom: 24px;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 8px;">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="#22B8CD">
                                    <path d="M19.785 0v7.272H22.5V17.62h-2.935V24l-7.037-6.194v6.145h-1.091v-6.152L4.392 24v-6.465H1.5V7.188h2.884V0l7.053 6.494V.19h1.09v6.49L19.786 0zm-7.257 9.044v7.319l5.946 5.234V14.44l-5.946-5.397zm-1.099-.08l-5.946 5.398v7.235l5.946-5.234V8.965zm8.136 7.58h1.844V8.349H13.46l6.105 5.54v2.655zm-8.982-8.28H2.59v8.195h1.8v-2.576l6.192-5.62zM5.475 2.476v4.71h5.115l-5.115-4.71zm13.219 0l-5.115 4.71h5.115v-4.71z"/>
                                </svg>
                                <h2 style="color: white; margin: 0; font-size: 24px; font-weight: 600;">
                                    Cole o texto do documento
                                </h2>
                            </div>
                            <p style="color: rgb(203 213 225); margin: 0; font-size: 16px;">
                                Prompt selecionado: <strong style="color: #22B8CD;">${promptDescription}</strong>
                            </p>
                            <p style="color: rgb(148, 163, 184); margin-top: 8px; font-size: 14px;">
                                Copie o conte√∫do do PDF e cole no campo abaixo
                            </p>
                        </div>

                        <div style="margin-bottom: 24px;">
                            <textarea id="perplexity-text-input" placeholder="Cole aqui o texto do documento..." style="
                                width: 100%;
                                min-height: 300px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.05);
                                border: 2px solid rgba(255, 255, 255, 0.1);
                                border-radius: 8px;
                                color: white;
                                font-size: 14px;
                                font-family: 'Segoe UI', sans-serif;
                                resize: vertical;
                                outline: none;
                                transition: all 0.2s ease;
                            "></textarea>
                        </div>

                        <div style="display: flex; justify-content: center; gap: 12px;">
                            <button id="send-to-perplexity-btn" style="
                                padding: 12px 32px;
                                background: #22B8CD;
                                border: none;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                font-size: 16px;
                                font-weight: 600;
                                transition: all 0.2s ease;
                                display: flex;
                                align-items: center;
                                gap: 8px;
                            ">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="white">
                                    <path d="M19.785 0v7.272H22.5V17.62h-2.935V24l-7.037-6.194v6.145h-1.091v-6.152L4.392 24v-6.465H1.5V7.188h2.884V0l7.053 6.494V.19h1.09v6.49L19.786 0zm-7.257 9.044v7.319l5.946 5.234V14.44l-5.946-5.397zm-1.099-.08l-5.946 5.398v7.235l5.946-5.234V8.965zm8.136 7.58h1.844V8.349H13.46l6.105 5.54v2.655zm-8.982-8.28H2.59v8.195h1.8v-2.576l6.192-5.62zM5.475 2.476v4.71h5.115l-5.115-4.71zm13.219 0l-5.115 4.71h5.115v-4.71z"/>
                                </svg>
                                Enviar para Perplexity
                            </button>
                            <button id="cancel-text-input-btn" style="
                                padding: 12px 24px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 1px solid rgba(255, 255, 255, 0.2);
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                font-size: 14px;
                                transition: all 0.2s ease;
                            ">
                                Cancelar
                            </button>
                        </div>
                    `;

                    // Adicionar CSS hover via JavaScript
                    const style = document.createElement("style");
                    style.textContent = `
                        #perplexity-text-input:focus {
                            border-color: #22B8CD !important;
                            background: rgba(255, 255, 255, 0.08) !important;
                        }
                        #send-to-perplexity-btn:hover {
                            background: #1a9daf !important;
                            transform: translateY(-1px);
                        }
                        #send-to-perplexity-btn:disabled {
                            background: rgba(255, 255, 255, 0.1) !important;
                            cursor: not-allowed;
                            opacity: 0.5;
                        }
                        #cancel-text-input-btn:hover {
                            background: rgba(255, 255, 255, 0.2) !important;
                        }
                    `;
                    document.head.appendChild(style);

                    const textarea = modal.querySelector(
                        "#perplexity-text-input",
                    );
                    const sendBtn = modal.querySelector(
                        "#send-to-perplexity-btn",
                    );
                    const cancelBtn = modal.querySelector(
                        "#cancel-text-input-btn",
                    );

                    // Focar no textarea automaticamente
                    setTimeout(() => textarea.focus(), 100);

                    // Evento do bot√£o Enviar
                    sendBtn.addEventListener("click", async () => {
                        const texto = textarea.value.trim();

                        if (!texto) {
                            showNotification(
                                "Por favor, cole o texto do documento antes de enviar",
                                "error",
                            );
                            return;
                        }

                        // Desabilitar bot√£o durante envio
                        sendBtn.disabled = true;
                        sendBtn.innerHTML = `
                            <svg style="animation: spin 1s linear infinite;" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
                                <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
                            </svg>
                            Enviando...
                        `;

                        // Adicionar anima√ß√£o de spin
                        const spinStyle = document.createElement("style");
                        spinStyle.textContent = `
                            @keyframes spin {
                                from { transform: rotate(0deg); }
                                to { transform: rotate(360deg); }
                            }
                        `;
                        document.head.appendChild(spinStyle);

                        // Chamar API do Perplexity
                        const success = await sendToPerplexityWithPrompt(
                            texto,
                            promptType,
                        );

                        // Fechar modal
                        overlay.remove();
                        style.remove();
                        spinStyle.remove();

                        resolve(success);
                    });

                    // Evento do bot√£o Cancelar
                    cancelBtn.addEventListener("click", () => {
                        overlay.remove();
                        style.remove();
                        resolve(false);
                    });

                    // Fechar ao clicar no overlay
                    overlay.addEventListener("click", (e) => {
                        if (e.target === overlay) {
                            overlay.remove();
                            style.remove();
                            resolve(false);
                        }
                    });

                    // Atalho Ctrl+Enter para enviar
                    textarea.addEventListener("keydown", (e) => {
                        if (e.ctrlKey && e.key === "Enter") {
                            sendBtn.click();
                        }
                    });

                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);
                });
            }

            // Modal para sele√ß√£o de prompt
            async function showPromptSelectionModal(aiName, url, texto) {
                return new Promise((resolve) => {
                    // Remover modal existente se houver
                    const existingModal = document.getElementById(
                        "prompt-selection-modal",
                    );
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Criar overlay do modal
                    const overlay = document.createElement("div");
                    overlay.id = "prompt-selection-modal";
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        z-index: 10003;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        font-family: "Roboto", -apple-system, system-ui, sans-serif;
                    `;

                    // Criar conte√∫do do modal
                    const modal = document.createElement("div");
                    modal.style.cssText = `
                        background: #134377;
                        border-radius: 12px;
                        padding: 32px;
                        max-width: 600px;
                        width: 90%;
                        max-height: 80vh;
                        overflow-y: auto;
                        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.4);
                        border: 1px solid rgba(82, 82, 82, 0.3);
                    `;

                    modal.innerHTML = `
                        <div style="text-align: center; margin-bottom: 24px;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 8px;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                    <polyline points="14,2 14,8 20,8"/>
                                    <line x1="16" y1="13" x2="8" y2="13"/>
                                    <line x1="16" y1="17" x2="8" y2="17"/>
                                    <polyline points="10,9 9,9 8,9"/>
                                </svg>
                                <h2 style="color: white; margin: 0; font-size: 24px; font-weight: 600;">
                                    Escolha o prompt para ${aiName}
                                </h2>
                            </div>
                            <p style="color: rgb(203 213 225); margin: 0; font-size: 16px;">
                                Selecione qual tipo de an√°lise deseja fazer no documento
                            </p>
                        </div>

                        <div style="display: grid; gap: 16px; margin-bottom: 24px;">
                            <button id="prompt-resumir" class="prompt-option" style="
                                display: flex;
                                flex-direction: column;
                                align-items: flex-start;
                                gap: 8px;
                                padding: 20px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                text-align: left;
                            ">
                                <div style="display: flex; align-items: center; gap: 12px; width: 100%;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M8 6h13"/>
                                        <path d="M8 12h13"/>
                                        <path d="M8 18h13"/>
                                        <path d="M3 6h.01"/>
                                        <path d="M3 12h.01"/>
                                        <path d="M3 18h.01"/>
                                    </svg>
                                    <div style="font-size: 18px; font-weight: 600;">Resumir em t√≥picos curtos</div>
                                </div>
                                <div style="font-size: 14px; color: rgb(203 213 225); line-height: 1.4;">
                                    Gera um resumo objetivo em bullet points para capa do processo digital, indicando tipo de a√ß√£o, partes, pedidos, decis√£o e fundamentos.
                                </div>
                            </button>

                            <button id="prompt-relatorio" class="prompt-option" style="
                                display: flex;
                                flex-direction: column;
                                align-items: flex-start;
                                gap: 8px;
                                padding: 20px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                text-align: left;
                            ">
                                <div style="display: flex; align-items: center; gap: 12px; width: 100%;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                        <polyline points="14,2 14,8 20,8"/>
                                        <line x1="16" y1="13" x2="8" y2="13"/>
                                        <line x1="16" y1="17" x2="8" y2="17"/>
                                        <polyline points="10,9 9,9 8,9"/>
                                    </svg>
                                    <div style="font-size: 18px; font-weight: 600;">Gerar relat√≥rio para ac√≥rd√£o</div>
                                </div>
                                <div style="font-size: 14px; color: rgb(203 213 225); line-height: 1.4;">
                                    Transforma a peti√ß√£o em relat√≥rio estruturado para minuta de ac√≥rd√£o, seguindo linguagem t√©cnica impessoal e formato espec√≠fico do tribunal.
                                </div>
                            </button>

                            <button id="prompt-lembrete" class="prompt-option" style="
                                display: flex;
                                flex-direction: column;
                                align-items: flex-start;
                                gap: 8px;
                                padding: 20px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                text-align: left;
                            ">
                                <div style="display: flex; align-items: center; gap: 12px; width: 100%;">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                                    </svg>
                                    <div style="font-size: 18px; font-weight: 600;">Criar lembrete</div>
                                </div>
                                <div style="font-size: 14px; color: rgb(203 213 225); line-height: 1.4;">
                                    Gera resumo estruturado com formata√ß√£o HTML para capa do processo, incluindo partes, a√ß√£o, objeto do recurso e pedidos.
                                </div>
                            </button>
                        </div>

                        <div style="display: flex; justify-content: center; gap: 12px;">
                            <button id="cancel-prompt" style="
                                padding: 12px 24px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 1px solid rgba(255, 255, 255, 0.2);
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                font-size: 14px;
                                transition: all 0.2s ease;
                            ">
                                Voltar
                            </button>
                        </div>
                    `;

                    console.log(
                        "üîç DEBUG MODAL PROMPTS: HTML definido para showPromptSelectionModal",
                    );
                    console.log(
                        "üîç DEBUG: Bot√£o #prompt-lembrete no HTML?",
                        modal.innerHTML.includes("prompt-lembrete"),
                    );
                    console.log(
                        "üîç DEBUG: Total de bot√µes .prompt-option no HTML:",
                        (modal.innerHTML.match(/class="prompt-option"/g) || [])
                            .length,
                    );

                    // Adicionar CSS hover via JavaScript
                    const style = document.createElement("style");
                    style.textContent = `
                        .prompt-option:hover {
                            background: rgba(255, 255, 255, 0.2) !important;
                            border-color: rgba(255, 255, 255, 0.3) !important;
                            transform: translateY(-1px);
                        }
                        #cancel-prompt:hover {
                            background: rgba(255, 255, 255, 0.2) !important;
                        }
                    `;
                    document.head.appendChild(style);

                    // Definir prompts
                    const promptResumir = `Voc√™ √© um assistente especializado em resumir documentos judiciais de forma extremamente objetiva e sucinta para capas de processos digitais. Sempre responda em bullet points diretos.

Fa√ßa um resumo extremamente sucinto do documento, em formato de apontamentos diretos (bullet points), para constar na capa do processo digital. Indique: tipo de a√ß√£o, partes, pedido(s) do autor, decis√£o (improcedente/procedente/parcialmente procedente), fundamentos centrais, condena√ß√£o (custas/honor√°rios se houver). Seja objetivo e direto, sem reda√ß√£o em texto corrido.

DOCUMENTO:
${texto}`;

                    const promptRelatorio = `Entrada: arquivo PDF enviado pelo usu√°rio ou texto colado no prompt = {{entrada}}

                    Atue como um assessor de desembargador do Tribunal de Justi√ßa de Santa Catarina que est√° redigindo uma minuta de ac√≥rd√£o sobre o caso relatado na {{entrada}}. Considerando o que consta na {{entrada}}, transforme a peti√ß√£o em um pequeno relat√≥rio com a seguinte estrutura:
                    
                    Alega a parte ("apelante" ou "impetrante" ou "agravante" ou "embargante" ou "recorrente" etc., a depender do tipo de recurso) que...
                    
                    Afirma que...
                    
                    Requer a concess√£o de ("antecipa√ß√£o dos efeitos da tutela recursal" ou "efeito suspensivo" ou "liminar" etc., dependendo do pedido; utilizar SOMENTE SE HOUVER pedido de tutela antecipada, liminar, etc.) para...
                    
                    No m√©rito, postula a... (CASO TENHA HAVIDO pedido de tutela antecipada, liminar, etc., conforme par√°grafo anterior; caso N√ÉO TENHA HAVIDO, usar apenas o PR√ìXIMO PAR√ÅGRAFO)
                    
                    Requer a ("reforma da senten√ßa", "reforma da decis√£o recorrida", "reforma da decis√£o de pron√∫ncia", "declara√ß√£o de nulidade do processo de origem", "trancamento do processo", etc., a depender do pedido formulado no recurso; utilizar este par√°grafo caso N√ÉO TENHA HAVIDO pedido de tutela antecipada, liminar, etc., conforme os dois par√°grafos anteriores) para... ("condenar", "absolver", "obrigar", etc., a depender do objetivo do recurso interposto)
                    
                    _______________
                    
                    Use: linguagem impessoal ("entende-se" ao inv√©s de "entendo", por exemplo) e seja sucinto.
                    
                    Evite utilizar o nome real das partes. Refira-se √†s partes sempre como "apelante"/"apelada" ou "impetrante"/"impetrada" ou "agravante"/"agravada" ou "embargante"/"embargada", "impetrante", "paciente", etc., a depender do tipo de recurso. 
                    
                    Utilize uma estrutura de texto, sem s√≠mbolos ou caracteres especiais no in√≠cio dos par√°grafos.
                    
                    Regras de escrita:
                    
                    Use linguagem objetiva, evitando termos excessivamente rebuscados. 
                    
                    N√£o inicie frases com ‚Äúcom efeito‚Äù ou ‚Äúdestarte‚Äù. 
                    
                    N√£o utilize ‚Äúfulcro‚Äù ou ‚Äúcom fulcro‚Äù. 
                    
                    N√£o empregue ‚Äúresta‚Äù com sentido de ‚Äúest√°‚Äù. 
                    
                    Utilize a express√£o ‚Äúcelebrar contrato‚Äù ao inv√©s de ‚Äúfirmar contrato‚Äù. 
                    
                    Utilize o formato de data DD/MM/AAAA e abrevie ‚Äún√∫mero‚Äù como ‚Äún.‚Äù, nunca "n¬∫", "n¬∫." ou outra forma que n√£o "n.".
                    
                    IMPORTANTE: sempre use colchetes ao inv√©s de par√™nteses.
                    
                    S√≥ descreva informa√ß√µes reais presentes na {{entrada}}.
                    
                    Ao citar dispositivos legais, utilize exclusivamente esse padr√£o: ‚Äúconforme determina o ¬ß 2¬∫ do art. 86 da Lei n. 8.213/1991‚Äù. Sempre indique primeiro o par√°grafo [se houver], depois o artigo, seguido do n√∫mero e ano da lei, exatamente neste formato. 

DOCUMENTO:
${texto}`;

                    const promptLembrete = `Voc√™ √© um assistente especializado em resumir documentos judiciais de forma extremamente objetiva e sucinta para capas de processos digitais. Sua tarefa √© fazer um resumo extremamente sucinto do documento, em formato de apontamentos diretos (bullet points), para constar na capa do processo digital. Seja objetivo e direto, sem reda√ß√£o em texto corrido. Voc√™ dever√° OBRIGATORIAMENTE MANTER os c√≥digos html na vers√£o entregue ao usu√°rio.

SEMPRE responda em bullet points diretos, com seguinte formato:

__________________________________

<b>Apelante/Recorrente/Embargante/Agravante/Impetrante</b>: Nome da Parte (usar plural em caso de mais de um apelante/recorrente etc.)<p>
<b>Paciente</b>: Nome da Parte (incluir SOMENTE se tratar de Habeas Corpus), usar plural em caso de mais de um apelante/recorrente etc.)<p>
<b>A√ß√£o</b>: Tipo de A√ß√£o na origem ("anulat√≥ria de d√©bito fiscal", "a√ß√£o por danos morais e materiais", "a√ß√£o penal p√∫blica condicionada ou incondicionada ou a√ß√£o penal privada", "inqu√©rito policial", "pedido de busca e apreens√£o", "pedido de pris√£o tempor√°ria formulado pelo MP ou formulado pelo Delegado de Pol√≠cia", "mandado de seguran√ßa", etc.; caso a informa√ß√£o n√£o consiga ser extra√≠da da pe√ßa enviada pelo usu√°rio, n√£o inclua este item; a "a√ß√£o da origem" √© aquela referente ao processo de primeiro grau, n√£o √© o recurso que a parte est√° interpondo agora<p>
<b>Objeto do Recurso</b>: resumo da decis√£o contra a qual a parte est√° se insurgindo (ex: "senten√ßa que condenou o apelante ao pagamento de danos morais no valor de...", "senten√ßa que condenou o apelante pela pr√°tica dos crimes do art. 121 do C√≥digo Penal e do art. 33 da Lei n. 11.343/2006, em concurso material", "decis√£o que pronunciou o recorrente pela pr√°tica do crime do art. 121, ¬ß 2¬∫, inciso II c/c art. 14, inciso II, ambos do C√≥digo Penal", "ac√≥rd√£o proferido na sess√£o de DD/MM/AAAA", "ac√≥rd√£o que deu parcial provimento ao recurso do autor/r√©u", etc.)
<b>Pedidos</b>: pedidos formulados no recurso pela parte, separados por ";" caso sejam mais de um (ex: "reforma da senten√ßa para absolver o acusado"; "reforma da senten√ßa para afastar a condena√ß√£o ao pagamento de compensa√ß√£o por danos morais"; "concess√£o da ordem para determinar a soltura do paciente, com base nos arts. XXX", "acolhimento dos embargos de declara√ß√£o para sanar a omiss√£o, com efeito infringente para desprover/prover o recurso", etc); caso o objeto seja uma decis√£o de pron√∫ncia, N√ÉO UTILIZE a estrutura "decis√£o de pron√∫ncia que pronunciou...", UTILIZE a estrutura "decis√£o que pronunciou o/a...",)<p>
<b>Pedidos</b>: pedidos formulados pela parte no recurso, separados por ";" caso sejam mais de um (ex: "reforma da senten√ßa para absolver o acusado"; "reforma da senten√ßa para afastar a condena√ß√£o ao pagamento de compensa√ß√£o por danos morais"; "concess√£o da ordem para determinar a soltura do paciente, com base nos arts. XXX", "acolhimento dos embargos de declara√ß√£o para sanar a omiss√£o, com efeitos infringentes para desprover/prover o recurso", etc.)

__________________________________

OBSERVA√á√ÉO IMPORTANTE E CR√çTICA, REGRA IMPRESCIND√çVEL: Quando devolver qualquer conte√∫do que contenha tags HTML (ex.: <b>, <p>, <a>), sempre coloque-o entre tr√™s crases (\`\`\`), sem especificar linguagem. N√£o renderize HTML. Mostre literalmente.

DOCUMENTO:
${texto}`;

                    // Adicionar eventos aos bot√µes
                    modal
                        .querySelector("#prompt-resumir")
                        .addEventListener("click", async () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                await openAIWithCustomPrompt(
                                    aiName,
                                    url,
                                    promptResumir,
                                ),
                            );
                        });

                    modal
                        .querySelector("#prompt-relatorio")
                        .addEventListener("click", async () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                await openAIWithCustomPrompt(
                                    aiName,
                                    url,
                                    promptRelatorio,
                                ),
                            );
                        });

                    modal
                        .querySelector("#prompt-lembrete")
                        .addEventListener("click", async () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                await openAIWithCustomPrompt(
                                    aiName,
                                    url,
                                    promptLembrete,
                                ),
                            );
                        });

                    modal
                        .querySelector("#cancel-prompt")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(false);
                        });

                    // Fechar ao clicar no overlay
                    overlay.addEventListener("click", (e) => {
                        if (e.target === overlay) {
                            overlay.remove();
                            style.remove();
                            resolve(false);
                        }
                    });

                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);
                });
            }

            // Modal para sele√ß√£o de IA
            async function showAISelectionModal(texto) {
                return new Promise((resolve) => {
                    // Remover modal existente se houver
                    const existingModal =
                        document.getElementById("ai-selection-modal");
                    if (existingModal) {
                        existingModal.remove();
                    }

                    // Criar overlay do modal
                    const overlay = document.createElement("div");
                    overlay.id = "ai-selection-modal";
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        z-index: 10002;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        font-family: "Roboto", -apple-system, system-ui, sans-serif;
                    `;

                    // Criar conte√∫do do modal
                    const modal = document.createElement("div");
                    modal.style.cssText = `
                        background: #134377;
                        border-radius: 12px;
                        padding: 32px;
                        max-width: 520px;
                        width: 90%;
                        box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.4);
                        border: 1px solid rgba(82, 82, 82, 0.3);
                    `;

                    modal.innerHTML = `
                        <div style="text-align: center; margin-bottom: 24px;">
                            <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 8px;">
                                <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="white">
                                    <path d="M335-160q-16.3 0-30.65-8.5Q290-177 282-190l-73-132h61l39.64 80H398v-24h-72.06l-40.15-80H194l-58-105q-3.8-6-5.9-13.5-2.1-7.5-2.1-15.72 0-4.78 8-29.78l60.31-104H289l39-80h72v-24h-86.67L274-638h-63l71-132q7.57-13.86 22.06-21.93Q318.54-800 335-800h70q25.1 0 42.55 17.45Q465-765.1 465-740v154h-53l-36 24h89v136h-97l-39.94-80H240l-26 24h98l40.47 80H465v182q0 25.1-17.45 42.55Q430.1-160 405-160h-70Zm214 0q-25.1 0-42.55-17.45Q489-194.9 489-220v-182h119l40-80h93l-21-24h-89.06L591-426H489v-136h95l-36-24h-59v-154q0-25.1 17.45-42.55Q523.9-800 549-800h76q16.3 0 30.65 8.5Q670-783 678-770l72 130h-62.51L647-718h-87v24h71.74l39.96 82H765l59 102q3.8 6.33 5.9 14.17Q832-488 832-480q0 5-8 29l-57 105h-94.79l-40.15 80H560v24h87.36L687-322h63l-73 132q-8 13-22.35 21.5Q640.3-160 624-160h-75Z"/>
                                </svg>
                                <h2 style="color: white; margin: 0; font-size: 24px; font-weight: 600;">
                                    Escolha sua IA
                                </h2>
                            </div>
                            <p style="color: rgb(203 213 225); margin: 0; font-size: 16px;">
                                Selecione qual IA deseja usar para an√°lise do documento
                            </p>
                        </div>

                        <div style="display: grid; gap: 12px; margin-bottom: 24px;">
                            <button id="ai-chatgpt" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="white">
                                    <path d="M21.55 10.004a5.416 5.416 0 00-.478-4.501c-1.217-2.09-3.662-3.166-6.05-2.66A5.59 5.59 0 0010.831 1C8.39.995 6.224 2.546 5.473 4.838A5.553 5.553 0 001.76 7.496a5.487 5.487 0 00.691 6.5 5.416 5.416 0 00.477 4.502c1.217 2.09 3.662 3.165 6.05 2.66A5.586 5.586 0 0013.168 23c2.443.006 4.61-1.546 5.361-3.84a5.553 5.553 0 003.715-2.66 5.488 5.488 0 00-.693-6.497v.001zm-8.381 11.558a4.199 4.199 0 01-2.675-.954c.034-.018.093-.05.132-.074l4.44-2.53a.71.71 0 00.364-.623v-6.176l1.877 1.069c.02.01.033.029.036.05v5.115c-.003 2.274-1.87 4.118-4.174 4.123zM4.192 17.78a4.059 4.059 0 01-.498-2.763c.032.02.09.055.131.078l4.44 2.53c.225.13.504.13.73 0l5.42-3.088v2.138a.068.068 0 01-.027.057L9.9 19.288c-1.999 1.136-4.552.46-5.707-1.51h-.001zM3.023 8.216A4.15 4.15 0 015.198 6.41l-.002.151v5.06a.711.711 0 00.364.624l5.42 3.087-1.876 1.07a.067.067 0 01-.063.005l-4.489-2.559c-1.995-1.14-2.679-3.658-1.53-5.63h.001zm15.417 3.54l-5.42-3.088L14.896 7.6a.067.067 0 01.063-.006l4.489 2.557c1.998 1.14 2.683 3.662 1.529 5.633a4.163 4.163 0 01-2.174 1.807V12.38a.71.71 0 00-.363-.623zm1.867-2.773a6.04 6.04 0 00-.132-.078l-4.44-2.53a.731.731 0 00-.729 0l-5.42 3.088V7.325a.068.068 0 01.027-.057L14.1 4.713c2-1.137 4.555-.46 5.707 1.513.487.833.664 1.809.499 2.757h.001zm-11.741 3.81l-1.877-1.068a.065.065 0 01-.036-.051V6.559c.001-2.277 1.873-4.122 4.181-4.12.976 0 1.92.338 2.671.954-.034.018-.092.05-.131.073l-4.44 2.53a.71.71 0 00-.365.623l-.003 6.173v.002zm1.02-2.168L12 9.25l2.414 1.375v2.75L12 14.75l-2.415-1.375v-2.75z"/>
                                </svg>
                                <span>ChatGPT</span>
                            </button>

                            <button id="ai-claude" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="#D97757">
                                    <path d="M4.709 15.955l4.72-2.647.08-.23-.08-.128H9.2l-.79-.048-2.698-.073-2.339-.097-2.266-.122-.571-.121L0 11.784l.055-.352.48-.321.686.06 1.52.103 2.278.158 1.652.097 2.449.255h.389l.055-.157-.134-.098-.103-.097-2.358-1.596-2.552-1.688-1.336-.972-.724-.491-.364-.462-.158-1.008.656-.722.881.06.225.061.893.686 1.908 1.476 2.491 1.833.365.304.145-.103.019-.073-.164-.274-1.355-2.446-1.446-2.49-.644-1.032-.17-.619a2.97 2.97 0 01-.104-.729L6.283.134 6.696 0l.996.134.42.364.62 1.414 1.002 2.229 1.555 3.03.456.898.243.832.091.255h.158V9.01l.128-1.706.237-2.095.23-2.695.08-.76.376-.91.747-.492.584.28.48.685-.067.444-.286 1.851-.559 2.903-.364 1.942h.212l.243-.242.985-1.306 1.652-2.064.73-.82.85-.904.547-.431h1.033l.76 1.129-.34 1.166-1.064 1.347-.881 1.142-1.264 1.7-.79 1.36.073.11.188-.02 2.856-.606 1.543-.28 1.841-.315.833.388.091.395-.328.807-1.969.486-2.309.462-3.439.813-.042.03.049.061 1.549.146.662.036h1.622l3.02.225.79.522.474.638-.079.485-1.215.62-1.64-.389-3.829-.91-1.312-.329h-.182v.11l1.093 1.068 2.006 1.81 2.509 2.33.127.578-.322.455-.34-.049-2.205-1.657-.851-.747-1.926-1.62h-.128v.17l.444.649 2.345 3.521.122 1.08-.17.353-.608.213-.668-.122-1.374-1.925-1.415-2.167-1.143-1.943-.14.08-.674 7.254-.316.37-.729.28-.607-.461-.322-.747.322-1.476.389-1.924.315-1.53.286-1.9.17-.632-.012-.042-.14.018-1.434 1.967-2.18 2.945-1.726 1.845-.414.164-.717-.37.067-.662.401-.589 2.388-3.036 1.44-1.882.93-1.086-.006-.158h-.055L4.132 18.56l-1.13.146-.487-.456.061-.746.231-.243 1.908-1.312-.006.006z"/>
                                </svg>
                                <span>Claude</span>
                            </button>

                            <button id="ai-gemini" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 24 24">
                                    <defs>
                                        <linearGradient gradientUnits="userSpaceOnUse" id="gemini-fill-0" x1="7" x2="11" y1="15.5" y2="12">
                                            <stop stop-color="#08B962"/>
                                            <stop offset="1" stop-color="#08B962" stop-opacity="0"/>
                                        </linearGradient>
                                        <linearGradient gradientUnits="userSpaceOnUse" id="gemini-fill-1" x1="8" x2="11.5" y1="5.5" y2="11">
                                            <stop stop-color="#F94543"/>
                                            <stop offset="1" stop-color="#F94543" stop-opacity="0"/>
                                        </linearGradient>
                                        <linearGradient gradientUnits="userSpaceOnUse" id="gemini-fill-2" x1="3.5" x2="17.5" y1="13.5" y2="12">
                                            <stop stop-color="#FABC12"/>
                                            <stop offset=".46" stop-color="#FABC12" stop-opacity="0"/>
                                        </linearGradient>
                                    </defs>
                                    <path d="M20.616 10.835a14.147 14.147 0 01-4.45-3.001 14.111 14.111 0 01-3.678-6.452.503.503 0 00-.975 0 14.134 14.134 0 01-3.679 6.452 14.155 14.155 0 01-4.45 3.001c-.65.28-1.318.505-2.002.678a.502.502 0 000 .975c.684.172 1.35.397 2.002.677a14.147 14.147 0 014.45 3.001 14.112 14.112 0 013.679 6.453.502.502 0 00.975 0c.172-.685.397-1.351.677-2.003a14.145 14.145 0 013.001-4.45 14.113 14.113 0 016.453-3.678.503.503 0 000-.975 13.245 13.245 0 01-2.003-.678z" fill="#3186FF"/>
                                    <path d="M20.616 10.835a14.147 14.147 0 01-4.45-3.001 14.111 14.111 0 01-3.678-6.452.503.503 0 00-.975 0 14.134 14.134 0 01-3.679 6.452 14.155 14.155 0 01-4.45 3.001c-.65.28-1.318.505-2.002.678a.502.502 0 000 .975c.684.172 1.35.397 2.002.677a14.147 14.147 0 014.45 3.001 14.112 14.112 0 013.679 6.453.502.502 0 00.975 0c.172-.685.397-1.351.677-2.003a14.145 14.145 0 013.001-4.45 14.113 14.113 0 016.453-3.678.503.503 0 000-.975 13.245 13.245 0 01-2.003-.678z" fill="url(#gemini-fill-0)"/>
                                    <path d="M20.616 10.835a14.147 14.147 0 01-4.45-3.001 14.111 14.111 0 01-3.678-6.452.503.503 0 00-.975 0 14.134 14.134 0 01-3.679 6.452 14.155 14.155 0 01-4.45 3.001c-.65.28-1.318.505-2.002.678a.502.502 0 000 .975c.684.172 1.35.397 2.002.677a14.147 14.147 0 014.45 3.001 14.112 14.112 0 013.679 6.453.502.502 0 00.975 0c.172-.685.397-1.351.677-2.003a14.145 14.145 0 013.001-4.45 14.113 14.113 0 016.453-3.678.503.503 0 000-.975 13.245 13.245 0 01-2.003-.678z" fill="url(#gemini-fill-1)"/>
                                    <path d="M20.616 10.835a14.147 14.147 0 01-4.45-3.001 14.111 14.111 0 01-3.678-6.452.503.503 0 00-.975 0 14.134 14.134 0 01-3.679 6.452 14.155 14.155 0 01-4.45 3.001c-.65.28-1.318.505-2.002.678a.502.502 0 000 .975c.684.172 1.35.397 2.002.677a14.147 14.147 0 014.45 3.001 14.112 14.112 0 013.679 6.453.502.502 0 00.975 0c.172-.685.397-1.351.677-2.003a14.145 14.145 0 013.001-4.45 14.113 14.113 0 016.453-3.678.503.503 0 000-.975 13.245 13.245 0 01-2.003-.678z" fill="url(#gemini-fill-2)"/>
                                </svg>
                                <span>Gemini</span>
                            </button>

                            <button id="ai-perplexity" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="#22B8CD">
                                    <path d="M19.785 0v7.272H22.5V17.62h-2.935V24l-7.037-6.194v6.145h-1.091v-6.152L4.392 24v-6.465H1.5V7.188h2.884V0l7.053 6.494V.19h1.09v6.49L19.786 0zm-7.257 9.044v7.319l5.946 5.234V14.44l-5.946-5.397zm-1.099-.08l-5.946 5.398v7.235l5.946-5.234V8.965zm8.136 7.58h1.844V8.349H13.46l6.105 5.54v2.655zm-8.982-8.28H2.59v8.195h1.8v-2.576l6.192-5.62zM5.475 2.476v4.71h5.115l-5.115-4.71zm13.219 0l-5.115 4.71h5.115v-4.71z"/>
                                </svg>
                                <span>Perplexity</span>
                            </button>

                            <button id="ai-copilot" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 24 24">
                                    <defs>
                                        <radialGradient cx="85.44%" cy="100.653%" fx="85.44%" fy="100.653%" gradientTransform="scale(-.8553 -1) rotate(50.927 2.041 -1.946)" id="copilot-fill-0" r="105.116%">
                                            <stop offset="9.6%" stop-color="#00AEFF"/>
                                            <stop offset="77.3%" stop-color="#2253CE"/>
                                            <stop offset="100%" stop-color="#0736C4"/>
                                        </radialGradient>
                                        <radialGradient cx="18.143%" cy="32.928%" fx="18.143%" fy="32.928%" gradientTransform="scale(.8897 1) rotate(52.069 .193 .352)" id="copilot-fill-1" r="95.612%">
                                            <stop offset="0%" stop-color="#FFB657"/>
                                            <stop offset="63.4%" stop-color="#FF5F3D"/>
                                            <stop offset="92.3%" stop-color="#C02B3C"/>
                                        </radialGradient>
                                        <radialGradient cx="82.987%" cy="-9.792%" fx="82.987%" fy="-9.792%" gradientTransform="scale(-1 -.9441) rotate(-70.872 .142 1.17)" id="copilot-fill-4" r="140.622%">
                                            <stop offset="6.6%" stop-color="#8C48FF"/>
                                            <stop offset="50%" stop-color="#F2598A"/>
                                            <stop offset="89.6%" stop-color="#FFB152"/>
                                        </radialGradient>
                                        <linearGradient id="copilot-fill-2" x1="39.465%" x2="46.884%" y1="12.117%" y2="103.774%">
                                            <stop offset="15.6%" stop-color="#0D91E1"/>
                                            <stop offset="48.7%" stop-color="#52B471"/>
                                            <stop offset="65.2%" stop-color="#98BD42"/>
                                            <stop offset="93.7%" stop-color="#FFC800"/>
                                        </linearGradient>
                                        <linearGradient id="copilot-fill-3" x1="45.949%" x2="50%" y1="0%" y2="100%">
                                            <stop offset="0%" stop-color="#3DCBFF"/>
                                            <stop offset="24.7%" stop-color="#0588F7" stop-opacity="0"/>
                                        </linearGradient>
                                        <linearGradient id="copilot-fill-5" x1="83.507%" x2="83.453%" y1="-6.106%" y2="21.131%">
                                            <stop offset="5.8%" stop-color="#F8ADFA"/>
                                            <stop offset="70.8%" stop-color="#A86EDD" stop-opacity="0"/>
                                        </linearGradient>
                                    </defs>
                                    <path d="M17.533 1.829A2.528 2.528 0 0015.11 0h-.737a2.531 2.531 0 00-2.484 2.087l-1.263 6.937.314-1.08a2.528 2.528 0 012.424-1.833h4.284l1.797.706 1.731-.706h-.505a2.528 2.528 0 01-2.423-1.829l-.715-2.453z" fill="url(#copilot-fill-0)" transform="translate(0 1)"/>
                                    <path d="M6.726 20.16A2.528 2.528 0 009.152 22h1.566c1.37 0 2.49-1.1 2.525-2.48l.17-6.69-.357 1.228a2.528 2.528 0 01-2.423 1.83h-4.32l-1.54-.842-1.667.843h.497c1.124 0 2.113.75 2.426 1.84l.697 2.432z" fill="url(#copilot-fill-1)" transform="translate(0 1)"/>
                                    <path d="M15 0H6.252c-2.5 0-4 3.331-5 6.662-1.184 3.947-2.734 9.225 1.75 9.225H6.78c1.13 0 2.12-.753 2.43-1.847.657-2.317 1.809-6.359 2.713-9.436.46-1.563.842-2.906 1.43-3.742A1.97 1.97 0 0115 0" fill="url(#copilot-fill-2)" transform="translate(0 1)"/>
                                    <path d="M15 0H6.252c-2.5 0-4 3.331-5 6.662-1.184 3.947-2.734 9.225 1.75 9.225H6.78c1.13 0 2.12-.753 2.43-1.847.657-2.317 1.809-6.359 2.713-9.436.46-1.563.842-2.906 1.43-3.742A1.97 1.97 0 0115 0" fill="url(#copilot-fill-3)" transform="translate(0 1)"/>
                                    <path d="M9 22h8.749c2.5 0 4-3.332 5-6.663 1.184-3.948 2.734-9.227-1.75-9.227H17.22c-1.129 0-2.12.754-2.43 1.848a1149.2 1149.2 0 01-2.713 9.437c-.46 1.564-.842 2.907-1.43 3.743A1.97 1.97 0 019 22" fill="url(#copilot-fill-4)" transform="translate(0 1)"/>
                                    <path d="M9 22h8.749c2.5 0 4-3.332 5-6.663 1.184-3.948 2.734-9.227-1.75-9.227H17.22c-1.129 0-2.12.754-2.43 1.848a1149.2 1149.2 0 01-2.713 9.437c-.46 1.564-.842 2.907-1.43 3.743A1.97 1.97 0 019 22" fill="url(#copilot-fill-5)" transform="translate(0 1)"/>
                                </svg>
                                <span>Copilot</span>
                            </button>

                            <button id="ai-deepseek" class="ai-option" style="
                                display: flex;
                                align-items: center;
                                gap: 12px;
                                padding: 16px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 2px solid transparent;
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                font-size: 16px;
                                font-weight: 500;
                            ">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="#4D6BFE">
                                    <path d="M23.748 4.482c-.254-.124-.364.113-.512.234-.051.039-.094.09-.137.136-.372.397-.806.657-1.373.626-.829-.046-1.537.214-2.163.848-.133-.782-.575-1.248-1.247-1.548-.352-.156-.708-.311-.955-.65-.172-.241-.219-.51-.305-.774-.055-.16-.11-.323-.293-.35-.2-.031-.278.136-.356.276-.313.572-.434 1.202-.422 1.84.027 1.436.633 2.58 1.838 3.393.137.093.172.187.129.323-.082.28-.18.552-.266.833-.055.179-.137.217-.329.14a5.526 5.526 0 01-1.736-1.18c-.857-.828-1.631-1.742-2.597-2.458a11.365 11.365 0 00-.689-.471c-.985-.957.13-1.743.388-1.836.27-.098.093-.432-.779-.428-.872.004-1.67.295-2.687.684a3.055 3.055 0 01-.465.137 9.597 9.597 0 00-2.883-.102c-1.885.21-3.39 1.102-4.497 2.623C.082 8.606-.231 10.684.152 12.85c.403 2.284 1.569 4.175 3.36 5.653 1.858 1.533 3.997 2.284 6.438 2.14 1.482-.085 3.133-.284 4.994-1.86.47.234.962.327 1.78.397.63.059 1.236-.03 1.705-.128.735-.156.684-.837.419-.961-2.155-1.004-1.682-.595-2.113-.926 1.096-1.296 2.746-2.642 3.392-7.003.05-.347.007-.565 0-.845-.004-.17.035-.237.23-.256a4.173 4.173 0 001.545-.475c1.396-.763 1.96-2.015 2.093-3.517.02-.23-.004-.467-.247-.588zM11.581 18c-2.089-1.642-3.102-2.183-3.52-2.16-.392.024-.321.471-.235.763.09.288.207.486.371.739.114.167.192.416-.113.603-.673.416-1.842-.14-1.897-.167-1.361-.802-2.5-1.86-3.301-3.307-.774-1.393-1.224-2.887-1.298-4.482-.02-.386.093-.522.477-.592a4.696 4.696 0 011.529-.039c2.132.312 3.946 1.265 5.468 2.774.868.86 1.525 1.887 2.202 2.891.72 1.066 1.494 2.082 2.48 2.914.348.292.625.514.891.677-.802.09-2.14.11-3.054-.614zm1-6.44a.306.306 0 01.415-.287.302.302 0 01.2.288.306.306 0 01-.31.307.303.303 0 01-.304-.308zm3.11 1.596c-.2.081-.399.151-.59.16a1.245 1.245 0 01-.798-.254c-.274-.23-.47-.358-.552-.758a1.73 1.73 0 01.016-.588c.07-.327-.008-.537-.239-.727-.187-.156-.426-.199-.688-.199a.559.559 0 01-.254-.078c-.11-.054-.2-.19-.114-.358.028-.054.16-.186.192-.21.356-.202.767-.136 1.146.016.352.144.618.408 1.001.782.391.451.462.576.685.914.176.265.336.537.445.848.067.195-.019.354-.25.452z"/>
                                </svg>
                                <span>Deepseek</span>
                            </button>
                        </div>

                        <div style="display: flex; justify-content: center; gap: 12px;">
                            <button id="cancel-ai" style="
                                padding: 12px 24px;
                                background: rgba(255, 255, 255, 0.1);
                                border: 1px solid rgba(255, 255, 255, 0.2);
                                border-radius: 8px;
                                color: white;
                                cursor: pointer;
                                font-size: 14px;
                                transition: all 0.2s ease;
                            ">
                                Cancelar
                            </button>
                        </div>
                    `;

                    // Adicionar CSS hover via JavaScript
                    const style = document.createElement("style");
                    style.textContent = `
                        .ai-option:hover {
                            background: rgba(255, 255, 255, 0.2) !important;
                            border-color: rgba(255, 255, 255, 0.3) !important;
                            transform: translateY(-1px);
                        }
                        #cancel-ai:hover {
                            background: rgba(255, 255, 255, 0.2) !important;
                        }
                    `;
                    document.head.appendChild(style);

                    // Adicionar eventos aos bot√µes
                    modal
                        .querySelector("#ai-chatgpt")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                showPromptSelectionModal(
                                    "ChatGPT",
                                    "https://chat.openai.com/",
                                    texto,
                                ),
                            );
                        });

                    modal
                        .querySelector("#ai-claude")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                showPromptSelectionModal(
                                    "Claude",
                                    "https://claude.ai/",
                                    texto,
                                ),
                            );
                        });

                    modal
                        .querySelector("#ai-gemini")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                showPromptSelectionModal(
                                    "Gemini",
                                    "https://gemini.google.com/",
                                    texto,
                                ),
                            );
                        });

                    modal
                        .querySelector("#ai-perplexity")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                showPromptSelectionModal(
                                    "Perplexity",
                                    "https://www.perplexity.ai/",
                                    texto,
                                ),
                            );
                        });

                    modal
                        .querySelector("#ai-copilot")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                showPromptSelectionModal(
                                    "Copilot",
                                    "https://copilot.cloud.microsoft/",
                                    texto,
                                ),
                            );
                        });

                    modal
                        .querySelector("#ai-deepseek")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(
                                showPromptSelectionModal(
                                    "Deepseek",
                                    "https://chat.deepseek.com/",
                                    texto,
                                ),
                            );
                        });

                    modal
                        .querySelector("#cancel-ai")
                        .addEventListener("click", () => {
                            overlay.remove();
                            style.remove();
                            resolve(false);
                        });

                    // Fechar ao clicar no overlay
                    overlay.addEventListener("click", (e) => {
                        if (e.target === overlay) {
                            overlay.remove();
                            style.remove();
                            resolve(false);
                        }
                    });

                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);
                });
            }

            // Abrir Copilot com texto e prompt espec√≠fico para an√°lise judicial (mantida para compatibilidade)
            async function openCopilotWithText(texto) {
                return openAIWithText(
                    "Copilot",
                    "https://copilot.cloud.microsoft/",
                    texto,
                );
            }

            // Enviar texto diretamente para Perplexity usando API - usando express√£o de fun√ß√£o
            const sendToPerplexity = async function (texto) {
                const requestId = Date.now().toString();

                try {
                    debugApiCall(requestId, "IN√çCIO", {
                        textoLength: texto.length,
                    });
                    log(" Enviando texto para Perplexity via API...");
                    showNotification("Enviando para Perplexity...", "info");

                    const apiKey = await getStoredApiKey();
                    if (!apiKey) {
                        debugApiCall(
                            requestId,
                            "ERRO",
                            "API key n√£o encontrada",
                        );
                        showNotification(" Erro ao obter chave API", "error");
                        return false;
                    }

                    const prompt = `Fa√ßa um resumo extremamente sucinto do documento, em formato de apontamentos diretos (bullet points), para constar na capa do processo digital. Indique: tipo de a√ß√£o, partes, pedido(s) do autor, decis√£o (improcedente/procedente/parcialmente procedente), fundamentos centrais, condena√ß√£o (custas/honor√°rios se houver). Seja objetivo e direto, sem reda√ß√£o em texto corrido. DOCUMENTO: ${texto}`;

                    const requestBody = {
                        model: "sonar",
                        messages: [
                            {
                                role: "system",
                                content:
                                    "Voc√™ √© um assistente especializado em resumir documentos judiciais de forma extremamente objetiva e sucinta para capas de processos digitais. Sempre responda em bullet points diretos.",
                            },
                            {
                                role: "user",
                                content: prompt,
                            },
                        ],
                        max_tokens: 1200,
                        temperature: 0.1,
                        top_p: 0.9,
                    };

                    debugApiCall(requestId, "REQUEST", {
                        url: "https://api.perplexity.ai/chat/completions",
                        model: requestBody.model,
                        promptLength: prompt.length,
                        maxTokens: requestBody.max_tokens,
                    });

                    const response = await fetch(
                        "https://api.perplexity.ai/chat/completions",
                        {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                Authorization: `Bearer ${apiKey}`,
                                "User-Agent": "eProbe-Extension/1.0",
                            },
                            body: JSON.stringify(requestBody),
                        },
                    );

                    const responseHeaders = Object.fromEntries(
                        response.headers.entries(),
                    );
                    debugApiCall(requestId, "RESPONSE_HEADERS", {
                        status: response.status,
                        statusText: response.statusText,
                        headers: responseHeaders,
                        requestId: responseHeaders["x-request-id"] || "N/A",
                        rateLimit: {
                            remaining:
                                responseHeaders[
                                    "x-ratelimit-remaining-requests"
                                ],
                            resetRequests:
                                responseHeaders["x-ratelimit-reset-requests"],
                            remainingTokens:
                                responseHeaders["x-ratelimit-remaining-tokens"],
                            resetTokens:
                                responseHeaders["x-ratelimit-reset-tokens"],
                        },
                    });

                    if (!response.ok) {
                        const errorData = await response.text();
                        let errorJson = null;

                        try {
                            errorJson = JSON.parse(errorData);
                        } catch (e) {
                            log(" Resposta de erro n√£o √© JSON v√°lido");
                        }

                        debugApiCall(requestId, "ERROR_DETAILS", {
                            status: response.status,
                            statusText: response.statusText,
                            errorText: errorData,
                            errorJson: errorJson,
                            headers: responseHeaders,
                        });

                        if (response.status === 401) {
                            const errorMsg =
                                errorJson?.error?.message ||
                                "Chave API inv√°lida";
                            log(" Erro 401:", errorMsg);
                            showNotification(
                                ` ${errorMsg}. Configure uma nova chave API do Perplexity.`,
                                "error",
                            );
                            await removeStoredApiKey();
                            return false;
                        } else if (response.status === 429) {
                            const rateLimitType =
                                errorJson?.error?.type || "rate_limit_exceeded";
                            const retryAfter = responseHeaders["retry-after"];

                            log(" Rate limit:", {
                                type: rateLimitType,
                                retryAfter,
                            });

                            if (rateLimitType === "insufficient_quota") {
                                showNotification(
                                    " Cota da API Perplexity esgotada. Verifique seus cr√©ditos em perplexity.ai/settings/api",
                                    "error",
                                );
                            } else {
                                showNotification(
                                    ` Limite de requests atingido. Aguarde ${
                                        retryAfter || "alguns minutos"
                                    } antes de tentar novamente.`,
                                    "warning",
                                );
                            }
                            return false;
                        } else if (response.status === 403) {
                            const errorMsg =
                                errorJson?.error?.message || "Acesso negado";
                            log(" Erro 403:", errorMsg);
                            showNotification(
                                ` ${errorMsg}. Usando m√©todo manual...`,
                                "warning",
                            );
                            return await fallbackToManual(texto);
                        } else if (response.status >= 500) {
                            log(
                                " Erro do servidor Perplexity:",
                                response.status,
                            );
                            showNotification(
                                ` Erro do servidor Perplexity (${response.status}). Usando m√©todo manual...`,
                                "warning",
                            );
                            return await fallbackToManual(texto);
                        } else {
                            const errorMsg =
                                errorJson?.error?.message ||
                                `Erro ${response.status}`;
                            log(" Erro desconhecido:", errorMsg);
                            showNotification(
                                ` ${errorMsg}. Usando m√©todo manual...`,
                                "warning",
                            );
                            return await fallbackToManual(texto);
                        }
                    }

                    const data = await response.json();

                    debugApiCall(requestId, "SUCCESS", {
                        responseId: responseHeaders["x-request-id"],
                        model: data.model,
                        usage: data.usage,
                        finishReason: data.choices?.[0]?.finish_reason,
                        responseLength:
                            data.choices?.[0]?.message?.content?.length,
                    });

                    const resumo = data.choices[0].message.content;

                    showNotification("Resumo gerado com sucesso!", "success");

                    await copyToClipboard(resumo);

                    showNotification(
                        " Resumo pronto!\n\nO resumo do documento est√° na sua √°rea de transfer√™ncia.",
                        "success",
                    );

                    return true;
                } catch (error) {
                    debugApiCall(requestId, "EXCEPTION", {
                        errorName: error.name,
                        errorMessage: error.message,
                        errorStack: error.stack,
                    });

                    log(" Erro ao enviar para Perplexity:", error);
                    showNotification(
                        " Erro de conex√£o na API. Usando m√©todo manual...",
                        "warning",
                    );

                    return await fallbackToManual(texto);
                }
            };

            // Fun√ß√£o auxiliar para fallback manual
            async function fallbackToManual(texto) {
                log(" Executando fallback para m√©todo manual");
                const copied = await copyToClipboardWithPrefix(texto);
                if (copied) {
                    showNotification(
                        " Texto copiado! Cole em Perplexity ou outra IA (Ctrl+V)",
                        "info",
                    );
                } else {
                    log(" Falha ao copiar texto no fallback");
                    showNotification(" Falha ao copiar texto", "error");
                }
                return false;
            }

            // Gerenciar chave API
            async function getStoredApiKey() {
                let apiKey = localStorage.getItem("perplexity_api_key");

                if (!apiKey) {
                    // Chave codificada em Base64 para ofusca√ß√£o b√°sica
                    const encodedKey =
                        "cHBseC1LUEFHYXhYZVZ4Yk1wUWJ5QzNCNmpZUERPd1luSk1ka3MxcUR6YmF1N2s3c05nbUo=";
                    apiKey = atob(encodedKey);
                    localStorage.setItem("perplexity_api_key", apiKey);
                    log(" API key do Perplexity configurada automaticamente");
                }

                return apiKey;
            }

            async function storeApiKey(apiKey) {
                if (!apiKey || !apiKey.startsWith("pplx-")) {
                    throw new Error(
                        'Chave API inv√°lida. Deve come√ßar com "pplx-"',
                    );
                }
                localStorage.setItem("perplexity_api_key", apiKey);
                log(" Chave API do Perplexity armazenada com sucesso");
            }

            async function removeStoredApiKey() {
                localStorage.removeItem("perplexity_api_key");
                log(" Chave API do Perplexity removida");
            }

            async function validateApiKey(apiKey) {
                if (!apiKey) return false;
                if (!apiKey.startsWith("pplx-")) return false;
                if (apiKey.length < 40) return false;
                return true;
            }

            // Menu de op√ß√µes
            function showOptionsMenu(x, y) {
                const existing = document.getElementById(
                    "documento-relevante-options-menu",
                );
                if (existing) {
                    existing.remove();
                    return;
                }

                // Verificar se h√° bot√£o flutuante e ajustar posi√ß√£o se necess√°rio
                const floatingButton =
                    document.getElementById("sent1-auto-button");
                const isFloatingButtonVisible =
                    floatingButton && floatingButton.style.display !== "none";

                // Calcular posi√ß√£o para evitar sair da tela
                const menuWidth = 200;
                const menuHeight = 400; // Estimativa
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;

                // Se o menu vai aparecer perto do bot√£o flutuante, ajustar posi√ß√£o
                if (
                    isFloatingButtonVisible &&
                    x > screenWidth - 220 &&
                    y < 200
                ) {
                    // Mover menu para a esquerda do bot√£o flutuante
                    x = screenWidth - 240;
                }

                // Ajustar X se o menu sair da tela pela direita
                if (x + menuWidth > screenWidth) {
                    x = screenWidth - menuWidth - 20;
                }

                // Ajustar Y se o menu sair da tela por baixo
                if (y + menuHeight > screenHeight) {
                    y = screenHeight - menuHeight - 20;
                }

                // Garantir que n√£o saia pela esquerda ou topo
                x = Math.max(10, x);
                y = Math.max(10, y);

                const menu = document.createElement("ul");
                menu.id = "documento-relevante-options-menu";
                menu.className = "eprobe-menu";
                menu.setAttribute("role", "menu");
                menu.style.cssText = `
                        position: fixed !important;
                        right: 20px !important;
                        top: 154px !important;
                        z-index: 10001;
                        min-width: 200px;
                        border-radius: 8px;
                        border: 1px solid rgb(19 67 119);
                        background: #134377;
                        padding: 6px;
                        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
                        font-family: "Roboto", -apple-system, system-ui, sans-serif;
                        `;

                const pageType = detectPageType();

                log(" Debug showOptionsMenu - pageType detectado:", pageType);
                log(" Debug showOptionsMenu - Posi√ß√£o do menu:", { x, y });

                if (pageType === "lista_documentos") {
                    // Verificar quantos documentos existem para customizar o menu
                    const documentosRelevantes = findDocumentosRelevantes();
                    const documentCount = documentosRelevantes.length;

                    let menuTitle = "Processar Documentos";
                    let buttonColor = "#134377";
                    let titleIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-cpu-icon lucide-cpu"><path d="M12 20v2"/><path d="M12 2v2"/><path d="M17 20v2"/><path d="M17 2v2"/><path d="M2 12h2"/><path d="M2 17h2"/><path d="M2 7h2"/><path d="M20 12h2"/><path d="M20 17h2"/><path d="M20 7h2"/><path d="M7 20v2"/><path d="M7 2v2"/><rect x="4" y="4" width="16" height="16" rx="2"/><rect x="8" y="8" width="8" height="8" rx="1"/></svg>`;

                    if (documentCount === 0) {
                        menuTitle = "Nenhum Documento";
                        buttonColor = "#ef4444";
                        titleIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 6-12 12"/><path d="m6 6 12 12"/></svg>`;
                    } else if (documentCount === 1) {
                        const doc = documentosRelevantes[0];
                        menuTitle = `1 ${doc.tipo.descricao} Encontrada`;
                    } else {
                        menuTitle = `${documentCount} Documentos Encontrados`;
                        buttonColor = "#134377";
                    }

                    menu.innerHTML = `
                        <li role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px; font-weight: 600; border-bottom: 1px solid rgb(148 163 184); margin-bottom: 6px;">
                        ${titleIcon}
                        ${menuTitle}
                        </li>
                        <li id="open-documento-btn" role="menuitem" style="cursor: ${
                            documentCount === 0 ? "not-allowed" : "pointer"
                        }; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px; ${
                            documentCount === 0 ? "opacity: 0.5;" : ""
                        }" ${documentCount === 0 ? 'data-disabled="true"' : ""}>
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="${buttonColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                        <polyline points="14,2 14,8 20,8"/>
                        <line x1="16" y1="13" x2="8" y2="13"/>
                        <line x1="16" y1="17" x2="8" y2="17"/>
                        <polyline points="10,9 9,9 8,9"/>
                        </svg>
                        ${
                            documentCount === 0
                                ? "Nenhum documento encontrado"
                                : documentCount === 1
                                  ? `Processar ${documentosRelevantes[0].tipo.descricao}`
                                  : `Escolher entre ${documentCount} documentos`
                        }
                        </li>
                        `;

                    const openBtn = menu.querySelector("#open-documento-btn");
                    if (documentCount > 0) {
                        openBtn.classList.add("eprobe-open-button");
                        openBtn.addEventListener("click", () => {
                            menu.remove();
                            if (documentCount > 1) {
                                showSentenceProcessingOptions();
                            } else {
                                runFullAutomation();
                            }
                        });
                    }
                } else if (
                    pageType === "documento_especifico" ||
                    pageType === "documento_html" ||
                    pageType === "documento_pdf"
                ) {
                    // Menu para p√°ginas de documento espec√≠fico
                    log(" Mostrando menu para documento espec√≠fico");
                    menu.innerHTML = `
                                        <li role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px; font-weight: 600; border-bottom: 1px solid rgba(148, 163, 184, 0.3); margin-bottom: 6px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-cpu-icon lucide-cpu"><path d="M12 20v2"/><path d="M12 2v2"/><path d="M17 20v2"/><path d="M17 2v2"/><path d="M2 12h2"/><path d="M2 17h2"/><path d="M2 7h2"/><path d="M20 12h2"/><path d="M20 17h2"/><path d="M20 7h2"/><path d="M7 20v2"/><path d="M7 2v2"/><rect x="4" y="4" width="16" height="16" rx="2"/><rect x="8" y="8" width="8" height="8" rx="1"/></svg>
                                        Processar Documento
                                        </li>
                                        <li id="api-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="#ffffff" stroke="none">
                                        <path d="M19.785 0v7.272H22.5V17.62h-2.935V24l-7.037-6.194v6.145h-1.091v-6.152L4.392 24v-6.465H1.5V7.188h2.884V0l7.053 6.494V.19h1.09v6.49L19.786 0zm-7.257 9.044v7.319l5.946 5.234V14.44l-5.946-5.397zm-1.099-.08l-5.946 5.398v7.235l5.946-5.234V8.965zm8.136 7.58h1.844V8.349H13.46l6.105 5.54v2.655zm-8.982-8.28H2.59v8.195h1.8v-2.576l6.192-5.62zM5.475 2.476v4.71h5.115l-5.115-4.71zm13.219 0l-5.115 4.71h5.115v-4.71z"/>
                                        </svg>
                                        Resumir com Perplexity
                                        </li>
                                        <li id="manual-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" height="16px" viewBox="0 -960 960 960" width="16px" fill="#ffffff">
                                        <path d="M255.7-156.65q-17.7 0-32.79-8.77-15.08-8.76-23.56-23.15l-73.24-132.47h60.91l41.13 81.19h87.68v-24h-71.54l-41-81.19h-91.94L53.83-449.09q-4.28-6.48-6.5-14.25-2.22-7.77-2.22-16.88 0-5.55 8.72-31.69l59.54-103.05h92.98l39.9-81.19h71.58v-24h-85.98l-40.5 81.19h-63.48l71.48-132.47q8.04-15.03 23.27-23.47 15.22-8.45 33.08-8.45h65.93q27.17 0 45.5 18.38 18.33 18.37 18.33 45.21v152.56h-53.72l-36 24h89.72v139.11h-98.2l-40.32-80.71h-87.2l-26 24h97.04l40.98 80.71h113.7v179.85q0 26.84-18.33 45.21-18.33 18.38-45.5 18.38H255.7Zm331.31 0q-36.74 0-62.52-25.93-25.77-25.92-25.77-62.76 0-21.04 9.5-40.05 9.5-19.01 26.5-30.52v-328.18q-17-11.51-26.5-30.52-9.5-19.01-9.5-40.05 0-36.84 26.04-62.76 26.03-25.93 62.81-25.93 36.77 0 62.55 25.93 25.77 25.92 25.77 62.76 0 21.04-9.5 40.05-9.5 19.01-26.5 30.52v48.16l78.35-47.54q2.72-33.4 28-56.26 25.29-22.86 60.8-22.86 36.22 0 62.18 26.04 25.95 26.04 25.95 62.81 0 36.78-25.98 62.55-25.99 25.78-62.69 25.78-9.48 0-17.81-1.26-8.33-1.26-16.2-5.26l-88.05 52.73 99.86 80.55q5.28-1.16 10.68-2.46 5.4-1.3 11.61-1.3 36.96 0 62.77 26.04 25.81 26.03 25.81 62.81 0 36.77-25.9 62.55-25.9 25.77-62.48 25.77-38.16 0-64.62-27.12-26.45-27.12-24.41-65.79l-77.87-61.55v82.49q16 11.21 25.5 30.66 9.5 19.44 9.5 41.21 0 36.84-25.54 62.76-25.54 25.93-62.34 25.93Z"/>
                                        </svg>
                                        Escolher IA
                                        </li>
                                        <li id="config-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/>
                                        <circle cx="12" cy="12" r="3"/>
                                        </svg>
                                        Configurar API
                                        </li>
                                        <li id="test-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="m14.5 9.5 1 1"/>
                                        <path d="m15.5 8.5-4 4"/>
                                        <path d="M3 12a9 9 0 1 0 9-9 9.74 9.74 0 0 0-6.74 2.74L3 8"/>
                                        <path d="M3 3v5h5"/>
                                        <circle cx="10" cy="14" r="2"/>
                                        </svg>
                                        Testar API Key
                                        </li>
                                        <li id="logs-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <rect width="8" height="4" x="8" y="2" rx="1" ry="1"/>
                                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                                        <line x1="9" y1="9" x2="15" y2="9"/>
                                        <line x1="9" y1="13" x2="15" y2="13"/>
                                        <line x1="9" y1="17" x2="13" y2="17"/>
                                        </svg>
                                        Ver Logs de Erro
                                        </li>
                                    `;

                    // Adicionar eventos de hover e click para todos os bot√µes
                    const menuItems = menu.querySelectorAll("li[id]");
                    menuItems.forEach((item) => {
                        item.addEventListener(
                            "mouseenter",
                            () => {
                                item.style.backgroundColor =
                                    "rgba(148, 163, 184, 0.1)";
                            },
                            { passive: true },
                        );
                        item.addEventListener(
                            "mouseleave",
                            () => {
                                item.style.backgroundColor = "transparent";
                            },
                            { passive: true },
                        );
                    });

                    menu.querySelector("#api-btn").addEventListener(
                        "click",
                        async () => {
                            menu.remove();
                            // N√£o extrair texto automaticamente - apenas abrir modal de prompts
                            const promptType =
                                await showPerplexityPromptModal();
                            if (promptType) {
                                // Abrir modal para usu√°rio colar texto manualmente
                                await showPerplexityTextInputModal(promptType);
                            }
                        },
                    );

                    menu.querySelector("#manual-btn").addEventListener(
                        "click",
                        async () => {
                            menu.remove();
                            const texto = await autoExtractText();
                            if (texto) {
                                log("üìù Abrindo modal de sele√ß√£o de IA...");
                                const success =
                                    await showAISelectionModal(texto);
                                if (!success) {
                                    log(
                                        "‚ùå Usu√°rio cancelou ou erro ao abrir IA",
                                    );
                                    // Fallback: copiar com prefixo tradicional
                                    const copied =
                                        await copyToClipboardWithPrefix(texto);
                                    if (copied) {
                                        showNotification(
                                            "üìã Texto copiado! Cole em qualquer IA (Ctrl+V)",
                                            "success",
                                        );
                                    }
                                }
                            } else {
                                log(
                                    "‚ùå N√£o foi poss√≠vel extrair texto do documento",
                                );
                                showNotification(
                                    "‚ùå Erro ao extrair texto do documento",
                                    "error",
                                );
                            }
                        },
                    );

                    menu.querySelector("#config-btn").addEventListener(
                        "click",
                        async () => {
                            menu.remove();
                            await showApiKeyConfig();
                        },
                    );

                    menu.querySelector("#test-btn").addEventListener(
                        "click",
                        async () => {
                            menu.remove();
                            await testApiKey();
                        },
                    );

                    menu.querySelector("#logs-btn").addEventListener(
                        "click",
                        () => {
                            menu.remove();
                            showErrorLogs();
                        },
                    );
                } else {
                    // P√°gina n√£o reconhecida, mas vamos verificar se h√° documentos
                    const pageHTML = document.documentElement.outerHTML;
                    const hasDocumentHtml = pageHTML.includes(
                        "acessar_documento&id",
                    );
                    const hasDocumentPdf = pageHTML.includes(
                        "acessar_documento&amp",
                    );

                    log(" P√°gina n√£o reconhecida, verificando documentos:", {
                        hasDocumentHtml: hasDocumentHtml,
                        hasDocumentPdf: hasDocumentPdf,
                    });

                    if (hasDocumentHtml || hasDocumentPdf) {
                        // H√° documentos, mostrar menu como se fosse documento espec√≠fico
                        log(
                            " H√° documentos, mostrando menu de documento espec√≠fico",
                        );
                        menu.innerHTML = `
                            <li role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px; font-weight: 600; border-bottom: 1px solid rgba(148, 163, 184, 0.3); margin-bottom: 6px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 8V4H8"/>
                            <rect width="16" height="12" x="4" y="8" rx="2"/>
                            <path d="M2 14h2"/>
                            <path d="M20 14h2"/>
                            <path d="M15 13v2"/>
                            <path d="M9 13v2"/>
                            </svg>
                            Processar Documento
                            </li>
                            <li id="api-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="#ffffff" stroke="none">
                            <path d="M19.785 0v7.272H22.5V17.62h-2.935V24l-7.037-6.194v6.145h-1.091v-6.152L4.392 24v-6.465H1.5V7.188h2.884V0l7.053 6.494V.19h1.09v6.49L19.786 0zm-7.257 9.044v7.319l5.946 5.234V14.44l-5.946-5.397zm-1.099-.08l-5.946 5.398v7.235l5.946-5.234V8.965zm8.136 7.58h1.844V8.349H13.46l6.105 5.54v2.655zm-8.982-8.28H2.59v8.195h1.8v-2.576l6.192-5.62zM5.475 2.476v4.71h5.115l-5.115-4.71zm13.219 0l-5.115 4.71h5.115v-4.71z"/>
                            </svg>
                            Resumo Perplexity
                            </li>
                            <li id="manual-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                            <svg xmlns="http://www.w3.org/2000/svg" height="16px" viewBox="0 -960 960 960" width="16px" fill="#ffffff">
                            <path d="M255.7-156.65q-17.7 0-32.79-8.77-15.08-8.76-23.56-23.15l-73.24-132.47h60.91l41.13 81.19h87.68v-24h-71.54l-41-81.19h-91.94L53.83-449.09q-4.28-6.48-6.5-14.25-2.22-7.77-2.22-16.88 0-5.55 8.72-31.69l59.54-103.05h92.98l39.9-81.19h71.58v-24h-85.98l-40.5 81.19h-63.48l71.48-132.47q8.04-15.03 23.27-23.47 15.22-8.45 33.08-8.45h65.93q27.17 0 45.5 18.38 18.33 18.37 18.33 45.21v152.56h-53.72l-36 24h89.72v139.11h-98.2l-40.32-80.71h-87.2l-26 24h97.04l40.98 80.71h113.7v179.85q0 26.84-18.33 45.21-18.33 18.38-45.5 18.38H255.7Zm331.31 0q-36.74 0-62.52-25.93-25.77-25.92-25.77-62.76 0-21.04 9.5-40.05 9.5-19.01 26.5-30.52v-328.18q-17-11.51-26.5-30.52-9.5-19.01-9.5-40.05 0-36.84 26.04-62.76 26.03-25.93 62.81-25.93 36.77 0 62.55 25.93 25.77 25.92 25.77 62.76 0 21.04-9.5 40.05-9.5 19.01-26.5 30.52v48.16l78.35-47.54q2.72-33.4 28-56.26 25.29-22.86 60.8-22.86 36.22 0 62.18 26.04 25.95 26.04 25.95 62.81 0 36.78-25.98 62.55-25.99 25.78-62.69 25.78-9.48 0-17.81-1.26-8.33-1.26-16.2-5.26l-88.05 52.73 99.86 80.55q5.28-1.16 10.68-2.46 5.4-1.3 11.61-1.3 36.96 0 62.77 26.04 25.81 26.03 25.81 62.81 0 36.77-25.9 62.55-25.9 25.77-62.48 25.77-38.16 0-64.62-27.12-26.45-27.12-24.41-65.79l-77.87-61.55v82.49q16 11.21 25.5 30.66 9.5 19.44 9.5 41.21 0 36.84-25.54 62.76-25.54 25.93-62.34 25.93Z"/>
                            </svg>
                            Escolher IA
                            </li>
                            <li id="config-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l-.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/>
                            <circle cx="12" cy="12" r="3"/>
                            </svg>
                            Configurar API
                            </li>
                            <li id="test-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="m14.5 9.5 1 1"/>
                            <path d="m15.5 8.5-4 4"/>
                            <path d="M3 12a9 9 0 1 0 9-9 9.74 9.74 0 0 0-6.74 2.74L3 8"/>
                            <path d="M3 3v5h5"/>
                            <circle cx="10" cy="14" r="2"/>
                            </svg>
                            Testar API Key
                            </li>
                            <li id="logs-btn" role="menuitem" style="cursor: pointer; color: rgb(203 213 225); display: flex; width: 100%; font-size: 14px; align-items: center; border-radius: 6px; padding: 12px; transition: all 0.15s ease; gap: 8px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ffffff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect width="8" height="4" x="8" y="2" rx="1" ry="1"/>
                            <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                            <line x1="9" y1="9" x2="15" y2="9"/>
                            <line x1="9" y1="13" x2="15" y2="13"/>
                            <line x1="9" y1="17" x2="13" y2="17"/>
                            </svg>
                            Ver Logs de Erro
                            </li>
                            `;

                        // Adicionar eventos de hover e click para todos os bot√µes
                        const menuItems = menu.querySelectorAll("li[id]");
                        menuItems.forEach((item) => {
                            item.addEventListener(
                                "mouseenter",
                                () => {
                                    item.style.backgroundColor =
                                        "rgba(148, 163, 184, 0.1)";
                                },
                                { passive: true },
                            );
                            item.addEventListener(
                                "mouseleave",
                                () => {
                                    item.style.backgroundColor = "transparent";
                                },
                                { passive: true },
                            );
                        });

                        menu.querySelector("#api-btn").addEventListener(
                            "click",
                            async () => {
                                menu.remove();
                                const texto = await autoExtractText();
                                if (texto) {
                                    await showPerplexityPromptModal(texto);
                                }
                            },
                        );

                        menu.querySelector("#manual-btn").addEventListener(
                            "click",
                            async () => {
                                menu.remove();
                                const texto = await autoExtractText();
                                if (texto) {
                                    log("üìù Abrindo modal de sele√ß√£o de IA...");
                                    const success =
                                        await showAISelectionModal(texto);
                                    if (!success) {
                                        log(
                                            "‚ùå Usu√°rio cancelou ou erro ao abrir IA",
                                        );
                                        // Fallback: copiar com prefixo tradicional
                                        const copied =
                                            await copyToClipboardWithPrefix(
                                                texto,
                                            );
                                        if (copied) {
                                            showNotification(
                                                "üìã Texto copiado! Cole em qualquer IA (Ctrl+V)",
                                                "success",
                                            );
                                        }
                                    }
                                } else {
                                    log(
                                        "‚ùå N√£o foi poss√≠vel extrair texto do documento",
                                    );
                                    showNotification(
                                        "‚ùå Erro ao extrair texto do documento",
                                        "error",
                                    );
                                }
                            },
                        );

                        menu.querySelector("#config-btn").addEventListener(
                            "click",
                            async () => {
                                menu.remove();
                                await showApiKeyConfig();
                            },
                        );

                        menu.querySelector("#test-btn").addEventListener(
                            "click",
                            async () => {
                                menu.remove();
                                await testApiKey();
                            },
                        );

                        menu.querySelector("#logs-btn").addEventListener(
                            "click",
                            () => {
                                menu.remove();
                                showErrorLogs();
                            },
                        );
                    } else {
                        // N√£o h√° documentos, mostrar mensagem de erro
                        log(" N√£o h√° documentos, n√£o criando menu");
                        return;
                    }
                }

                document.body.appendChild(menu);

                // Verificar e prevenir sobreposi√ß√µes ap√≥s um pequeno delay
                setTimeout(() => {
                    preventElementOverlap();
                }, 100);

                document.addEventListener("click", function closeMenu(e) {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener("click", closeMenu);
                    }
                });
            }

            // Op√ß√µes de processamento quando h√° m√∫ltiplos documentos
            function showDocumentProcessingOptions() {
                const documentosRelevantes = findDocumentosRelevantes();

                if (documentosRelevantes.length === 0) {
                    showNotification(
                        "‚ùå Nenhum documento relevante encontrado",
                        "error",
                    );
                    return;
                }

                const existing = document.getElementById(
                    "documento-relevante-selection-modal",
                );
                if (existing) {
                    existing.remove();
                }

                const overlay = document.createElement("div");
                overlay.id = "documento-relevante-selection-modal";
                overlay.className = "eprobe-modal";
                overlay.style.cssText = `
            position: fixed !important;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: "Roboto", -apple-system, system-ui, sans-serif;
        `;

                const modal = document.createElement("div");
                modal.style.cssText = `
            background: #1e293b;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            border: 1px solid #334155;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            color: #f8fafc;
        `;

                const title = document.createElement("h2");
                title.style.cssText = `
            margin: 0 0 20px 0;
            color: #3b82f6;
            font-size: 20px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        `;
                title.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                <polyline points="14,2 14,8 20,8"/>
            </svg>
            Escolher Documento (${documentosRelevantes.length} encontrados)
        `;

                const subtitle = document.createElement("p");
                subtitle.style.cssText = `
            margin: 0 0 20px 0;
            color: #94a3b8;
            font-size: 14px;
            line-height: 1.5;
        `;
                subtitle.textContent =
                    "Selecione o documento que deseja processar:";

                const list = document.createElement("div");
                list.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        `;

                documentosRelevantes.forEach((doc, index) => {
                    const item = document.createElement("div");
                    item.style.cssText = `
                border: 1px solid #475569;
                border-radius: 8px;
                padding: 16px;
                cursor: pointer;
                transition: all 0.2s ease;
                background: #334155;
            `;

                    item.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="color: ${doc.tipo.cor}; font-size: 18px;">
                        ${doc.tipo.icone}
                    </div>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; color: #f8fafc; margin-bottom: 4px;">
                            ${doc.tipo.descricao}
                        </div>
                        <div style="font-size: 12px; color: #94a3b8;">
                            ${doc.nome}
                        </div>
                    </div>
                    <div style="color: #3b82f6;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="9,18 15,12 9,6"/>
                        </svg>
                    </div>
                </div>
            `;

                    item.addEventListener(
                        "mouseenter",
                        () => {
                            item.style.backgroundColor = "#475569";
                            item.style.borderColor = "#3b82f6";
                        },
                        { passive: true },
                    );

                    item.addEventListener(
                        "mouseleave",
                        () => {
                            item.style.backgroundColor = "#334155";
                            item.style.borderColor = "#475569";
                        },
                        { passive: true },
                    );

                    item.addEventListener("click", () => {
                        overlay.remove();
                        autoOpenSpecificDocument(doc);
                    });

                    list.appendChild(item);
                });

                const buttons = document.createElement("div");
                buttons.style.cssText = `
            display: flex;
            justify-content: space-between;
            gap: 12px;
        `;

                const cancelBtn = document.createElement("button");
                cancelBtn.style.cssText = `
            background: #6b7280;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s ease;
        `;
                cancelBtn.textContent = "Cancelar";
                cancelBtn.classList.add("eprobe-cancel-button");
                cancelBtn.addEventListener("click", () => {
                    overlay.remove();
                });

                const processAllBtn = document.createElement("button");
                processAllBtn.style.cssText = `
            background: #059669;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s ease;
        `;
                processAllBtn.textContent = "Processar Primeiro";
                processAllBtn.classList.add("eprobe-process-button");
                processAllBtn.addEventListener("click", () => {
                    overlay.remove();
                    autoOpenSpecificDocument(documentosRelevantes[0]);
                });

                buttons.appendChild(cancelBtn);
                buttons.appendChild(processAllBtn);

                modal.appendChild(title);
                modal.appendChild(subtitle);
                modal.appendChild(list);
                modal.appendChild(buttons);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);

                overlay.addEventListener("click", (e) => {
                    if (e.target === overlay) {
                        overlay.remove();
                    }
                });
            }

            // Abrir documento espec√≠fico
            async function autoOpenSpecificDocument(documento) {
                log("üîó Abrindo documento espec√≠fico:", documento);

                try {
                    showNotification("üìÑ Abrindo documento...", "info");

                    const link = documento.elemento.querySelector("a");
                    if (!link) {
                        log("‚ùå Link n√£o encontrado no documento");
                        showNotification(
                            "‚ùå Erro: Link do documento n√£o encontrado",
                            "error",
                        );
                        return false;
                    }

                    const url = link.href;
                    if (!url) {
                        log("‚ùå URL n√£o encontrada no link");
                        showNotification(
                            "‚ùå Erro: URL do documento n√£o encontrada",
                            "error",
                        );
                        return false;
                    }

                    log("üåê URL do documento:", url);

                    const newTab = window.open(url, "_blank");
                    if (newTab) {
                        log("‚úÖ Documento aberto em nova aba");
                        showNotification(
                            "‚úÖ Documento aberto! Execute a extens√£o novamente na nova aba",
                            "success",
                        );
                        return true;
                    } else {
                        log("‚ùå Falha ao abrir nova aba - popup bloqueado?");
                        showNotification(
                            "‚ùå N√£o foi poss√≠vel abrir o documento. Verifique se popups est√£o bloqueados.",
                            "error",
                        );
                        return false;
                    }
                } catch (error) {
                    log("‚ùå Erro ao abrir documento espec√≠fico:", error);
                    showNotification(
                        "‚ùå Erro ao abrir documento: " + error.message,
                        "error",
                    );
                    return false;
                }
            }

            // Automa√ß√£o completa - usando express√£o de fun√ß√£o para evitar problemas de escopo
            const runFullAutomation = async function () {
                if (isAutomationActive) {
                    log("‚ö†Ô∏è Automa√ß√£o j√° est√° ativa");
                    return;
                }

                isAutomationActive = true;
                log("üöÄ Iniciando automa√ß√£o completa...");

                try {
                    const pageType = detectPageType();

                    if (pageType === "lista_documentos") {
                        const opened = await autoOpenDocumentoRelevante();
                        if (opened) {
                            showNotification(
                                "‚úÖ Documento aberto! Aguarde carregar e clique novamente no bot√£o eProbe",
                                "success",
                            );
                        }
                    } else if (
                        pageType === "documento_especifico" ||
                        pageType === "documento_pdf" ||
                        pageType === "documento_html"
                    ) {
                        showNotification(
                            "‚ö° Extraindo texto automaticamente...",
                            "info",
                        );

                        const texto = await autoExtractText();

                        if (texto && texto.length > 100) {
                            showNotification(
                                "‚úÖ Texto extra√≠do! Enviando para Perplexity...",
                                "info",
                            );

                            // Tentar enviar para Perplexity
                            const apiSent = await sendToPerplexityWithPrompt(
                                texto,
                                "resumir",
                            );

                            if (!apiSent) {
                                log(
                                    "‚ö†Ô∏è API falhou, copiando para clipboard como fallback",
                                );
                                const copied =
                                    await copyToClipboardWithPrefix(texto);
                                if (copied) {
                                    showNotification(
                                        "‚úÖ Texto copiado com prefixo para IA!\n\nCole em Perplexity (Ctrl+V)",
                                        "success",
                                        5000,
                                    );
                                }
                            }
                        } else {
                            showNotification(
                                "‚ùå N√£o foi poss√≠vel extrair texto suficiente",
                                "error",
                            );
                        }
                    } else {
                        showNotification(
                            "‚ö†Ô∏è P√°gina n√£o reconhecida. Use na p√°gina do documento",
                            "warning",
                        );
                    }
                } catch (error) {
                    log("‚ùå Erro na automa√ß√£o:", error);
                    showNotification("‚ùå Erro: " + error.message, "error");
                } finally {
                    isAutomationActive = false;
                }
            };

            // Fun√ß√£o para prevenir sobreposi√ß√£o de elementos da interface
            function preventElementOverlap() {
                const floatingButton =
                    document.getElementById("sent1-auto-button");
                const notification = document.getElementById(
                    "documento-relevante-notification",
                );
                const optionsMenu = document.getElementById(
                    "documento-relevante-options-menu",
                );

                if (
                    !floatingButton ||
                    floatingButton.style.display === "none"
                ) {
                    return; // Bot√£o flutuante n√£o est√° vis√≠vel
                }

                // Verificar sobreposi√ß√£o com notifica√ß√£o
                if (notification) {
                    const buttonRect = floatingButton.getBoundingClientRect();
                    const notificationRect =
                        notification.getBoundingClientRect();

                    // Se h√° sobreposi√ß√£o, mover notifica√ß√£o
                    if (
                        buttonRect.left < notificationRect.right + 10 &&
                        buttonRect.top < notificationRect.bottom + 10 &&
                        buttonRect.bottom > notificationRect.top - 10
                    ) {
                        log(
                            "üîß Ajustando posi√ß√£o da notifica√ß√£o para evitar sobreposi√ß√£o",
                        );
                        notification.style.right = "240px"; // Mover mais √† esquerda
                    }
                }

                // Verificar sobreposi√ß√£o com menu de op√ß√µes
                if (optionsMenu) {
                    const buttonRect = floatingButton.getBoundingClientRect();
                    const menuRect = optionsMenu.getBoundingClientRect();

                    // Se h√° sobreposi√ß√£o, mover menu
                    if (
                        buttonRect.left < menuRect.right + 10 &&
                        buttonRect.top < menuRect.bottom + 10 &&
                        buttonRect.bottom > menuRect.top - 10
                    ) {
                        log(
                            "üîß Ajustando posi√ß√£o do menu para evitar sobreposi√ß√£o",
                        );
                        const newLeft = Math.max(
                            10,
                            buttonRect.left - menuRect.width - 10,
                        );
                        optionsMenu.style.left = newLeft + "px";
                    }
                }
            }

            // ‚úÖ REMOVIDO: setupInterfaceObserver duplicada - agora est√° no escopo global
            // A fun√ß√£o foi movida para o escopo global para estar dispon√≠vel em toda a extens√£o

            // Sistema de notifica√ß√µes
            function showNotification(message, type = "info") {
                // Remover notifica√ß√£o anterior se existir
                const existing = document.getElementById(
                    "documento-relevante-notification",
                );
                if (existing) {
                    existing.remove();
                }

                // Verificar se existe bot√£o flutuante para ajustar posi√ß√£o
                const floatingButton =
                    document.getElementById("sent1-auto-button");
                const isFloatingButtonVisible =
                    floatingButton &&
                    floatingButton.style.display !== "none" &&
                    floatingButton.offsetParent !== null; // Verifica se est√° realmente vis√≠vel

                // Posi√ß√£o din√¢mica baseada na presen√ßa do bot√£o flutuante
                let notificationTop = "20px";
                let notificationRight = "20px";

                if (isFloatingButtonVisible) {
                    // Se h√° bot√£o flutuante, calcular posi√ß√£o para evitar sobreposi√ß√£o
                    const buttonRect = floatingButton.getBoundingClientRect();
                    const windowWidth = window.innerWidth;

                    // Se h√° espa√ßo √† esquerda do bot√£o, colocar a notifica√ß√£o l√°
                    if (buttonRect.left > 300) {
                        notificationRight =
                            windowWidth - buttonRect.left + 10 + "px";
                    } else {
                        // Se n√£o h√° espa√ßo, colocar acima ou abaixo do bot√£o
                        if (buttonRect.top > 100) {
                            notificationTop = buttonRect.top - 80 + "px";
                            notificationRight = "20px";
                        } else {
                            notificationTop = buttonRect.bottom + 10 + "px";
                            notificationRight = "20px";
                        }
                    }
                }

                const notification = document.createElement("div");
                notification.id = "documento-relevante-notification";
                notification.className = "eprobe-notification";
                notification.style.cssText = `
                    position: fixed !important;
                    top: ${notificationTop};
                    right: ${notificationRight};
                    background: ${
                        type === "error"
                            ? "#dc3545"
                            : type === "warning"
                              ? "#ffc107"
                              : type === "success"
                                ? "#134377"
                                : "#134377"
                    };
                    color: white;
                    padding: 15px 20px;
                    border-radius: 5px;
                    font-weight: bold;
                    z-index: 10000;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    max-width: 280px;
                    font-size: 14px;
                    line-height: 1.4;
                    `;
                // Verificar se deve mostrar spinner
                if (message.includes("Enviando para Perplexity")) {
                    notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="position: relative; width: 24px; height: 24px;">
                        <div style="width: 24px; height: 24px; border-top: 3px solid rgba(255,255,255,0.3); border-bottom: 3px solid rgba(255,255,255,0.3); border-radius: 50%; position: absolute; top: 0; left: 0;"></div>
                        <div style="width: 24px; height: 24px; border-top: 3px solid white; border-bottom: 3px solid white; border-radius: 50%; position: absolute; top: 0; left: 0; animation: spin 1s linear infinite;"></div>
                    </div>
                    <span>${message}</span>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
                } else {
                    notification.textContent = message;
                }

                document.body.appendChild(notification);

                // Verificar e prevenir sobreposi√ß√µes ap√≥s um pequeno delay
                setTimeout(() => {
                    preventElementOverlap();
                }, 100);

                // Remover ap√≥s 5 segundos
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 5000);
            }

            // Verificar se a p√°gina deve mostrar o bot√£o integrado (REMOVIDA - usar a vers√£o melhorada)
            // Fun√ß√£o movida para cima para evitar duplica√ß√£o

            // Criar bot√£o de automa√ß√£o integrado na p√°gina
            function createAutomationButton() {
                log(" Tentando criar bot√£o integrado...");

                // Verificar se j√° existe (verificar todos os IDs poss√≠veis)
                if (
                    document.getElementById(
                        "documento-relevante-auto-button",
                    ) ||
                    document.getElementById("sent1-auto-button")
                ) {
                    log(" Bot√£o j√° existe, pulando cria√ß√£o");
                    return;
                }

                // CRIT√âRIO ESPEC√çFICO: Verificar se a p√°gina tem o t√≠tulo exato
                let shouldShowIntegrated = false;
                try {
                    if (typeof shouldShowIntegratedButton === "function") {
                        shouldShowIntegrated = shouldShowIntegratedButton();
                    }
                } catch (e) {
                    console.warn(
                        "‚ö†Ô∏è Erro ao verificar shouldShowIntegratedButton:",
                        e.message,
                    );
                }

                if (!shouldShowIntegrated) {
                    log(
                        " P√°gina n√£o possui o t√≠tulo correto para bot√£o integrado, verificando crit√©rio para bot√£o flutuante...",
                    );
                    // Se n√£o tem o t√≠tulo correto mas deve mostrar o bot√£o flutuante, criar bot√£o flutuante
                    let shouldShowFloating = false;
                    try {
                        if (typeof shouldShowFloatingButton === "function") {
                            shouldShowFloating = shouldShowFloatingButton();
                        }
                    } catch (e) {
                        console.warn(
                            "‚ö†Ô∏è Erro ao verificar shouldShowFloatingButton:",
                            e.message,
                        );
                    }

                    if (shouldShowFloating) {
                        createFloatingButton();
                    } else {
                        log(" P√°gina n√£o atende crit√©rios para nenhum bot√£o");
                    }
                    return;
                }

                // Buscar container principal para integra√ß√£o
                const targetInfo = findTargetContainer();

                if (!targetInfo) {
                    log(
                        " Container alvo n√£o encontrado, usando posi√ß√£o fixa como fallback",
                    );
                    createFloatingButton();
                    return;
                }

                // Extrair informa√ß√µes do container
                const targetContainer = targetInfo.container || targetInfo;
                const insertMethod = targetInfo.insertMethod || "append";
                const referenceElement = targetInfo.referenceElement;

                log(" Container encontrado, criando bot√£o integrado...");
                const button = criarInfraButtonPrimary(
                    "documento-relevante-auto-button",
                    `
 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 3px !important; vertical-align: middle;">
 <rect width="18" height="18" x="3" y="3" rx="2"/>
 <path d="m9 8 6 4-6 4Z"/>
 </svg>
 Resumir Documento
 `,
                );

                // Adicionar espa√ßamento quando posicionado ao lado do PDPJ
                if (insertMethod === "beforePDPJ") {
                    button.style.marginRight = "15px";
                }

                // Adicionar evento de click
                button.addEventListener("click", async (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    log(" Bot√£o integrado clicado!");
                    log(" Debug: Bot√£o Resumir Documento clicado");

                    // Adicionar feedback visual
                    button.style.transform = "scale(0.95)";
                    setTimeout(() => {
                        button.style.transform = "";
                    }, 150);

                    const pageType = detectPageType();
                    log(" Tipo de p√°gina detectado:", pageType);

                    if (pageType === "lista_documentos") {
                        showNotification(" Abrindo documento...", "info");
                        await runFullAutomation();
                    } else if (pageType === "documento_especifico") {
                        const rect = button.getBoundingClientRect();
                        showOptionsMenu(rect.left, rect.bottom);
                    } else {
                        showNotification(" P√°gina n√£o reconhecida", "error");
                    }
                });

                // Inserir no container usando o m√©todo apropriado
                if (insertMethod === "beforeDownload" && referenceElement) {
                    try {
                        log(
                            " Inserindo bot√£o antes do Download Completo na barra de comandos...",
                        );
                        log(
                            " Reference element (Download button):",
                            referenceElement,
                        );
                        log(" Container (form):", targetContainer);

                        // Criar um wrapper para melhor alinhamento na barra de comandos
                        const buttonWrapper = document.createElement("span");
                        buttonWrapper.style.cssText = "display: inline-block;";
                        buttonWrapper.appendChild(button);

                        // Inserir o wrapper antes do bot√£o Download Completo
                        referenceElement.insertAdjacentElement(
                            "beforebegin",
                            buttonWrapper,
                        );

                        log(
                            " Bot√£o inserido com sucesso antes do Download Completo",
                        );
                        log(
                            " Posi√ß√£o final do bot√£o:",
                            button.parentElement.parentElement,
                        );
                    } catch (error) {
                        log(
                            " Erro ao inserir antes do Download Completo, usando fallback:",
                            error,
                        );
                        // Fallback: inserir no in√≠cio do container
                        targetContainer.insertBefore(
                            button,
                            targetContainer.firstChild,
                        );
                        log(
                            " Bot√£o inserido no in√≠cio do container (fallback)",
                        );
                    }
                } else if (insertMethod === "prepend") {
                    // Inserir no in√≠cio do container
                    const firstChild = targetContainer.firstChild;
                    if (firstChild) {
                        targetContainer.insertBefore(button, firstChild);
                    } else {
                        targetContainer.appendChild(button);
                    }
                    log(" Bot√£o inserido no in√≠cio do container");
                } else if (insertMethod === "beforePDPJ" && referenceElement) {
                    try {
                        // Estrat√©gia 1: Inserir diretamente ao lado esquerdo da imagem usando insertAdjacentElement
                        log(
                            " Tentando posicionar ao lado esquerdo da imagem PDPJ...",
                        );
                        log(" Reference element:", referenceElement);
                        log(
                            " Reference element tagName:",
                            referenceElement.tagName,
                        );
                        log(
                            " Reference element parent:",
                            referenceElement.parentElement,
                        );

                        // Usar insertAdjacentElement para posicionar exatamente ao lado esquerdo
                        referenceElement.insertAdjacentElement(
                            "beforebegin",
                            button,
                        );

                        // Verifica√ß√£o final: garantir que o bot√£o n√£o est√° dentro de um link
                        const buttonParent = button.parentElement;
                        const isInsideLink = button.closest("a") !== null;

                        if (isInsideLink) {
                            log(
                                " PROBLEMA: Bot√£o foi inserido dentro de um link!",
                            );
                            log(" Tentando mover para fora do link...");

                            // Encontrar o link pai
                            const linkElement = button.closest("a");
                            const linkContainer = linkElement.parentElement;

                            // Remover bot√£o do local atual
                            button.remove();

                            // Inserir antes do link
                            linkContainer.insertBefore(button, linkElement);
                            log(" Bot√£o movido para fora do link");
                        }

                        log(" Bot√£o inserido ao lado esquerdo da imagem PDPJ");
                        log(" Posi√ß√£o final do bot√£o:", button.parentElement);
                        log(
                            " Bot√£o est√° dentro de link?",
                            button.closest("a") !== null ? "SIM" : "N√ÉO",
                        );
                    } catch (error) {
                        log(
                            " Erro ao inserir ao lado da imagem PDPJ, tentando estrat√©gias alternativas:",
                            error,
                        );

                        try {
                            // Estrat√©gia 2: Verificar se a imagem √© realmente filha direta do container
                            if (
                                Array.from(targetContainer.children).includes(
                                    referenceElement,
                                )
                            ) {
                                // Inserir antes da imagem PDPJ (ao lado esquerdo)
                                targetContainer.insertBefore(
                                    button,
                                    referenceElement,
                                );
                                log(" Bot√£o inserido antes da imagem PDPJ");
                            } else {
                                // Estrat√©gia 3: A imagem n√£o √© filha direta, usar o pai direto da imagem
                                const directParent =
                                    referenceElement.parentElement;
                                if (
                                    directParent &&
                                    Array.from(directParent.children).includes(
                                        referenceElement,
                                    )
                                ) {
                                    directParent.insertBefore(
                                        button,
                                        referenceElement,
                                    );
                                    log(
                                        " Bot√£o inserido antes da imagem PDPJ (no pai direto)",
                                    );
                                } else {
                                    // Estrat√©gia 4: Fallback - adicionar no final do container encontrado
                                    targetContainer.appendChild(button);
                                    log(
                                        " Bot√£o adicionado ao container (fallback)",
                                    );
                                }
                            }
                        } catch (secondError) {
                            log(
                                " Erro na segunda tentativa, usando fallback final:",
                                secondError,
                            );
                            // Fallback final: adicionar no final do container
                            targetContainer.appendChild(button);
                            log(
                                " Bot√£o adicionado ao container (fallback final)",
                            );
                        }
                    }
                } else {
                    // M√©todo padr√£o - adicionar ao final do container
                    targetContainer.appendChild(button);
                    log(
                        " Bot√£o integrado adicionado ao container:",
                        targetContainer,
                    );
                }
            }

            // Fun√ß√£o para encontrar o container alvo na p√°gina
            function findTargetContainer() {
                // Prioridade 1: Buscar o bot√£o "Download Completo" na barra de comandos superior do eProc
                const commandBar = document.getElementById(
                    "divInfraBarraComandosSuperior",
                );
                if (commandBar) {
                    log(" Barra de comandos superior encontrada:", commandBar);

                    // Procurar pelo formul√°rio que cont√©m o bot√£o "Download Completo"
                    const processForm =
                        commandBar.querySelector("#frmProcessoLista");
                    if (processForm) {
                        log(" Formul√°rio do processo encontrado:", processForm);

                        // Buscar o bot√£o "Download Completo" por diferentes estrat√©gias
                        const downloadSelectors = [
                            'button[id*="btnDownloadCompleto"]',
                            'input[id*="btnDownloadCompleto"]',
                            'button[aria-label*="Download Completo"]',
                            'input[aria-label*="Download Completo"]',
                            'button[value*="Download Completo"]',
                            'input[value*="Download Completo"]',
                            'button[title*="Download Completo"]',
                            'input[title*="Download Completo"]',
                            'button:contains("Download Completo")',
                            '*[onclick*="download_completo"]',
                            '*[onclick*="downloadCompleto"]',
                            '*[onclick*="download"]',
                        ];

                        let downloadButton = null;

                        // Primeiro tentar seletores diretos
                        for (const selector of downloadSelectors) {
                            if (selector.includes(":contains(")) continue; // Pular seletores que n√£o funcionam com querySelector
                            downloadButton =
                                processForm.querySelector(selector);
                            if (downloadButton) {
                                log(
                                    ` Bot√£o Download Completo encontrado com seletor: ${selector}`,
                                    downloadButton,
                                );
                                break;
                            }
                        }

                        // Se n√£o encontrou, buscar por texto nos bot√µes
                        if (!downloadButton) {
                            log(
                                " Buscando bot√£o Download Completo por texto...",
                            );
                            const allButtons = processForm.querySelectorAll(
                                'button, input[type="submit"], input[type="button"]',
                            );
                            for (const btn of allButtons) {
                                const text =
                                    btn.textContent ||
                                    btn.value ||
                                    btn.getAttribute("aria-label") ||
                                    "";
                                if (
                                    text.toLowerCase().includes("download") &&
                                    text.toLowerCase().includes("completo")
                                ) {
                                    downloadButton = btn;
                                    log(
                                        " Bot√£o Download Completo encontrado por texto:",
                                        downloadButton,
                                    );
                                    break;
                                }
                            }
                        }

                        if (downloadButton) {
                            log(
                                " Inserindo antes do bot√£o Download Completo na barra de comandos",
                            );
                            return {
                                container: processForm,
                                insertMethod: "beforeDownload",
                                referenceElement: downloadButton,
                            };
                        } else {
                            // Se n√£o encontrou o bot√£o Download, inserir no in√≠cio do formul√°rio
                            log(
                                " Bot√£o Download Completo n√£o encontrado, inserindo no in√≠cio do formul√°rio",
                            );
                            return {
                                container: processForm,
                                insertMethod: "prepend",
                            };
                        }
                    } else {
                        // Se n√£o encontrou o formul√°rio, buscar diretamente na barra de comandos
                        log(
                            " Formul√°rio n√£o encontrado, buscando Download Completo diretamente na barra...",
                        );

                        const downloadSelectors = [
                            'button[id*="btnDownloadCompleto"]',
                            'input[id*="btnDownloadCompleto"]',
                            'button[aria-label*="Download Completo"]',
                            'input[aria-label*="Download Completo"]',
                            'button[value*="Download Completo"]',
                            'input[value*="Download Completo"]',
                        ];

                        let downloadButton = null;
                        for (const selector of downloadSelectors) {
                            downloadButton = commandBar.querySelector(selector);
                            if (downloadButton) {
                                log(
                                    ` Bot√£o Download encontrado na barra: ${selector}`,
                                    downloadButton,
                                );
                                return {
                                    container: commandBar,
                                    insertMethod: "beforeDownload",
                                    referenceElement: downloadButton,
                                };
                            }
                        }

                        // Buscar por texto nos bot√µes da barra
                        const allButtons = commandBar.querySelectorAll(
                            'button, input[type="submit"], input[type="button"]',
                        );
                        for (const btn of allButtons) {
                            const text =
                                btn.textContent ||
                                btn.value ||
                                btn.getAttribute("aria-label") ||
                                "";
                            if (
                                text.toLowerCase().includes("download") &&
                                text.toLowerCase().includes("completo")
                            ) {
                                log(
                                    " Bot√£o Download encontrado por texto na barra:",
                                    btn,
                                );
                                return {
                                    container: commandBar,
                                    insertMethod: "beforeDownload",
                                    referenceElement: btn,
                                };
                            }
                        }

                        // Se n√£o encontrou nada, inserir na barra de comandos
                        log(
                            " Bot√£o Download n√£o encontrado, inserindo na barra de comandos",
                        );
                        return {
                            container: commandBar,
                            insertMethod: "prepend",
                        };
                    }
                }

                // Prioridade 2: Buscar pela imagem PDPJ e posicionar ao lado esquerdo (fallback)
                const pdpjImage = document.querySelector(
                    'img[src*="pdpj-logotipo_3.png"], img[src*="pdpj-logotipo"]',
                );
                if (pdpjImage) {
                    log(
                        " Imagem PDPJ encontrada, buscando container pai adequado",
                    );

                    // Verificar se a imagem est√° dentro de um link <a>
                    const linkParent = pdpjImage.closest("a");
                    if (linkParent) {
                        log("Imagem PDPJ est√° dentro de um link:", linkParent);
                        log(
                            "Link src/href:",
                            linkParent.href || linkParent.getAttribute("href"),
                        );
                        const linkContainer = linkParent.parentElement;
                        if (linkContainer) {
                            log("Container do link:", linkContainer);
                            return {
                                container: linkContainer,
                                insertMethod: "beforePDPJ",
                                referenceElement: linkParent, // Usar o link como refer√™ncia, n√£o a imagem
                            };
                        }
                    }

                    // Primeiro tentar o pai direto da imagem se n√£o estiver em um link
                    const directParent = pdpjImage.parentElement;
                    if (directParent) {
                        log(" Usando pai direto da imagem PDPJ:", directParent);
                        return {
                            container: directParent,
                            insertMethod: "beforePDPJ",
                            referenceElement: pdpjImage,
                        };
                    }

                    // Buscar o container pai que permite inserir o bot√£o ao lado esquerdo
                    let parent = pdpjImage.parentElement;
                    while (parent && parent !== document.body) {
                        const styles = window.getComputedStyle(parent);

                        // Verificar se √© um container que permita posicionamento (SEM verifica√ß√£o d-flex)
                        if (
                            styles.display === "flex" ||
                            parent.classList.contains("header") ||
                            parent.tagName === "HEADER"
                        ) {
                            log(
                                " Container de header encontrado para PDPJ:",
                                parent,
                            );

                            // Retornar um objeto especial indicando posicionamento pr√≥ximo √† imagem PDPJ
                            return {
                                container: parent,
                                insertMethod: "beforePDPJ",
                                referenceElement: pdpjImage,
                            };
                        }
                        parent = parent.parentElement;
                    }

                    // Se n√£o encontrou container flex, usar o pai direto da imagem como fallback
                    log(" Usando container pai direto da imagem PDPJ");
                    return {
                        container: pdpjImage.parentElement,
                        insertMethod: "beforePDPJ",
                        referenceElement: pdpjImage,
                    };
                }

                // Prioridade 2: REMOVIDO - N√£o buscar na navbar para evitar interfer√™ncias
                // A navbar agora √© gerenciada exclusivamente por gerenciarNavbarEprobe()
                log(
                    "‚ÑπÔ∏è BUTTON: Pulando busca na navbar para evitar interfer√™ncias",
                );

                // Prioridade 3: Lista atualizada de seletores com foco no eProc (SEM elementos d-flex que podem interferir na navbar)
                const containerSelectors = [
                    "#divInfraBarraComandosSuperior", // Barra de comandos superior do eProc
                    ".infraBarraComandos", // Barra de comandos geral do eProc
                    "#frmProcessoLista", // Formul√°rio da lista de processos
                    ".toolbar",
                    ".action-bar",
                    ".header-actions",
                    "#barraComandos",
                    ".infra-barra-comandos",
                ];

                for (const selector of containerSelectors) {
                    const container = document.querySelector(selector);
                    if (container) {
                        log(` Container encontrado com seletor: ${selector}`);
                        return { container: container, insertMethod: "append" };
                    }
                }

                // Fallback: buscar containers espec√≠ficos (SEM d-flex que pode interferir na navbar)
                const fallbackSelectors = [
                    'div[class*="toolbar"]',
                    'div[class*="header"]',
                    'div[class*="action"]',
                ];

                for (const selector of fallbackSelectors) {
                    const containers = document.querySelectorAll(selector);
                    for (const container of containers) {
                        // Verificar se o container est√° vis√≠vel e tem tamanho adequado
                        const rect = container.getBoundingClientRect();
                        if (
                            rect.width > 200 &&
                            rect.height > 20 &&
                            rect.top < 300
                        ) {
                            log(` Container fallback encontrado: ${selector}`);
                            return {
                                container: container,
                                insertMethod: "append",
                            };
                        }
                    }
                }

                log(" Nenhum container adequado encontrado");
                return null;
            }

            // Fun√ß√£o para mostrar menu b√°sico de debug quando a p√°gina n√£o √© reconhecida
            function showBasicDebugMenu(button) {
                log("üõ†Ô∏è DEBUG MENU: Criando menu b√°sico de debug");

                const rect = button.getBoundingClientRect();
                const menu = document.createElement("div");
                menu.id = "eprobe-debug-menu";
                menu.style.cssText = `
                    position: fixed !important;
                    left: ${rect.left - 200}px;
                    top: ${rect.bottom + 10}px;
                    z-index: 10002;
                    background: rgb(19, 67, 119);
                    border: 1px solid rgb(19, 67, 119);
                    border-radius: 8px;
                    padding: 12px;
                    min-width: 250px;
                    color: white;
                    font-family: "Roboto", sans-serif;
                    font-size: 14px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                `;

                const pageType = detectPageType();
                const url = window.location.href;

                menu.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid rgb(19, 67, 119); padding-bottom: 8px;">
                        üõ†Ô∏è eProbe Debug Menu
                    </div>
                    <div style="font-size: 12px; margin-bottom: 8px;">
                        <strong>P√°gina:</strong> ${
                            pageType || "n√£o reconhecida"
                        }
                    </div>
                    <div style="font-size: 12px; margin-bottom: 12px; word-break: break-all;">
                        <strong>URL:</strong> ${url.substring(0, 60)}...
                    </div>
                    <button id="debug-extract-text" style="width: 100%; margin-bottom: 6px; background: rgb(19, 67, 119); color: white; border: none; padding: 8px; border-radius: 4px; cursor: pointer;">
                        üìÑ Extrair Texto da P√°gina
                    </button>
                    <button id="debug-show-api-config" style="width: 100%; margin-bottom: 6px; background: rgb(19, 67, 119); color: white; border: none; padding: 8px; border-radius: 4px; cursor: pointer;">
                        üîë Configurar API Perplexity
                    </button>
                    <button id="debug-close" style="width: 100%; background: #6c757d; color: white; border: none; padding: 8px; border-radius: 4px; cursor: pointer;">
                        ‚ùå Fechar
                    </button>
                `;

                document.body.appendChild(menu);

                // Event listeners
                menu.querySelector("#debug-extract-text").addEventListener(
                    "click",
                    async () => {
                        menu.remove();
                        try {
                            const texto = await autoExtractText();
                            if (texto) {
                                await copyToClipboardWithPrefix(texto);
                                showNotification(
                                    "üìÑ Texto extra√≠do e copiado! Cole no Perplexity (Ctrl+V)",
                                    "success",
                                );
                            } else {
                                showNotification(
                                    "‚ùå N√£o foi poss√≠vel extrair texto desta p√°gina",
                                    "error",
                                );
                            }
                        } catch (error) {
                            console.error("Erro ao extrair texto:", error);
                            showNotification(
                                "‚ùå Erro ao extrair texto: " + error.message,
                                "error",
                            );
                        }
                    },
                );

                menu.querySelector("#debug-show-api-config").addEventListener(
                    "click",
                    () => {
                        menu.remove();
                        showApiKeyConfig();
                    },
                );

                menu.querySelector("#debug-close").addEventListener(
                    "click",
                    () => {
                        menu.remove();
                    },
                );

                // Fechar ao clicar fora
                setTimeout(() => {
                    document.addEventListener(
                        "click",
                        function closeDebugMenu(e) {
                            if (!menu.contains(e.target)) {
                                menu.remove();
                                document.removeEventListener(
                                    "click",
                                    closeDebugMenu,
                                );
                            }
                        },
                    );
                }, 100);

                log("‚úÖ DEBUG MENU: Menu de debug criado");
            }

            // Fun√ß√£o auxiliar para getBoundingClientRect com fallback
            window.getCachedBoundingRect = function (element) {
                try {
                    if (
                        !element ||
                        typeof element.getBoundingClientRect !== "function"
                    ) {
                        console.warn(
                            "‚ö†Ô∏è getCachedBoundingRect: Elemento inv√°lido",
                            element,
                        );
                        return {
                            left: 0,
                            top: 0,
                            right: 0,
                            bottom: 0,
                            width: 0,
                            height: 0,
                        };
                    }
                    return element.getBoundingClientRect();
                } catch (error) {
                    console.error(
                        "‚ùå getCachedBoundingRect: Erro ao obter coordenadas",
                        error,
                    );
                    return {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0,
                        width: 0,
                        height: 0,
                    };
                }
            };

            // Fun√ß√£o de fallback para criar bot√£o flutuante (caso container n√£o seja encontrado)
            function createFloatingButton() {
                log("üéØ FLOATING BUTTON: Iniciando cria√ß√£o do bot√£o flutuante");

                // Verificar se j√° existe um bot√£o
                if (document.getElementById("sent1-auto-button")) {
                    log(
                        "‚ö†Ô∏è FLOATING BUTTON: Bot√£o flutuante j√° existe, cancelando cria√ß√£o",
                    );
                    return;
                }

                // Verificar se a p√°gina √© v√°lida para mostrar o bot√£o
                const shouldShow = shouldShowFloatingButton();
                log("üîç FLOATING BUTTON: Verifica√ß√£o de crit√©rios:", {
                    shouldShow: shouldShow,
                    url: window.location.href,
                });

                if (!shouldShow) {
                    log(
                        "‚ùå FLOATING BUTTON: P√°gina n√£o atende crit√©rios para o bot√£o flutuante, cancelando cria√ß√£o",
                    );
                    return;
                }

                log("‚úÖ FLOATING BUTTON: Criando bot√£o flutuante...");
                const button = document.createElement("button");
                button.id = "sent1-auto-button";
                button.className = "eprobe-button";
                button.innerHTML = `
 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 3px !important; vertical-align: middle;">
 <rect width="18" height="18" x="3" y="3" rx="2"/>
 <path d="m9 8 6 4-6 4Z"/>
 </svg>
 Resumir Documento
 `;

                // FOR√áAR aplica√ß√£o do margin-right no SVG ap√≥s cria√ß√£o
                setTimeout(() => {
                    const svg = button.querySelector("svg");
                    if (svg) {
                        svg.style.marginRight = "4px";
                        svg.style.setProperty(
                            "margin-right",
                            "4px",
                            "important",
                        );
                        log("‚úÖ FLOATING BUTTON: Margin-right aplicado ao SVG");
                    }
                }, 100);

                // Usar estilo customizado pr√≥prio para o bot√£o flutuante
                button.style.cssText = `
 position: fixed !important;
 top: 120px;
 right: 20px;
 z-index: 99999;
 background-color: #134377;
 border: 1px solid #134377;
 color: white;
 padding: 8px 16px;
 border-radius: 4px;
 font-family: "Roboto", -apple-system, system-ui, sans-serif;
 font-size: 14px;
 font-weight: normal;
 cursor: pointer;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 text-decoration: none;
 white-space: nowrap;
 box-shadow: 0 2px 4px rgba(0,0,0,0.2);
 transition: background-color 0.2s ease;
 `;

                // ‚ö° OTIMIZA√á√ÉO PERFORMANCE: CSS hover em vez de event listeners
                button.style.cssText += `
                transition: background-color 0.2s ease;
            `;
                button.classList.add("eprobe-button-hover");

                button.addEventListener("blur", () => {
                    button.style.backgroundColor = "#134377";
                    button.style.borderColor = "#134377";
                });

                button.addEventListener("click", async (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    log("üéØ FLOATING BUTTON: Bot√£o flutuante clicado!");
                    log("üîç FLOATING BUTTON: Debug do click");

                    // Adicionar feedback visual
                    button.style.transform = "scale(0.95)";
                    setTimeout(() => {
                        button.style.transform = "";
                    }, 150);

                    const pageType = detectPageType();
                    log(
                        "üìÑ FLOATING BUTTON: Tipo de p√°gina detectado:",
                        pageType,
                    );

                    try {
                        // L√≥gica espec√≠fica para o bot√£o flutuante
                        if (pageType === "lista_documentos") {
                            showNotification("üöÄ Abrindo documento...", "info");
                            await runFullAutomation();
                        } else if (
                            pageType === "documento_especifico" ||
                            pageType === "documento_html" ||
                            pageType === "documento_pdf"
                        ) {
                            // P√°gina de documento espec√≠fico - mostrar menu de op√ß√µes
                            log("üìã FLOATING BUTTON: Mostrando menu de op√ß√µes");

                            // Usar getBoundingClientRect diretamente em vez de getCachedBoundingRect
                            const rect = button.getBoundingClientRect();
                            log("üìê FLOATING BUTTON: Coordenadas do bot√£o:", {
                                left: rect.left,
                                bottom: rect.bottom,
                                top: rect.top,
                                right: rect.right,
                            });

                            showOptionsMenu(rect.left, rect.bottom);
                        } else {
                            // Para o bot√£o flutuante, verificar se h√° documento na p√°gina
                            const pageHTML = document.documentElement.outerHTML;
                            const hasDocumentHtml = pageHTML.includes(
                                "acessar_documento&id",
                            );
                            const hasDocumentPdf = pageHTML.includes(
                                "acessar_documento&amp",
                            );

                            log(
                                "üîç FLOATING BUTTON: Verifica√ß√£o de documento:",
                                {
                                    hasDocumentHtml: hasDocumentHtml,
                                    hasDocumentPdf: hasDocumentPdf,
                                    url: window.location.href,
                                },
                            );

                            if (hasDocumentHtml || hasDocumentPdf) {
                                // H√° documento, mas a p√°gina n√£o foi reconhecida - tratar como documento espec√≠fico
                                log(
                                    "üìÑ FLOATING BUTTON: Documento encontrado - mostrando menu",
                                );

                                const rect = button.getBoundingClientRect();
                                showOptionsMenu(rect.left, rect.bottom);
                            } else {
                                // P√°gina n√£o reconhecida - mostrar menu de debug
                                log(
                                    "‚ùì FLOATING BUTTON: P√°gina n√£o reconhecida - mostrando menu de debug",
                                );
                                showBasicDebugMenu(button);
                            }
                        }
                    } catch (error) {
                        console.error(
                            "‚ùå FLOATING BUTTON: Erro ao processar click:",
                            error,
                        );
                        showNotification("‚ùå Erro ao processar a√ß√£o", "error");
                    }
                });

                document.body.appendChild(button);
                log("‚úÖ FLOATING BUTTON: Bot√£o flutuante adicionado ao DOM");

                // Verificar se o bot√£o foi realmente adicionado
                setTimeout(() => {
                    const addedButton =
                        document.getElementById("sent1-auto-button");
                    if (addedButton) {
                        const computedStyle =
                            window.getComputedStyle(addedButton);
                        log("üîç FLOATING BUTTON: Status ap√≥s adi√ß√£o:", {
                            existe: true,
                            display: computedStyle.display,
                            visibility: computedStyle.visibility,
                            position: computedStyle.position,
                            zIndex: computedStyle.zIndex,
                            top: addedButton.style.top,
                            right: addedButton.style.right,
                            backgroundColor: computedStyle.backgroundColor,
                        });

                        // Testar se o bot√£o responde a eventos
                        addedButton.addEventListener(
                            "mouseover",
                            () => {
                                log("üñ±Ô∏è FLOATING BUTTON: Mouse over detectado");
                            },
                            { once: true },
                        );
                    } else {
                        console.error(
                            "‚ùå FLOATING BUTTON: Bot√£o n√£o encontrado ap√≥s adi√ß√£o ao DOM!",
                        );
                    }
                }, 100);

                // Verificar e prevenir sobreposi√ß√µes ap√≥s um pequeno delay
                setTimeout(() => {
                    preventElementOverlap();
                }, 100);
            }

            // Debug: verificar se o bot√£o foi criado

            // Debug avan√ßado da API com logging estruturado
            function debugApiCall(requestId, phase, data) {
                if (!debugMode) return;

                const timestamp = new Date().toISOString();
                const phaseColors = {
                    IN√çCIO: "",
                    REQUEST: "",
                    RESPONSE_HEADERS: "",
                    SUCCESS: "",
                    ERROR_DETAILS: "",
                    EXCEPTION: "",
                    TEST_START: "",
                    TEST_RESPONSE: "",
                    TEST_SUCCESS: "",
                    TEST_ERROR: "",
                };

                const icon = phaseColors[phase] || "";

                console.group(
                    `${icon} API Debug [ID: ${requestId}] - ${phase}`,
                );
                log(" Timestamp:", timestamp);

                if (phase === "REQUEST") {
                    log(" URL:", data.url);
                    log(" Model:", data.model);
                    log(" Prompt Length:", data.promptLength);
                    log(" Max Tokens:", data.maxTokens);
                } else if (phase === "RESPONSE_HEADERS") {
                    log("  Status:", data.status, data.statusText);
                    log(" Request ID:", data.requestId);
                    if (data.rateLimit) {
                        log(" Rate Limits:");
                        console.table(data.rateLimit);
                    }
                } else if (phase === "SUCCESS") {
                    log(" Response ID:", data.responseId);
                    log(" Model Used:", data.model);
                    log(" Usage:", data.usage);
                    log("üèÅ Finish Reason:", data.choices?.[0]?.finish_reason);
                    log(
                        " Response Length:",
                        data.choices?.[0]?.message?.content?.length,
                    );
                } else if (phase === "ERROR_DETAILS") {
                    log(" Status:", data.status, data.statusText);
                    logError(" Error Text:", data.errorText);
                    if (data.errorJson) {
                        logError(" Error JSON:", data.errorJson);
                    }
                } else if (phase === "EXCEPTION") {
                    logError(" Error Name:", data.errorName);
                    logError(" Error Message:", data.errorMessage);
                    logError("üìö Stack Trace:", data.errorStack);
                } else if (phase === "TEST_SUCCESS") {
                    log(" Total Models:", data.totalModels);
                    log(" GPT Models:", data.gptModels);
                    log("üè¢ Organization:", data.organization);
                    log(" Has GPT-4:", data.hasGpt4);
                } else {
                    log(" Data:", data);
                }

                console.groupEnd();

                // Salvar logs cr√≠ticos no localStorage para debug posterior
                if (phase === "ERROR_DETAILS" || phase === "EXCEPTION") {
                    const errorLogs = JSON.parse(
                        localStorage.getItem("eprobe_error_logs") || "[]",
                    );
                    errorLogs.push({
                        requestId,
                        phase,
                        timestamp,
                        data,
                    });

                    // Manter apenas os √∫ltimos 10 logs de erro
                    if (errorLogs.length > 10) {
                        errorLogs.splice(0, errorLogs.length - 10);
                    }

                    localStorage.setItem(
                        "eprobe_error_logs",
                        JSON.stringify(errorLogs),
                    );
                }
            }

            // Verificar status da API key com informa√ß√µes detalhadas
            async function testApiKey() {
                try {
                    const apiKey = await getStoredApiKey();
                    if (!apiKey) {
                        showNotification(
                            " Nenhuma API key configurada",
                            "error",
                        );
                        return false;
                    }

                    log(" Testando API key...");

                    const testId = Date.now().toString();
                    debugApiCall(testId, "TEST_START", {
                        keyPreview: apiKey.substring(0, 10) + "...",
                    });

                    const response = await fetch(
                        "https://api.perplexity.ai/chat/completions",
                        {
                            method: "POST",
                            headers: {
                                Authorization: `Bearer ${apiKey}`,
                                "Content-Type": "application/json",
                                "User-Agent": "eProbe-Extension/1.0",
                            },
                            body: JSON.stringify({
                                model: "sonar",
                                messages: [
                                    {
                                        role: "user",
                                        content: "Teste de conex√£o",
                                    },
                                ],
                                max_tokens: 10,
                            }),
                        },
                    );

                    const responseHeaders = Object.fromEntries(
                        response.headers.entries(),
                    );

                    debugApiCall(testId, "TEST_RESPONSE", {
                        status: response.status,
                        headers: responseHeaders,
                        requestId: responseHeaders["x-request-id"] || "N/A",
                    });

                    if (response.ok) {
                        const data = await response.json();

                        log(
                            " API key v√°lida! Modelo usado:",
                            data.model || "sonar",
                        );

                        debugApiCall(testId, "TEST_SUCCESS", {
                            model: data.model,
                            usage: data.usage,
                            responseContent:
                                data.choices?.[0]?.message?.content,
                        });

                        showNotification(
                            ` API key v√°lida!\nModelo: ${
                                data.model || "sonar"
                            }`,
                            "success",
                        );
                        return true;
                    } else {
                        const errorData = await response.text();
                        let errorJson = null;

                        try {
                            errorJson = JSON.parse(errorData);
                        } catch (e) {
                            log(" Erro de resposta n√£o √© JSON v√°lido");
                        }

                        debugApiCall(testId, "TEST_ERROR", {
                            status: response.status,
                            errorText: errorData,
                            errorJson: errorJson,
                        });

                        if (response.status === 401) {
                            const errorMsg =
                                errorJson?.error?.message ||
                                "API key inv√°lida ou expirada";
                            showNotification(` ${errorMsg}`, "error");
                            await removeStoredApiKey();
                        } else if (response.status === 429) {
                            const rateLimitType =
                                errorJson?.error?.type || "rate_limit_exceeded";

                            if (rateLimitType === "insufficient_quota") {
                                showNotification(
                                    " Cota da API Perplexity esgotada. Verifique em perplexity.ai/settings/api",
                                    "error",
                                );
                                await removeStoredApiKey();
                            } else {
                                showNotification(
                                    ` Rate limit atingido no teste da API`,
                                    "warning",
                                );
                            }
                        } else if (response.status === 403) {
                            showNotification(
                                " Acesso negado. Verifique cr√©ditos da conta",
                                "error",
                            );
                        } else {
                            const errorMsg =
                                errorJson?.error?.message ||
                                `Erro ${response.status}`;
                            showNotification(` ${errorMsg}`, "error");
                        }
                        return false;
                    }
                } catch (error) {
                    log(" Erro de conex√£o no teste:", error);
                    showNotification(
                        " Erro de conex√£o com Perplexity",
                        "error",
                    );
                    return false;
                }
            }

            // Mostrar modal para sele√ß√£o de m√∫ltiplos documentos relevantes
            function showDocumentSelectionModal(documentosRelevantes) {
                log(
                    " DEBUG MODAL: Recebido documentosRelevantes:",
                    documentosRelevantes,
                );
                log(" DEBUG MODAL: Detalhes de cada documento:");
                documentosRelevantes.forEach((doc, i) => {
                    log(` DOC${i + 1}:`, {
                        eventoDescricao: doc.eventoDescricao,
                        seqEvento: doc.seqEvento,
                        tipoDocumento: doc.tipoDocumento,
                        eventoData: doc.eventoData,
                    });
                });

                // üìÖ ORDENA√á√ÉO DECRESCENTE POR DATA DE ASSINATURA (mais novo em cima, mais antigo embaixo)
                const documentosOrdenados = [...documentosRelevantes].sort(
                    (a, b) => {
                        // Fun√ß√£o auxiliar para converter data brasileira DD/MM/YYYY para Date
                        const parseDataBrasileira = (dataStr) => {
                            if (!dataStr || typeof dataStr !== "string")
                                return null;

                            // Extrair data no formato DD/MM/YYYY ou DD/MM/YY
                            const match = dataStr.match(
                                /(\d{1,2})\/(\d{1,2})\/(\d{2,4})/,
                            );
                            if (!match) return null;

                            let [, dia, mes, ano] = match;

                            // Se ano tem apenas 2 d√≠gitos, assumir 20XX
                            if (ano.length === 2) {
                                ano = "20" + ano;
                            }

                            // Criar objeto Date (m√™s √© 0-indexado)
                            return new Date(
                                parseInt(ano),
                                parseInt(mes) - 1,
                                parseInt(dia),
                            );
                        };

                        const dataA = parseDataBrasileira(a.eventoData);
                        const dataB = parseDataBrasileira(b.eventoData);

                        // Se ambas as datas s√£o v√°lidas, ordenar por data (mais recente primeiro)
                        if (dataA && dataB) {
                            return dataB.getTime() - dataA.getTime();
                        }

                        // Se apenas uma data √© v√°lida, colocar a v√°lida primeiro
                        if (dataA && !dataB) return -1;
                        if (!dataA && dataB) return 1;

                        // Se nenhuma data √© v√°lida, manter ordem original por seqEvento
                        const seqA = parseInt(a.seqEvento) || 0;
                        const seqB = parseInt(b.seqEvento) || 0;
                        return seqB - seqA; // Ordem decrescente por sequ√™ncia
                    },
                );

                log(
                    "üîÑ ORDENA√á√ÉO: Documentos ordenados por data (mais novo ‚Üí mais antigo):",
                );
                documentosOrdenados.forEach((doc, i) => {
                    log(
                        `  ${i + 1}. ${doc.eventoDescricao} - ${
                            doc.eventoData || "Sem data"
                        } (Evento ${doc.seqEvento})`,
                    );
                });

                // Usar array ordenado para o resto da fun√ß√£o
                documentosRelevantes = documentosOrdenados;

                return new Promise((resolve) => {
                    // Remover modal anterior se existir
                    const existing = document.getElementById(
                        "document-selection-modal",
                    );
                    if (existing) {
                        existing.remove();
                    }

                    const modal = document.createElement("div");
                    modal.id = "document-selection-modal";
                    modal.style.cssText = `
                        position: fixed !important;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0,0,0,0.8);
                        z-index: 100010;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        backdrop-filter: blur(4px);
                        `;

                    let documentOptions = "";
                    documentosRelevantes.forEach((documento, index) => {
                        const seqEvento = documento.seqEvento
                            ? `Evento ${documento.seqEvento}`
                            : `Documento ${index + 1}`;
                        const tamanhoInfo = documento.tamanho
                            ? ` (${documento.tamanho})`
                            : "";
                        const tipoInfo =
                            documento.tipoDocumento ||
                            TIPOS_DOCUMENTO_RELEVANTE[documento.tipo]
                                ?.descricao ||
                            "DOCUMENTO";
                        const eventoDesc =
                            documento.eventoDescricao || "Documento";

                        log(` DEBUG OPTION ${index + 1}:`, {
                            seqEvento,
                            tipoInfo,
                            eventoDesc,
                            tamanhoInfo,
                            eventoMagistrado: documento.eventoMagistrado, // Debug magistrado
                            magistradoInfo: documento.magistradoInfo, // ‚úÖ NOVO: Debug magistradoInfo estruturado
                            magistradoInfoTipo: documento.magistradoInfo?.tipo, // ‚úÖ Debug espec√≠fico do tipo
                            magistradoInfoNome: documento.magistradoInfo?.nome, // ‚úÖ Debug espec√≠fico do nome
                            magistradoInfoVara: documento.magistradoInfo?.vara, // ‚úÖ Debug espec√≠fico da vara
                            original_eventoDescricao: documento.eventoDescricao,
                        });

                        documentOptions += `
                                <div style="margin-bottom: 12px; padding: 16px; border: 1px solid rgba(82, 82, 82, 0.3); border-radius: 8px; background: rgb(32, 39, 51); cursor: pointer; transition: all 0.2s ease; color: rgb(243, 246, 249);" 
                                class="document-option" data-index="${index}">
                                <div style="font-weight: 600; color: rgb(243, 246, 249); margin-bottom: 8px; display: flex; align-items: center; gap: 8px; font-size: 14px;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; color: rgb(133, 190, 255);">
                                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                                <polyline points="14,2 14,8 20,8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                                <polyline points="10,9 9,9 8,9"/>
                                </svg>
                                ${tipoInfo} - ${seqEvento}
                                </div>
                                <div style="font-size: 12px; color: rgb(136, 152, 181); margin-bottom: 6px; font-weight: 500; display: flex; align-items: center; gap: 8px;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
                                <rect width="8" height="4" x="8" y="2" rx="1" ry="1"/>
                                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                                </svg>
                                ${eventoDesc}
                                </div>
                                <div style="font-size: 12px; color: rgb(136, 152, 181); display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
                                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                                </svg>
                                Documento: ${documento.texto}${tamanhoInfo}
                                </div>${
                                    // ‚úÖ DEBUG: Log direto no modal para diagnosticar
                                    console.log(
                                        `üîç MODAL DEBUG ${index}: magistradoInfo =`,
                                        documento.magistradoInfo,
                                        `eventoMagistrado =`,
                                        documento.eventoMagistrado,
                                    ) ||
                                    // ‚úÖ CONDI√á√ÉO FLEX√çVEL: Aceitar qualquer magistradoInfo com nome
                                    (documento.magistradoInfo &&
                                        documento.magistradoInfo.nome)
                                        ? `
                                <div style="font-size: 12px; color: rgb(136, 152, 181); opacity: 0.9; display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
                                <path d="M11.5 15H7a4 4 0 0 0-4 4v2"/>
                                <path d="M21.378 16.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a .5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/>
                                <circle cx="10" cy="7" r="4"/>
                                </svg>
                                ${
                                    documento.magistradoInfo.tipo?.toLowerCase() ===
                                    "magistrado"
                                        ? "Magistrado(a)"
                                        : documento.magistradoInfo.tipo?.toLowerCase() ===
                                            "advogado"
                                          ? "Advogado(a)"
                                          : "Usu√°rio"
                                }: ${documento.magistradoInfo.nome}
                                </div>${
                                    // Mostrar vara apenas se existir
                                    documento.magistradoInfo.vara
                                        ? `
            <div style="font-size: 12px; color: rgb(136, 152, 181); opacity: 0.9; display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
            <path d="M10 18v-7"/>
            <path d="M11.12 2.198a2 2 0 0 1 1.76.006l7.866 3.847c.476.233.31.949-.22.949H3.474c-.53 0-.695-.716-.22-.949z"/>
            <path d="M14 18v-7"/>
            <path d="M18 18v-7"/>
            <path d="M3 22h18"/>
            <path d="M6 18v-7"/>
            </svg>
            ${documento.magistradoInfo.vara}
            </div>`
                                        : ""
                                }`
                                        : // FALLBACK: Se n√£o h√° dados estruturados mas h√° eventoMagistrado simples
                                          documento.eventoMagistrado
                                          ? `
            <div style="font-size: 12px; color: rgb(136, 152, 181); opacity: 0.9; display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
            <path d="M11.5 15H7a4 4 0 0 0-4 4v2"/>
            <path d="M21.378 16.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/>
            <circle cx="10" cy="7" r="4"/>
            </svg>
            ${documento.eventoMagistrado}
            </div>`
                                          : ""
                                }${
                                    documento.eventoData
                                        ? `
            <div style="font-size: 12px; color: rgb(136, 152, 181); opacity: 0.9; display: flex; align-items: center; gap: 8px;">
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0;">
            <path d="M15.707 21.293a1 1 0 0 1-1.414 0l-1.586-1.586a1 1 0 0 1 0-1.414l5.586-5.586a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 1 0 1.414z"/>
            <path d="m18 13-1.375-6.874a1 1 0 0 0-.746-.776L3.235 2.028a1 1 0 0 0-1.207 1.207L5.35 15.879a1 1 0 0 0 .776.746L13 18"/>
            <path d="m2.3 2.3 7.286 7.286"/>
            <circle cx="11" cy="11" r="2"/>
            </svg>
            Assinado em ${documento.eventoData}
            </div>`
                                        : ""
                                }
            </div>
            `;
                    });

                    modal.innerHTML = `
                                <div style="background: rgb(19, 67, 119); border-radius: 8px; padding: 24px; max-width: 620px; width: 90%; max-height: 80%; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.5); border: 1px solid rgba(82, 82, 82, 0.3);">
                                <div style="margin-bottom: 20px; text-align: center; border-bottom: 1px solid rgba(82, 82, 82, 0.3); padding-bottom: 16px;">
                                <h2 style="margin: 0; color: rgb(243, 246, 249); font-size: 18px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 10px; letter-spacing: -0.025em;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: rgb(133, 190, 255);">
                                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                                <polyline points="14,2 14,8 20,8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                                <polyline points="10,9 9,9 8,9"/>
                                </svg>
                                M√∫ltiplos Documentos Encontrados
                                </h2>
                                <p style="margin: 8px 0 0 0; color: rgb(243, 246, 249); font-size: 13px; font-weight: 400;">
                                Foram encontrados ${documentosRelevantes.length} documentos relevantes neste processo. Selecione qual deseja processar:
                                </p>
                                </div>
                                
                                <div id="document-options" style="margin-bottom: 20px;">
                                ${documentOptions}
                                </div>

                                <div style="text-align: center; padding-top: 16px; border-top: 1px solid rgba(82, 82, 82, 0.3);">
                                <button id="cancel-selection" style="background: rgb(32, 39, 51); color: rgb(243, 246, 249); border: 1px solid rgba(82, 82, 82, 0.5); padding: 12px 16px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 14px; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s ease; min-height: 44px;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="m18 6-12 12"/>
                                <path d="m6 6 12 12"/>
                                </svg>
                                Cancelar
                                </button>
                                </div>
                                </div>
                                `;

                    document.body.appendChild(modal);

                    // Adicionar eventos de clique nas op√ß√µes
                    modal
                        .querySelectorAll(".document-option")
                        .forEach((option, index) => {
                            option.addEventListener(
                                "mouseover",
                                () => {
                                    option.style.borderColor =
                                        "rgba(19, 67, 119, 0.6)";
                                    option.style.background = "rgb(47, 52, 61)";
                                    option.style.transform = "translateY(-1px)";
                                    option.style.boxShadow =
                                        "0 4px 12px rgba(19, 67, 119, 0.25)";
                                },
                                { passive: true },
                            );

                            option.addEventListener(
                                "mouseout",
                                () => {
                                    option.style.borderColor =
                                        "rgba(82, 82, 82, 0.3)";
                                    option.style.background = "rgb(32, 39, 51)";
                                    option.style.transform = "translateY(0)";
                                    option.style.boxShadow = "none";
                                },
                                { passive: true },
                            );

                            option.addEventListener("click", () => {
                                const selectedIndex = parseInt(
                                    option.getAttribute("data-index"),
                                );
                                const selectedDocument =
                                    documentosRelevantes[selectedIndex];

                                log(
                                    ` Documento selecionado: ${selectedDocument.eventoDescricao} - Evento ${selectedDocument.seqEvento}`,
                                );
                                showNotification(
                                    ` Documento selecionado: ${selectedDocument.eventoDescricao}`,
                                    "success",
                                );

                                modal.remove();
                                resolve(selectedDocument);
                            });
                        });

                    // Evento do bot√£o cancelar
                    const cancelBtn = modal.querySelector("#cancel-selection");

                    // Adicionar hover vermelho no bot√£o cancelar
                    cancelBtn.addEventListener(
                        "mouseenter",
                        () => {
                            cancelBtn.style.backgroundColor = "#91433d";
                            cancelBtn.style.borderColor = "#91433d";
                        },
                        { passive: true },
                    );

                    cancelBtn.addEventListener(
                        "mouseleave",
                        () => {
                            cancelBtn.style.backgroundColor = "rgb(32, 39, 51)";
                            cancelBtn.style.borderColor =
                                "rgba(82, 82, 82, 0.5)";
                        },
                        { passive: true },
                    );

                    cancelBtn.addEventListener("click", () => {
                        modal.remove();
                        resolve(null);
                    });

                    modal.addEventListener("click", (e) => {
                        if (e.target === modal) {
                            modal.remove();
                            resolve(null);
                        }
                    });
                });
            }

            // Interface melhorada para configura√ß√£o da API key
            async function showApiKeyConfig() {
                const existing = document.getElementById("api-key-config");
                if (existing) {
                    existing.remove();
                    return;
                }

                const currentKey = localStorage.getItem("perplexity_api_key");

                const modal = document.createElement("div");
                modal.id = "api-key-config";
                modal.className = "eprobe-modal";
                modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 100001;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
            `;

                modal.innerHTML = `
            <div style="background: #134377; border-radius: 12px; padding: 32px; max-width: 560px; width: 90%; box-shadow: 0 12px 40px rgba(0,0,0,0.6); border: 1px solid rgba(255, 255, 255, 0.1);">
            <div style="margin-bottom: 24px; text-align: center; border-bottom: 1px solid rgba(255, 255, 255, 0.15); padding-bottom: 20px;">
            <h2 style="margin: 0; color: rgb(255, 255, 255); font-size: 20px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 12px; letter-spacing: -0.025em;">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgb(133, 190, 255)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="16" r="1"/>
            <rect x="3" y="10" width="18" height="12" rx="2"/>
            <path d="M7 10V7a5 5 0 0 1 10 0v3"/>
            </svg>
            Configurar API Key do Perplexity
            </h2>
            </div>
            
            <div style="margin-bottom: 24px; padding: 20px; background: rgba(32, 39, 51, 0.6); border-radius: 10px; font-size: 14px; line-height: 1.6; color: rgb(255, 255, 255); border: 1px solid rgba(255, 255, 255, 0.1);">
            <div style="margin-bottom: 12px;">
            <strong style="color: rgb(133, 190, 255); font-size: 15px;">Como obter sua API Key do Perplexity:</strong>
            </div>
            <div style="padding-left: 8px; color: rgb(226, 232, 240);">
            <div style="margin-bottom: 8px;">1. Acesse: <a href="https://www.perplexity.ai/settings/api" target="_blank" style="color: rgb(133, 190, 255); text-decoration: underline; font-weight: 500;">www.perplexity.ai/settings/api</a></div>
            <div style="margin-bottom: 8px;">2. Fa√ßa login na sua conta Perplexity</div>
            <div style="margin-bottom: 8px;">3. Clique em "Generate" para criar uma nova chave</div>
            <div>4. Copie a chave e cole abaixo</div>
            </div>
            </div>

            <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600; color: rgb(255, 255, 255); font-size: 14px;">API Key:</label>
            <input type="password" id="api-key-input" placeholder="pplx-..." style="width: 100%; padding: 12px 16px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; font-family: 'Roboto', monospace, sans-serif; background: rgba(32, 39, 51, 0.5); color: rgb(255, 255, 255); font-size: 14px; transition: all 0.2s ease; box-sizing: border-box;" value="${
                currentKey || ""
            }" />
            </div>

            <div style="margin-bottom: 24px; padding: 16px; background: rgba(251, 191, 36, 0.15); border: 1px solid rgba(251, 191, 36, 0.4); border-radius: 10px; font-size: 13px; display: flex; align-items: flex-start; gap: 12px; color: rgb(254, 240, 138);">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
            <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
            <path d="M12 9v4"/>
            <path d="m12 17 .01 0"/>
            </svg>
            <span style="line-height: 1.5;"><strong>Privacidade:</strong> Sua API Key √© armazenada apenas localmente no seu navegador e n√£o √© compartilhada.</span>
            </div>

            <div style="text-align: center; display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
            <button id="save-key" style="background: rgb(133, 190, 255); color: #134377; border: 1px solid rgb(133, 190, 255); padding: 14px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s ease; min-width: 140px; justify-content: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="20,6 9,17 4,12"/>
            </svg>
            Salvar e Testar
            </button>
            <button id="remove-key" style="background: rgb(145, 67, 61); color: white; border: 1px solid rgb(145, 67, 61); padding: 14px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s ease; min-width: 120px; justify-content: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="3,6 5,6 21,6"/>
            <path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"/>
            </svg>
            Remover
            </button>
            <button id="cancel-config" style="background: rgba(255, 255, 255, 0.1); color: rgb(255, 255, 255); border: 1px solid rgba(255, 255, 255, 0.2); padding: 14px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s ease; min-width: 100px; justify-content: center;">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="m18 6-12 12"/>
            <path d="m6 6 12 12"/>
            </svg>
            Cancelar
            </button>
            </div>
            </div>
            `;

                document.body.appendChild(modal);

                const input = modal.querySelector("#api-key-input");
                const saveBtn = modal.querySelector("#save-key");
                const removeBtn = modal.querySelector("#remove-key");
                const cancelBtn = modal.querySelector("#cancel-config");

                // Adicionar eventos de focus/blur para o input
                input.addEventListener("focus", () => {
                    input.style.borderColor = "rgb(19, 67, 119)";
                    input.style.boxShadow = "0 0 0 3px rgba(19, 67, 119, 0.1)";
                });

                input.addEventListener("blur", () => {
                    input.style.borderColor = "rgba(82, 82, 82, 0.5)";
                    input.style.boxShadow = "none";
                });

                input.focus();

                saveBtn.addEventListener("click", async () => {
                    const newKey = input.value.trim();

                    if (!newKey) {
                        showNotification("Digite uma API key", "error");
                        return;
                    }

                    if (!(await validateApiKey(newKey))) {
                        showNotification(
                            "API key inv√°lida. Deve come√ßar com 'pplx-'",
                            "error",
                        );
                        return;
                    }

                    try {
                        await storeApiKey(newKey);
                        modal.remove();

                        showNotification("Testando API key...", "info");

                        const isValid = await testApiKey();
                        if (isValid) {
                            showNotification(
                                "API key configurada e validada!",
                                "success",
                            );
                        } else {
                            showNotification(
                                "API key salva, mas pode n√£o estar funcionando",
                                "warning",
                            );
                        }
                    } catch (error) {
                        showNotification(`Erro: ${error.message}`, "error");
                    }
                });

                removeBtn.addEventListener("click", async () => {
                    await removeStoredApiKey();
                    modal.remove();
                    showNotification("API key removida!", "info");
                });

                // Adicionar eventos de hover para os bot√µes
                saveBtn.addEventListener(
                    "mouseenter",
                    () => {
                        saveBtn.style.backgroundColor = "rgb(107, 170, 255)";
                        saveBtn.style.color = "#134377";
                        saveBtn.style.transform = "translateY(-1px)";
                    },
                    { passive: true },
                );

                saveBtn.addEventListener(
                    "mouseleave",
                    () => {
                        saveBtn.style.backgroundColor = "rgb(133, 190, 255)";
                        saveBtn.style.color = "#134377";
                        saveBtn.style.transform = "translateY(0)";
                    },
                    { passive: true },
                );

                removeBtn.addEventListener(
                    "mouseenter",
                    () => {
                        removeBtn.style.backgroundColor = "rgb(120, 55, 50)";
                        removeBtn.style.transform = "translateY(-1px)";
                    },
                    { passive: true },
                );

                removeBtn.addEventListener(
                    "mouseleave",
                    () => {
                        removeBtn.style.backgroundColor = "rgb(145, 67, 61)";
                        removeBtn.style.transform = "translateY(0)";
                    },
                    { passive: true },
                );

                // Adicionar hover para o bot√£o cancelar
                cancelBtn.addEventListener(
                    "mouseenter",
                    () => {
                        cancelBtn.style.backgroundColor =
                            "rgba(255, 255, 255, 0.15)";
                        cancelBtn.style.borderColor =
                            "rgba(255, 255, 255, 0.3)";
                        cancelBtn.style.transform = "translateY(-1px)";
                    },
                    { passive: true },
                );

                cancelBtn.addEventListener(
                    "mouseleave",
                    () => {
                        cancelBtn.style.backgroundColor =
                            "rgba(255, 255, 255, 0.1)";
                        cancelBtn.style.borderColor =
                            "rgba(255, 255, 255, 0.2)";
                        cancelBtn.style.transform = "translateY(0)";
                    },
                    { passive: true },
                );

                cancelBtn.addEventListener("click", () => {
                    modal.remove();
                });

                modal.addEventListener("click", (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });

                input.addEventListener("keypress", (e) => {
                    if (e.key === "Enter") {
                        saveBtn.click();
                    }
                });
            }

            // Fun√ß√£o para visualizar logs de erro
            function showErrorLogs() {
                const logs = JSON.parse(
                    localStorage.getItem("eprobe_error_logs") || "[]",
                );

                if (logs.length === 0) {
                    showNotification("Nenhum log de erro encontrado", "info");
                    return;
                }

                const modal = document.createElement("div");
                modal.className = "eprobe-modal";
                modal.style.cssText = `
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background: rgba(0,0,0,0.8);
 z-index: 100002;
 display: flex;
 align-items: center;
 justify-content: center;
 backdrop-filter: blur(4px);
 `;

                modal.innerHTML = `
 <div style="background: rgb(19, 67, 119); border-radius: 8px; padding: 24px; max-width: 80%; max-height: 80%; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.5); border: 1px solid rgba(82, 82, 82, 0.3);">
 <div style="margin-bottom: 20px; text-align: center; border-bottom: 1px solid rgba(82, 82, 82, 0.3); padding-bottom: 16px;">
 <h2 style="margin: 0; color: rgb(243, 246, 249); font-size: 18px; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 10px; letter-spacing: -0.025em;">
 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: rgb(19, 67, 119);">
 <circle cx="11" cy="11" r="8"/>
 <path d="m21 21-4.35-4.35"/>
 </svg>
 Logs de Erro da API
 </h2>
 <button id="clear-logs" style="background: rgb(220, 38, 38); color: white; border: 1px solid rgb(220, 38, 38); padding: 8px 12px; border-radius: 6px; cursor: pointer; margin-top: 12px; display: inline-flex; align-items: center; gap: 6px; font-size: 12px; font-weight: 500; transition: all 0.2s ease;">
 <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <polyline points="3,6 5,6 21,6"/>
 <path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"/>
 </svg>
 Limpar Logs
 </button>
 </div>
 <div style="font-family: 'Roboto', monospace, sans-serif; font-size: 12px; line-height: 1.4; color: rgb(243, 246, 249);">
 ${logs
     .map(
         (log, i) => `
 <div style="margin-bottom: 16px; padding: 12px; border: 1px solid rgba(82, 82, 82, 0.3); border-radius: 8px; background: rgb(32, 39, 51);">
 <strong style="color: rgb(19, 67, 119);">Log ${i + 1} - ${
     log.timestamp
 }</strong><br>
 <strong style="color: rgb(136, 152, 181);">Request ID:</strong> <span style="color: rgb(243, 246, 249);">${
     log.requestId
 }</span><br>
 <strong style="color: rgb(136, 152, 181);">Phase:</strong> <span style="color: rgb(243, 246, 249);">${
     log.phase
 }</span><br>
 <strong style="color: rgb(136, 152, 181);">Data:</strong><br>
 <pre style="background: rgb(18, 26, 39); padding: 10px; border-radius: 6px; overflow-x: auto; white-space: pre-wrap; color: rgb(243, 246, 249); border: 1px solid rgba(82, 82, 82, 0.2); margin-top: 8px;">${JSON.stringify(
     log.data,
     null,
     2,
 )}</pre>
 </div>
 `,
     )
     .join("")}
 </div>
 <div style="text-align: center; margin-top: 20px; padding-top: 16px; border-top: 1px solid rgba(82, 82, 82, 0.3);">
 <button id="close-logs" style="background: rgb(32, 39, 51); color: rgb(243, 246, 249); border: 1px solid rgba(82, 82, 82, 0.5); padding: 12px 16px; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 14px; display: inline-flex; align-items: center; gap: 8px; transition: all 0.2s ease;">
 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
 <path d="m18 6-12 12"/>
 <path d="m6 6 12 12"/>
 </svg>
 Fechar
 </button>
 </div>
 </div>
 `;

                document.body.appendChild(modal);

                modal
                    .querySelector("#close-logs")
                    .addEventListener("click", () => {
                        modal.remove();
                    });

                modal
                    .querySelector("#clear-logs")
                    .addEventListener("click", () => {
                        localStorage.removeItem("eprobe_error_logs");
                        modal.remove();
                        showNotification("Logs de erro limpos", "info");
                    });

                modal.addEventListener("click", (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            // Mostrar informa√ß√µes sobre quota da API
            function showApiQuotaInfo() {
                const modal = document.createElement("div");
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    z-index: 100003;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    `;

                modal.innerHTML = `
                    <div style="background: white; border-radius: 10px; padding: 30px; max-width: 500px; width: 90%; box-shadow: 0 10px 25px rgba(0,0,0,0.3);">
                    <div style="margin-bottom: 20px; text-align: center;">
                    <h2 style="margin: 0; color: #dc3545; font-size: 20px;"> Cr√©ditos da API Esgotados</h2>
                    </div>
                    
                    <div style="margin-bottom: 20px; font-size: 14px; line-height: 1.6;">
                    <p><strong>Sua API key do Perplexity n√£o possui cr√©ditos suficientes.</strong></p>
                    
                    <p><strong>Para resolver:</strong></p>
                    <ol>
                    <li>Acesse: <a href="https://www.perplexity.ai/settings/api" target="_blank" style="color: #134377;">perplexity.ai/settings/api</a></li>
                    <li>Verifique seus cr√©ditos e limites</li>
                    <li>Se necess√°rio, adicione cr√©ditos √† sua conta</li>
                    <li>Ou aguarde a renova√ß√£o dos cr√©ditos</li>
                    </ol>
                    
                    <p><strong>Alternativa:</strong> Use o m√©todo manual que copia o texto para voc√™ colar em Perplexity web.</p>
                    </div>

                    <div style="text-align: center;">
                    <button id="open-billing" style="background: #134377; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin-right: 10px; cursor: pointer; font-weight: bold;">
                    Abrir Configura√ß√µes
                    </button>
                    <button id="config-new-key" style="background: #134377; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin-right: 10px; cursor: pointer; font-weight: bold;">
                    Nova API Key
                    </button>
                    <button id="close-quota-info" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">
                    Fechar
                    </button>
                    </div>
                    </div>
                    `;

                document.body.appendChild(modal);

                modal
                    .querySelector("#open-billing")
                    .addEventListener("click", () => {
                        window.open(
                            "https://www.perplexity.ai/settings/api",
                            "_blank",
                        );
                        modal.remove();
                    });

                modal
                    .querySelector("#config-new-key")
                    .addEventListener("click", () => {
                        modal.remove();
                        showApiKeyConfig();
                    });

                modal
                    .querySelector("#close-quota-info")
                    .addEventListener("click", () => {
                        modal.remove();
                    });

                modal.addEventListener("click", (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }

            // Mostrar op√ß√µes de processamento para p√°gina de lista com m√∫ltiplas senten√ßas
            async function showSentenceProcessingOptions() {
                const documentosRelevantes = findDocumentosRelevantes();

                if (documentosRelevantes.length === 0) {
                    showNotification("Nenhuma senten√ßa encontrada", "error");
                    return;
                }

                if (documentosRelevantes.length === 1) {
                    // Apenas uma senten√ßa, abrir diretamente
                    await autoOpenDocumentoRelevante();
                    return;
                }

                // M√∫ltiplas senten√ßas, mostrar op√ß√µes
                const selectedDocument =
                    await showDocumentSelectionModal(documentosRelevantes);

                if (!selectedDocument) {
                    return; // Usu√°rio cancelou
                }

                // Perguntar o que fazer com o documento selecionado
                const processChoice = await showDocumentProcessingModal();

                if (processChoice) {
                    // Abrir o documento selecionado
                    log(
                        " Abrindo documento selecionado:",
                        selectedDocument.href,
                    );
                    showNotification(
                        " Abrindo documento selecionado...",
                        "info",
                    );
                    window.open(selectedDocument.href, "_blank");
                } else {
                    // Processar diretamente via API (funcionalidade experimental)
                    showNotification(
                        " Processamento direto via API ainda n√£o implementado. Abrindo documento...",
                        "warning",
                    );
                    window.open(selectedDocument.href, "_blank");
                }
            }

            // Debug completo da estrutura HTML ao redor do link SENT1
            function debugEventStructure(linkElement) {
                log(" === DEBUG ESTRUTURA HTML ===");

                // 1. Informa√ß√µes sobre o pr√≥prio link
                log(" Link SENT1:");
                log(` Texto: "${linkElement.textContent.trim()}"`);
                log(` Classes: "${linkElement.className}"`);
                log(` Atributos:`, {
                    href: linkElement.getAttribute("href"),
                    onclick: linkElement.getAttribute("onclick"),
                    onmouseover: linkElement.getAttribute("onmouseover"),
                    "data-nome": linkElement.getAttribute("data-nome"),
                    "data-id": linkElement.getAttribute("data-id"),
                });

                // 2. Analisar a linha (tr) que cont√©m o link
                const currentRow = linkElement.closest("tr");
                if (currentRow) {
                    log(" Linha atual (TR):");
                    log(` Classes da linha: "${currentRow.className}"`);

                    const cells = currentRow.querySelectorAll("td");
                    log(` Total de c√©lulas: ${cells.length}`);

                    cells.forEach((cell, index) => {
                        const text = cell.textContent.trim();
                        log(
                            ` C√©lula ${index}: "${text}" (classes: "${cell.className}")`,
                        );

                        // Verificar se tem elementos filhos interessantes
                        const labels = cell.querySelectorAll("label");
                        const spans = cell.querySelectorAll("span");
                        const divs = cell.querySelectorAll("div");

                        if (labels.length > 0) {
                            labels.forEach((label, i) => {
                                log(
                                    ` Label ${i}: "${label.textContent.trim()}" (classes: "${
                                        label.className
                                    }")`,
                                );
                            });
                        }
                        if (spans.length > 0) {
                            spans.forEach((span, i) => {
                                log(
                                    ` Span ${i}: "${span.textContent.trim()}" (classes: "${
                                        span.className
                                    }")`,
                                );
                            });
                        }
                        if (divs.length > 0) {
                            divs.forEach((div, i) => {
                                log(
                                    ` Div ${i}: "${div.textContent.trim()}" (classes: "${
                                        div.className
                                    }")`,
                                );
                            });
                        }
                    });
                }

                // 3. Analisar linhas anteriores
                log(" Linhas anteriores:");
                let prevRow = currentRow?.previousElementSibling;
                let rowCount = 0;
                while (prevRow && rowCount < 3) {
                    rowCount++;
                    const prevCells = prevRow.querySelectorAll("td");
                    log(
                        ` Linha anterior ${rowCount}: ${prevCells.length} c√©lulas`,
                    );

                    prevCells.forEach((cell, index) => {
                        const text = cell.textContent.trim();
                        if (text.length > 10) {
                            log(
                                ` C√©lula ${index}: "${text.substring(
                                    0,
                                    100,
                                )}..."`,
                            );
                        }
                    });

                    prevRow = prevRow.previousElementSibling;
                }

                // 4. Analisar a tabela completa
                const table = linkElement.closest("table");
                if (table) {
                    log(" Tabela:");
                    log(` Classes da tabela: "${table.className}"`);
                    log(` ID da tabela: "${table.id}"`);

                    // Procurar por cabe√ßalhos
                    const headers = table.querySelectorAll("th");
                    if (headers.length > 0) {
                        log(" Cabe√ßalhos encontrados:");
                        headers.forEach((header, index) => {
                            log(
                                ` Header ${index}: "${header.textContent.trim()}"`,
                            );
                        });
                    }
                }

                log(" === FIM DEBUG ESTRUTURA ===");
            }

            // Observador de mudan√ßas na p√°gina - VERS√ÉO ULTRA-ROBUSTA
            function setupPageObserver() {
                let lastUrl = window.location.href;
                let isProcessing = false;
                let processingTimeout = null;

                // Observador super otimizado com debouncing
                const observer = new MutationObserver((mutations) => {
                    // Throttling aprimorado: cancelar timeout anterior se existir
                    if (processingTimeout) {
                        clearTimeout(processingTimeout);
                    }

                    if (isProcessing) return;
                    isProcessing = true;

                    // Usar requestIdleCallback se dispon√≠vel, sen√£o requestAnimationFrame
                    const scheduleWork = (callback) => {
                        if (window.requestIdleCallback) {
                            requestIdleCallback(callback, { timeout: 100 });
                        } else {
                            requestAnimationFrame(callback);
                        }
                    };

                    scheduleWork(() => {
                        const currentUrl = window.location.href;

                        // Verificar se a URL mudou (navega√ß√£o SPA)
                        if (currentUrl !== lastUrl) {
                            log("üåê NAVEGA√á√ÉO: URL mudou para:", currentUrl);
                            lastUrl = currentUrl;

                            // Reset contador de tentativas para nova p√°gina
                            buttonCreationAttempts = 0;

                            // Garantir que o bot√£o existe ap√≥s navega√ß√£o
                            setTimeout(() => {
                                ensureButtonExists();
                            }, 300);
                        }

                        // Verificar se bot√£o foi removido com delay otimizado
                        processingTimeout = setTimeout(() => {
                            // Usar sistema robusto para verificar e criar bot√£o
                            ensureButtonExists();

                            // Reset processing flag
                            isProcessing = false;
                            processingTimeout = null;
                        }, 400);
                    });
                });

                // Configurar observador com configura√ß√£o ultra-otimizada
                observer.observe(document.body, {
                    childList: true,
                    subtree: false, // Evitar observa√ß√£o profunda
                    attributes: false, // N√£o observar mudan√ßas de atributos
                    characterData: false, // N√£o observar mudan√ßas de texto
                    attributeOldValue: false,
                    characterDataOldValue: false,
                });

                log(
                    "‚úÖ PAGE OBSERVER: Configurado com sistema robusto de bot√£o",
                );
            }

            // Inicializa√ß√£o
            // Inicializa√ß√£o - REABILITADA cria√ß√£o de bot√µes com prote√ß√£o da navbar
            function init() {
                log(" Iniciando content script automatizado");
                log(" Resumir Documento: Script iniciado");

                // Configurar observador de p√°gina (VERS√ÉO REABILITADA - cria√ß√£o de bot√µes segura)
                setupPageObserver();

                log(
                    "‚ÑπÔ∏è INIT: Cria√ß√£o autom√°tica de bot√µes REABILITADA de forma segura",
                );

                // Criar bot√£o inicial com sistema robusto
                setTimeout(() => {
                    ensureButtonExists();
                }, 400);

                // Segunda tentativa (caso a primeira falhe)
                setTimeout(() => {
                    ensureButtonExists();
                }, 1000);

                // Terceira tentativa (para p√°ginas que demoram para carregar)
                setTimeout(() => {
                    ensureButtonExists();
                }, 2000);

                // ‚úÖ VERIFICA√á√ÉO: Evitar loop infinito - s√≥ detectar se n√£o foi processado
                processoAtual = obterNumeroProcesso(); // Obter processo atual antes das verifica√ß√µes
                if (processoAtual && processoJaFoiProcessado(processoAtual)) {
                    log(
                        `üîê SKIP: Processo ${processoAtual} j√° foi processado nesta sess√£o`,
                    );
                    return;
                }

                // Detec√ß√£o de data da sess√£o otimizada
                setTimeout(() => {
                    if (
                        !processoAtual ||
                        !processoJaFoiProcessado(processoAtual)
                    ) {
                        log(
                            "üîç Tentando detectar data da sess√£o automaticamente...",
                        );
                        if (
                            window.SENT1_AUTO &&
                            window.SENT1_AUTO.detectarCardSessaoSimplificado
                        ) {
                            window.SENT1_AUTO.detectarCardSessaoSimplificado();
                        }
                    }
                }, 500); // Reduzido de 800ms para 500ms

                // Segunda tentativa de detec√ß√£o otimizada
                setTimeout(() => {
                    if (
                        !hasDataSessaoPautado() &&
                        (!processoAtual ||
                            !processoJaFoiProcessado(processoAtual))
                    ) {
                        log(
                            "üîç Segunda tentativa de detec√ß√£o da data da sess√£o...",
                        );
                        if (
                            window.SENT1_AUTO &&
                            window.SENT1_AUTO.detectarCardSessaoSimplificado
                        ) {
                            window.SENT1_AUTO.detectarCardSessaoSimplificado();
                        }
                    }
                }, 1500); // Reduzido de 2000ms para 1500ms

                // Ô∏è INTEGRA√á√ÉO AUTOM√ÅTICA DESABILITADA - Prevenindo logout por excesso de requisi√ß√µes
                setTimeout(async () => {
                    if (hasDataSessaoPautado()) {
                        log(
                            "‚ÑπÔ∏è CRUZAMENTO: Modo autom√°tico desabilitado para prevenir logout",
                        );
                        log(
                            "üí° Use window.SENT1_AUTO.cruzarDadosDataSessao() para busca manual",
                        );
                    }
                }, 6000);

                // ‚ö†Ô∏è TENTATIVA FINAL TAMB√âM DESABILITADA
                setTimeout(async () => {
                    if (
                        hasDataSessaoPautado() &&
                        !hasDadosCompletosSessionJulgamento()
                    ) {
                        log(
                            "‚ÑπÔ∏è CRUZAMENTO: Tentativa final desabilitada - use modo manual",
                        );
                        log(
                            "üîß Execute: window.SENT1_AUTO.debugPaginaSessoes() para investigar",
                        );
                    }
                }, 10000);

                // üìã DETEC√á√ÉO E PROCESSAMENTO DA P√ÅGINA DE LOCALIZADORES (MANTIDA - n√£o interfere na navbar)
                setTimeout(() => {
                    detectarPaginaLocalizadores();
                    adicionarFiltroBuscaLocalizador();
                }, 1000);
            }

            // Fun√ß√£o de debug para verificar status dos localizadores
            function debugLocalizadores() {
                const currentUrl = window.location.href;
                const isLocalizadoresPage = currentUrl.includes(
                    "acao=usuario_tipo_monitoramento_localizador_listar",
                );
                const tabela = document.querySelector(
                    'table.infraTable[summary*="Localizadores"]',
                );
                const toolbar = document.getElementById(
                    "eprobe-separadores-toolbar",
                );

                console.log("üêõ DEBUG LOCALIZADORES:", {
                    url: currentUrl,
                    isLocalizadoresPage: isLocalizadoresPage,
                    tabelaEncontrada: !!tabela,
                    toolbarCriado: !!toolbar,
                    urlPattern:
                        "acao=usuario_tipo_monitoramento_localizador_listar",
                    numeroLinhas: tabela
                        ? tabela.querySelectorAll(
                              "tbody tr:not(.eprobe-divisor-linha)",
                          ).length
                        : 0,
                });

                if (!isLocalizadoresPage) {
                    console.log("‚ö†Ô∏è N√£o est√° na p√°gina de localizadores");
                } else {
                    console.log("‚úÖ Est√° na p√°gina de localizadores");
                    if (tabela) {
                        console.log(
                            "‚úÖ Tabela encontrada - for√ßando reprocessamento",
                        );
                        // For√ßar re-processamento
                        processarTabelaLocalizadores();
                    } else {
                        console.log("‚ùå Tabela n√£o encontrada");
                    }
                }

                return {
                    isLocalizadoresPage,
                    tabelaEncontrada: !!tabela,
                    toolbarCriado: !!toolbar,
                };
            }

            // üß™ Fun√ß√£o de teste espec√≠fica para separadores
            function testarSeparadoresHover() {
                log(
                    "üß™ TESTE SEPARADORES: Iniciando teste do hover dos bot√µes...",
                );

                const separadores = document.querySelectorAll(
                    ".eprobe-container-hover",
                );
                log(
                    `üìä SEPARADORES: Encontrados ${separadores.length} separadores`,
                );

                separadores.forEach((separador, index) => {
                    const botaoRemover = separador.querySelector(
                        ".eprobe-remove-button",
                    );
                    const titulo = separador.querySelector(
                        'span[contentEditable="true"]',
                    );

                    log(`üîç SEPARADOR ${index + 1}:`, {
                        temBotao: !!botaoRemover,
                        temTitulo: !!titulo,
                        tituloTexto: titulo?.textContent,
                        botaoOpacidade: botaoRemover?.style.opacity,
                        botaoOpacidadeComputada: botaoRemover
                            ? window.getComputedStyle(botaoRemover).opacity
                            : "N/A",
                        posicionamento: {
                            position: botaoRemover?.style.position,
                            marginLeft: botaoRemover?.style.marginLeft,
                            display: botaoRemover?.style.display,
                        },
                    });
                });

                // Simular hover no primeiro separador para teste
                if (separadores.length > 0) {
                    const primeiroSeparador = separadores[0];
                    log("‚ú® TESTE: Simulando hover no primeiro separador...");

                    // Trigger mouseenter event
                    const event = new MouseEvent("mouseenter", {
                        bubbles: true,
                    });
                    primeiroSeparador.dispatchEvent(event);

                    setTimeout(() => {
                        const botao = primeiroSeparador.querySelector(
                            ".eprobe-remove-button",
                        );
                        log(
                            `üìä AP√ìS HOVER: Bot√£o opacidade inline = ${
                                botao?.style.opacity || "n√£o definido"
                            }`,
                        );
                        log(
                            `üìä AP√ìS HOVER: Bot√£o opacidade computada = ${
                                botao
                                    ? window.getComputedStyle(botao).opacity
                                    : "N/A"
                            }`,
                        );

                        // Trigger mouseleave para voltar ao normal
                        const leaveEvent = new MouseEvent("mouseleave", {
                            bubbles: true,
                        });
                        primeiroSeparador.dispatchEvent(leaveEvent);
                    }, 100);
                }

                return separadores.length;
            }

            // üîß Fun√ß√£o para for√ßar corre√ß√£o da visibilidade dos bot√µes de remover
            function corrigirVisibilidadeBotoes() {
                log("üîß CORRE√á√ÉO: For√ßando visibilidade correta dos bot√µes...");

                const botoes = document.querySelectorAll(
                    ".eprobe-remove-button",
                );
                botoes.forEach((botao, index) => {
                    // Remover qualquer opacity inline que possa estar conflitando
                    botao.style.removeProperty("opacity");

                    log(`üîß BOT√ÉO ${index + 1}: Opacity inline removida`);
                    log(
                        `   Opacity computada atual: ${
                            window.getComputedStyle(botao).opacity
                        }`,
                    );
                });

                return botoes.length;
            }

            // üé® FUN√á√ïES REUTILIZ√ÅVEIS DE INTERFACE

            // Fun√ß√£o para criar bot√£o com estilo eProc elegante e discreto
            function criarBotaoEleganteeProc(id, className = "col-auto mr-2") {
                const botao = document.createElement("div");
                botao.id = id;
                botao.className = className;

                // Estilo base elegante (inspirado no eprobe-data-sessao)
                botao.style.cssText = `
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            border: 1px solid #d1d5db;
            padding: 8px 12px;
            border-radius: 4px;
            background-color: #f8fafc;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
            cursor: pointer;
            white-space: nowrap;
            max-width: fit-content;
        `;

                // Adicionar efeitos hover discretos e elegantes
                botao.addEventListener(
                    "mouseenter",
                    function () {
                        this.style.backgroundColor = "#fafbfc";
                        this.style.borderColor = "#e2e8f0";
                        this.style.boxShadow =
                            "0 2px 4px 0 rgba(0, 0, 0, 0.04)";
                    },
                    { passive: true },
                );

                botao.addEventListener(
                    "mouseleave",
                    function () {
                        this.style.backgroundColor = "#f8fafc";
                        this.style.borderColor = "#d1d5db";
                        this.style.boxShadow =
                            "0 1px 2px 0 rgba(0, 0, 0, 0.05)";
                    },
                    { passive: true },
                );

                return botao;
            }

            // Fun√ß√£o espec√≠fica para criar bot√£o branco capa do processo (alias mais descritivo)
            function botaoBrancoCapaProcesso(id, className = "col-auto mr-2") {
                return criarBotaoEleganteeProc(id, className);
            }

            // Fun√ß√£o para criar bot√£o infraButton btn-primary com estilo eProc
            function criarInfraButtonPrimary(id, innerHTML) {
                const button = document.createElement("button");
                button.id = id;
                button.className = "infraButton btn-primary";
                button.style.marginRight = "3px !important";

                // Conte√∫do do bot√£o (HTML interno)
                if (innerHTML) {
                    button.innerHTML = innerHTML;
                }

                // üéØ SOLU√á√ÉO: Verificar tema ativo antes de aplicar cor
                let temaCor = "#134377"; // Cor padr√£o azul eProbe

                try {
                    // Tentar pegar tema salvo do localStorage
                    const temaSalvo = localStorage.getItem(
                        "eprobe_tema_botoes_eproc",
                    );
                    if (temaSalvo && TEMAS_BOTOES_EPROC[temaSalvo]) {
                        temaCor = TEMAS_BOTOES_EPROC[temaSalvo].backgroundColor;
                        log(
                            `üé® BOT√ÉO: Usando cor do tema ${temaSalvo}: ${temaCor}`,
                        );
                    }
                } catch (e) {
                    log(
                        "‚ö†Ô∏è BOT√ÉO: Erro ao verificar tema salvo, usando azul padr√£o",
                    );
                }

                // Aplicar cor baseada no tema ativo
                button.style.backgroundColor = temaCor;
                button.style.borderColor = temaCor;

                // FOR√áAR aplica√ß√£o do margin-right no SVG
                setTimeout(() => {
                    const svg = button.querySelector("svg");
                    if (svg) {
                        svg.style.marginRight = "4px";
                        svg.style.setProperty(
                            "margin-right",
                            "4px",
                            "important",
                        );
                        log(
                            "‚úÖ FUN√á√ÉO CENTRAL: Margin-right aplicado automaticamente ao SVG:",
                            svg.style.marginRight,
                        );
                    }
                }, 50);

                // üéØ EVENTOS HOVER DIN√ÇMICOS baseados na cor do tema
                const corHover =
                    temaCor === "#134377" ? "rgb(19, 67, 119)" : temaCor; // Se azul, usar hover mais escuro

                // Adicionar eventos para hover, focus e blur (otimizados para performance)
                button.addEventListener(
                    "mouseenter",
                    () => {
                        button.style.backgroundColor = corHover;
                        button.style.borderColor = corHover;
                    },
                    { passive: true },
                );

                button.addEventListener(
                    "mouseleave",
                    () => {
                        button.style.backgroundColor = temaCor;
                        button.style.borderColor = temaCor;
                    },
                    { passive: true },
                );

                button.addEventListener("focus", () => {
                    button.style.backgroundColor = corHover;
                    button.style.borderColor = corHover;
                });

                button.addEventListener("blur", () => {
                    button.style.backgroundColor = temaCor;
                    button.style.borderColor = temaCor;
                });

                return button;
            }

            // Fun√ß√£o espec√≠fica para criar bot√£o azul eProc (alias mais descritivo)
            function botaoAzuleProc(id, innerHTML) {
                return criarInfraButtonPrimary(id, innerHTML);
            }

            // FUN√á√ÉO REMOVIDA: detectarDataSessaoExperimental - substitu√≠da por detectarCardSessaoSimplificado √öNICA

            // Inicializar - VERS√ÉO SEGURA (sem interfer√™ncia na navbar)
            init();

            // Fun√ß√£o de teste Material Base Layout
            function testarMaterialBaseLayout() {
                try {
                    // Buscar elementos com IDs espec√≠ficos das minutas
                    const minutasIds = [
                        "conteudoInternoMinutas_0",
                        "conteudoInternoMinutas_1",
                        "conteudoInternoMinutas_2",
                        "conteudoInternoMinutas_3",
                    ];

                    log("üîç Procurando elementos de minutas:");
                    let encontrados = 0;
                    minutasIds.forEach((id) => {
                        const element = document.getElementById(id);
                        if (element) {
                            log(`‚úÖ Encontrado: ${id}`, element);
                            log(`   - Display: ${element.style.display}`);
                            log(
                                `   - Visible: ${element.offsetParent !== null}`,
                            );
                            encontrados++;
                        } else {
                            logError(`‚ùå N√£o encontrado: ${id}`);
                        }
                    });

                    // Buscar elementos com onclick
                    const elementsWithOnclick = document.querySelectorAll(
                        '[onclick*="infraAbrirFecharElementoHTML"]',
                    );
                    log(
                        `üìä Encontrados ${elementsWithOnclick.length} elementos com onclick`,
                    );

                    // Buscar containers substitu√≠dos
                    const containers =
                        document.querySelectorAll("div[data-expanded]");
                    log(
                        `üìä Encontrados ${containers.length} containers com data-expanded`,
                    );

                    // Criar card Material Base - vers√£o segura
                    let card = null;
                    if (
                        typeof window.SENT1_AUTO?.criarCardSessaoMaterial ===
                        "function"
                    ) {
                        card =
                            window.SENT1_AUTO.criarCardSessaoMaterial(
                                dadosTeste,
                            );
                    } else if (typeof criarCardSessaoMaterial === "function") {
                        card = criarCardSessaoMaterial(dadosTeste);
                    } else {
                        console.warn(
                            "‚ö†Ô∏è TESTE: criarCardSessaoMaterial n√£o dispon√≠vel",
                        );
                        return {
                            erro: "Fun√ß√£o n√£o dispon√≠vel",
                            disponivel: false,
                        };
                    }

                    if (!card) {
                        console.warn("‚ö†Ô∏è TESTE: Card n√£o foi criado");
                        return { erro: "Card n√£o criado", disponivel: false };
                    }

                    // Verificar especifica√ß√µes CSS
                    const computedStyle = window.getComputedStyle(card);

                    const especificacoes = {
                        width: computedStyle.width,
                        height: computedStyle.height,
                        background: computedStyle.backgroundColor,
                        border: computedStyle.border,
                        borderRadius: computedStyle.borderRadius,
                        boxShadow: computedStyle.boxShadow,
                        display: computedStyle.display,
                        flexDirection: computedStyle.flexDirection,
                        justifyContent: computedStyle.justifyContent,
                        alignItems: computedStyle.alignItems,
                        padding: computedStyle.padding,
                        gap: computedStyle.gap,
                        position: computedStyle.position,
                    };

                    log("üìä ESPECIFICA√á√ïES APLICADAS:", especificacoes);

                    // Verificar se atende aos requisitos
                    const conformidade = {
                        dimensoes:
                            especificacoes.width === "225px" &&
                            especificacoes.height === "80px",
                        background:
                            especificacoes.background.includes(
                                "254, 247, 255",
                            ) || especificacoes.background === "#FEF7FF",
                        borderRadius: especificacoes.borderRadius === "12px",
                        flexLayout:
                            especificacoes.display === "flex" &&
                            especificacoes.flexDirection === "column",
                        centralizado:
                            especificacoes.justifyContent === "center" &&
                            especificacoes.alignItems === "center",
                        padding: especificacoes.padding === "10px",
                        gap: especificacoes.gap === "10px",
                    };

                    log("‚úÖ CONFORMIDADE MATERIAL BASE:", conformidade);

                    // Verificar √°reas do card
                    const iconArea = card.querySelector(".eprobe-icon-area");
                    const headerArea = card.querySelector(
                        ".eprobe-header-area",
                    );
                    const subheadArea = card.querySelector(
                        ".eprobe-subhead-area",
                    );
                    const dataArea = card.querySelector(".eprobe-data-area");

                    const areas = {
                        icone: !!iconArea,
                        header: !!headerArea ? headerArea.textContent : null,
                        subhead: !!subheadArea ? subheadArea.textContent : null,
                        data: !!dataArea ? dataArea.textContent : null,
                    };

                    log("üìê √ÅREAS DO CARD:", areas);

                    return {
                        sucesso: true,
                        layout: "Material Base CSS",
                        especificacoes: especificacoes,
                        conformidade: conformidade,
                        areas: areas,
                        verificacao: {
                            dimensoesCorretas: conformidade.dimensoes,
                            layoutFlexCorreto: conformidade.flexLayout,
                            estilizacaoCorreta:
                                conformidade.background &&
                                conformidade.borderRadius,
                            areasPresentes: Object.values(areas).every(Boolean),
                        },
                    };
                } catch (error) {
                    console.error("‚ùå ERRO no teste Material Base:", error);
                    return {
                        sucesso: false,
                        erro: error.message,
                    };
                }
            }
            // üß™ FUN√á√ÉO DE TESTE XPATH + MATERIAL DESIGN (movida para namespace principal)
            // üß™ FUN√á√ïES DE TESTE SIMPLIFICADO (movidas para namespace principal)
            // üé® FUN√á√ïES DE √çCONES (movidas para namespace principal)
            // üîç FUN√á√ïES DE DIAGN√ìSTICO (movidas para namespace principal)
            // üîß FUN√á√ïES DE DEBUG PARA BOT√ÉO (movidas para namespace principal)
            // üåê FUN√á√ïES GLOBAIS PARA DADOS DE SESS√ÉO (movidas para namespace principal)
            // üß™ FUN√á√ïES DE TESTE (movidas para namespace principal)
            // üß™ FUN√á√ÉO DE TESTE PARA CORRE√á√ÉO DO CARD DE SESS√ÉO (movida para namespace principal)
            // üöÄ FUN√á√ÉO PARA FOR√áAR CRIA√á√ÉO DE CARD SEM VALIDA√á√ïES (movida para namespace principal)
            // üß™ FUN√á√ÉO PARA TESTE DE CARD FIGMA EXATO (movida para namespace principal)
            // üß™ FUN√á√ÉO DE TESTE PARA ERRO SWITCH RELEVANCIA (movida para namespace principal)
            // üîß FUN√á√ïES DE DIAGN√ìSTICO DE √çCONES CSS (movidas para namespace principal)
            // ü©∫ FUN√á√ÉO DE DIAGN√ìSTICO COMPLETO DO CARD DE SESS√ÉO (movida para namespace principal)
            // üî• FUN√á√ïES DE CONTROLE DE PERFORMANCE ULTRA (movidas para namespace principal)
            // üìã NAMESPACE ESPEC√çFICO PARA LOCALIZADORES (movido para namespace principal)
            // ======== TODAS AS FUN√á√ïES FORAM MOVIDAS PARA O NAMESPACE PRINCIPAL ========

            // üß™ EXPOR FUN√á√ïES DE TESTE NO NAMESPACE (movidas para namespace principal)

            // =============================================
            // FILTRO DE BUSCA NA TABELA DE PROCESSOS DO LOCALIZADOR
            // =============================================
            function adicionarFiltroBuscaLocalizador() {
                var currentUrl = window.location.href;
                if (!currentUrl.includes("acao=localizador_processos_lista")) {
                    return false;
                }

                var tabela = document.getElementById("tabelaLocalizadores");
                if (!tabela) {
                    tabela = document.querySelector(
                        'table.infraTable[summary*="Processos por Localizador"]',
                    );
                }
                if (!tabela) {
                    console.log(
                        "FILTRO LOCALIZADOR: Tabela de processos nao encontrada",
                    );
                    return false;
                }

                // Evitar duplicacao
                if (document.getElementById("eprobe-filtro-localizador")) {
                    return true;
                }

                console.log(
                    "FILTRO LOCALIZADOR: Adicionando campo de busca na tabela de processos",
                );

                // Criar container do filtro
                var container = document.createElement("div");
                container.id = "eprobe-filtro-localizador";
                container.style.cssText =
                    "display:flex;align-items:center;gap:8px;padding:8px 12px;" +
                    "background:#f0f4f8;border:1px solid #c8d6e5;" +
                    "border-radius:6px;font-family:inherit;box-sizing:border-box;";

                // Label
                var label = document.createElement("label");
                label.setAttribute("for", "eprobe-filtro-input");
                label.style.cssText =
                    "font-weight:600;font-size:13px;color:#2c3e50;" +
                    "white-space:nowrap;margin:0;";
                label.textContent = "Filtrar processos:";

                // Input de busca
                var input = document.createElement("input");
                input.type = "text";
                input.id = "eprobe-filtro-input";
                input.placeholder = "digite o termo de busca";
                input.style.cssText =
                    "flex:1;padding:6px 10px;border:1px solid #b0c4de;" +
                    "border-radius:4px;font-size:13px;outline:none;" +
                    "transition:border-color 0.2s;min-width:0;";
                input.setAttribute("autocomplete", "off");

                // Contador de resultados
                var contador = document.createElement("span");
                contador.id = "eprobe-filtro-contador";
                contador.style.cssText =
                    "font-size:12px;color:#555;white-space:nowrap;";

                // Botao selecionar filtrados
                var btnSelecionar = document.createElement("button");
                btnSelecionar.type = "button";
                btnSelecionar.id = "eprobe-filtro-selecionar";
                btnSelecionar.textContent = "Selecionar filtrados";
                btnSelecionar.style.cssText =
                    "padding:5px 10px;background:#2980b9;color:#fff;" +
                    "border:none;border-radius:4px;font-size:12px;" +
                    "cursor:pointer;font-weight:600;display:none;" +
                    "white-space:nowrap;";

                // Botao limpar
                var btnLimpar = document.createElement("button");
                btnLimpar.type = "button";
                btnLimpar.textContent = "Limpar";
                btnLimpar.style.cssText =
                    "padding:5px 10px;background:#e74c3c;color:#fff;" +
                    "border:none;border-radius:4px;font-size:12px;" +
                    "cursor:pointer;font-weight:600;display:none;" +
                    "white-space:nowrap;";

                container.appendChild(label);
                container.appendChild(input);
                container.appendChild(contador);
                container.appendChild(btnSelecionar);
                container.appendChild(btnLimpar);

                // Extrair total de registros do caption antes de modificar
                var caption = tabela.querySelector("caption");
                var totalRegistros = 0;
                var paginaInfo = "";
                if (caption) {
                    var captionText = caption.textContent || "";
                    var matchTotal = captionText.match(
                        /\((\d+)\s*registros?\s*-\s*(\d+)\s*a\s*(\d+)\)/,
                    );
                    if (matchTotal) {
                        totalRegistros = parseInt(matchTotal[1], 10);
                        paginaInfo =
                            matchTotal[2] +
                            " a " +
                            matchTotal[3] +
                            " de " +
                            matchTotal[1];
                    }
                }

                // Inserir filtro como tr no topo do tbody da tabela (antes do cabecalho)
                var tbody = tabela.querySelector("tbody");
                if (tbody) {
                    var trFiltro = document.createElement("tr");
                    trFiltro.id = "eprobe-filtro-tr";
                    var tdFiltro = document.createElement("td");
                    tdFiltro.colSpan = 13;
                    tdFiltro.style.cssText =
                        "padding:6px 4px;border:none;background:transparent;";
                    tdFiltro.appendChild(container);
                    trFiltro.appendChild(tdFiltro);
                    // Inserir antes da primeira tr (cabecalho)
                    var primeiroTr = tbody.querySelector("tr");
                    if (primeiroTr) {
                        tbody.insertBefore(trFiltro, primeiroTr);
                    } else {
                        tbody.appendChild(trFiltro);
                    }
                } else {
                    tabela.parentNode.insertBefore(container, tabela);
                }

                // Coletar todas as linhas de dados (exclui cabecalho e separadores eprobe)
                var tbody = tabela.querySelector("tbody");
                var linhasData = [];
                if (tbody) {
                    var todasLinhas = tbody.querySelectorAll("tr");
                    for (var i = 0; i < todasLinhas.length; i++) {
                        var tr = todasLinhas[i];
                        if (
                            tr.classList.contains("infraTrClara") ||
                            tr.classList.contains("infraTrEscura")
                        ) {
                            linhasData.push(tr);
                        }
                    }
                }

                var totalProcessos = linhasData.length;
                var textoBase = totalProcessos + " processos";
                if (totalRegistros > 0 && totalRegistros !== totalProcessos) {
                    textoBase =
                        totalProcessos +
                        " nesta pagina | " +
                        totalRegistros +
                        " total";
                }
                contador.textContent = textoBase;

                // Funcao para normalizar texto (remover acentos)
                function normalizar(texto) {
                    if (!texto) return "";
                    return texto
                        .toLowerCase()
                        .normalize("NFD")
                        .replace(/[\u0300-\u036f]/g, "");
                }

                // Estado do filtro ativo
                var filtroAtivo = false;

                // Funcao de filtragem com debounce
                var timerFiltro = null;
                function filtrar() {
                    var termo = normalizar(input.value.trim());

                    if (!termo) {
                        // Mostrar todas
                        for (var i = 0; i < linhasData.length; i++) {
                            linhasData[i].style.display = "";
                        }
                        contador.textContent = textoBase;
                        contador.style.color = "#555";
                        btnLimpar.style.display = "none";
                        btnSelecionar.style.display = "none";
                        filtroAtivo = false;
                        return;
                    }

                    // Suporte a multiplos termos separados por virgula
                    var termos = termo.split(",");
                    for (var t = 0; t < termos.length; t++) {
                        termos[t] = termos[t].trim();
                    }
                    var termosValidos = [];
                    for (var t = 0; t < termos.length; t++) {
                        if (termos[t].length > 0) {
                            termosValidos.push(termos[t]);
                        }
                    }
                    if (termosValidos.length === 0) {
                        for (var i = 0; i < linhasData.length; i++) {
                            linhasData[i].style.display = "";
                        }
                        contador.textContent = textoBase;
                        contador.style.color = "#555";
                        btnLimpar.style.display = "none";
                        btnSelecionar.style.display = "none";
                        filtroAtivo = false;
                        return;
                    }

                    var visiveis = 0;
                    for (var i = 0; i < linhasData.length; i++) {
                        var tr = linhasData[i];
                        // Buscar apenas no texto visivel das celulas (sem tooltips)
                        var celulas = tr.querySelectorAll("td");
                        var textoLinha = "";
                        for (var c = 0; c < celulas.length; c++) {
                            textoLinha +=
                                " " + normalizar(celulas[c].textContent);
                        }

                        // Verificar se TODOS os termos aparecem (AND logic)
                        var match = true;
                        for (var t = 0; t < termosValidos.length; t++) {
                            if (textoLinha.indexOf(termosValidos[t]) === -1) {
                                match = false;
                                break;
                            }
                        }

                        if (match) {
                            tr.style.display = "";
                            visiveis++;
                        } else {
                            tr.style.display = "none";
                        }
                    }

                    // Atualizar contador
                    var sufixo =
                        totalRegistros > totalProcessos
                            ? " nesta pag. (" + totalRegistros + " total)"
                            : " de " + totalProcessos;
                    contador.textContent = visiveis + sufixo;
                    contador.style.color =
                        visiveis === 0 ? "#e74c3c" : "#27ae60";
                    btnLimpar.style.display = "inline-block";
                    btnSelecionar.style.display =
                        visiveis > 0 ? "inline-block" : "none";
                    filtroAtivo = true;
                }

                // Funcao para selecionar apenas os processos filtrados (visiveis)
                function selecionarFiltrados() {
                    // Primeiro desmarcar todos
                    for (var i = 0; i < linhasData.length; i++) {
                        var chk = linhasData[i].querySelector(
                            'input[type="checkbox"].infraCheckbox',
                        );
                        if (chk && chk.checked) {
                            chk.checked = false;
                        }
                    }
                    // Marcar apenas os visiveis
                    var selecionados = 0;
                    for (var i = 0; i < linhasData.length; i++) {
                        if (linhasData[i].style.display !== "none") {
                            var chk = linhasData[i].querySelector(
                                'input[type="checkbox"].infraCheckbox',
                            );
                            if (chk) {
                                chk.checked = true;
                                selecionados++;
                            }
                        }
                    }
                    // Atualizar icone do "Selecionar Tudo" do eProc
                    var imgCheck = document.getElementById("imgInfraCheck");
                    if (imgCheck) {
                        imgCheck.src = "infra_css/imagens/uncheck.gif";
                        imgCheck.title = "Deselecionar Tudo";
                        imgCheck.alt = "Deselecionar Tudo";
                    }
                    // Feedback visual no botao
                    btnSelecionar.textContent =
                        selecionados + " selecionado(s)";
                    setTimeout(function () {
                        btnSelecionar.textContent = "Selecionar filtrados";
                    }, 2000);
                }

                // Event listeners
                input.addEventListener("input", function () {
                    if (timerFiltro) {
                        clearTimeout(timerFiltro);
                    }
                    timerFiltro = setTimeout(filtrar, 200);
                });

                input.addEventListener("keydown", function (e) {
                    if (e.key === "Escape") {
                        input.value = "";
                        filtrar();
                        input.blur();
                    }
                });

                btnLimpar.addEventListener("click", function () {
                    input.value = "";
                    filtrar();
                    input.focus();
                });

                btnSelecionar.addEventListener("click", function () {
                    selecionarFiltrados();
                });

                // Focus styling
                input.addEventListener("focus", function () {
                    input.style.borderColor = "#3498db";
                    input.style.boxShadow = "0 0 0 2px rgba(52,152,219,0.2)";
                });
                input.addEventListener("blur", function () {
                    input.style.borderColor = "#b0c4de";
                    input.style.boxShadow = "none";
                });

                console.log(
                    "FILTRO LOCALIZADOR: Campo de busca adicionado com sucesso (" +
                        totalProcessos +
                        " processos detectados)",
                );

                return true;
            }

            // ‚úÖ EXPOSI√á√ÉO GLOBAL DAS FUN√á√ïES DE LOCALIZADORES
            // Expor as fun√ß√µes de localizadores globalmente para uso no namespace
            window.detectarPaginaLocalizadores = detectarPaginaLocalizadores;
            window.processarTabelaLocalizadores = processarTabelaLocalizadores;
            window.destacarLocalizadoresUrgentes =
                destacarLocalizadoresUrgentes;
            window.adicionarFiltroBuscaLocalizador =
                adicionarFiltroBuscaLocalizador;

            // ========================================
            // VARI√ÅVEIS GLOBAIS PARA DADOS DE SESS√ÉO
            // ========================================

            // ========================================
            // FUN√á√ïES GLOBAIS PARA GERENCIAMENTO DOS DADOS
            // ========================================

            /**
             * üîß SETUP INTERFACE OBSERVER - Monitora mudan√ßas na interface (OTIMIZADO)
             * Observer unificado com debounce para melhor performance
             */
            function setupInterfaceObserver() {
                log(
                    "üîç OBSERVER: Configurando observer de interface otimizado",
                );

                // Debounce para evitar m√∫ltiplas execu√ß√µes
                let debounceTimer = null;
                const debounceDelay = 50;

                // Observer otimizado para detectar mudan√ßas nos elementos da interface
                const observer = new MutationObserver((mutations) => {
                    let shouldCheckOverlap = false;
                    let shouldCheckLembretes = false;

                    // Processar muta√ß√µes de forma mais eficiente
                    for (const mutation of mutations) {
                        // Se elementos foram adicionados ou removidos
                        if (mutation.type === "childList") {
                            for (const node of mutation.addedNodes) {
                                if (node.nodeType === Node.ELEMENT_NODE) {
                                    const id = node.id;
                                    if (
                                        id === "sent1-auto-button" ||
                                        id ===
                                            "documento-relevante-notification" ||
                                        id ===
                                            "documento-relevante-options-menu"
                                    ) {
                                        shouldCheckOverlap = true;
                                    }

                                    // Verificar se √© um div.divLembrete
                                    if (
                                        node.classList &&
                                        node.classList.contains("divLembrete")
                                    ) {
                                        shouldCheckLembretes = true;
                                    }

                                    // üîß NOVO: Verificar se √© um bot√£o "Ler mais" que n√£o foi processado
                                    if (
                                        node.classList &&
                                        node.classList.contains(
                                            "botaoLerMais",
                                        ) &&
                                        !node.hasAttribute(
                                            "data-eprobe-expandir-replaced",
                                        )
                                    ) {
                                        shouldCheckLembretes = true;
                                        console.log(
                                            "üîç OBSERVER: Novo bot√£o 'Ler mais' detectado:",
                                            node,
                                        );
                                    }

                                    // Verificar elementos filhos tamb√©m
                                    const lembreteElements =
                                        node.querySelectorAll &&
                                        node.querySelectorAll(
                                            "div.divLembrete",
                                        );
                                    if (
                                        lembreteElements &&
                                        lembreteElements.length > 0
                                    ) {
                                        shouldCheckLembretes = true;
                                    }

                                    // üîß NOVO: Verificar bot√µes "Ler mais" filhos n√£o processados
                                    const botoesLerMais =
                                        node.querySelectorAll &&
                                        node.querySelectorAll(
                                            "div.botaoLerMais:not([data-eprobe-expandir-replaced])",
                                        );
                                    if (
                                        botoesLerMais &&
                                        botoesLerMais.length > 0
                                    ) {
                                        shouldCheckLembretes = true;
                                        console.log(
                                            `üîç OBSERVER: ${botoesLerMais.length} bot√µes 'Ler mais' n√£o processados detectados em filhos`,
                                        );
                                    }

                                    if (
                                        shouldCheckOverlap &&
                                        shouldCheckLembretes
                                    )
                                        break;
                                }
                            }
                        }

                        // Se atributos de estilo mudaram
                        if (
                            mutation.type === "attributes" &&
                            mutation.attributeName === "style" &&
                            mutation.target.id &&
                            (mutation.target.id === "sent1-auto-button" ||
                                mutation.target.id ===
                                    "documento-relevante-notification" ||
                                mutation.target.id ===
                                    "documento-relevante-options-menu")
                        ) {
                            shouldCheckOverlap = true;
                        }

                        // Early exit se j√° encontrou o que precisa
                        if (shouldCheckOverlap && shouldCheckLembretes) break;
                    }

                    // Debounce da verifica√ß√£o de overlap
                    if (
                        shouldCheckOverlap &&
                        typeof preventElementOverlap === "function"
                    ) {
                        if (debounceTimer) clearTimeout(debounceTimer);
                        debounceTimer = setTimeout(
                            preventElementOverlap,
                            debounceDelay,
                        );
                    }

                    // Debounce da estiliza√ß√£o de lembretes
                    if (
                        shouldCheckLembretes &&
                        typeof estilizarTodosDivLembrete === "function"
                    ) {
                        if (debounceTimer) clearTimeout(debounceTimer);
                        debounceTimer = setTimeout(() => {
                            // ‚ö° APLICA√á√ÉO IMEDIATA - SEM FLASH
                            aplicarEstilizacaoImediataLembretes();

                            const resultado = estilizarTodosDivLembrete();
                            log(
                                "üîÑ OBSERVER: Lembretes re-estilizados ap√≥s mudan√ßa no DOM",
                                resultado,
                            );

                            // Reaplicar icones via funcao unificada
                            if (isCapaProcessoPage()) {
                                substituirTodosIcones();
                            }
                        }, debounceDelay + 100); // Pequeno delay adicional para lembretes
                    }
                });

                // Observar mudan√ßas no body
                observer.observe(document.body, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ["style"],
                });

                logCritical(
                    "‚úÖ OBSERVER: Interface observer configurado com sucesso",
                );
                return observer;
            }

            // ========================================
            // üîç FUN√á√ïES DE DIAGN√ìSTICO E CORRE√á√ÉO AUTOM√ÅTICA
            // ========================================

            /**
             * Diagn√≥stico completo do estado atual da extens√£o
             * Verifica se todas as funcionalidades est√£o operando corretamente
             */
            function diagnosticarCompleto() {
                log(
                    "üîç DIAGN√ìSTICO: Iniciando diagn√≥stico completo do sistema",
                );

                const diagnostico = {
                    timestamp: new Date().toISOString(),
                    url: window.location.href,
                    pageType: detectPageType(),
                    dadosSessao: {
                        hasDataSessao: hasDataSessaoPautado(),
                        dataSessao: dataSessaoPautado,
                        processoComData: processoComDataSessao,
                        dadosCompletos: hasDadosCompletosSessionJulgamento(),
                    },
                    elementos: {
                        botaoIntegrado: !!document.getElementById(
                            "documento-relevante-auto-button",
                        ),
                        botaoFlutuante:
                            !!document.getElementById("sent1-auto-button"),
                        navbar: !!document.querySelector(".navbar"),
                        minutas: !!document.querySelector("#conteudoMinutas"),
                    },
                    performance: {
                        tentativasCruzamento: tentativasCruzamento,
                        cacheValido: cacheValidoAte > Date.now(),
                        processosProcessados: processosJaProcessados.size,
                        modoUltraPerformance: MODO_ULTRA_PERFORMANCE,
                    },
                    apis: {
                        perplexityKey:
                            !!localStorage.getItem("perplexity_api_key"),
                        requisicoesDesabilitadas:
                            REQUISICOES_AUTOMATICAS_DESABILITADAS,
                    },
                };

                log("üìä DIAGN√ìSTICO COMPLETO:", diagnostico);

                // Verificar problemas comuns
                const problemas = [];

                if (
                    !diagnostico.elementos.botaoIntegrado &&
                    !diagnostico.elementos.botaoFlutuante
                ) {
                    problemas.push("Nenhum bot√£o da extens√£o encontrado");
                }

                if (
                    diagnostico.dadosSessao.hasDataSessao &&
                    !diagnostico.dadosSessao.dadosCompletos
                ) {
                    problemas.push(
                        "Data de sess√£o detectada mas dados completos n√£o obtidos",
                    );
                }

                if (
                    diagnostico.performance.tentativasCruzamento >=
                    MAX_TENTATIVAS_CRUZAMENTO
                ) {
                    problemas.push(
                        "M√°ximo de tentativas de cruzamento atingido",
                    );
                }

                if (!diagnostico.apis.perplexityKey) {
                    problemas.push("API key do Perplexity n√£o configurada");
                }

                if (problemas.length > 0) {
                    console.warn("‚ö†Ô∏è PROBLEMAS IDENTIFICADOS:", problemas);
                } else {
                    log("‚úÖ DIAGN√ìSTICO: Sistema funcionando corretamente");
                }

                return {
                    ...diagnostico,
                    problemas: problemas,
                    status: problemas.length === 0 ? "OK" : "ATEN√á√ÉO",
                };
            }

            /**
             * Fun√ß√£o de corre√ß√£o autom√°tica para problemas detectados
             * Tenta resolver os problemas mais comuns automaticamente
             */
            function corrigirProblemas() {
                log("üîß CORRE√á√ÉO: Iniciando corre√ß√£o autom√°tica de problemas");

                const resultadoCorrecao = {
                    timestamp: new Date().toLocaleString("pt-BR"),
                    acoes: [],
                };

                // 1. Tentar criar bot√£o se n√£o existir
                const botaoJaExiste =
                    document.getElementById("eprobe-btn") ||
                    document.getElementById(
                        "documento-relevante-auto-button",
                    ) ||
                    document.getElementById("sent1-auto-button");

                if (!botaoJaExiste) {
                    log("üîò Criando bot√£o Resumir Documento...");
                    try {
                        ensureButtonExists();
                        const botaoCriado =
                            document.getElementById("eprobe-btn") ||
                            document.getElementById(
                                "documento-relevante-auto-button",
                            ) ||
                            document.getElementById("sent1-auto-button");

                        resultadoCorrecao.acoes.push({
                            acao: "Cria√ß√£o de bot√£o",
                            status: "Tentativa executada",
                            sucesso: botaoCriado !== null,
                            idCriado: botaoCriado ? botaoCriado.id : null,
                        });
                    } catch (error) {
                        console.error("‚ùå Erro ao criar bot√£o:", error);
                        resultadoCorrecao.acoes.push({
                            acao: "Cria√ß√£o de bot√£o",
                            status: "Erro",
                            erro: error.message,
                        });
                    }
                }

                // 2. Tentar aplicar substitui√ß√£o de √≠cones
                if (
                    document.querySelectorAll("[data-eprobe-icon-replaced]")
                        .length === 0
                ) {
                    log("Aplicando substituicao de icones...");
                    try {
                        substituirTodosIcones();
                        resultadoCorrecao.acoes.push({
                            acao: "Substitui√ß√£o de √≠cones",
                            status: "Executada",
                            quantidade: document.querySelectorAll(
                                "[data-eprobe-icon-replaced]",
                            ).length,
                        });
                    } catch (error) {
                        console.error("‚ùå Erro ao substituir √≠cones:", error);
                        resultadoCorrecao.acoes.push({
                            acao: "Substitui√ß√£o de √≠cones",
                            status: "Erro",
                            erro: error.message,
                        });
                    }
                }

                // 3. For√ßar detec√ß√£o de data da sess√£o se necess√°rio
                if (!hasDataSessaoPautado()) {
                    log("üìÖ For√ßando detec√ß√£o de data da sess√£o...");
                    try {
                        const dataDetectada =
                            window.SENT1_AUTO &&
                            window.SENT1_AUTO.detectarCardSessaoSimplificado
                                ? window.SENT1_AUTO.detectarCardSessaoSimplificado()
                                : null;
                        resultadoCorrecao.acoes.push({
                            acao: "Detec√ß√£o de data da sess√£o",
                            status: "Executada",
                            sucesso: dataDetectada !== null,
                            valor: dataDetectada,
                        });
                    } catch (error) {
                        console.error(
                            "‚ùå Erro ao detectar data da sess√£o:",
                            error,
                        );
                        resultadoCorrecao.acoes.push({
                            acao: "Detec√ß√£o de data da sess√£o",
                            status: "Erro",
                            erro: error.message,
                        });
                    }
                }

                log("üîß CORRE√á√ÉO COMPLETA:", resultadoCorrecao);
                return resultadoCorrecao;
            }

            /**
             * üîß FUN√á√ÉO CR√çTICA: Corrigir pointer-events de bot√µes do eProc
             * Garante que bot√µes importantes como LegNovaMinuta sejam clic√°veis
             */
            function corrigirPointerEventsBotoes() {
                var correcoesAplicadas = [];

                // Protecao: Nao aplicar em elementos select2
                var isSelect2Element = function (element) {
                    return (
                        element.classList.contains(
                            "select2-search-choice-close",
                        ) ||
                        element.closest(".select2-container") ||
                        element.matches('[class*="select2"]')
                    );
                };

                // Funcao auxiliar: garante que o link/botao e clicavel
                // SVGs/imgs nao interceptam cliques; spans HERDAM do pai
                var corrigirElementoClicavel = function (el) {
                    if (!el || isSelect2Element(el)) return;
                    el.style.setProperty("pointer-events", "auto", "important");
                    // Apenas SVGs e imgs ficam com pointer-events: none
                    var filhosVisuais = el.querySelectorAll(
                        "svg, img, [data-eprobe-icon-replaced]",
                    );
                    filhosVisuais.forEach(function (filho) {
                        filho.style.setProperty(
                            "pointer-events",
                            "none",
                            "important",
                        );
                    });
                    // Containers de icones devem ser clicaveis
                    var containers = el.querySelectorAll(
                        "span[data-eprobe-icon-container]",
                    );
                    containers.forEach(function (container) {
                        container.style.setProperty(
                            "pointer-events",
                            "auto",
                            "important",
                        );
                    });
                };

                // 1. Corrigir botao LegNovaMinuta
                var botaoLegNovaMinuta = document.querySelector(
                    "#LegNovaMinuta button",
                );
                if (botaoLegNovaMinuta) {
                    corrigirElementoClicavel(botaoLegNovaMinuta);
                    correcoesAplicadas.push("LegNovaMinuta button");
                }

                // 2. Corrigir botoes infraLegendObrigatorio
                document
                    .querySelectorAll(".infraLegendObrigatorio button")
                    .forEach(function (botao) {
                        corrigirElementoClicavel(botao);
                    });

                // 3. Corrigir links com icones eProbe substituidos
                document
                    .querySelectorAll("a:has(span[data-eprobe-icon-container])")
                    .forEach(function (link) {
                        corrigirElementoClicavel(link);
                    });

                // 4. Corrigir icones de estrela protegidos
                document
                    .querySelectorAll('img[data-eprobe-protected="true"]')
                    .forEach(function (icone) {
                        icone.style.setProperty(
                            "pointer-events",
                            "auto",
                            "important",
                        );
                        var parentLink = icone.closest("a");
                        if (parentLink) {
                            parentLink.style.setProperty(
                                "pointer-events",
                                "auto",
                                "important",
                            );
                        }
                    });

                // 5. Corrigir botoes btn-link (exceto select2)
                document
                    .querySelectorAll("button.btn-link")
                    .forEach(function (botao) {
                        corrigirElementoClicavel(botao);
                    });

                // 6. Corrigir links com classe infraLegendObrigatorio diretamente
                document
                    .querySelectorAll("a.infraLegendObrigatorio")
                    .forEach(function (link) {
                        corrigirElementoClicavel(link);
                    });

                return {
                    status: "sucesso",
                    correcoesAplicadas: correcoesAplicadas.length,
                };
            }

            /**
             *  NOVA VERS√ÉO ROBUSTA: switchRelevanciaDocumento sem depend√™ncias problem√°ticas
             */
            function corrigirSwitchRelevanciaDocumentoRobusta() {
                console.log(
                    "üöÄ CORRE√á√ÉO ROBUSTA: Iniciando substitui√ß√£o completa da fun√ß√£o switchRelevanciaDocumento...",
                );

                const correcoesAplicadas = [];

                // üîß IMPLEMENTA√á√ÉO ROBUSTA COMPLETA da switchRelevanciaDocumento
                function switchRelevanciaDocumentoRobusta(
                    idEvento,
                    relevancia,
                    tipo,
                    urlAjax,
                ) {
                    try {
                        console.log(
                            "üöÄ FUN√á√ÉO ROBUSTA: switchRelevanciaDocumento chamada:",
                            {
                                idEvento,
                                relevancia,
                                tipo,
                                urlAjax,
                            },
                        );

                        // Valida√ß√£o b√°sica dos par√¢metros
                        if (!idEvento || !urlAjax) {
                            console.error("‚ùå PAR√ÇMETROS INV√ÅLIDOS:", {
                                idEvento,
                                urlAjax,
                            });
                            return false;
                        }

                        // Construir URL da requisi√ß√£o AJAX de forma segura
                        let fullUrl = urlAjax;
                        const separator =
                            fullUrl.indexOf("?") === -1 ? "?" : "&";
                        fullUrl += `${separator}idEvento=${encodeURIComponent(
                            idEvento,
                        )}&relevancia=${encodeURIComponent(
                            relevancia,
                        )}&tipo=${encodeURIComponent(tipo || "")}`;

                        console.log("üåê REQUISI√á√ÉO AJAX ROBUSTA:", fullUrl);

                        // Executar requisi√ß√£o AJAX com tratamento completo de erros
                        const xhr = new XMLHttpRequest();
                        xhr.open("GET", fullUrl, true);

                        xhr.onreadystatechange = function () {
                            if (xhr.readyState === 4) {
                                if (xhr.status === 200) {
                                    console.log(
                                        "‚úÖ AJAX SUCESSO:",
                                        xhr.responseText,
                                    );

                                    // Atualizar √≠cone visualmente
                                    setTimeout(() => {
                                        atualizarIconeEstrelaVisualRobusta(
                                            idEvento,
                                            relevancia,
                                        );
                                    }, 100);

                                    // Verificar se precisa recarregar (comportamento padr√£o do eProc)
                                    if (
                                        xhr.responseText &&
                                        xhr.responseText
                                            .toLowerCase()
                                            .includes("reload")
                                    ) {
                                        console.log(
                                            "üîÑ RECARREGANDO P√ÅGINA conforme resposta do servidor",
                                        );
                                        setTimeout(
                                            () => window.location.reload(),
                                            500,
                                        );
                                    }
                                } else {
                                    console.error(
                                        "‚ùå AJAX ERRO:",
                                        xhr.status,
                                        xhr.statusText,
                                    );
                                }
                            }
                        };

                        xhr.onerror = function () {
                            console.error("‚ùå AJAX ERRO DE REDE");
                        };

                        xhr.timeout = 10000; // 10 segundos de timeout
                        xhr.ontimeout = function () {
                            console.error("‚ùå AJAX TIMEOUT");
                        };

                        xhr.send();
                        return true;
                    } catch (error) {
                        console.error(
                            "‚ùå ERRO CR√çTICO na fun√ß√£o robusta:",
                            error,
                        );
                        return false;
                    }
                }

                // Fun√ß√£o auxiliar para atualizar √≠cone visualmente (vers√£o robusta)
                function atualizarIconeEstrelaVisualRobusta(
                    idEvento,
                    relevancia,
                ) {
                    try {
                        console.log(
                            `üåü ATUALIZANDO √çCONES: Evento ${idEvento}, Relev√¢ncia ${relevancia}`,
                        );

                        // Procurar √≠cones de estrela por m√∫ltiplos seletores
                        const seletores = [
                            `img[onclick*="switchRelevanciaDocumento('${idEvento}'"]`,
                            `a[onclick*="switchRelevanciaDocumento('${idEvento}'"]`,
                            `img[onclick*='switchRelevanciaDocumento("${idEvento}"']`,
                            `a[onclick*='switchRelevanciaDocumento("${idEvento}"']`,
                            `img[src*="estrela"]`,
                            `img[src*="Estrela"]`,
                        ];

                        let iconesAtualizados = 0;

                        for (const seletor of seletores) {
                            const elementos =
                                document.querySelectorAll(seletor);
                            elementos.forEach((elemento, index) => {
                                try {
                                    // Verificar se este elemento pertence ao evento correto
                                    const pertenceAoEvento =
                                        verificarSeElementoPertenceAoEventoRobusta(
                                            elemento,
                                            idEvento,
                                        );

                                    if (pertenceAoEvento) {
                                        if (elemento.tagName === "IMG") {
                                            // Atualizar src da imagem
                                            const srcAtual = elemento.src;
                                            let novoSrc;

                                            if (
                                                relevancia === "S" ||
                                                relevancia === "1"
                                            ) {
                                                // Marcar como relevante (estrela acesa)
                                                novoSrc = srcAtual
                                                    .replace(
                                                        /estrela[_\-]?off/gi,
                                                        "estrela_on",
                                                    )
                                                    .replace(
                                                        /estrela[_\-]?apagada/gi,
                                                        "estrela_acesa",
                                                    )
                                                    .replace(
                                                        /EstrelaApagada/gi,
                                                        "EstrelaAcesa",
                                                    );
                                            } else {
                                                // Marcar como n√£o relevante (estrela apagada)
                                                novoSrc = srcAtual
                                                    .replace(
                                                        /estrela[_\-]?on/gi,
                                                        "estrela_off",
                                                    )
                                                    .replace(
                                                        /estrela[_\-]?acesa/gi,
                                                        "estrela_apagada",
                                                    )
                                                    .replace(
                                                        /EstrelaAcesa/gi,
                                                        "EstrelaApagada",
                                                    );
                                            }

                                            if (novoSrc !== srcAtual) {
                                                elemento.src = novoSrc;
                                                iconesAtualizados++;
                                                console.log(
                                                    `‚úÖ √çcone ${index} atualizado: ${srcAtual} ‚Üí ${novoSrc}`,
                                                );
                                            }
                                        }

                                        // Atualizar atributos de acessibilidade
                                        const textoRelevancia =
                                            relevancia === "S" ||
                                            relevancia === "1"
                                                ? "Relevante"
                                                : "N√£o relevante";
                                        elemento.title = textoRelevancia;
                                        elemento.alt = textoRelevancia;
                                    }
                                } catch (iconError) {
                                    console.warn(
                                        `‚ö†Ô∏è Erro ao atualizar √≠cone ${index}:`,
                                        iconError,
                                    );
                                }
                            });
                        }

                        console.log(
                            `üéØ RESULTADO: ${iconesAtualizados} √≠cones atualizados para evento ${idEvento}`,
                        );
                    } catch (error) {
                        console.error(
                            "‚ùå ERRO ao atualizar √≠cones visuais:",
                            error,
                        );
                    }
                }

                // Fun√ß√£o para verificar se um elemento pertence ao evento espec√≠fico (vers√£o robusta)
                function verificarSeElementoPertenceAoEventoRobusta(
                    elemento,
                    idEvento,
                ) {
                    try {
                        // M√©todo 1: Verificar onclick do pr√≥prio elemento
                        const onclick = elemento.getAttribute("onclick");
                        if (onclick && onclick.includes(idEvento)) {
                            console.log(
                                `üéØ MATCH: Elemento pertence ao evento ${idEvento} (onclick)`,
                            );
                            return true;
                        }

                        // M√©todo 2: Procurar no container pai por refer√™ncia ao evento
                        const container = elemento.closest(
                            'tr, .evento, [id*="evento"], .infraLinha',
                        );
                        if (container) {
                            // Verificar se o ID do evento aparece no texto ou atributos do container
                            if (
                                container.textContent.includes(idEvento) ||
                                container.innerHTML.includes(idEvento) ||
                                container.getAttribute("id")?.includes(idEvento)
                            ) {
                                console.log(
                                    `üéØ MATCH: Elemento pertence ao evento ${idEvento} (container)`,
                                );
                                return true;
                            }
                        }

                        // M√©todo 3: Verificar elementos irm√£os
                        const parent = elemento.parentElement;
                        if (
                            parent &&
                            (parent.textContent.includes(idEvento) ||
                                parent.innerHTML.includes(idEvento))
                        ) {
                            console.log(
                                `üéØ MATCH: Elemento pertence ao evento ${idEvento} (parent)`,
                            );
                            return true;
                        }

                        return false;
                    } catch (error) {
                        console.warn("‚ö†Ô∏è Erro ao verificar evento:", error);
                        return false;
                    }
                }

                // üîÑ SUBSTITUIR COMPLETAMENTE a fun√ß√£o original
                const funcaoOriginal = window.switchRelevanciaDocumento;
                window.switchRelevanciaDocumento =
                    switchRelevanciaDocumentoRobusta;

                if (funcaoOriginal) {
                    console.log(
                        "üîÑ SUBSTITUI√á√ÉO COMPLETA: Fun√ß√£o original substitu√≠da por vers√£o robusta",
                    );
                    correcoesAplicadas.push(
                        "Fun√ß√£o original completamente substitu√≠da por vers√£o robusta",
                    );
                } else {
                    console.log(
                        "üÜï CRIA√á√ÉO: Fun√ß√£o switchRelevanciaDocumento robusta criada do zero",
                    );
                    correcoesAplicadas.push("Fun√ß√£o robusta criada do zero");
                }

                // üõ°Ô∏è PROTE√á√ÉO: Observar e re-aplicar se a fun√ß√£o for sobrescrita
                let reprotecaoAttempts = 0;
                const maxReprotecaoAttempts = 5;

                const observerReprotecao = new MutationObserver(() => {
                    if (
                        window.switchRelevanciaDocumento !==
                            switchRelevanciaDocumentoRobusta &&
                        reprotecaoAttempts < maxReprotecaoAttempts
                    ) {
                        reprotecaoAttempts++;
                        console.log(
                            `üîÑ REPROTEC√á√ÉO ${reprotecaoAttempts}: Re-aplicando fun√ß√£o robusta...`,
                        );
                        window.switchRelevanciaDocumento =
                            switchRelevanciaDocumentoRobusta;
                        correcoesAplicadas.push(
                            `Re-prote√ß√£o aplicada (tentativa ${reprotecaoAttempts})`,
                        );
                    }
                });

                observerReprotecao.observe(document.body, {
                    childList: true,
                    subtree: true,
                });

                // Parar observer ap√≥s 30 segundos para evitar overhead
                setTimeout(() => {
                    observerReprotecao.disconnect();
                    console.log(
                        "üõë Observer de re-prote√ß√£o desativado ap√≥s 30 segundos",
                    );
                }, 30000);

                // üîß CORRIGIR links onclick existentes para usar nossa fun√ß√£o robusta
                setTimeout(() => {
                    const linksEstrela = document.querySelectorAll(
                        'a[onclick*="switchRelevanciaDocumento"], img[onclick*="switchRelevanciaDocumento"]',
                    );
                    console.log(
                        `üîó CORRE√á√ÉO: Encontrados ${linksEstrela.length} links com switchRelevanciaDocumento`,
                    );

                    linksEstrela.forEach((link, index) => {
                        try {
                            // Pular links j√° protegidos pela nossa extens√£o
                            if (
                                link.classList?.contains(
                                    "eprobe-icon-protected",
                                ) ||
                                link.dataset?.eprobeProtected === "true"
                            ) {
                                console.log(
                                    `üõ°Ô∏è PROTE√á√ÉO: Link ${index} j√° protegido pelo eProbe, mantendo...`,
                                );
                                return;
                            }

                            const onclickOriginal =
                                link.getAttribute("onclick");
                            if (
                                onclickOriginal &&
                                onclickOriginal.includes(
                                    "switchRelevanciaDocumento",
                                )
                            ) {
                                // Garantir que usa a fun√ß√£o global robusta
                                const novoOnclick = onclickOriginal.replace(
                                    /switchRelevanciaDocumento\(/g,
                                    "window.switchRelevanciaDocumento(",
                                );

                                if (novoOnclick !== onclickOriginal) {
                                    link.setAttribute("onclick", novoOnclick);
                                    link.classList.add(
                                        "eprobe-link-corrigido-robusta",
                                    );
                                    console.log(
                                        `‚úÖ LINK ${index} CORRIGIDO: onclick atualizado para vers√£o robusta`,
                                    );
                                    correcoesAplicadas.push(
                                        `Link onclick corrigido robustamente (${index})`,
                                    );
                                }
                            }
                        } catch (linkError) {
                            console.warn(
                                `‚ö†Ô∏è Erro ao corrigir link ${index}:`,
                                linkError,
                            );
                        }
                    });
                }, 500);

                console.log(
                    `‚úÖ CORRE√á√ÉO ROBUSTA COMPLETA: ${correcoesAplicadas.length} corre√ß√µes aplicadas:`,
                    correcoesAplicadas,
                );

                return {
                    status: "sucesso_robusta",
                    correcoesAplicadas: correcoesAplicadas.length,
                    detalhes: correcoesAplicadas,
                    funcaoOriginal: funcaoOriginal ? "substitu√≠da" : "criada",
                };
            }

            /**
             * üîß FUN√á√ÉO CR√çTICA: Corrigir problemas com switchRelevanciaDocumento do eProc
             * Garante que a fun√ß√£o de marcar/desmarcar eventos como relevantes funcione
             */
            function corrigirSwitchRelevanciaDocumento() {
                console.log(
                    "üîß CORRE√á√ÉO: Iniciando corre√ß√£o da fun√ß√£o switchRelevanciaDocumento...",
                );

                const correcoesAplicadas = [];

                // 1. Interceptar e corrigir erros na fun√ß√£o switchRelevanciaDocumento
                if (typeof window.switchRelevanciaDocumento === "function") {
                    const originalFunction = window.switchRelevanciaDocumento;

                    window.switchRelevanciaDocumento = function (...args) {
                        try {
                            console.log(
                                "üîç INTERCEPTA√á√ÉO: switchRelevanciaDocumento chamada com args:",
                                args,
                            );
                            return originalFunction.apply(this, args);
                        } catch (error) {
                            console.error(
                                "‚ùå ERRO interceptado em switchRelevanciaDocumento:",
                                error,
                            );

                            // Tentar recuperar e executar manualmente se poss√≠vel
                            if (args.length >= 4) {
                                const [idEvento, relevancia, tipo, urlAjax] =
                                    args;
                                console.log("üîß TENTATIVA DE RECUPERA√á√ÉO:", {
                                    idEvento,
                                    relevancia,
                                    tipo,
                                    urlAjax,
                                });

                                // Fazer chamada AJAX manual se poss√≠vel
                                if (urlAjax && typeof urlAjax === "string") {
                                    try {
                                        const xhr = new XMLHttpRequest();
                                        const fullUrl =
                                            urlAjax +
                                            "&idEvento=" +
                                            idEvento +
                                            "&relevancia=" +
                                            relevancia +
                                            "&tipo=" +
                                            tipo;

                                        xhr.open("GET", fullUrl, true);
                                        xhr.onreadystatechange = function () {
                                            if (
                                                xhr.readyState === 4 &&
                                                xhr.status === 200
                                            ) {
                                                console.log(
                                                    "‚úÖ RECUPERA√á√ÉO: Requisi√ß√£o AJAX manual executada com sucesso",
                                                );
                                                // Atualizar visualmente o √≠cone
                                                atualizarIconeEstrela(
                                                    idEvento,
                                                    relevancia,
                                                );
                                            }
                                        };
                                        xhr.send();

                                        correcoesAplicadas.push(
                                            "Requisi√ß√£o AJAX manual executada",
                                        );
                                        return true;
                                    } catch (ajaxError) {
                                        console.error(
                                            "‚ùå ERRO na recupera√ß√£o AJAX:",
                                            ajaxError,
                                        );
                                    }
                                }
                            }

                            // Se n√£o conseguiu recuperar, mostrar erro amig√°vel
                            alert(
                                "Erro ao alterar relev√¢ncia do evento. Tente recarregar a p√°gina.",
                            );
                            return false;
                        }
                    };

                    correcoesAplicadas.push(
                        "Fun√ß√£o switchRelevanciaDocumento interceptada",
                    );
                    console.log(
                        "‚úÖ CORRE√á√ÉO: switchRelevanciaDocumento interceptada com prote√ß√£o",
                    );
                }

                // 2. Fun√ß√£o auxiliar para atualizar visualmente os √≠cones de estrela
                function atualizarIconeEstrela(idEvento, relevancia) {
                    // Procurar o √≠cone relacionado ao evento
                    const iconesEstrela = document.querySelectorAll(
                        'img[src*="Estrela"], img[data-eprobe-protected="true"]',
                    );

                    iconesEstrela.forEach((icone) => {
                        // Verificar se o √≠cone pertence ao evento correto (por contexto ou id)
                        const eventoContainer = icone.closest(
                            'tr, .evento, [id*="evento"]',
                        );
                        if (
                            eventoContainer &&
                            eventoContainer.textContent.includes(idEvento)
                        ) {
                            if (relevancia === "1") {
                                // Mudar para estrela acesa
                                if (icone.src.includes("EstrelaApagada")) {
                                    icone.src = icone.src.replace(
                                        "EstrelaApagada",
                                        "EstrelaAcesa",
                                    );
                                    icone.alt = "Evento relevante";
                                    icone.title = "Relevante";
                                }
                            } else {
                                // Mudar para estrela apagada
                                if (icone.src.includes("EstrelaAcesa")) {
                                    icone.src = icone.src.replace(
                                        "EstrelaAcesa",
                                        "EstrelaApagada",
                                    );
                                    icone.alt = "Evento normal";
                                    icone.title = "Marcar como relevante";
                                }
                            }
                        }
                    });
                }

                console.log(
                    `‚úÖ CORRE√á√ÉO: ${correcoesAplicadas.length} corre√ß√µes aplicadas para switchRelevanciaDocumento:`,
                    correcoesAplicadas,
                );

                return {
                    status: "sucesso",
                    correcoesAplicadas: correcoesAplicadas.length,
                    detalhes: correcoesAplicadas,
                };
            }

            /**
             * DESABILITADO: For√ßa a reaplica√ß√£o dos √≠cones em caso de falha
             * Esta fun√ß√£o pode estar interferindo com os √≠cones de estrela do eProc
             */
            function forcarReaplicacaoIcones() {
                // Delega para substituirTodosIcones com force mode
                return substituirTodosIcones(document, { force: true });
            }

            /**
             * Inicializa o sistema de substitui√ß√£o de √≠cones
             * Fun√ß√£o principal que coordena toda a substitui√ß√£o
             */
            function inicializarSubstituicaoIcones() {
                if (!isCapaProcessoPage()) {
                    return false;
                }
                if (MODO_ULTRA_PERFORMANCE) {
                    return false;
                }
                // Delega para funcao unificada
                var resultado = substituirTodosIcones();
                log(
                    "ICONES: Inicializacao concluida -",
                    resultado,
                    "icones substituidos",
                );
                return resultado;
            }

            /**
             * Diagn√≥stico espec√≠fico para problemas com √≠cones CSS
             * Analisa o estado atual dos √≠cones na p√°gina
             */
            // Diagnostico de icones - delega para funcao unificada
            function diagnosticarIconesCSS() {
                return debugIcones();
            }

            // ========================================
            // FUN√á√ïES GLOBAIS PARA GERENCIAMENTO DOS DADOS
            // ========================================

            /**
             * Fun√ß√£o global para obter o tipo de julgamento
             * @returns {string|null} - Tipo do julgamento (ex: "M√©rito", "Embargos de Declara√ß√£o")
             */
            function getTipoJulgamentoProcessoPautado() {
                return TipoJulgamentoProcessoPautado;
            }

            /**
             * Fun√ß√£o global para definir o tipo de julgamento
             * @param {string} tipo - Tipo do julgamento
             */
            function setTipoJulgamentoProcessoPautado(tipo) {
                TipoJulgamentoProcessoPautado = tipo;
                log("üìã TIPO: Tipo de julgamento definido:", tipo);
            }

            /**
             * Fun√ß√£o global para obter o status do julgamento
             * @returns {string|null} - Status do julgamento (ex: "Julgado em Pauta", "Retirado em Pauta")
             */
            function getStatusJulgamento() {
                return StatusJulgamento;
            }

            /**
             * Fun√ß√£o global para definir o status do julgamento
             * @param {string} status - Status do julgamento
             */
            function setStatusJulgamento(status) {
                StatusJulgamento = status;
                log("üìä STATUS: Status de julgamento definido:", status);
            }

            /**
             * Fun√ß√£o global para obter a data da sess√£o
             * @returns {string|null} - Data da sess√£o (ex: "10/04/2025")
             */
            function getDataSessao() {
                return DataSessao;
            }

            /**
             * Fun√ß√£o global para definir a data da sess√£o
             * @param {string} data - Data da sess√£o
             */
            function setDataSessao(data) {
                DataSessao = data;
                log("üìÖ DATA: Data da sess√£o definida:", data);
            }

            /**
             * Fun√ß√£o para resetar todos os dados globais da sess√£o
             */
            function resetDadosGlobaisSessao() {
                TipoJulgamentoProcessoPautado = null;
                StatusJulgamento = null;
                DataSessao = null;
                log(
                    "üîÑ RESET: Todos os dados globais da sess√£o foram resetados",
                );
            }

            /**
             * Fun√ß√£o para mostrar todos os dados globais da sess√£o
             */
            function showDadosGlobaisSessao() {
                log("üìä DADOS GLOBAIS DA SESS√ÉO:");
                log("   Tipo de Julgamento:", TipoJulgamentoProcessoPautado);
                log("   Status do Julgamento:", StatusJulgamento);
                log("   Data da Sess√£o:", DataSessao);

                return {
                    tipoJulgamento: TipoJulgamentoProcessoPautado,
                    statusJulgamento: StatusJulgamento,
                    dataSessao: DataSessao,
                };
            }

            // ‚ùå FUN√á√ÉO REMOVIDA: detectarStatusSessao()
            // ‚úÖ USE AGORA: detectarSessoesUnificado()

            /**
             * Retorna o texto do card baseado no status da sess√£o
             * @param {Object} statusSessao - Objeto com informa√ß√µes do status
             * @returns {string} - Texto para exibir no card
             */
            function obterTextoCardPorStatus(statusSessao) {
                if (!statusSessao) {
                    return "Processo Pautado"; // Fallback padr√£o
                }

                switch (statusSessao.status) {
                    case "Inclu√≠do":
                        return "Processo Pautado";
                    case "Julgado":
                        return "Processo Julgado";
                    case "Retirado":
                        return "Processo retirado de pauta";
                    default:
                        return "Processo Pautado";
                }
            }

            /**
             * Retorna a cor do card baseado no status da sess√£o
             * @param {Object} statusSessao - Objeto com informa√ß√µes do status
             * @returns {string} - Cor em formato hex
             */
            function obterCorCardPorStatus(statusSessao) {
                if (!statusSessao) {
                    return "#3b82f6"; // Azul padr√£o
                }

                switch (statusSessao.status) {
                    case "Inclu√≠do":
                        return "#3b82f6"; // Azul para pautado
                    case "Julgado":
                        return "#16a34a"; // Verde para julgado
                    case "Retirado":
                        return "#dc2626"; // Vermelho para retirado
                    default:
                        return "#3b82f6";
                }
            }

            // FUN√á√ÉO REMOVIDA: detectarDataSessaoComStatus - substitu√≠da por detectarCardSessaoSimplificado √öNICA

            // Fun√ß√µes auxiliares para gerenciar status de sess√£o
            function getStatusSessao() {
                return dataSessaoPautado?.statusSessao || null;
            }

            function hasStatusSessao() {
                return (
                    dataSessaoPautado?.statusSessao !== null &&
                    dataSessaoPautado?.statusSessao !== undefined
                );
            }

            function resetStatusSessao() {
                if (dataSessaoPautado) {
                    delete dataSessaoPautado.statusSessao;
                }
                log("üîÑ STATUS: Status da sess√£o resetado");
            }

            function showStatusSessaoInfo() {
                const status = getStatusSessao();
                if (status) {
                    const info = `üìã STATUS DA SESS√ÉO DETECTADO:
                
    Status: ${status.status}
    Descri√ß√£o: ${status.descricao}
    Tipo do Processo: ${status.tipoProcesso}
    Data: ${status.data.dataFormatada}
    √ìrg√£o: ${traduzirSiglaOrgao(status.orgao)}
    Texto Completo: ${status.textoCompleto}`;

                    log(info);
                    alert(info);
                    return status;
                } else {
                    const msg =
                        "‚ùå Nenhum status de sess√£o foi detectado ainda.";
                    log(msg);
                    alert(msg);
                    return null;
                }
            }

            // ========================================
            // FUN√á√ïES DE TESTE E DEBUG PARA STATUS DE SESS√ÉO
            // ========================================

            /**
             * Testa o sistema completo de detec√ß√£o de status de sess√£o
             * @returns {Object} - Resultado do teste com informa√ß√µes detalhadas
             */
            function testarSistemaStatusSessao() {
                log("üß™ TESTE: Iniciando teste completo do sistema de status");

                try {
                    // 1. Verificar se h√° data de sess√£o detectada
                    const temDataSessao = hasDataSessaoPautado();
                    log(
                        `üìä Data de sess√£o detectada: ${
                            temDataSessao ? "SIM" : "N√ÉO"
                        }`,
                    );

                    if (temDataSessao) {
                        const dadosSessao = getDataSessaoPautado();
                        log(`üìÖ Data: ${dadosSessao.dataFormatada}`);
                    }

                    // 2. Testar detec√ß√£o de status
                    const statusDetectado = detectarStatusSessao();
                    log(
                        `üéØ Status detectado: ${
                            statusDetectado ? "SIM" : "N√ÉO"
                        }`,
                    );

                    if (statusDetectado) {
                        log(`üìã Status: ${statusDetectado.status}`);
                        log(`üìù Descri√ß√£o: ${statusDetectado.descricao}`);
                        log(`üìÖ Data: ${statusDetectado.data.dataFormatada}`);
                        log(
                            `üèõÔ∏è √ìrg√£o: ${traduzirSiglaOrgao(
                                statusDetectado.orgao,
                            )}`,
                        );
                    }

                    // 3. Testar fun√ß√µes de texto e cor
                    const textoCard = obterTextoCardPorStatus(statusDetectado);
                    const corCard = obterCorCardPorStatus(statusDetectado);

                    log(`üé® Texto do card: "${textoCard}"`);
                    log(`üé® Cor do card: ${corCard}`);

                    // 4. Verificar interface
                    const cardExiste =
                        document.getElementById("eprobe-data-sessao");
                    log(`üñºÔ∏è Card na interface: ${cardExiste ? "SIM" : "N√ÉO"}`);

                    const resultado = {
                        temDataSessao,
                        statusDetectado,
                        textoCard,
                        corCard,
                        cardExiste: !!cardExiste,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };

                    log("‚úÖ TESTE: Sistema testado com sucesso!");
                    return resultado;
                } catch (error) {
                    console.error("‚ùå TESTE: Erro durante o teste:", error);
                    return {
                        erro: error.message,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };
                }
            }

            /**
             * Debug dos padr√µes de busca para status de sess√£o
             * Mostra quais padr√µes est√£o encontrando matches no texto da p√°gina
             */
            function debugPadroesStatusSessao() {
                log("üîç DEBUG: Analisando padr√µes de status de sess√£o");

                try {
                    // Obter texto completo da p√°gina
                    const textoCompleto = document.body.innerText;
                    log(
                        `üìÑ Texto da p√°gina: ${textoCompleto.length} caracteres`,
                    );

                    // Padr√µes a serem testados
                    const padroes = [
                        {
                            nome: "Inclu√≠do em Pauta",
                            regex: /([A-Za-z√Ä-√ø\s]+(?:Interno|Declara√ß√£o|M√©rito|Preliminar|Cautelar|Retrata√ß√£o))\s*\(Inclu√≠do em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi,
                            status: "Pautado",
                        },
                        {
                            nome: "Inclu√≠do em Mesa",
                            regex: /([A-Za-z√Ä-√ø\s]+(?:Interno|Declara√ß√£o|M√©rito|Preliminar|Cautelar|Retrata√ß√£o))\s*\(Inclu√≠do em Mesa em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi,
                            status: "Pautado",
                        },
                        {
                            nome: "Julgado em Pauta",
                            regex: /([A-Za-z√Ä-√ø\s]+(?:Interno|Declara√ß√£o|M√©rito|Preliminar|Cautelar))\s*\(Julgado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi,
                            status: "Julgado",
                        },
                        {
                            nome: "Retirado em Pauta",
                            regex: /([A-Za-z√Ä-√ø\s]+(?:Interno|Declara√ß√£o|M√©rito|Preliminar|Cautelar))\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi,
                            status: "Retirado",
                        },
                    ];

                    let encontrados = 0;

                    // Testar cada padr√£o
                    padroes.forEach((padrao, index) => {
                        log(
                            `\nüîç Testando padr√£o ${index + 1}: ${padrao.nome}`,
                        );

                        // Resetar regex
                        padrao.regex.lastIndex = 0;

                        const matches = textoCompleto.match(padrao.regex);

                        if (matches && matches.length > 0) {
                            encontrados++;
                            log(
                                `‚úÖ MATCH ENCONTRADO! (${
                                    matches.length
                                } ocorr√™ncia${matches.length > 1 ? "s" : ""})`,
                            );

                            matches.forEach((match, i) => {
                                log(`   ${i + 1}. "${match}"`);
                            });

                            // Tentar extrair detalhes do primeiro match
                            padrao.regex.lastIndex = 0;
                            const detalhes = padrao.regex.exec(textoCompleto);
                            if (detalhes) {
                                log(`   üìã Tipo: ${detalhes[1]?.trim()}`);
                                log(`   üìÖ Data: ${detalhes[2]}`);
                                log(`   üèõÔ∏è √ìrg√£o: ${detalhes[3]}`);
                            }
                        } else {
                            logError(`‚ùå Nenhum match encontrado`);
                        }
                    });

                    log(
                        `\nüìä RESUMO: ${encontrados} ${
                            encontrados === 1
                                ? "padr√£o encontrado"
                                : "padr√µes encontrados"
                        }`,
                    );

                    // Buscar por texto relacionado a sess√£o
                    const termosRelacionados = [
                        "Inclu√≠do em Pauta",
                        "Julgado em Pauta",
                        "Retirado em Pauta",
                        "sess√£o",
                        "julgamento",
                        "pauta",
                    ];

                    log("\nüîç Buscando termos relacionados:");
                    termosRelacionados.forEach((termo) => {
                        const regex = new RegExp(termo, "gi");
                        const matches = textoCompleto.match(regex);
                        log(
                            `   "${termo}": ${
                                matches ? matches.length : 0
                            } ocorr√™ncia${
                                matches && matches.length !== 1 ? "s" : ""
                            }`,
                        );
                    });

                    return {
                        totalPadroes: padroes.length,
                        padroesEncontrados: encontrados,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };
                } catch (error) {
                    console.error(
                        "‚ùå DEBUG: Erro durante debug dos padr√µes:",
                        error,
                    );
                    return { erro: error.message };
                }
            }

            /**
             * For√ßa a detec√ß√£o de um status espec√≠fico (para testes)
             * @param {string} tipoStatus - "pautado", "julgado" ou "retirado"
             * @returns {Object|null} - Objeto com status for√ßado ou null se inv√°lido
             */
            function forcarStatusSessao(tipoStatus = "pautado") {
                log(`üöÄ FOR√áA: For√ßando status "${tipoStatus}"`);

                try {
                    const statusValidos = {
                        pautado: {
                            status: "Pautado",
                            descricao: "Processo Pautado",
                            cor: "#134377",
                        },
                        julgado: {
                            status: "Julgado",
                            descricao: "Processo Julgado",
                            cor: "#16a34a",
                        },
                        retirado: {
                            status: "Retirado",
                            descricao: "Processo Retirado de Pauta",
                            cor: "#dc2626",
                        },
                    };

                    const tipoLower = tipoStatus.toLowerCase();

                    if (!statusValidos[tipoLower]) {
                        console.error(
                            `‚ùå FOR√áA: Status "${tipoStatus}" inv√°lido. Use: pautado, julgado ou retirado`,
                        );
                        return null;
                    }

                    const config = statusValidos[tipoLower];
                    const dataAtual = new Date();
                    const dataFormatada = dataAtual.toLocaleDateString("pt-BR");

                    // Criar objeto de status for√ßado
                    const statusForcado = {
                        status: config.status,
                        descricao: config.descricao,
                        tipoProcesso: "Teste For√ßado",
                        data: {
                            dataFormatada: dataFormatada,
                            dataObject: dataAtual,
                        },
                        orgao: "TESTE",
                        textoCompleto: `Teste For√ßado (${config.status} em Pauta em ${dataFormatada} - TESTE)`,
                        forcado: true,
                    };

                    log(
                        `‚úÖ FOR√áA: Status "${config.status}" criado artificialmente`,
                    );
                    log(`üìÖ Data: ${dataFormatada}`);
                    log(`üé® Cor: ${config.cor}`);

                    // Testar fun√ß√µes relacionadas
                    const textoCard = obterTextoCardPorStatus(statusForcado);
                    const corCard = obterCorCardPorStatus(statusForcado);

                    log(`üé® Texto do card: "${textoCard}"`);
                    log(`üé® Cor do card: ${corCard}`);

                    // Opcionalmente atualizar a interface se houver data de sess√£o
                    if (hasDataSessaoPautado()) {
                        log("üñºÔ∏è Atualizando interface com status for√ßado...");

                        // Salvar dados temporariamente
                        const dadosOriginais = dataSessaoPautado;

                        // Aplicar status for√ßado
                        if (dataSessaoPautado) {
                            dataSessaoPautado.statusSessao = statusForcado;
                        }

                        // Tentar atualizar interface
                        const sucesso = atualizarDataSessaoNaInterface();
                        log(
                            `üñºÔ∏è Interface atualizada: ${
                                sucesso ? "SIM" : "N√ÉO"
                            }`,
                        );

                        // Restaurar dados originais ap√≥s 5 segundos
                        setTimeout(() => {
                            dataSessaoPautado = dadosOriginais;
                            log("üîÑ FOR√áA: Dados originais restaurados");
                        }, 5000);
                    }

                    return statusForcado;
                } catch (error) {
                    console.error("‚ùå FOR√áA: Erro ao for√ßar status:", error);
                    return null;
                }
            }

            /**
             * For√ßa uma nova detec√ß√£o de status e atualiza√ß√£o do card
             */
            function forcarAtualizacaoStatus() {
                log("üîÑ FOR√áA: For√ßando atualiza√ß√£o do status da sess√£o");

                try {
                    // 1. Re-detectar status
                    const novoStatus = detectarStatusSessao();
                    log("üîç Novo status detectado:", novoStatus);

                    // 2. Atualizar dados se h√° sess√£o
                    if (hasDataSessaoPautado() && novoStatus) {
                        dataSessaoPautado.statusSessao = novoStatus;
                        log("‚úÖ Status atualizado nos dados da sess√£o");
                    }

                    // 3. For√ßar atualiza√ß√£o da interface
                    const cardExistente =
                        document.getElementById("eprobe-data-sessao");
                    if (cardExistente) {
                        log("üóëÔ∏è Removendo card existente");
                        cardExistente.remove();
                    }

                    // 4. Re-inserir com novo status
                    setTimeout(() => {
                        const sucesso = inserirDataSessaoNaInterface();
                        if (sucesso) {
                            log("‚úÖ Card atualizado com novo status");
                        } else {
                            logError("‚ùå Falha ao re-inserir card");
                        }
                    }, 100);

                    return novoStatus;
                } catch (error) {
                    console.error(
                        "‚ùå Erro ao for√ßar atualiza√ß√£o de status:",
                        error,
                    );
                    return null;
                }
            }

            /**
             * Testa especificamente o caso "Retirado em Pauta"
             */
            function testarCasoRetirado() {
                log("üß™ TESTE: Testando caso espec√≠fico 'Retirado em Pauta'");

                // Texto de exemplo do usu√°rio
                const textoExemplo =
                    "M√©rito (Retirado em Pauta em 10/04/2025 - CAMPUB5)";
                log(`üìù Texto de exemplo: "${textoExemplo}"`);

                // Testar regex espec√≠fico
                const regexRetirado =
                    /([A-Za-z√Ä-√ø\s]+(?:Interno|Declara√ß√£o|M√©rito|Preliminar|Cautelar))\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi;

                const match = textoExemplo.match(regexRetirado);
                log("üîç Match resultado:", match);

                if (match) {
                    regexRetirado.lastIndex = 0;
                    const detalhes = regexRetirado.exec(textoExemplo);
                    log("üìã Detalhes extra√≠dos:", detalhes);

                    if (detalhes) {
                        const resultado = {
                            tipo: detalhes[1]?.trim(),
                            data: detalhes[2],
                            orgao: detalhes[3],
                            status: "Retirado",
                            descricao: "Processo Retirado de Pauta",
                        };

                        log("‚úÖ RESULTADO:", resultado);

                        // Testar cores e textos
                        const textoCard = obterTextoCardPorStatus({
                            status: "Retirado",
                        });
                        const corCard = obterCorCardPorStatus({
                            status: "Retirado",
                        });

                        log(`üé® Texto do card: "${textoCard}"`);
                        log(`üé® Cor do card: ${corCard}`);

                        return resultado;
                    }
                } else {
                    logError(
                        "‚ùå FALHA: Regex n√£o funcionou com o texto de exemplo",
                    );
                }

                // Buscar na se√ß√£o espec√≠fica das minutas
                log("üîç Procurando na se√ß√£o de minutas...");
                const minutasElement = document.getElementById("fldMinutas");
                if (minutasElement) {
                    const textoMinutas =
                        minutasElement.innerText ||
                        minutasElement.textContent ||
                        "";
                    log(
                        `üìù Texto das minutas encontrado (${textoMinutas.length} chars):`,
                        textoMinutas.substring(0, 200) + "...",
                    );

                    const matchMinutas = textoMinutas.match(regexRetirado);
                    if (matchMinutas) {
                        log(
                            "‚úÖ Padr√£o 'Retirado' encontrado nas minutas:",
                            matchMinutas,
                        );

                        // Simular detec√ß√£o correta
                        regexRetirado.lastIndex = 0;
                        const detalhesMinutas =
                            regexRetirado.exec(textoMinutas);
                        if (detalhesMinutas) {
                            const resultadoMinutas = {
                                tipo: detalhesMinutas[1]?.trim(),
                                data: detalhesMinutas[2],
                                orgao: detalhesMinutas[3],
                                status: "Retirado",
                                descricao: "Processo Retirado de Pauta",
                            };
                            log("‚úÖ RESULTADO DAS MINUTAS:", resultadoMinutas);
                            return resultadoMinutas;
                        }
                    } else {
                        logError(
                            "‚ùå Padr√£o 'Retirado' n√£o encontrado nas minutas",
                        );

                        // Verificar padr√µes mais simples
                        if (/retirado/i.test(textoMinutas)) {
                            logError(
                                "‚ö†Ô∏è Palavra 'retirado' encontrada nas minutas",
                            );
                            log(
                                "üìù Contexto:",
                                textoMinutas.match(
                                    /(.{0,50}retirado.{0,50})/gi,
                                ),
                            );
                        }
                    }
                } else {
                    logError("‚ùå Elemento #fldMinutas n√£o encontrado");
                }

                // Verificar em toda a p√°gina como fallback
                log("üîç Testando na p√°gina completa...");
                const textoCompleto = document.body.innerText;
                const matchPagina = textoCompleto.match(regexRetirado);

                if (matchPagina) {
                    log("‚úÖ Encontrado padr√£o 'Retirado' na p√°gina");
                } else {
                    logError("‚ùå Padr√£o 'Retirado' n√£o encontrado na p√°gina");

                    // Verificar se h√° pelo menos a palavra "retirado"
                    if (/retirado/i.test(textoCompleto)) {
                        log(
                            "‚ö†Ô∏è Palavra 'retirado' encontrada, mas n√£o no padr√£o esperado",
                        );
                        const contextosRetirado = textoCompleto.match(
                            /(.{0,80}retirado.{0,80})/gi,
                        );
                        if (contextosRetirado) {
                            log(
                                "üìù Contextos encontrados:",
                                contextosRetirado.slice(0, 3),
                            );
                        }
                    } else {
                        logError(
                            "‚ùå Palavra 'retirado' n√£o encontrada na p√°gina",
                        );
                    }
                }

                return null;
            }

            /**
             * Debug completo do status da sess√£o
             */
            function debugStatusCompleto() {
                log("üß™ DEBUG STATUS COMPLETO: Verificando detec√ß√£o de status");

                // 1. Verificar estado atual
                log("üìä ESTADO ATUAL:");
                log("   Data sess√£o pautado:", dataSessaoPautado);
                log("   Processo atual:", processoAtual);
                log("   Processo com data:", processoComDataSessao);

                // 2. Executar detec√ß√£o de status
                log("üîç EXECUTANDO DETEC√á√ÉO:");
                const statusDetectado = detectarStatusSessao();
                log("   Status detectado:", statusDetectado);

                // 3. Verificar status armazenado
                log("üíæ STATUS ARMAZENADO:");
                const statusArmazenado = getStatusSessao();
                log("   Status via getStatusSessao():", statusArmazenado);

                // 4. Verificar texto na p√°gina
                const textoCompleto = document.body.innerText;
                log("üìù VERIFICA√á√ïES DE TEXTO:");

                // Procurar por diferentes padr√µes
                const padroes = [
                    { nome: "Retirado", regex: /retirado\s+em\s+pauta/i },
                    { nome: "Julgado", regex: /julgado\s+em\s+pauta/i },
                    { nome: "Inclu√≠do", regex: /inclu√≠do\s+em\s+pauta/i },
                ];

                padroes.forEach((padrao) => {
                    const encontrado = textoCompleto.match(padrao.regex);
                    if (encontrado) {
                        log(`   ‚úÖ ${padrao.nome}: "${encontrado[0]}"`);
                    } else {
                        logError(`   ‚ùå ${padrao.nome}: n√£o encontrado`);
                    }
                });

                // 5. Simular chamada da interface
                log("üé® SIMULA√á√ÉO INTERFACE:");
                const textoCard = obterTextoCardPorStatus(statusArmazenado);
                const corCard = obterCorCardPorStatus(statusArmazenado);
                log(`   Texto do card: "${textoCard}"`);
                log(`   Cor do card: ${corCard}`);

                return {
                    statusDetectado,
                    statusArmazenado,
                    textoCard,
                    corCard,
                    temTextoRetirado: /retirado\s+em\s+pauta/i.test(
                        textoCompleto,
                    ),
                };
            }

            /**
             * Debug do padr√£o espec√≠fico "Retirado"
             */
            function debugPadraoRetirado() {
                log(
                    "üß™ DEBUG RETIRADO: Testando detec√ß√£o de padr√£o 'Retirado em Pauta'",
                );

                // Texto de exemplo fornecido pelo usu√°rio
                const textoTeste =
                    "M√©rito (Retirado em Pauta em 10/04/2025 - CAMPUB5)";
                log(`üìù Texto de teste: "${textoTeste}"`);

                // Testar o padr√£o regex espec√≠fico
                const padraoRetirado =
                    /([A-Za-z√Ä-√ø\s]+(?:Interno|Declara√ß√£o|M√©rito|Preliminar|Cautelar))\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi;

                const match = textoTeste.match(padraoRetirado);
                log("üîç Match resultado:", match);

                if (match) {
                    // Resetar lastIndex para nova busca
                    padraoRetirado.lastIndex = 0;
                    const detalhes = padraoRetirado.exec(textoTeste);
                    log("üìã Detalhes extra√≠dos:", detalhes);

                    if (detalhes) {
                        log("‚úÖ SUCESSO:");
                        log(`   Tipo: ${detalhes[1]?.trim()}`);
                        log(`   Data: ${detalhes[2]}`);
                        log(`   √ìrg√£o: ${detalhes[3]}`);
                        log(`   Texto completo: ${detalhes[0]}`);
                    }
                } else {
                    logError("‚ùå FALHA: Padr√£o n√£o encontrou match");
                }

                // Testar tamb√©m com o texto completo da p√°gina atual
                const textoCompleto = document.body.innerText;
                log("üîç Testando na p√°gina atual...");

                const matchPagina = textoCompleto.match(padraoRetirado);
                if (matchPagina) {
                    log("‚úÖ Encontrado na p√°gina:", matchPagina);
                } else {
                    logError("‚ùå N√£o encontrado na p√°gina atual");
                }

                // Procurar por qualquer texto similar
                const buscaRetirado = /retirado\s+em\s+pauta/i;
                const encontrouRetirado = textoCompleto.match(buscaRetirado);
                if (encontrouRetirado) {
                    log("üîç Texto 'retirado em pauta' encontrado na p√°gina");
                } else {
                    log(
                        "‚ùå Texto 'retirado em pauta' N√ÉO encontrado na p√°gina",
                    );
                }
            }

            /**
             * Fun√ß√£o para procurar texto espec√≠fico "Retirado em Pauta" em toda a p√°gina
             */
            function encontrarTextoRetirado() {
                log(
                    "üîç BUSCA: Procurando texto 'Retirado em Pauta' em toda a p√°gina",
                );

                // 1. Buscar em elementos espec√≠ficos primeiro
                const seletores = [
                    "#fldMinutas",
                    "#divInfraAreaProcesso",
                    "#conteudoMinutas",
                    ".infraEventoDescricao",
                    "[id*='minutas']",
                    "[class*='minutas']",
                ];

                seletores.forEach((seletor) => {
                    const elemento = document.querySelector(seletor);
                    if (elemento) {
                        const texto =
                            elemento.innerText || elemento.textContent || "";
                        if (/retirado\s+em\s+pauta/i.test(texto)) {
                            log(
                                `‚úÖ ENCONTRADO em ${seletor}:`,
                                texto.substring(0, 200),
                            );

                            // Buscar o padr√£o espec√≠fico
                            const regex =
                                /([A-Za-z√Ä-√ø\s]+(?:Interno|Declara√ß√£o|M√©rito|Preliminar|Cautelar))\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi;
                            const match = texto.match(regex);
                            if (match) {
                                log(
                                    `üéØ PADR√ÉO ENCONTRADO em ${seletor}:`,
                                    match,
                                );
                            }
                        } else {
                            logError(`‚ùå N√£o encontrado em ${seletor}`);
                        }
                    } else {
                        logError(`‚ùå Elemento ${seletor} n√£o existe`);
                    }
                });

                // 2. Buscar em toda a p√°gina
                const textoCompleto = document.body.innerText;
                const matches = textoCompleto.match(
                    /(.{0,100}retirado\s+em\s+pauta.{0,100})/gi,
                );
                if (matches) {
                    log("üîç CONTEXTOS 'Retirado em Pauta' na p√°gina:");
                    matches.forEach((match, index) => {
                        log(`   ${index + 1}: ${match}`);
                    });
                } else {
                    log(
                        "‚ùå Texto 'Retirado em Pauta' n√£o encontrado na p√°gina",
                    );
                }

                // 3. Testar regex completo na p√°gina
                const regexCompleto =
                    /([A-Za-z√Ä-√ø\s]+(?:Interno|Declara√ß√£o|M√©rito|Preliminar|Cautelar))\s*\(Retirado em Pauta em (\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9]+)\)/gi;
                const matchCompleto = textoCompleto.match(regexCompleto);
                if (matchCompleto) {
                    log("‚úÖ REGEX COMPLETO funcionou:", matchCompleto);
                } else {
                    logError("‚ùå REGEX COMPLETO n√£o encontrou nada");
                }

                return {
                    encontrouTexto: matches ? true : false,
                    contextos: matches || [],
                    matchRegex: matchCompleto || [],
                };
            }

            /**
             * For√ßa uma re-detec√ß√£o completa com logging detalhado
             */
            function forcarDeteccaoCompleta() {
                log("üîÑ FOR√áA: Iniciando detec√ß√£o completa com debug");

                // 1. Procurar texto primeiro
                encontrarTextoRetirado();

                // 2. Executar detec√ß√£o normal
                const statusDetectado = detectarStatusSessao();
                log("üéØ Status detectado:", statusDetectado);

                // 3. For√ßar atualiza√ß√£o se necess√°rio
                if (statusDetectado) {
                    // Atualizar dados globais
                    if (hasDataSessaoPautado()) {
                        dataSessaoPautado.statusSessao = statusDetectado;
                        log("‚úÖ Dados globais atualizados");
                    }

                    // Re-inserir interface
                    forcarAtualizacaoStatus();
                } else {
                    log(
                        "‚ùå Nenhum status detectado - verifique se a p√°gina cont√©m dados de sess√£o",
                    );
                }

                return statusDetectado;
            }
            // Modal customizado para op√ß√µes de processamento de documento
            function showDocumentProcessingModal() {
                return new Promise((resolve) => {
                    const overlay = document.createElement("div");
                    overlay.className = "help-modal-overlay";
                    overlay.innerHTML = `
                        <div class="help-modal" style="max-width: 450px;">
                        <div class="help-modal-header">
                        <h2 style="font-size:1.1rem;display:flex;align-items:center;gap:8px;">
                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:1.2em;height:1.2em;">
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/>
                        <polyline points="14,2 14,8 20,8"/>
                        <line x1="16" y1="13" x2="8" y2="13"/>
                        <line x1="16" y1="17" x2="8" y2="17"/>
                        <polyline points="10,9 9,9 8,9"/>
                        </svg>
                        Documento Selecionado
                        </h2>
                        <button class="help-close-btn" aria-label="Fechar">
                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 6-12 12" /><path d="m6 6 12 12" /></svg>
                        </button>
                        </div>
                        <div class="help-modal-content" style="padding:24px 20px 20px 20px;">
                        <p style="color:rgb(var(--color-text-main));margin-bottom:20px;line-height:1.5;">Como deseja processar o documento selecionado?</p>
                        <div style="margin-bottom:20px;">
                        <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px;padding:12px;border-radius:8px;background:rgb(var(--color-background-alt3));">
                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:1.2em;height:1.2em;color:#134377;flex-shrink:0;">
                        <path d="M15 3h6v6"/>
                        <path d="M10 14 21 3"/>
                        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
                        </svg>
                        <div>
                        <div style="color:rgb(var(--color-text-main));font-weight:500;margin-bottom:4px;">Processamento Manual</div>
                        <div style="color:rgb(var(--color-text-muted));font-size:0.9rem;">Abre o documento em nova aba para extra√ß√£o manual</div>
                        </div>
                        </div>
                        <div style="display:flex;align-items:center;gap:12px;padding:12px;border-radius:8px;background:rgb(var(--color-background-alt3));">
                        <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width:1.2em;height:1.2em;color:#f59e0b;flex-shrink:0;">
                        <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                        <line x1="12" y1="19" x2="12" y2="22"/>
                        <line x1="8" y1="22" x2="16" y2="22"/>
                        </svg>
                        <div>
                        <div style="color:rgb(var(--color-text-main));font-weight:500;margin-bottom:4px;">Processamento via API</div>
                        <div style="color:rgb(var(--color-text-muted));font-size:0.9rem;">Tenta processar diretamente (experimental)</div>
                        </div>
                        </div>
                        </div>
                        <div style="display:flex;gap:12px;justify-content:flex-end;">
                        <button class="btn primary" id="process-manual-btn" style="min-width:120px;">Manual</button>
                        <button class="btn" id="process-api-btn" style="min-width:100px;">Via API</button>
                        </div>
                        </div>
                        </div>
                        `;
                    document.body.appendChild(overlay);
                    const close = (result) => {
                        document.body.removeChild(overlay);
                        resolve(result);
                    };
                    overlay.querySelector(".help-close-btn").onclick = () =>
                        close(true);
                    overlay.querySelector("#process-manual-btn").onclick = () =>
                        close(true);
                    overlay.querySelector("#process-api-btn").onclick = () =>
                        close(false);
                    overlay.addEventListener("click", (e) => {
                        if (e.target === overlay) close(true);
                    });
                });
            }

            // Formatar informa√ß√µes de magistrado/advogado
            function formatarMagistradoAdvogado(texto) {
                if (!texto || texto.trim().length === 0) {
                    return "";
                }

                let textoLimpo = texto.trim();

                // Remover tags HTML (incluindo <br/> e <br>)
                textoLimpo = textoLimpo.replace(/<br\s*\/?>/gi, "\n");
                textoLimpo = textoLimpo.replace(/<[^>]*>/g, "");

                // Separar em linhas e filtrar conte√∫do √∫til
                const linhas = textoLimpo
                    .split(/\n/)
                    .map((l) => l.trim())
                    .filter((l) => l.length > 0)
                    .filter((l) => !l.match(/^(MAGISTRADO|ADVOGADO)$/i)); // Remover labels extras

                // Detectar se √© magistrado ou advogado baseado em palavras-chave
                const isMagistrado =
                    /juiz|ju√≠z|magistrad|vara|gabinete|comarca/i.test(
                        textoLimpo,
                    );

                if (isMagistrado) {
                    // Para magistrados: procurar nome da pessoa e informa√ß√£o da vara
                    let nomePessoa = "";
                    let infoVara = "";

                    for (const linha of linhas) {
                        // Se a linha cont√©m palavras t√≠picas de vara/gabinete, √© info de vara
                        if (/\d+[¬™¬∫]?\s*(vara|gabinete|comarca)/i.test(linha)) {
                            infoVara = linha;
                        }
                        // Se √© um nome de pessoa (cont√©m pelo menos 2 palavras com letras)
                        else if (
                            /^[A-Z√Å√ä√á√ï√ú√Ä√Å√â√ä√ç√ì√î√ö√Ç√É\s]{3,}$/i.test(linha) &&
                            linha.split(" ").length >= 2
                        ) {
                            // Capitalizar corretamente o nome (primeira letra mai√∫scula, resto min√∫scula)
                            nomePessoa = linha
                                .toLowerCase()
                                .split(" ")
                                .map(
                                    (palavra) =>
                                        palavra.charAt(0).toUpperCase() +
                                        palavra.slice(1),
                                )
                                .join(" ");
                        }
                    }

                    // Se encontrou nome e vara, retornar objeto com ambos
                    if (nomePessoa && infoVara) {
                        return {
                            tipo: "magistrado",
                            nome: `Magistrado(a): ${nomePessoa}`,
                            vara: infoVara,
                        };
                    }
                    // Se s√≥ encontrou nome
                    else if (nomePessoa) {
                        return {
                            tipo: "magistrado",
                            nome: `Magistrado(a): ${nomePessoa}`,
                            vara: null,
                        };
                    }
                    // Se s√≥ encontrou vara
                    else if (infoVara) {
                        return {
                            tipo: "magistrado",
                            nome: `Magistrado(a): ${infoVara}`,
                            vara: null,
                        };
                    }
                    // Fallback: usar primeira linha √∫til
                    else if (linhas.length > 0) {
                        const primeiraLinha = linhas[0]
                            .toLowerCase()
                            .split(" ")
                            .map(
                                (palavra) =>
                                    palavra.charAt(0).toUpperCase() +
                                    palavra.slice(1),
                            )
                            .join(" ");
                        return {
                            tipo: "magistrado",
                            nome: `Magistrado(a): ${primeiraLinha}`,
                            vara: null,
                        };
                    }
                } else {
                    // Para advogados: usar a primeira linha que parece um nome
                    let nomeAdvogado =
                        linhas.find(
                            (linha) =>
                                /^[A-Z√Å√ä√á√ï√ú√Ä√Å√â√ä√ç√ì√î√ö√Ç√É\s]{3,}$/i.test(linha) &&
                                linha.split(" ").length >= 2,
                        ) || linhas[0];

                    if (nomeAdvogado) {
                        // Capitalizar corretamente o nome do advogado
                        nomeAdvogado = nomeAdvogado
                            .toLowerCase()
                            .split(" ")
                            .map(
                                (palavra) =>
                                    palavra.charAt(0).toUpperCase() +
                                    palavra.slice(1),
                            )
                            .join(" ");
                        return {
                            tipo: "advogado",
                            nome: `Advogado(a): ${nomeAdvogado}`,
                            vara: null,
                        };
                    }
                }

                // Fallback final
                return textoLimpo;
            }

            // ‚ö†Ô∏è NOTA: Observer de interface foi removido desta se√ß√£o pois setupInterfaceObserver()
            // est√° definido dentro da IIFE principal e n√£o √© acess√≠vel aqui.
            // A inicializa√ß√£o do observer j√° √© feita corretamente dentro da IIFE principal.

            // Fun√ß√£o auxiliar para validar data brasileira
            // üîç IDENTIFICAR PROCESSO - Extrair n√∫mero do processo atual (COM CACHE ANTI-LOOP)
            // Vari√°veis j√° declaradas no topo do arquivo

            function validarDataBrasileira(dataString) {
                log(`üìÖ VALIDA√á√ÉO: Validando data "${dataString}"`);

                // Limpar e normalizar a string da data
                const dataLimpa = dataString.trim().replace(/[^\d\/\-\.]/g, "");
                log(`üìÖ VALIDA√á√ÉO: Data limpa: "${dataLimpa}"`);

                // Tentar diferentes separadores
                const separadores = ["/", "-", "."];
                let partesData = null;
                let separadorUsado = "";

                for (const sep of separadores) {
                    if (dataLimpa.includes(sep)) {
                        partesData = dataLimpa.split(sep);
                        separadorUsado = sep;
                        break;
                    }
                }

                if (!partesData || partesData.length !== 3) {
                    log(
                        `‚ùå VALIDA√á√ÉO: Formato inv√°lido - esperado 3 partes separadas por ${separadores.join(
                            ", ",
                        )}`,
                    );
                    return null;
                }

                // Assumir formato brasileiro: DD/MM/AAAA
                const dia = parseInt(partesData[0], 10);
                const mes = parseInt(partesData[1], 10);
                const ano = parseInt(partesData[2], 10);

                log(
                    `üìÖ VALIDA√á√ÉO: Partes extra√≠das - Dia: ${dia}, M√™s: ${mes}, Ano: ${ano}`,
                );

                // Valida√ß√µes b√°sicas
                if (isNaN(dia) || isNaN(mes) || isNaN(ano)) {
                    logError("‚ùå VALIDA√á√ÉO: Partes n√£o s√£o n√∫meros v√°lidos");
                    return null;
                }

                if (dia < 1 || dia > 31) {
                    log(
                        `‚ùå VALIDA√á√ÉO: Dia inv√°lido: ${dia} (deve estar entre 1 e 31)`,
                    );
                    return null;
                }

                if (mes < 1 || mes > 12) {
                    log(
                        `‚ùå VALIDA√á√ÉO: M√™s inv√°lido: ${mes} (deve estar entre 1 e 12)`,
                    );
                    return null;
                }

                if (ano < 2020 || ano > 2030) {
                    log(
                        `‚ùå VALIDA√á√ÉO: Ano inv√°lido: ${ano} (deve estar entre 2020 e 2030)`,
                    );
                    return null;
                }

                // Criar objeto Date para valida√ß√£o mais rigorosa
                const dataObj = new Date(ano, mes - 1, dia); // mes-1 porque Date usa 0-based months

                if (
                    dataObj.getFullYear() !== ano ||
                    dataObj.getMonth() !== mes - 1 ||
                    dataObj.getDate() !== dia
                ) {
                    log(
                        `‚ùå VALIDA√á√ÉO: Data inexistente no calend√°rio: ${dia}/${mes}/${ano}`,
                    );
                    return null;
                }

                log(
                    `‚úÖ VALIDA√á√ÉO: Data v√°lida confirmada: ${dia}/${mes}/${ano}`,
                );

                // Criar objeto de retorno com informa√ß√µes estruturadas
                const dataValidada = {
                    dataOriginal: dataString,
                    dataFormatada: `${dia.toString().padStart(2, "0")}/${mes
                        .toString()
                        .padStart(2, "0")}/${ano}`,
                    dia: dia,
                    mes: mes,
                    ano: ano,
                    timestamp: dataObj.getTime(),
                    dataObj: dataObj,
                };

                logCritical(
                    `‚úÖ VALIDA√á√ÉO: Objeto de data criado:`,
                    dataValidada,
                );
                return dataValidada;
            }

            // FUN√á√ÉO REMOVIDA: detectarDataSessao - substitu√≠da por detectarCardSessaoSimplificado √öNICA

            // üîç FUN√á√ÉO PARA VERIFICAR STATUS DOS CONTROLES
            function statusControlesRequisicao() {
                const agora = Date.now();
                const info = {
                    tentativasRealizadas: tentativasCruzamento,
                    tentativasRestantes:
                        MAX_TENTATIVAS_CRUZAMENTO - tentativasCruzamento,
                    emAndamento: cruzamentoEmAndamento,
                    proximaTentativaEm: Math.max(
                        0,
                        (DELAY_ENTRE_TENTATIVAS -
                            (agora - ultimaTentativaCruzamento)) /
                            1000,
                    ),
                    temCache: !!cacheResultadoSessoes,
                    cacheValidoPor: Math.max(
                        0,
                        (cacheValidoAte - agora) / 1000,
                    ),
                };

                log("üìä STATUS DOS CONTROLES:", info);
                return info;
            }

            function showDataSessaoPautadoInfo() {
                if (hasDataSessaoPautado()) {
                    const info = `Clique para mais informa√ß√µes`;

                    log(info);
                    alert(info);
                    return dataSessaoPautado;
                } else {
                    const msg =
                        "‚ùå Nenhuma data da sess√£o foi detectada ainda.";
                    log(msg);
                    alert(msg);
                    return null;
                }
            }

            // Fun√ß√£o para remover data da sess√£o da interface
            // VERS√ÉO MATERIAL DESIGN - Remove apenas cards Material Design
            function removerDataSessaoDaInterface() {
                log("üóëÔ∏è REMOVER: Removendo cards Material Design da interface");

                return removerCardMaterialDesign();
            }

            // Fun√ß√£o para atualizar data da sess√£o na interface
            // VERS√ÉO SIMPLIFICADA - Usa sistema XPath direto
            function atualizarDataSessaoNaInterface() {
                log("üîÑ ATUALIZAR: Usando sistema XPath simplificado...");

                // Remover cards antigos
                removerDataSessaoDaInterface();

                // Usar sistema simplificado
                return window.SENT1_AUTO &&
                    window.SENT1_AUTO.detectarCardSessaoSimplificado
                    ? window.SENT1_AUTO.detectarCardSessaoSimplificado()
                    : null;
            }

            // üö® FUN√á√ÉO PARA FOR√áAR INSER√á√ÉO DO CARD MESMO PARA PROCESSOS PROCESSADOS
            function forcarInsercaoCardSemValidacao() {
                log("üö® FOR√áA: For√ßando inser√ß√£o do card sem valida√ß√µes");

                // 1. Verificar se h√° data detectada
                if (!hasDataSessaoPautado()) {
                    logError(
                        "‚ùå FOR√áA: Nenhuma data detectada - tentando detectar",
                    );

                    // For√ßar detec√ß√£o mesmo para processo j√° processado
                    const processoAnterior = processoAtual;
                    const jaProcessadoAnterior = processoAnterior
                        ? processosJaProcessados.has(processoAnterior)
                        : false;

                    if (jaProcessadoAnterior) {
                        log(
                            "üîÑ FOR√áA: Removendo processo da lista de processados temporariamente",
                        );
                        processosJaProcessados.delete(processoAnterior);
                    }

                    // Detectar data
                    const dataDetectada =
                        window.SENT1_AUTO &&
                        window.SENT1_AUTO.detectarCardSessaoSimplificado
                            ? window.SENT1_AUTO.detectarCardSessaoSimplificado()
                            : null;

                    if (!dataDetectada) {
                        logError("‚ùå FOR√áA: Falha na detec√ß√£o da data");
                        if (jaProcessadoAnterior) {
                            processosJaProcessados.add(processoAnterior);
                        }
                        return false;
                    }
                }

                // 2. Remover card existente
                const cardExistente =
                    document.getElementById("eprobe-data-sessao");
                if (cardExistente) {
                    cardExistente.remove();
                    log("üóëÔ∏è FOR√áA: Card existente removido");
                }

                // 3. For√ßar inser√ß√£o
                log("üéØ FOR√áA: Tentando inserir card...");
                const sucesso = inserirDataSessaoNaInterface();

                if (sucesso) {
                    log("‚úÖ FOR√áA: Card inserido com sucesso!");
                    return true;
                } else {
                    logError("‚ùå FOR√áA: Falha na inser√ß√£o do card");
                    return false;
                }
            }

            // ========================================
            // ‚ùå SE√á√ÉO REMOVIDA: FUN√á√ïES DE CRUZAMENTO DE DADOS DE SESS√ÉO
            // ‚úÖ SUBSTITU√çDO POR: detectarSessoesUnificado() - busca espec√≠fica no DOM
            // ========================================

            /**
             * Busca dados das sess√µes de julgamento no eProc
             * @param {string} hash - Hash da p√°gina de sess√µes (opcional)
             * @returns {Promise<Array>} - Array com dados das sess√µes
             */
            async function buscarDadosSessoes(hash = null) {
                log("üîç SESS√ïES: Iniciando busca de dados das sess√µes");

                // üõ°Ô∏è VERIFICAR CACHE PRIMEIRO
                const agora = Date.now();
                if (cacheResultadoSessoes && agora < cacheValidoAte) {
                    log(
                        "üì¶ SESS√ïES: Usando dados do cache (evitando nova requisi√ß√£o)",
                    );
                    return cacheResultadoSessoes;
                }

                // üõ°Ô∏è VERIFICAR SE J√Å EST√Å EM ANDAMENTO
                if (cruzamentoEmAndamento) {
                    log("‚è≥ SESS√ïES: Busca j√° em andamento, aguardando...");
                    return [];
                }

                // üõ°Ô∏è VERIFICAR LIMITE DE TENTATIVAS
                if (tentativasCruzamento >= MAX_TENTATIVAS_CRUZAMENTO) {
                    log(
                        `üö´ SESS√ïES: Limite de ${MAX_TENTATIVAS_CRUZAMENTO} tentativas atingido`,
                    );
                    log(
                        "üí° SESS√ïES: Use window.SENT1_AUTO.debugPaginaSessoes() para debug manual",
                    );
                    return [];
                }

                // üõ°Ô∏è VERIFICAR DELAY ENTRE TENTATIVAS
                if (
                    agora - ultimaTentativaCruzamento <
                    DELAY_ENTRE_TENTATIVAS
                ) {
                    const tempoRestante = Math.ceil(
                        (DELAY_ENTRE_TENTATIVAS -
                            (agora - ultimaTentativaCruzamento)) /
                            1000,
                    );
                    log(
                        `‚è∞ SESS√ïES: Aguardando ${tempoRestante}s antes da pr√≥xima tentativa`,
                    );
                    return [];
                }

                try {
                    // Marcar in√≠cio da busca
                    cruzamentoEmAndamento = true;
                    tentativasCruzamento++;
                    ultimaTentativaCruzamento = agora;

                    log(
                        `üîÑ SESS√ïES: Tentativa ${tentativasCruzamento}/${MAX_TENTATIVAS_CRUZAMENTO}`,
                    );

                    // Construir URL da p√°gina de sess√µes
                    const baseUrl = window.location.origin;
                    const urlSessoes = hash
                        ? `${baseUrl}/eproc/controlador.php?acao=sessao_julgamento_listar&hash=${hash}`
                        : `${baseUrl}/eproc/controlador.php?acao=sessao_julgamento_listar`;

                    log(`üåê SESS√ïES: Buscando URL: ${urlSessoes}`);

                    // Fazer fetch da p√°gina
                    const response = await fetch(urlSessoes, {
                        credentials: "same-origin",
                        headers: {
                            Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                        },
                    });

                    if (!response.ok) {
                        throw new Error(
                            `HTTP ${response.status}: ${response.statusText}`,
                        );
                    }

                    const htmlContent = await response.text();
                    logCritical("‚úÖ SESS√ïES: P√°gina carregada com sucesso");

                    // Fazer parse dos dados
                    const dadosSessoes = await parsearDadosSessoes(htmlContent);
                    log(
                        `üìä SESS√ïES: ${dadosSessoes.length} sess√µes encontradas`,
                    );

                    // üì¶ ARMAZENAR NO CACHE
                    if (dadosSessoes.length > 0) {
                        cacheResultadoSessoes = dadosSessoes;
                        cacheValidoAte = agora + CACHE_DURATION;
                        log(
                            "üì¶ SESS√ïES: Resultado armazenado no cache por 5 minutos",
                        );
                    }

                    return dadosSessoes;
                } catch (error) {
                    console.error(
                        `‚ùå SESS√ïES: Erro ao buscar dados: ${error.message}`,
                    );
                    return [];
                } finally {
                    // Sempre limpar flag de andamento
                    cruzamentoEmAndamento = false;
                }
            }

            /**
             * Faz parse dos dados das sess√µes do HTML
             * @param {string} htmlContent - Conte√∫do HTML da p√°gina
             * @returns {Array} - Array com dados estruturados das sess√µes
             */
            async function parsearDadosSessoes(htmlContent) {
                log("üîç PARSE: Iniciando parse dos dados das sess√µes");

                try {
                    // Criar parser DOM
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(
                        htmlContent,
                        "text/html",
                    );

                    // üîç DEBUG: Verificar estrutura da p√°gina
                    log("üìã PARSE DEBUG: Analisando estrutura da p√°gina...");

                    // Verificar se a p√°gina foi carregada corretamente
                    const title =
                        doc.querySelector("title")?.textContent || "sem t√≠tulo";
                    log(`üìã PARSE DEBUG: T√≠tulo da p√°gina: "${title}"`);

                    // Verificar se h√° redirecionamento para login
                    if (
                        title.toLowerCase().includes("login") ||
                        title.toLowerCase().includes("acesso")
                    ) {
                        log(
                            "‚ùå PARSE DEBUG: P√°gina de login detectada - sess√£o expirada",
                        );
                        return [];
                    }

                    // Buscar diferentes seletores poss√≠veis para a tabela
                    const seletoresTabela = [
                        "#divInfraAreaTelaD .table-responsive table.table",
                        "#divInfraAreaTelaD table.table",
                        ".table-responsive table.table",
                        "table.table",
                        "#divInfraAreaTelaD table",
                        ".table-responsive table",
                        "table",
                        "#frmLista table",
                        "#divInfraAreaTelaE table",
                    ];

                    let tabela = null;
                    let seletorUsado = "";

                    for (const seletor of seletoresTabela) {
                        tabela = doc.querySelector(seletor);
                        if (tabela) {
                            seletorUsado = seletor;
                            log(
                                `‚úÖ PARSE DEBUG: Tabela encontrada com seletor: "${seletor}"`,
                            );
                            break;
                        }
                    }

                    if (!tabela) {
                        // Debug mais detalhado se n√£o encontrar tabela
                        log(
                            "üîç PARSE DEBUG: Nenhuma tabela encontrada, analisando estrutura...",
                        );

                        // Verificar elementos principais
                        const divInfraAreaTelaD =
                            doc.querySelector("#divInfraAreaTelaD");
                        const tableResponsive =
                            doc.querySelector(".table-responsive");
                        const allTables = doc.querySelectorAll("table");
                        const allDivs = doc.querySelectorAll("div[id*='Area']");

                        log(
                            `üìã PARSE DEBUG: #divInfraAreaTelaD encontrado: ${!!divInfraAreaTelaD}`,
                        );
                        log(
                            `üìã PARSE DEBUG: .table-responsive encontrado: ${!!tableResponsive}`,
                        );
                        log(
                            `üìã PARSE DEBUG: Total de tabelas: ${allTables.length}`,
                        );
                        log(
                            `üìã PARSE DEBUG: Divs com 'Area' no ID: ${allDivs.length}`,
                        );

                        // Listar todas as tabelas encontradas
                        allTables.forEach((table, index) => {
                            const tableId = table.id || "sem-id";
                            const tableClass = table.className || "sem-class";
                            const rowCount =
                                table.querySelectorAll("tr").length;
                            log(
                                `üìã PARSE DEBUG: Tabela ${
                                    index + 1
                                }: id="${tableId}", class="${tableClass}", linhas=${rowCount}`,
                            );
                        });

                        // Listar divs com Area no ID
                        allDivs.forEach((div, index) => {
                            log(
                                `üìã PARSE DEBUG: Div ${index + 1}: id="${
                                    div.id
                                }", class="${div.className}"`,
                            );
                        });

                        // Verificar se h√° erro espec√≠fico na p√°gina
                        const errorElements = doc.querySelectorAll(
                            ".alert-danger, .error, .erro, [class*='erro'], [class*='error']",
                        );
                        if (errorElements.length > 0) {
                            log(
                                "‚ùå PARSE DEBUG: Elementos de erro encontrados:",
                            );
                            errorElements.forEach((error, index) => {
                                log(
                                    `üìã PARSE DEBUG: Erro ${
                                        index + 1
                                    }: "${error.textContent.trim()}"`,
                                );
                            });
                        }

                        log(
                            "‚ùå PARSE: Tabela de sess√µes n√£o encontrada em nenhum seletor",
                        );
                        return [];
                    }

                    // Buscar todas as linhas de dados (tbody > tr)
                    const linhasSessoes = tabela.querySelectorAll(
                        'tbody tr[id^="tr_"]',
                    );
                    log(`üìã PARSE: ${linhasSessoes.length} linhas encontradas`);

                    const sessoes = [];

                    for (const linha of linhasSessoes) {
                        try {
                            const sessao = await extrairDadosLinhaSessao(linha);
                            if (sessao) {
                                sessoes.push(sessao);
                            }
                        } catch (error) {
                            console.warn(
                                `‚ö†Ô∏è PARSE: Erro ao processar linha: ${error.message}`,
                            );
                        }
                    }

                    log(
                        `‚úÖ PARSE: ${sessoes.length} sess√µes processadas com sucesso`,
                    );
                    return sessoes;
                } catch (error) {
                    console.error(`‚ùå PARSE: Erro no parse: ${error.message}`);
                    return [];
                }
            }

            /**
             * Extrai dados de uma linha espec√≠fica da tabela de sess√µes
             * @param {Element} linha - Elemento tr da linha
             * @returns {Object|null} - Objeto com dados da sess√£o ou null
             */
            async function extrairDadosLinhaSessao(linha) {
                try {
                    const id = linha.getAttribute("id");
                    const colunas = linha.querySelectorAll("td");

                    if (colunas.length < 8) {
                        console.warn(
                            `‚ö†Ô∏è LINHA: Linha ${id} tem ${colunas.length} colunas, esperado >= 8`,
                        );
                        return null;
                    }

                    // Extrair dados conforme a estrutura HTML fornecida
                    const orgaoJulgador = colunas[1]?.textContent?.trim() || "";
                    const dataHoraSessao =
                        colunas[2]?.textContent?.trim() || "";
                    const tipoSessao = colunas[3]?.textContent?.trim() || "";
                    const localSessao = colunas[4]?.textContent?.trim() || "";
                    const dataLimitePauta =
                        colunas[5]?.textContent?.trim() || "";
                    const dataLimiteMesa =
                        colunas[6]?.textContent?.trim() || "";
                    const dataLimiteMinutas =
                        colunas[7]?.textContent?.trim() || "";
                    const statusSessao = colunas[8]?.textContent?.trim() || "";

                    // Extrair s√≥ a data da string "03/06/2025 14:00"
                    const dataMatch = dataHoraSessao.match(
                        /(\d{1,2}\/\d{1,2}\/\d{4})/,
                    );
                    const dataSessao = dataMatch ? dataMatch[1] : "";

                    // Extrair s√≥ o hor√°rio
                    const horaMatch = dataHoraSessao.match(/(\d{1,2}:\d{2})/);
                    const horaSessao = horaMatch ? horaMatch[1] : "";

                    const sessao = {
                        id: id,
                        orgaoJulgador: orgaoJulgador,
                        dataSessao: dataSessao,
                        horaSessao: horaSessao,
                        dataHoraCompleta: dataHoraSessao,
                        tipoSessao: tipoSessao,
                        localSessao: localSessao,
                        dataLimitePauta: dataLimitePauta,
                        dataLimiteMesa: dataLimiteMesa,
                        dataLimiteMinutas: dataLimiteMinutas,
                        statusSessao: statusSessao,
                        // Dados adicionais
                        dataDetectada: new Date(),
                        validData: !!dataSessao,
                    };

                    log(
                        `üìã LINHA: Sess√£o extra√≠da - ${traduzirSiglaOrgao(
                            orgaoJulgador,
                        )} em ${dataSessao}`,
                    );
                    return sessao;
                } catch (error) {
                    console.error(
                        `‚ùå LINHA: Erro ao extrair dados: ${error.message}`,
                    );
                    return null;
                }
            }

            /**
             * Busca sess√£o espec√≠fica por data
             * @param {string} dataProcurada - Data no formato DD/MM/AAAA
             * @param {string} hash - Hash da p√°gina (opcional)
             * @returns {Promise<Object|null>} - Dados da sess√£o encontrada ou null
             */
            async function buscarSessaoPorData(dataProcurada, hash = null) {
                log(`üéØ BUSCA: Procurando sess√£o para data: ${dataProcurada}`);

                try {
                    // Buscar todas as sess√µes
                    const sessoes = await buscarDadosSessoes(hash);

                    if (sessoes.length === 0) {
                        return null;
                    }

                    // Procurar sess√£o com a data espec√≠fica
                    const sessaoEncontrada = sessoes.find(
                        (sessao) => sessao.dataSessao === dataProcurada,
                    );

                    if (sessaoEncontrada) {
                        log(`‚úÖ BUSCA: Sess√£o encontrada!`);
                        log(
                            `üìã BUSCA: ${traduzirSiglaOrgao(
                                sessaoEncontrada.orgaoJulgador,
                            )} - ${sessaoEncontrada.dataHoraCompleta}`,
                        );

                        // Armazenar na vari√°vel global
                        dadosCompletosSessionJulgamento = sessaoEncontrada;

                        return sessaoEncontrada;
                    } else {
                        // Log das datas dispon√≠veis para debug
                        const datasDisponiveis = sessoes
                            .map((s) => s.dataSessao)
                            .filter((d) => d);
                        log(
                            `üìÖ BUSCA: Datas dispon√≠veis: ${datasDisponiveis.join(
                                ", ",
                            )}`,
                        );

                        return null;
                    }
                } catch (error) {
                    console.error(`‚ùå BUSCA: Erro na busca: ${error.message}`);
                    return null;
                }
            }

            /**
             * Realiza cruzamento autom√°tico da data detectada com os dados das sess√µes
             * @param {string} hash - Hash da p√°gina (opcional)
             * @returns {Promise<boolean>} - true se encontrou e cruzou dados
             */
            async function cruzarDadosDataSessao(
                hash = null,
                forcarRequisicao = false,
            ) {
                log("üîÑ CRUZAMENTO: Iniciando cruzamento de dados da sess√£o");

                //  VERIFICAR SE REQUISI√á√ïES AUTOM√ÅTICAS EST√ÉO DESABILITADAS
                if (REQUISICOES_AUTOMATICAS_DESABILITADAS) {
                    log(
                        "üö´ CRUZAMENTO: Requisi√ß√µes autom√°ticas desabilitadas globalmente",
                    );
                    log(
                        "üí° Para habilitar: window.SENT1_AUTO.habilitarRequisicoes()",
                    );
                    return false;
                }

                // üîê VERIFICA√á√ÉO DUPLA: Processo atual deve estar marcado como processado
                if (!processoAtual) {
                    logError("‚ùå CRUZAMENTO: Processo atual n√£o identificado");
                    return false;
                }

                if (!processoJaFoiProcessado(processoAtual)) {
                    log(
                        `‚ùå CRUZAMENTO: Processo ${processoAtual} n√£o foi marcado como processado`,
                    );
                    return false;
                }

                if (!hasDataSessaoPautado()) {
                    log(
                        "‚ùå CRUZAMENTO: Nenhuma data de sess√£o detectada para cruzar",
                    );
                    return false;
                }

                const dataFormatada = dataSessaoPautado.dataFormatada;
                log(
                    `üéØ CRUZAMENTO: Buscando dados para: ${dataFormatada} (Processo: ${processoAtual})`,
                );

                try {
                    const sessaoEncontrada = await buscarSessaoPorData(
                        dataFormatada,
                        hash,
                    );

                    if (sessaoEncontrada) {
                        log("‚úÖ CRUZAMENTO: Dados cruzados com sucesso!");

                        // Atualizar interface se estiver sendo exibida
                        setTimeout(() => {
                            atualizarDataSessaoNaInterface();
                        }, 500);

                        return true;
                    } else {
                        logError(
                            "‚ùå CRUZAMENTO: N√£o foi poss√≠vel cruzar os dados",
                        );
                        return false;
                    }
                } catch (error) {
                    console.error(
                        `‚ùå CRUZAMENTO: Erro no cruzamento: ${error.message}`,
                    );
                    return false;
                }
            }

            /**
             * Retorna os dados completos da sess√£o (se dispon√≠veis)
             * @returns {Object|null} - Dados da sess√£o ou null
             */
            function getDadosCompletosSessionJulgamento() {
                return dadosCompletosSessionJulgamento;
            }

            /**
             * Verifica se h√° dados completos da sess√£o dispon√≠veis
             * @returns {boolean} - true se h√° dados dispon√≠veis
             */
            function hasDadosCompletosSessionJulgamento() {
                return dadosCompletosSessionJulgamento !== null;
            }

            /**
             * Reseta os dados completos da sess√£o
             */
            function resetDadosCompletosSessionJulgamento() {
                log("üîÑ RESET: Limpando dados completos da sess√£o");
                dadosCompletosSessionJulgamento = null;
            }

            /**
             * Mostra informa√ß√µes completas da sess√£o
             */
            function showDadosCompletosSessionJulgamento() {
                if (hasDadosCompletosSessionJulgamento()) {
                    const dados = dadosCompletosSessionJulgamento;
                    const info = `üìã DADOS COMPLETOS DA SESS√ÉO:

            üèõÔ∏è √ìrg√£o Julgador: ${traduzirSiglaOrgao(dados.orgaoJulgador)}
            üìÖ Data da Sess√£o: ${dados.dataSessao}
            ‚è∞ Hor√°rio: ${dados.horaSessao}
            üñ•Ô∏è Tipo: ${dados.tipoSessao}
            üìç Local: ${dados.localSessao}
            üìã Status: ${dados.statusSessao}

            üìÖ Data Limite Pauta: ${dados.dataLimitePauta}
            üìÖ Data Limite Mesa: ${dados.dataLimiteMesa}
            üìÖ Data Limite Minutas: ${dados.dataLimiteMinutas}

            üÜî ID: ${dados.id}`;

                    log(info);
                    alert(info);
                    return dados;
                } else {
                    const msg =
                        "‚ùå Nenhum dado completo de sess√£o foi encontrado ainda.";
                    log(msg);
                    alert(msg);
                    return null;
                }
            }

            // üöÄ INICIALIZA√á√ÉO AUTOM√ÅTICA OTIMIZADA - Carregamento mais r√°pido
            let inicializacaoExecutada = false; // Prevenir execu√ß√£o dupla

            function inicializarAutomaticamente() {
                if (inicializacaoExecutada) {
                    logError("‚ö†Ô∏è INICIALIZA√á√ÉO: J√° executada, pulando...");
                    return;
                }

                inicializacaoExecutada = true;
                log(
                    "üöÄ INICIALIZA√á√ÉO: Iniciando detec√ß√£o autom√°tica de sess√£o...",
                );

                // ===== APLICA√á√ÉO IMEDIATA DE ESTILOS E ELEMENTOS =====
                log(
                    "‚ö° INICIALIZA√á√ÉO: Aplicando estilos e elementos imediatamente...",
                );

                // 0. ‚ö° APLICAR ANTI-FLASH CR√çTICO PRIMEIRO
                aplicarAntiFlashIcones();

                // 1. CSS Instant√¢neo j√° aplicado no in√≠cio do arquivo - sem a√ß√£o necess√°ria
                try {
                    const tema =
                        localStorage.getItem("eprobe_selected_theme") || "blue";
                    log(
                        `‚úÖ INICIALIZA√á√ÉO: Tema ${tema} usando CSS instant√¢neo`,
                    );
                } catch (error) {
                    console.warn(
                        "‚ö†Ô∏è INICIALIZA√á√ÉO: Erro ao aplicar tema:",
                        error,
                    );
                }

                // 2. Executar aplica√ß√£o de estilos e elementos imediatamente
                try {
                    // For√ßa aplica√ß√£o imediata dos estilos CSS cr√≠ticos
                    const head =
                        document.head ||
                        document.getElementsByTagName("head")[0];
                    if (
                        head &&
                        !document.getElementById("eprobe-instant-performance")
                    ) {
                        const performanceStyles =
                            document.createElement("style");
                        performanceStyles.id = "eprobe-instant-performance";
                        performanceStyles.textContent = `
                    /* Performance instant√¢nea para elementos eProbe */
                    body { opacity: 1 !important; }
                    .navbar { opacity: 1 !important; }
                    
                    /* Garantir que elementos cr√≠ticos apare√ßam imediatamente */
                    #navbar.navbar.bg-instancia,
                    .navbar.bg-instancia {
                        opacity: 1 !important;
                        transition: all 0.3s ease !important;
                        display: flex !important; 
                        align-items: center !important;
                    }
                    
                    /* Aplicar estilos SVG Figma instantaneamente */
                    .eprobe-figma-card-svg {
                        display: inline-block !important;
                        margin: 8px 0 !important;
                        position: relative !important;
                    }
                `;
                        head.appendChild(performanceStyles);
                        log(
                            "‚úÖ INICIALIZA√á√ÉO: Estilos de performance aplicados",
                        );
                    }

                    // Executar gerenciamento da navbar imediatamente
                    if (typeof window.gerenciarNavbarEprobe === "function") {
                        window.gerenciarNavbarEprobe();
                        log(
                            "‚úÖ INICIALIZA√á√ÉO: Navbar gerenciada imediatamente",
                        );
                    }

                    // Detectar e aplicar card de sess√£o imediatamente se poss√≠vel
                    debounceGlobal(
                        () => {
                            if (
                                typeof detectarSessoesUnificado === "function"
                            ) {
                                detectarSessoesUnificado();
                                log(
                                    "INICIALIZACAO: Deteccao de card de sessao iniciada",
                                );
                            }

                            // Aplicar estiliza√ß√£o de lembretes
                            if (
                                typeof aplicarEstilizacaoLembretesRobusta ===
                                "function"
                            ) {
                                aplicarEstilizacaoLembretesRobusta();
                                log(
                                    "‚úÖ INICIALIZA√á√ÉO: Estiliza√ß√£o robusta de lembretes iniciada",
                                );
                            }

                            // Aplicar gradientes na capa do processo
                            if (
                                typeof aplicarGradientesCapaProcessoRobusta ===
                                "function"
                            ) {
                                aplicarGradientesCapaProcessoRobusta();
                                log(
                                    "‚úÖ INICIALIZA√á√ÉO: Gradientes robustos na capa iniciados",
                                );
                            }

                            // Aplicar gradientes nas minutas
                            if (
                                typeof aplicarGradientesLegMinutasRobusta ===
                                "function"
                            ) {
                                aplicarGradientesLegMinutasRobusta();
                                log(
                                    "‚úÖ INICIALIZA√á√ÉO: Gradientes robustos nas minutas iniciados",
                                );
                            }

                            // Aplicar gradientes nos detalhes da capa (cores partes, descricoes, etc.)
                            if (
                                typeof aplicarGradientesDetalhesCapaRobusta ===
                                "function"
                            ) {
                                aplicarGradientesDetalhesCapaRobusta();
                                log(
                                    "‚úÖ INICIALIZA√á√ÉO: Gradientes detalhes da capa iniciados",
                                );
                            }

                            // ‚ö° NOVO: Aplicar estiliza√ß√£o IMEDIATA para eliminar flash
                            if (
                                typeof aplicarEstilizacaoImediataLembretes ===
                                "function"
                            ) {
                                aplicarEstilizacaoImediataLembretes();
                            }

                            // Aplicar substituicao de icones unificada\n                            if (isCapaProcessoPage()) {\n                                substituirTodosIcones();\n                            }
                        },
                        "deteccao-card-instantanea",
                        50,
                    );
                } catch (error) {
                    console.warn(
                        "‚ö†Ô∏è INICIALIZA√á√ÉO: Erro ao aplicar estilos:",
                        error,
                    );
                }

                // Execu√ß√£o imediata sem delay desnecess√°rio
                try {
                    // 1. Detectar data da sess√£o de forma n√£o-bloqueante
                    if (!hasDataSessaoPautado()) {
                        log(
                            "üîç INICIALIZA√á√ÉO: Tentando detectar data da sess√£o...",
                        );

                        // üö® CORRE√á√ÉO ANTI-LOOP: N√£o fazer chamadas recursivas
                        log(
                            "‚ÑπÔ∏è INICIALIZA√á√ÉO: Sistema j√° inicializado, evitando loops",
                        );
                        return;
                    }

                    // 2. Verificar se h√° dados para inserir na interface
                    if (hasDataSessaoPautado()) {
                        log(
                            "‚úÖ INICIALIZA√á√ÉO: Data detectada, inserindo na interface...",
                        );
                        inserirDataSessaoNaInterface();

                        // 3. Cruzamento s√≥ se requisi√ß√µes estiverem habilitadas
                        if (!REQUISICOES_AUTOMATICAS_DESABILITADAS) {
                            log(
                                "üîÑ INICIALIZA√á√ÉO: Agendando cruzamento de dados...",
                            );
                            debounceGlobal(
                                () => {
                                    cruzarDadosDataSessao()
                                        .then(() => {
                                            log(
                                                "‚úÖ INICIALIZA√á√ÉO: Processo completo finalizado!",
                                            );
                                            atualizarDataSessaoNaInterface();
                                        })
                                        .catch((error) => {
                                            console.warn(
                                                "‚ö†Ô∏è INICIALIZA√á√ÉO: Erro no cruzamento:",
                                                error.message,
                                            );
                                        });
                                },
                                "cruzamento-automatico",
                                2000,
                            );
                        } else {
                            log(
                                "‚ÑπÔ∏è INICIALIZA√á√ÉO: Cruzamento autom√°tico desabilitado - interface b√°sica pronta",
                            );
                        }
                    } else {
                        log(
                            "‚ÑπÔ∏è INICIALIZA√á√ÉO: Nenhuma data de sess√£o detectada nesta p√°gina",
                        );
                    }
                } catch (error) {
                    console.error(
                        "‚ùå INICIALIZA√á√ÉO: Erro na inicializa√ß√£o autom√°tica:",
                        error,
                    );
                    inicializacaoExecutada = false; // Permitir retry em caso de erro
                }
            }

            // üß™ FUN√á√ÉO DE TESTE - Para valida√ß√£o durante desenvolvimento
            function testarSistemaCompleto() {
                log(
                    "üß™ TESTE: Iniciando teste completo do sistema de sess√µes...",
                );

                return new Promise(async (resolve) => {
                    try {
                        // 1. Resetar estado
                        log("üîÑ TESTE: Resetando estado...");
                        resetDataSessaoPautado();
                        resetDadosCompletosSessionJulgamento();

                        // 2. Testar detec√ß√£o de data
                        log("üîç TESTE: Testando detec√ß√£o de data...");
                        if (
                            window.SENT1_AUTO &&
                            window.SENT1_AUTO.detectarCardSessaoSimplificado
                        ) {
                            window.SENT1_AUTO.detectarCardSessaoSimplificado();
                        }

                        if (hasDataSessaoPautado()) {
                            log("‚úÖ TESTE: Data detectada com sucesso!");
                            showDataSessaoPautadoInfo();

                            // 3. Testar inser√ß√£o na interface
                            log("üé® TESTE: Testando inser√ß√£o na interface...");
                            inserirDataSessaoNaInterface();

                            // 4. Testar cruzamento de dados
                            log("üîÑ TESTE: Testando cruzamento de dados...");
                            const resultado = await cruzarDadosDataSessao();

                            if (resultado) {
                                log(
                                    "‚úÖ TESTE: Cruzamento realizado com sucesso!",
                                );
                                showDadosCompletosSessionJulgamento();

                                // 5. Testar atualiza√ß√£o da interface
                                log(
                                    "üé® TESTE: Testando atualiza√ß√£o da interface...",
                                );
                                atualizarDataSessaoNaInterface();

                                log(
                                    "üéâ TESTE: Teste completo finalizado com SUCESSO!",
                                );
                                resolve(true);
                            } else {
                                logError(
                                    "‚ö†Ô∏è TESTE: Cruzamento n√£o encontrou dados",
                                );
                                resolve(false);
                            }
                        } else {
                            logError(
                                "‚ùå TESTE: Nenhuma data de sess√£o detectada",
                            );
                            resolve(false);
                        }
                    } catch (error) {
                        console.error("‚ùå TESTE: Erro durante teste:", error);
                        resolve(false);
                    }
                });
            }

            // Adicionar fun√ß√µes ao namespace global para debug (movidas para namespace principal)

            // üîç FUN√á√ÉO DE DEBUG - Para investigar estrutura da p√°gina de sess√µes
            async function debugPaginaSessoes() {
                log("üîç DEBUG: Iniciando debug da p√°gina de sess√µes...");

                try {
                    const baseUrl = window.location.origin;
                    const urlSessoes = `${baseUrl}/eproc/controlador.php?acao=sessao_julgamento_listar`;

                    log(`üåê DEBUG: Fazendo fetch para: ${urlSessoes}`);

                    const response = await fetch(urlSessoes, {
                        credentials: "same-origin",
                        headers: {
                            Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                        },
                    });

                    if (!response.ok) {
                        console.error(
                            `‚ùå DEBUG: Erro HTTP ${response.status}: ${response.statusText}`,
                        );
                        return;
                    }

                    const htmlContent = await response.text();
                    log(
                        `‚úÖ DEBUG: P√°gina carregada, tamanho: ${htmlContent.length} caracteres`,
                    );

                    // Fazer parse
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(
                        htmlContent,
                        "text/html",
                    );

                    // Debug b√°sico
                    const title =
                        doc.querySelector("title")?.textContent || "sem t√≠tulo";
                    log(`üìã DEBUG: T√≠tulo: "${title}"`);

                    // Verificar se foi redirecionado para login
                    if (
                        title.toLowerCase().includes("login") ||
                        htmlContent.includes("frmLogin")
                    ) {
                        console.warn(
                            "‚ö†Ô∏è DEBUG: Parece que foi redirecionado para p√°gina de login!",
                        );
                        console.warn(
                            "üí° DEBUG: Tente acessar a URL manualmente no navegador primeiro",
                        );
                        return;
                    }

                    // Analisar estrutura
                    const allTables = doc.querySelectorAll("table");
                    log(`üìä DEBUG: ${allTables.length} tabelas encontradas`);

                    allTables.forEach((table, index) => {
                        const id = table.id || "sem-id";
                        const className = table.className || "sem-class";
                        const rows = table.querySelectorAll("tr").length;
                        const hasSessionData =
                            table.innerHTML.includes("√ìrg√£o Julgador") ||
                            table.innerHTML.includes("Data da Sess√£o") ||
                            table.innerHTML.includes("sessao");

                        log(`üìã DEBUG: Tabela ${index + 1}:`);
                        log(`  - ID: "${id}"`);
                        log(`  - Class: "${className}"`);
                        log(`  - Linhas: ${rows}`);
                        log(
                            `  - Parece ter dados de sess√£o: ${hasSessionData}`,
                        );

                        if (hasSessionData && rows > 1) {
                            log(
                                `üéØ DEBUG: Esta tabela parece promissora! Analisando mais...`,
                            );

                            // Pegar headers
                            const headers = Array.from(
                                table.querySelectorAll("th, thead td"),
                            ).map((th) => th.textContent.trim());
                            log(
                                `üìã DEBUG: Headers: ${JSON.stringify(headers)}`,
                            );

                            // Pegar algumas linhas de exemplo
                            const dataRows = table.querySelectorAll("tbody tr");
                            log(`üìã DEBUG: ${dataRows.length} linhas de dados`);

                            Array.from(dataRows)
                                .slice(0, 3)
                                .forEach((row, rowIndex) => {
                                    const cells = Array.from(
                                        row.querySelectorAll("td"),
                                    ).map((td) => td.textContent.trim());
                                    log(
                                        `üìã DEBUG: Linha ${
                                            rowIndex + 1
                                        }: ${JSON.stringify(cells)}`,
                                    );
                                });
                        }
                    });

                    // Salvar HTML para inspe√ß√£o manual
                    log(
                        "üíæ DEBUG: HTML da p√°gina salvo em window.debugPageHTML (use console para inspecionar)",
                    );
                    window.debugPageHTML = htmlContent;

                    log("‚úÖ DEBUG: An√°lise completa! Verifique os logs acima.");
                } catch (error) {
                    console.error("‚ùå DEBUG: Erro durante debug:", error);
                }
            }

            // üì® HANDLER DE MENSAGENS - Para comunica√ß√£o com o popup
            if (
                typeof chrome !== "undefined" &&
                chrome.runtime &&
                chrome.runtime.onMessage
            ) {
                chrome.runtime.onMessage.addListener(
                    function (request, sender, sendResponse) {
                        log("üì® MENSAGEM: Recebida do popup:", request);

                        if (request.action === "toggleAutoSessionRequests") {
                            const enabled = request.enabled;

                            if (enabled) {
                                log(
                                    "üîì POPUP: Habilitando requisi√ß√µes autom√°ticas de sess√£o",
                                );
                                REQUISICOES_AUTOMATICAS_DESABILITADAS = false;
                            } else {
                                log(
                                    "üîí POPUP: Desabilitando requisi√ß√µes autom√°ticas de sess√£o",
                                );
                                REQUISICOES_AUTOMATICAS_DESABILITADAS = true;
                            }

                            log(
                                `‚öôÔ∏è POPUP: REQUISICOES_AUTOMATICAS_DESABILITADAS = ${REQUISICOES_AUTOMATICAS_DESABILITADAS}`,
                            );

                            // Enviar resposta de confirma√ß√£o
                            sendResponse({
                                success: true,
                                message: enabled
                                    ? "Requisi√ß√µes autom√°ticas habilitadas"
                                    : "Requisi√ß√µes autom√°ticas desabilitadas",
                                currentState:
                                    !REQUISICOES_AUTOMATICAS_DESABILITADAS,
                            });
                        }

                        // Manter o handler para outras mensagens se necess√°rio
                        if (request.action === "toggleSessionDateHighlight") {
                            log(
                                "üéØ POPUP: Toggle para destaque da data da sess√£o:",
                                request.enabled,
                            );

                            // Aqui voc√™ pode adicionar a l√≥gica para o destaque da data da sess√£o
                            // Por enquanto, apenas confirmar recebimento
                            sendResponse({
                                success: true,
                                message: request.enabled
                                    ? "Destaque ativado"
                                    : "Destaque desativado",
                            });
                        }

                        // ========================================
                        // HANDLERS PARA NOVOS TOGGLES DE PERSONALIZA√á√ÉO
                        // ========================================

                        if (request.action === "toggleNavbarCustomization") {
                            log(
                                "üé® POPUP: Toggle para personaliza√ß√£o da navbar:",
                                request.enabled,
                            );

                            let success = false;
                            let message = "";

                            try {
                                if (request.enabled) {
                                    // Ativar personaliza√ß√£o da navbar
                                    success = ativarPersonalizacaoNavbar();
                                    message = success
                                        ? "Personaliza√ß√£o da navbar ativada com sucesso"
                                        : "Erro ao ativar personaliza√ß√£o da navbar";
                                } else {
                                    // Desativar personaliza√ß√£o da navbar
                                    success = desativarPersonalizacaoNavbar();
                                    message = success
                                        ? "Personaliza√ß√£o da navbar desativada com sucesso"
                                        : "Erro ao desativar personaliza√ß√£o da navbar";
                                }

                                // Log do status atual
                                const status =
                                    verificarStatusPersonalizacaoNavbar();
                                log("üìä NAVBAR: Status atual:", status);
                            } catch (error) {
                                logError("‚ùå NAVBAR: Erro no toggle:", error);
                                success = false;
                                message = "Erro interno no controle da navbar";
                            }

                            sendResponse({
                                success: success,
                                message: message,
                                enabled: PERSONALIZACAO_NAVBAR_HABILITADA,
                            });
                        }

                        if (request.action === "toggleIconsCustomization") {
                            log(
                                "üé® POPUP: Toggle para personaliza√ß√£o de √≠cones:",
                                request.enabled,
                            );

                            // TODO: Implementar l√≥gica de ativa√ß√£o/desativa√ß√£o da personaliza√ß√£o de √≠cones
                            // Por enquanto, apenas confirmar recebimento
                            sendResponse({
                                success: true,
                                message: request.enabled
                                    ? "Personaliza√ß√£o de √≠cones ativada"
                                    : "Personaliza√ß√£o de √≠cones desativada",
                            });
                        }

                        if (request.action === "toggleButtonsCustomization") {
                            log(
                                "üé® POPUP: Toggle para personaliza√ß√£o de bot√µes:",
                                request.enabled,
                            );

                            // TODO: Implementar l√≥gica de ativa√ß√£o/desativa√ß√£o da personaliza√ß√£o de bot√µes
                            // Por enquanto, apenas confirmar recebimento
                            sendResponse({
                                success: true,
                                message: request.enabled
                                    ? "Personaliza√ß√£o de bot√µes ativada"
                                    : "Personaliza√ß√£o de bot√µes desativada",
                            });
                        }

                        if (request.action === "toggleRemindersCustomization") {
                            log(
                                "üé® POPUP: Toggle para personaliza√ß√£o de lembretes:",
                                request.enabled,
                            );

                            // TODO: Implementar l√≥gica de ativa√ß√£o/desativa√ß√£o da personaliza√ß√£o de lembretes
                            // Por enquanto, apenas confirmar recebimento
                            sendResponse({
                                success: true,
                                message: request.enabled
                                    ? "Personaliza√ß√£o de lembretes ativada"
                                    : "Personaliza√ß√£o de lembretes desativada",
                            });
                        }

                        if (
                            request.action ===
                            "toggleAllAppearanceCustomization"
                        ) {
                            log(
                                "üé® POPUP: Toggle para todas as personaliza√ß√µes:",
                                request.enabled,
                            );

                            // TODO: Implementar l√≥gica de ativa√ß√£o/desativa√ß√£o de todas as personaliza√ß√µes
                            // Por enquanto, apenas confirmar recebimento
                            sendResponse({
                                success: true,
                                message: request.enabled
                                    ? "Todas as personaliza√ß√µes ativadas"
                                    : "Todas as personaliza√ß√µes desativadas",
                            });
                        }

                        // Handler para aplica√ß√£o de temas
                        if (request.action === "applyTheme") {
                            const theme = request.theme;
                            log(
                                "üé® MAIN: Aplicando tema recebido do popup:",
                                theme,
                            );

                            // APLICAR TEMA REALMENTE usando a fun√ß√£o correta
                            if (typeof applyThemeStyles === "function") {
                                applyThemeStyles(theme);
                                log(
                                    "‚úÖ MAIN: Tema aplicado via applyThemeStyles",
                                );
                            } else if (
                                typeof window.applyThemeStyles === "function"
                            ) {
                                window.applyThemeStyles(theme);
                                log(
                                    "‚úÖ MAIN: Tema aplicado via window.applyThemeStyles",
                                );
                            } else {
                                log(
                                    "‚ùå MAIN: Fun√ß√£o applyThemeStyles n√£o encontrada",
                                );
                            }

                            // Resposta de sucesso
                            sendResponse({
                                success: true,
                                message: `Tema ${theme} aplicado com sucesso`,
                            });
                        }

                        // Handler para temas de bot√µes
                        if (request.action === "applyButtonTheme") {
                            const theme = request.theme;
                            log(
                                "üíº MAIN: Aplicando tema de bot√£o recebido do popup:",
                                theme,
                            );

                            // Verificar se a fun√ß√£o aplicarEstiloBotoesEproc est√° dispon√≠vel
                            if (
                                typeof window.aplicarEstiloBotoesEproc ===
                                "function"
                            ) {
                                try {
                                    if (theme === "reset") {
                                        // Reset para padr√£o do sistema
                                        window.resetarBotoesEproc();
                                        sendResponse({
                                            success: true,
                                            message:
                                                "Bot√µes resetados para o padr√£o do sistema",
                                        });
                                    } else {
                                        // Aplicar tema espec√≠fico
                                        window.aplicarEstiloBotoesEproc(theme);
                                        sendResponse({
                                            success: true,
                                            message: `Tema "${theme}" aplicado aos bot√µes`,
                                        });
                                    }
                                } catch (error) {
                                    console.error(
                                        "‚ùå MAIN: Erro ao aplicar tema de bot√£o:",
                                        error,
                                    );
                                    sendResponse({
                                        success: false,
                                        message: `Erro ao aplicar tema: ${error.message}`,
                                    });
                                }
                            } else {
                                console.error(
                                    "‚ùå MAIN: Fun√ß√µes de tema de bot√£o n√£o encontradas",
                                );
                                sendResponse({
                                    success: false,
                                    message:
                                        "Erro: fun√ß√µes de tema de bot√£o n√£o dispon√≠veis",
                                });
                            }
                        }

                        return true; // Indica que a resposta ser√° enviada de forma ass√≠ncrona
                    },
                );

                log("üì® HANDLER: Listener de mensagens do popup registrado");
            }

            // ===== EXECU√á√ÉO IMEDIATA - ELIMINAR FLASH TOTAL =====
            // Executar inicializa√ß√£o IMEDIATAMENTE sem aguardar DOM
            log("‚ö° INSTANT: Executando inicializa√ß√£o imediata...");

            // ‚ö° SUPER ANTI-FLASH: Aplicar imediatamente antes de qualquer coisa
            try {
                aplicarEstilizacaoImediataLembretes();
            } catch (error) {
                console.error(
                    "‚ùå ANTI-FLASH: Erro na aplica√ß√£o imediata:",
                    error,
                );
            }

            // Executar inicializa√ß√£o IMEDIATAMENTE
            inicializarAutomaticamente();

            // ‚ö° MONITOR ULTRARR√ÅPIDO: Verifica√ß√£o a cada 16ms (60fps) - ULTRA-OTIMIZADO
            let tentativasMonitor = 0;
            const maxTentativasMonitor = 1875; // 30 segundos a 60fps

            const monitorUltraRapido = setInterval(() => {
                try {
                    tentativasMonitor++;

                    // OTIMIZA√á√ÉO: Verifica√ß√£o ultrarr√°pida sem logs
                    const lembretesNaoProcessados = document.querySelectorAll(
                        ".lista-lembretes .lembrete:not(.eprobe-lembrete-processado), div.divLembrete:not(.eprobe-lembrete-processado)",
                    );

                    if (lembretesNaoProcessados.length > 0) {
                        // PROCESSAMENTO INSTANT√ÇNEO: Aplicar estilos diretamente sem fun√ß√£o intermedi√°ria
                        lembretesNaoProcessados.forEach((elemento) => {
                            const style = elemento.getAttribute("style") || "";
                            let aplicouEstilo = false;

                            // Detec√ß√£o e aplica√ß√£o instant√¢nea por cor
                            if (style.includes("#efef8f")) {
                                elemento.style.setProperty(
                                    "background",
                                    "linear-gradient(#F9EFAF, #F7E98D)",
                                    "important",
                                );
                                aplicouEstilo = true;
                            } else if (style.includes("#db8080")) {
                                elemento.style.setProperty(
                                    "background",
                                    "linear-gradient(#FAAFAF, #F78D8D)",
                                    "important",
                                );
                                aplicouEstilo = true;
                            } else if (style.includes("#87adcd")) {
                                elemento.style.setProperty(
                                    "background",
                                    "linear-gradient(#AFCFFA, #8DC0F7)",
                                    "important",
                                );
                                aplicouEstilo = true;
                            } else if (style.includes("#a7eda7")) {
                                elemento.style.setProperty(
                                    "background",
                                    "linear-gradient(#AFFAB6, #8DF792)",
                                    "important",
                                );
                                aplicouEstilo = true;
                            } else if (style.includes("#f5b574")) {
                                elemento.style.setProperty(
                                    "background",
                                    "linear-gradient(#FAD3AF, #F7C68D)",
                                    "important",
                                );
                                aplicouEstilo = true;
                            }

                            if (aplicouEstilo) {
                                // Aplicar estilos base instantaneamente
                                elemento.style.setProperty(
                                    "padding",
                                    "20px",
                                    "important",
                                );
                                elemento.style.setProperty(
                                    "min-width",
                                    "315px",
                                    "important",
                                );
                                elemento.style.setProperty(
                                    "min-height",
                                    "140px",
                                    "important",
                                );
                                elemento.style.setProperty(
                                    "box-shadow",
                                    "0 4px 6px rgba(0, 0, 0, 0.1)",
                                    "important",
                                );
                                elemento.style.setProperty(
                                    "transition",
                                    "box-shadow 0.5s ease",
                                    "important",
                                );
                                elemento.style.setProperty(
                                    "-webkit-font-smoothing",
                                    "subpixel-antialiased",
                                    "important",
                                );
                                elemento.style.setProperty(
                                    "visibility",
                                    "visible",
                                    "important",
                                );
                                elemento.style.setProperty(
                                    "opacity",
                                    "1",
                                    "important",
                                );
                                elemento.classList.add(
                                    "eprobe-lembrete-processado",
                                );
                            }
                        });

                        // Substitui√ß√£o instant√¢nea de √≠cones
                        substituirIconesLembretesImediato();
                    }

                    // OTIMIZA√á√ÉO: Verifica√ß√£o de bot√µes ultrarr√°pida
                    const botoesNaoMarcados = document.querySelectorAll(
                        "div.botaoLerMais:not([data-eprobe-will-replace]):not([data-eprobe-expandir-replaced])",
                    );

                    if (botoesNaoMarcados.length > 0) {
                        botoesNaoMarcados.forEach((botao) => {
                            const texto = (
                                botao.textContent || ""
                            ).toLowerCase();
                            if (
                                texto.includes("ler mais") ||
                                texto.includes("...ler mais")
                            ) {
                                const lembreteParent =
                                    botao.closest(".divLembrete");
                                if (lembreteParent) {
                                    const desLembrete =
                                        lembreteParent.querySelector(
                                            ".desLembrete",
                                        );
                                    if (desLembrete) {
                                        const textoCompleto =
                                            desLembrete.textContent || "";
                                        const temTextoTruncado =
                                            textoCompleto.length > 150 ||
                                            desLembrete.scrollHeight >
                                                desLembrete.clientHeight ||
                                            textoCompleto.includes("...") ||
                                            window.getComputedStyle(desLembrete)
                                                .textOverflow === "ellipsis";

                                        if (temTextoTruncado) {
                                            botao.setAttribute(
                                                "data-eprobe-will-replace",
                                                "true",
                                            );
                                            botao.style.display = "none";
                                            botao.style.visibility = "hidden";
                                        }
                                    }
                                }
                            }
                        });
                    }

                    // OTIMIZA√á√ÉO: Parar ap√≥s tempo limite ou estabilidade
                    if (
                        tentativasMonitor >= maxTentativasMonitor ||
                        (tentativasMonitor > 125 &&
                            lembretesNaoProcessados.length === 0 &&
                            botoesNaoMarcados.length === 0)
                    ) {
                        clearInterval(monitorUltraRapido);
                        // Log final apenas (sem logs intermedi√°rios para m√°xima performance)
                        if (tentativasMonitor < maxTentativasMonitor) {
                            log(
                                "‚ö° MONITOR ULTRARR√ÅPIDO: Finalizado - p√°gina est√°vel ap√≥s",
                                tentativasMonitor,
                                "verifica√ß√µes",
                            );
                        }
                    }
                } catch (error) {
                    // Silencioso para m√°xima performance - sem logs de erro
                }
            }, 16); // 60fps para captura instant√¢nea

            // ‚ö° MONITOR SECUND√ÅRIO: Backup a cada 100ms para garantir cobertura total
            const monitorBackup = setInterval(() => {
                try {
                    const lembretesNaoProcessados = document.querySelectorAll(
                        ".lista-lembretes .lembrete:not(.eprobe-lembrete-processado), div.divLembrete:not(.eprobe-lembrete-processado)",
                    );
                    if (lembretesNaoProcessados.length > 0) {
                        aplicarEstilizacaoImediataLembretes();
                        substituirIconesLembretesImediato();
                    }
                } catch (error) {
                    // Silencioso
                }
            }, 100);

            // Parar monitores ap√≥s 10 segundos
            setTimeout(() => {
                clearInterval(monitorBackup);
                log("‚ö° MONITORES: Finalizados ap√≥s timeout de 10 segundos");
            }, 10000);

            // Backup: Executar novamente quando DOM estiver pronto (para reaplicar estilos se necess√°rio)
            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", () => {
                    log("üîÑ BACKUP: Reaplicando estilos ap√≥s DOMContentLoaded");

                    // Aplicar anti-flash novamente
                    try {
                        aplicarEstilizacaoImediataLembretes();
                    } catch (error) {
                        console.error("‚ùå BACKUP ANTI-FLASH: Erro:", error);
                    }

                    // CSS instant√¢neo j√° aplicado - sem necessidade de reaplica√ß√£o
                    log(
                        "‚úÖ BACKUP: CSS instant√¢neo j√° garante aplica√ß√£o correta",
                    );
                });
            }

            /**
             * üé® FUN√á√ÉO DE DEBUG PARA divLembrete - Identifica elementos com background amarelo
             */
            function debugDivLembrete() {
                log(
                    "üîç DEBUG: Procurando elementos divLembrete com background-color:#efef8f",
                );

                const elementos = document.querySelectorAll(
                    'div.divLembrete[style*="background-color:#efef8f"], div.divLembrete[style*="background-color: #efef8f"]',
                );

                log(
                    `‚úÖ Encontrados ${elementos.length} elementos divLembrete com background amarelo:`,
                );

                elementos.forEach((elemento, index) => {
                    log(`üìã divLembrete ${index + 1}:`, {
                        id: elemento.id,
                        classes: elemento.className,
                        style: elemento.getAttribute("style"),
                        conteudo:
                            elemento.textContent.substring(0, 100) + "...",
                    });
                });

                return elementos;
            }

            /**
             * üîç FUN√á√ÉO DE DETEC√á√ÉO INTELIGENTE DE LEMBRETES
             * Detecta automaticamente quais tipos de lembretes existem na p√°gina
             */
            function detectarTiposLembretesNaPagina() {
                log("üîç DETEC√á√ÉO: Analisando tipos de lembretes na p√°gina...");

                const tiposDetectados = {
                    divLembrete: 0,
                    listaLembretes: 0,
                    outrosElementos: 0,
                    coresEncontradas: [],
                    elementos: [], // ADICIONADO: Array com todos os elementos encontrados
                    elementosPorCor: {}, // ADICIONADO: Elementos organizados por cor
                };

                // 1. Detectar div.divLembrete
                const divLembretes =
                    document.querySelectorAll("div.divLembrete");
                tiposDetectados.divLembrete = divLembretes.length;

                // 2. Detectar .lista-lembretes .lembrete
                const listaLembretes = document.querySelectorAll(
                    ".lista-lembretes .lembrete",
                );
                tiposDetectados.listaLembretes = listaLembretes.length;

                // 3. Detectar cores de background em qualquer div
                const coresLembrete = [
                    "#efef8f",
                    "#db8080",
                    "#87adcd",
                    "#a7eda7",
                    "#f5b574",
                ];

                coresLembrete.forEach((cor) => {
                    const elementos = document.querySelectorAll(
                        `div[style*="background-color:${cor}"], div[style*="background-color: ${cor}"]`,
                    );
                    if (elementos.length > 0) {
                        const nomeCor =
                            cor === "#efef8f"
                                ? "amarelo"
                                : cor === "#db8080"
                                  ? "vermelho"
                                  : cor === "#87adcd"
                                    ? "azul"
                                    : cor === "#a7eda7"
                                      ? "verde"
                                      : "laranja";

                        tiposDetectados.coresEncontradas.push(nomeCor);
                        tiposDetectados.elementosPorCor[nomeCor] =
                            Array.from(elementos);
                        tiposDetectados.elementos.push(
                            ...Array.from(elementos),
                        );
                        tiposDetectados.outrosElementos += elementos.length;
                    }
                });

                log("üìä DETEC√á√ÉO COMPLETA:", tiposDetectados);
                return tiposDetectados;
            }

            /**
             * üé® FUN√á√ÉO DE ESTILIZA√á√ÉO INTELIGENTE PARA LEMBRETES
             * Detecta automaticamente o tipo de elemento de lembrete na p√°gina
             */
            function estilizarDivLembrete() {
                log(
                    "üé® ESTILIZA√á√ÉO: Procurando lembretes amarelos em TODOS os seletores...",
                );

                // Seletores m√∫ltiplos para diferentes tipos de lembretes
                const seletores = [
                    'div.divLembrete[style*="background-color:#efef8f"]',
                    'div.divLembrete[style*="background-color: #efef8f"]',
                    '.lista-lembretes .lembrete[style*="background-color:#efef8f"]',
                    '.lista-lembretes .lembrete[style*="background-color: #efef8f"]',
                    'div[style*="background-color:#efef8f"]',
                    'div[style*="background-color: #efef8f"]',
                ];

                let elementosEncontrados = [];

                // Tentar cada seletor
                seletores.forEach((seletor, index) => {
                    const elementos = document.querySelectorAll(seletor);
                    if (elementos.length > 0) {
                        log(
                            `‚úÖ ENCONTRADOS ${
                                elementos.length
                            } lembretes amarelos com seletor ${
                                index + 1
                            }: ${seletor}`,
                        );
                        elementosEncontrados.push(...elementos);
                    }
                });

                // Remover duplicatas
                elementosEncontrados = [...new Set(elementosEncontrados)];

                if (elementosEncontrados.length === 0) {
                    log(
                        "‚ùå Nenhum elemento lembrete com background amarelo encontrado",
                    );
                    return false;
                }

                elementosEncontrados.forEach((elemento, index) => {
                    // Aplicar gradiente amarelo
                    elemento.style.background =
                        "linear-gradient( #F9EFAF, #F7E98D)";

                    // Aplicar estilos aprimorados - GARANTINDO MESMO TAMANHO
                    elemento.style.padding = "20px !important";
                    elemento.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
                    elemento.style.transition = "box-shadow 0.5s ease";
                    elemento.style.webkitFontSmoothing = "subpixel-antialiased";

                    // CORRE√á√ÉO: Garantir mesmo tamanho visual de todos os lembretes
                    elemento.style.minWidth = "315px";
                    elemento.style.minHeight = "140px";
                    elemento.style.fontSize = "1rem";
                    elemento.style.lineHeight = "1.5";
                    elemento.style.margin = "0";
                    elemento.style.border = "none";

                    // Marcar como processado para consist√™ncia
                    elemento.classList.add("eprobe-lembrete-processado");

                    // Adicionar eventos de hover e focus
                    elemento.addEventListener(
                        "mouseenter",
                        function () {
                            this.style.boxShadow = "0 5px 8px rgba(0,0,0,0.15)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "mouseleave",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "focus",
                        function () {
                            this.style.boxShadow = "0 5px 12px rgba(0,0,0,0.2)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "blur",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true },
                    );

                    log(
                        `‚úÖ Gradiente amarelo aplicado ao lembrete ${
                            index + 1
                        } (ID: ${elemento.id || "sem-id"})`,
                    );
                });
                log(
                    `üé® AMARELO CONCLU√çDO: ${elementosEncontrados.length} elementos estilizados`,
                );
                return elementosEncontrados.length;
            }

            /**
             * üé® FUN√á√ÉO DE ESTILIZA√á√ÉO INTELIGENTE PARA LEMBRETES VERMELHOS
             */
            function estilizarDivLembreteVermelho() {
                log(
                    "üé® ESTILIZA√á√ÉO: Procurando lembretes vermelhos em TODOS os seletores...",
                );

                // Seletores m√∫ltiplos para diferentes tipos de lembretes
                const seletores = [
                    'div.divLembrete[style*="background-color:#db8080"]',
                    'div.divLembrete[style*="background-color: #db8080"]',
                    '.lista-lembretes .lembrete[style*="background-color:#db8080"]',
                    '.lista-lembretes .lembrete[style*="background-color: #db8080"]',
                    'div[style*="background-color:#db8080"]',
                    'div[style*="background-color: #db8080"]',
                ];

                let elementosEncontrados = [];

                // Tentar cada seletor
                seletores.forEach((seletor, index) => {
                    const elementos = document.querySelectorAll(seletor);
                    if (elementos.length > 0) {
                        log(
                            `‚úÖ ENCONTRADOS ${
                                elementos.length
                            } lembretes vermelhos com seletor ${
                                index + 1
                            }: ${seletor}`,
                        );
                        elementosEncontrados.push(...elementos);
                    }
                });

                // Remover duplicatas
                elementosEncontrados = [...new Set(elementosEncontrados)];

                if (elementosEncontrados.length === 0) {
                    log("‚ùå Nenhum elemento lembrete vermelho encontrado");
                    return false;
                }

                elementosEncontrados.forEach((elemento, index) => {
                    // Aplicar gradiente vermelho
                    elemento.style.background =
                        "linear-gradient( #FAAFAF, #F78D8D)";

                    // Aplicar estilos aprimorados - GARANTINDO MESMO TAMANHO
                    elemento.style.padding = "20px !important";
                    elemento.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
                    elemento.style.transition = "box-shadow 0.5s ease";
                    elemento.style.webkitFontSmoothing = "subpixel-antialiased";

                    // CORRE√á√ÉO: Garantir mesmo tamanho visual de todos os lembretes
                    elemento.style.minWidth = "315px";
                    elemento.style.minHeight = "140px";
                    elemento.style.fontSize = "1rem";
                    elemento.style.lineHeight = "1.5";
                    elemento.style.margin = "0";
                    elemento.style.border = "none";

                    // Marcar como processado para consist√™ncia
                    elemento.classList.add("eprobe-lembrete-processado");

                    // Adicionar eventos de hover e focus
                    elemento.addEventListener(
                        "mouseenter",
                        function () {
                            this.style.boxShadow = "0 5px 8px rgba(0,0,0,0.15)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "mouseleave",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "focus",
                        function () {
                            this.style.boxShadow = "0 5px 12px rgba(0,0,0,0.2)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "blur",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true },
                    );

                    log(
                        `‚úÖ Gradiente vermelho aplicado ao divLembrete ${
                            index + 1
                        } (ID: ${elemento.id})`,
                    );
                });
                log(
                    `üé® CONCLU√çDO: ${elementosEncontrados.length} elementos divLembrete vermelhos com gradiente`,
                );
                return elementosEncontrados.length;
            }

            /**
             * üé® FUN√á√ÉO DE ESTILIZA√á√ÉO PARA LEMBRETES AZUIS - Com detec√ß√£o inteligente
             */
            function estilizarDivLembreteAzul() {
                log(
                    "üé® ESTILIZA√á√ÉO AZUL: Aplicando gradiente com detec√ß√£o inteligente",
                );

                // M√∫ltiplos seletores para diferentes estruturas da p√°gina
                const seletores = [
                    'div.divLembrete[style*="background-color:#87adcd"]',
                    'div.divLembrete[style*="background-color: #87adcd"]',
                    '.lista-lembretes div[style*="#87adcd"]',
                    'div[style*="background-color:#87adcd"]',
                    'div[style*="background-color: #87adcd"]',
                ];

                let elementos = [];

                // Tentar cada seletor at√© encontrar elementos
                for (const seletor of seletores) {
                    elementos = document.querySelectorAll(seletor);
                    if (elementos.length > 0) {
                        log(
                            `‚úÖ AZUL: Encontrados ${elementos.length} elementos com seletor: ${seletor}`,
                        );
                        break;
                    }
                }

                if (elementos.length === 0) {
                    log(
                        "‚ùå AZUL: Nenhum elemento azul encontrado com nenhum dos seletores",
                    );
                    return false;
                }

                elementos.forEach((elemento, index) => {
                    // Aplicar gradiente azul
                    elemento.style.background =
                        "linear-gradient( #AFCFFA, #8DC0F7)";

                    // Aplicar estilos aprimorados - GARANTINDO MESMO TAMANHO
                    elemento.style.padding = "20px !important";
                    elemento.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
                    elemento.style.transition = "box-shadow 0.5s ease";
                    elemento.style.webkitFontSmoothing = "subpixel-antialiased";

                    // CORRE√á√ÉO: Garantir mesmo tamanho visual de todos os lembretes
                    elemento.style.minWidth = "315px";
                    elemento.style.minHeight = "140px";
                    elemento.style.fontSize = "1rem";
                    elemento.style.lineHeight = "1.5";
                    elemento.style.margin = "0";
                    elemento.style.border = "none";

                    // Marcar como processado para consist√™ncia
                    elemento.classList.add("eprobe-lembrete-processado");

                    // Adicionar eventos de hover e focus
                    elemento.addEventListener(
                        "mouseenter",
                        function () {
                            this.style.boxShadow = "0 5px 8px rgba(0,0,0,0.15)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "mouseleave",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "focus",
                        function () {
                            this.style.boxShadow = "0 5px 12px rgba(0,0,0,0.2)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "blur",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true },
                    );

                    log(
                        `‚úÖ AZUL: Gradiente aplicado ao elemento ${
                            index + 1
                        } (ID: ${elemento.id})`,
                    );
                });

                log(
                    `üé® AZUL CONCLU√çDO: ${elementos.length} elementos estilizados`,
                );
                return elementos.length;
            }

            /**
             * üé® FUN√á√ÉO DE ESTILIZA√á√ÉO PARA LEMBRETES VERDES - Com detec√ß√£o inteligente
             */
            function estilizarDivLembreteVerde() {
                log(
                    "üé® ESTILIZA√á√ÉO VERDE: Aplicando gradiente com detec√ß√£o inteligente",
                );

                // M√∫ltiplos seletores para diferentes estruturas da p√°gina
                const seletores = [
                    'div.divLembrete[style*="background-color:#a7eda7"]',
                    'div.divLembrete[style*="background-color: #a7eda7"]',
                    '.lista-lembretes div[style*="#a7eda7"]',
                    'div[style*="background-color:#a7eda7"]',
                    'div[style*="background-color: #a7eda7"]',
                ];

                let elementos = [];

                // Tentar cada seletor at√© encontrar elementos
                for (const seletor of seletores) {
                    elementos = document.querySelectorAll(seletor);
                    if (elementos.length > 0) {
                        log(
                            `‚úÖ VERDE: Encontrados ${elementos.length} elementos com seletor: ${seletor}`,
                        );
                        break;
                    }
                }

                if (elementos.length === 0) {
                    log(
                        "‚ùå VERDE: Nenhum elemento verde encontrado com nenhum dos seletores",
                    );
                    return false;
                }

                elementos.forEach((elemento, index) => {
                    // Aplicar gradiente verde
                    elemento.style.background =
                        "linear-gradient( #AFFAB6, #8DF792)";

                    // Aplicar estilos aprimorados - GARANTINDO MESMO TAMANHO
                    elemento.style.padding = "20px !important";
                    elemento.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
                    elemento.style.transition = "box-shadow 0.5s ease";
                    elemento.style.webkitFontSmoothing = "subpixel-antialiased";

                    // CORRE√á√ÉO: Garantir mesmo tamanho visual de todos os lembretes
                    elemento.style.minWidth = "315px";
                    elemento.style.minHeight = "140px";
                    elemento.style.fontSize = "1rem";
                    elemento.style.lineHeight = "1.5";
                    elemento.style.margin = "0";
                    elemento.style.border = "none";

                    // Marcar como processado para consist√™ncia
                    elemento.classList.add("eprobe-lembrete-processado");

                    // Adicionar eventos de hover e focus
                    elemento.addEventListener(
                        "mouseenter",
                        function () {
                            this.style.boxShadow = "0 5px 8px rgba(0,0,0,0.15)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "mouseleave",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "focus",
                        function () {
                            this.style.boxShadow = "0 5px 12px rgba(0,0,0,0.2)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "blur",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true },
                    );

                    log(
                        `‚úÖ VERDE: Gradiente aplicado ao elemento ${
                            index + 1
                        } (ID: ${elemento.id})`,
                    );
                });

                log(
                    `üé® VERDE CONCLU√çDO: ${elementos.length} elementos estilizados`,
                );
                return elementos.length;
            }

            /**
             * üé® FUN√á√ÉO DE ESTILIZA√á√ÉO PARA LEMBRETES LARANJAS - Com detec√ß√£o inteligente
             */
            function estilizarDivLembreteLaranja() {
                log(
                    "üé® ESTILIZA√á√ÉO LARANJA: Aplicando gradiente com detec√ß√£o inteligente",
                );

                // M√∫ltiplos seletores para diferentes estruturas da p√°gina
                const seletores = [
                    'div.divLembrete[style*="background-color:#f5b574"]',
                    'div.divLembrete[style*="background-color: #f5b574"]',
                    '.lista-lembretes div[style*="#f5b574"]',
                    'div[style*="background-color:#f5b574"]',
                    'div[style*="background-color: #f5b574"]',
                ];

                let elementos = [];

                // Tentar cada seletor at√© encontrar elementos
                for (const seletor of seletores) {
                    elementos = document.querySelectorAll(seletor);
                    if (elementos.length > 0) {
                        log(
                            `‚úÖ LARANJA: Encontrados ${elementos.length} elementos com seletor: ${seletor}`,
                        );
                        break;
                    }
                }

                if (elementos.length === 0) {
                    log(
                        "‚ùå LARANJA: Nenhum elemento laranja encontrado com nenhum dos seletores",
                    );
                    return false;
                }

                elementos.forEach((elemento, index) => {
                    // Aplicar gradiente laranja
                    elemento.style.background =
                        "linear-gradient( #FAD3AF, #F7C68D)";

                    // Aplicar estilos aprimorados - GARANTINDO MESMO TAMANHO DOS OUTROS
                    elemento.style.padding = "20px !important";
                    elemento.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.1)";
                    elemento.style.transition = "box-shadow 0.5s ease";
                    elemento.style.webkitFontSmoothing = "subpixel-antialiased";

                    // CORRE√á√ÉO CR√çTICA: Garantir mesmo tamanho visual dos outros lembretes
                    elemento.style.minWidth = "315px";
                    elemento.style.minHeight = "140px";
                    elemento.style.fontSize = "1rem";
                    elemento.style.lineHeight = "1.5";
                    elemento.style.margin = "0";
                    elemento.style.border = "none";

                    // Marcar como processado para consist√™ncia
                    elemento.classList.add("eprobe-lembrete-processado");

                    // Adicionar eventos de hover e focus
                    elemento.addEventListener(
                        "mouseenter",
                        function () {
                            this.style.boxShadow = "0 5px 8px rgba(0,0,0,0.15)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "mouseleave",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "focus",
                        function () {
                            this.style.boxShadow = "0 5px 12px rgba(0,0,0,0.2)";
                        },
                        { passive: true },
                    );

                    elemento.addEventListener(
                        "blur",
                        function () {
                            this.style.boxShadow =
                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                        },
                        { passive: true },
                    );

                    log(
                        `‚úÖ LARANJA: Gradiente aplicado ao elemento ${
                            index + 1
                        } (ID: ${elemento.id})`,
                    );
                });

                log(
                    `üé® LARANJA CONCLU√çDO: ${elementos.length} elementos estilizados`,
                );
                return elementos.length;
            }

            /**
             * üé® FUN√á√ÉO MASTER - Aplica todos os gradientes de uma vez com detec√ß√£o inteligente
             */
            function estilizarTodosDivLembrete() {
                log(
                    "üé® MASTER: Iniciando estiliza√ß√£o com detec√ß√£o inteligente...",
                );

                // Primeiro detectar que tipos de lembretes existem
                const deteccao = detectarTiposLembretesNaPagina();

                if (deteccao.coresEncontradas.length === 0) {
                    log(
                        "‚ÑπÔ∏è MASTER: Nenhum lembrete colorido encontrado para estilizar",
                    );
                    return { total: 0, detalhes: {} };
                }

                log(
                    `üéØ MASTER: Cores encontradas: ${deteccao.coresEncontradas.join(
                        ", ",
                    )}`,
                );

                const resultados = {
                    amarelos: 0,
                    vermelhos: 0,
                    azuis: 0,
                    verdes: 0,
                    laranjas: 0,
                    total: 0,
                    deteccao: deteccao,
                };

                // Aplicar cada cor encontrada
                deteccao.coresEncontradas.forEach((cor) => {
                    try {
                        let sucesso = false;
                        let quantidade = 0;

                        switch (cor) {
                            case "amarelo":
                                sucesso = estilizarDivLembrete();
                                if (sucesso) {
                                    quantidade = document.querySelectorAll(
                                        'div[style*="background-color:#efef8f"], div[style*="background-color: #efef8f"], .lista-lembretes [style*="#efef8f"]',
                                    ).length;
                                    resultados.amarelos = quantidade;
                                }
                                break;
                            case "vermelho":
                                sucesso = estilizarDivLembreteVermelho();
                                if (sucesso) {
                                    quantidade = document.querySelectorAll(
                                        'div[style*="background-color:#db8080"], div[style*="background-color: #db8080"], .lista-lembretes [style*="#db8080"]',
                                    ).length;
                                    resultados.vermelhos = quantidade;
                                }
                                break;
                            case "azul":
                                sucesso = estilizarDivLembreteAzul();
                                if (sucesso) {
                                    quantidade = document.querySelectorAll(
                                        'div[style*="background-color:#87adcd"], div[style*="background-color: #87adcd"], .lista-lembretes [style*="#87adcd"]',
                                    ).length;
                                    resultados.azuis = quantidade;
                                }
                                break;
                            case "verde":
                                sucesso = estilizarDivLembreteVerde();
                                if (sucesso) {
                                    quantidade = document.querySelectorAll(
                                        'div[style*="background-color:#a7eda7"], div[style*="background-color: #a7eda7"], .lista-lembretes [style*="#a7eda7"]',
                                    ).length;
                                    resultados.verdes = quantidade;
                                }
                                break;
                            case "laranja":
                                sucesso = estilizarDivLembreteLaranja();
                                if (sucesso) {
                                    quantidade = document.querySelectorAll(
                                        'div[style*="background-color:#f5b574"], div[style*="background-color: #f5b574"], .lista-lembretes [style*="#f5b574"]',
                                    ).length;
                                    resultados.laranjas = quantidade;
                                }
                                break;
                        }

                        log(
                            `‚úÖ MASTER ${cor}: ${quantidade} lembretes estilizados`,
                        );
                    } catch (error) {
                        log(
                            `‚ùå MASTER: Erro ao estilizar lembretes ${cor}:`,
                            error,
                        );
                    }
                });

                resultados.total =
                    resultados.amarelos +
                    resultados.vermelhos +
                    resultados.azuis +
                    resultados.verdes +
                    resultados.laranjas;

                log("üé® MASTER CONCLU√çDO:", resultados);
                return resultados;
            }

            /**
             * üîç FUN√á√ÉO DE DEBUG MASTER - Verifica todos os divLembrete coloridos
             */
            function debugTodosDivLembrete() {
                log(
                    "üîç DEBUG MASTER: Analisando todos os divLembrete coloridos",
                );

                const cores = {
                    amarelo: {
                        seletor:
                            'div.divLembrete[style*="background-color:#efef8f"], div.divLembrete[style*="background-color: #efef8f"]',
                        gradiente: "linear-gradient( #F9EFAF, #F7E98D)",
                    },
                    vermelho: {
                        seletor:
                            'div.divLembrete[style*="background-color:#db8080"], div.divLembrete[style*="background-color: #db8080"]',
                        gradiente: "linear-gradient( #FAAFAF, #F78D8D)",
                    },
                    azul: {
                        seletor:
                            'div.divLembrete[style*="background-color:#87adcd"], div.divLembrete[style*="background-color: #87adcd"]',
                        gradiente: "linear-gradient( #AFCFFA, #8DC0F7)",
                    },
                    verde: {
                        seletor:
                            'div.divLembrete[style*="background-color:#a7eda7"], div.divLembrete[style*="background-color: #a7eda7"]',
                        gradiente: "linear-gradient( #AFFAB6, #8DF792)",
                    },
                    laranja: {
                        seletor:
                            'div.divLembrete[style*="background-color:#f5b574"], div.divLembrete[style*="background-color: #f5b574"]',
                        gradiente: "linear-gradient( #FAD3AF, #F7C68D)",
                    },
                };

                const resumo = {
                    totalEncontrados: 0,
                    porCor: {},
                };

                Object.keys(cores).forEach((cor) => {
                    const elementos = document.querySelectorAll(
                        cores[cor].seletor,
                    );
                    resumo.porCor[cor] = {
                        quantidade: elementos.length,
                        elementos: Array.from(elementos).map((el) => ({
                            id: el.id,
                            classes: el.className,
                            conteudo: el.textContent.substring(0, 50) + "...",
                        })),
                    };
                    resumo.totalEncontrados += elementos.length;

                    log(
                        `üìã ${cor.toUpperCase()}: ${elementos.length} elementos`,
                    );
                });

                log("üîç DEBUG MASTER RESUMO:", resumo);
                return resumo;
            }

            /**
             * üîÑ FUN√á√ÉO DE ESTILIZA√á√ÉO ROBUSTA - Com detec√ß√£o inteligente e retry autom√°tico
             */
            function aplicarEstilizacaoLembretesRobusta() {
                log(
                    "üîÑ ESTILIZA√á√ÉO ROBUSTA: Iniciando com detec√ß√£o inteligente...",
                );

                // 1. PRIMEIRO: Detectar que tipos de lembretes existem
                const deteccao = detectarTiposLembretesNaPagina();

                if (deteccao.coresEncontradas.length === 0) {
                    log(
                        "‚ÑπÔ∏è ESTILIZA√á√ÉO ROBUSTA: Nenhum lembrete colorido encontrado na p√°gina atual",
                    );
                    return false;
                }

                log(
                    `üéØ ESTILIZA√á√ÉO ROBUSTA: Encontrados lembretes de ${deteccao.coresEncontradas.length} cores diferentes`,
                );

                let tentativas = 0;
                const maxTentativas = 5;
                const intervalTentativas = 1000; // 1 segundo entre tentativas

                const tentarEstilizar = () => {
                    tentativas++;
                    log(
                        `üéØ ESTILIZA√á√ÉO: Tentativa ${tentativas}/${maxTentativas}`,
                    );

                    const resultado = estilizarTodosDivLembrete();
                    const sucesso = resultado.total > 0;

                    if (!sucesso && tentativas < maxTentativas) {
                        log(
                            `‚è≥ ESTILIZA√á√ÉO: Aguardando ${intervalTentativas}ms para nova tentativa...`,
                        );
                        setTimeout(tentarEstilizar, intervalTentativas);
                    } else if (sucesso) {
                        log(
                            "‚úÖ ESTILIZA√á√ÉO ROBUSTA: Lembretes estilizados com sucesso!",
                        );
                        log(
                            `üìä RESULTADOS: ${resultado.total} lembretes processados`,
                            resultado,
                        );
                    } else {
                        log(
                            "‚ö†Ô∏è ESTILIZA√á√ÉO ROBUSTA: N√£o foi poss√≠vel encontrar lembretes ap√≥s todas as tentativas",
                        );
                    }
                };

                // Iniciar primeira tentativa
                tentarEstilizar();

                // Tamb√©m agendar uma verifica√ß√£o ap√≥s carregamento completo
                if (document.readyState !== "complete") {
                    window.addEventListener("load", () => {
                        setTimeout(() => {
                            log(
                                "üîÑ ESTILIZA√á√ÉO: Verifica√ß√£o p√≥s-carregamento...",
                            );
                            estilizarTodosDivLembrete();
                        }, 500);
                    });
                }
            }

            /**
             * ‚ö° APLICA√á√ÉO IMEDIATA ANTI-FLASH ULTRA-OTIMIZADA - ZERO FLASH GARANTIDO
             * Sistema ultrarr√°pido que elimina completamente qualquer transforma√ß√£o visual
             */
            function aplicarEstilizacaoImediataLembretes() {
                try {
                    // üöÄ ULTRA-OTIMIZA√á√ÉO: Execu√ß√£o sem logs para m√°xima velocidade

                    // 1. DETEC√á√ÉO ULTRARR√ÅPIDA de lembretes
                    const deteccao = detectarTiposLembretesNaPagina();

                    if (deteccao.coresEncontradas.length === 0) {
                        return false;
                    }

                    // 2. BATCH PROCESSING: Preparar todos os estilos em mem√≥ria primeiro
                    const styleBatch = new Map();
                    const elementsToProcess = [];

                    deteccao.coresEncontradas.forEach((nomeCor) => {
                        const elementos =
                            deteccao.elementosPorCor[nomeCor] || [];

                        elementos.forEach((elemento) => {
                            if (
                                !elemento.classList.contains(
                                    "eprobe-lembrete-processado",
                                )
                            ) {
                                // Preparar estilos em batch para aplica√ß√£o simult√¢nea
                                const styleConfig = {
                                    element: elemento,
                                    styles: {},
                                };

                                // Gradientes otimizados por cor
                                switch (nomeCor) {
                                    case "amarelo":
                                        styleConfig.styles.background =
                                            "linear-gradient(#F9EFAF, #F7E98D)";
                                        break;
                                    case "vermelho":
                                        styleConfig.styles.background =
                                            "linear-gradient(#FAAFAF, #F78D8D)";
                                        break;
                                    case "azul":
                                        styleConfig.styles.background =
                                            "linear-gradient(#AFCFFA, #8DC0F7)";
                                        break;
                                    case "verde":
                                        styleConfig.styles.background =
                                            "linear-gradient(#AFFAB6, #8DF792)";
                                        break;
                                    case "laranja":
                                        styleConfig.styles.background =
                                            "linear-gradient(#FAD3AF, #F7C68D)";
                                        break;
                                }

                                // Estilos base ultra-otimizados
                                Object.assign(styleConfig.styles, {
                                    padding: "20px",
                                    boxShadow: "0 4px 6px rgba(0, 0, 0, 0.1)",
                                    transition: "box-shadow 0.2s ease",
                                    WebkitFontSmoothing: "subpixel-antialiased",
                                    visibility: "visible",
                                    opacity: "1",
                                });

                                elementsToProcess.push(styleConfig);
                            }
                        });
                    });

                    // 3. APLICA√á√ÉO SIMULT√ÇNEA: Aplicar todos os estilos de uma vez
                    // Usar requestAnimationFrame para sincronizar com o browser
                    const applyStylesBatch = () => {
                        elementsToProcess.forEach(({ element, styles }) => {
                            // Aplica√ß√£o ultrarr√°pida usando Object.assign para CSSStyleDeclaration
                            Object.entries(styles).forEach(([prop, value]) => {
                                element.style.setProperty(
                                    prop
                                        .replace(/([A-Z])/g, "-$1")
                                        .toLowerCase(),
                                    value,
                                    "important",
                                );
                            });

                            // Marcar como processado instantaneamente
                            element.classList.add("eprobe-lembrete-processado");
                        });

                        // 4. SUBSTITUI√á√ÉO INSTANT√ÇNEA de √≠cones (sem logs)
                        substituirIconesLembretesImediato();

                        // 5. VERIFICA√á√ÉO FINAL: Garantir visibilidade
                        deteccao.elementos.forEach((elemento) => {
                            if (
                                !elemento.classList.contains(
                                    "eprobe-lembrete-processado",
                                )
                            ) {
                                elemento.classList.add(
                                    "eprobe-lembrete-processado",
                                );
                                elemento.style.setProperty(
                                    "visibility",
                                    "visible",
                                    "important",
                                );
                                elemento.style.setProperty(
                                    "opacity",
                                    "1",
                                    "important",
                                );
                            }
                        });
                    };

                    // Executar IMEDIATAMENTE sem aguardar frame
                    applyStylesBatch();

                    return true;
                } catch (error) {
                    log(
                        "‚ùå ANTI-FLASH: Erro durante aplica√ß√£o imediata:",
                        error,
                    );

                    // FALLBACK DE EMERG√äNCIA: Tornar todos os lembretes vis√≠veis imediatamente
                    const todosLembretes = document.querySelectorAll(
                        'div.divLembrete, .lista-lembretes .lembrete, div[style*="background-color:#efef8f"], div[style*="background-color:#db8080"], div[style*="background-color:#87adcd"], div[style*="background-color:#a7eda7"], div[style*="background-color:#f5b574"]',
                    );

                    todosLembretes.forEach((elemento) => {
                        elemento.style.setProperty(
                            "visibility",
                            "visible",
                            "important",
                        );
                        elemento.style.setProperty("opacity", "1", "important");
                    });

                    log(
                        `üö® FALLBACK: ${todosLembretes.length} lembretes restaurados via fallback`,
                    );
                    return false;
                }
            }

            /**
             * ‚ö° SUBSTITUI√á√ÉO IMEDIATA DE √çCONES - SEM LOGS PARA M√ÅXIMA PERFORMANCE
             * Vers√£o ultra-r√°pida da substitui√ß√£o de √≠cones para eliminar flash
             */
            function substituirIconesLembretesImediato() {
                // Restricao: So na pagina de capa do processo
                if (!isCapaProcessoPage()) {
                    return false;
                }

                try {
                    // Delegar substituicao de icones para funcao unificada
                    substituirTodosIcones();

                    // 3. Substituir botoes "Ler mais" por icone expand_all (apenas quando necessario)
                    let botoesLerMais = Array.from(
                        document.querySelectorAll("div.botaoLerMais"),
                    ).filter((botao) => {
                        const texto = (botao.textContent || "").toLowerCase();
                        return (
                            texto.includes("ler mais") ||
                            texto.includes("...ler mais") ||
                            texto.includes("... ler mais")
                        );
                    });

                    // üîß DEBUG: Log dos bot√µes encontrados
                    console.log(
                        `üîç LEMBRETES: ${botoesLerMais.length} bot√µes "Ler mais" encontrados total`,
                    );
                    const botoesNaoProcessados = botoesLerMais.filter(
                        (botao) =>
                            !botao.hasAttribute(
                                "data-eprobe-expandir-replaced",
                            ),
                    );
                    console.log(
                        `üîç LEMBRETES: ${botoesNaoProcessados.length} bot√µes "Ler mais" n√£o processados`,
                    );

                    botoesLerMais.forEach((botao, index) => {
                        const jaProcessado = botao.hasAttribute(
                            "data-eprobe-expandir-replaced",
                        );
                        console.log(
                            `üîç BOT√ÉO ${index + 1}: ${
                                jaProcessado
                                    ? "‚úÖ J√° processado"
                                    : "üîÑ Processando..."
                            }`,
                        );

                        if (!jaProcessado) {
                            const temEventoClick =
                                botao.onclick || botao.getAttribute("onclick");
                            if (!temEventoClick) {
                                console.log(
                                    `‚ùå BOT√ÉO ${index + 1}: Sem evento de click`,
                                );
                                return;
                            }

                            const lembreteParent =
                                botao.closest(".divLembrete");
                            if (!lembreteParent) {
                                console.log(
                                    `‚ùå BOT√ÉO ${
                                        index + 1
                                    }: Sem parent .divLembrete`,
                                );
                                return;
                            }

                            const desLembrete =
                                lembreteParent.querySelector(".desLembrete");
                            if (!desLembrete) {
                                console.log(
                                    `‚ùå BOT√ÉO ${
                                        index + 1
                                    }: Sem elemento .desLembrete`,
                                );
                                return;
                            }

                            // Verificar se h√° truncamento de texto
                            const textoCompleto = desLembrete.textContent || "";
                            const temTextoTruncado =
                                textoCompleto.length > 150 ||
                                desLembrete.scrollHeight >
                                    desLembrete.clientHeight ||
                                textoCompleto.includes("...") ||
                                window.getComputedStyle(desLembrete)
                                    .textOverflow === "ellipsis";

                            if (!temTextoTruncado) return;

                            // Criar container centralizado
                            const container = document.createElement("div");
                            container.style.cssText =
                                "margin-top: 15px; margin-bottom: 25px; display: flex; align-items: center; justify-content: center; cursor: pointer; width: 100%;";
                            container.setAttribute(
                                "data-eprobe-expandir-replaced",
                                "true",
                            );

                            container.innerHTML = `
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#545454">
                                    <path d="M480-72 230-322l68-70 182 182 182-182 68 70L480-72ZM297-569l-67-71 250-250 250 250-67 71-183-183-183 183Z"/>
                                </svg>
                                <span style="color: #545454; font-size: 14px; font-weight: 500;">Expandir lembrete</span>
                            </div>
                        `;

                            // Copiar eventos
                            if (botao.onclick)
                                container.onclick = botao.onclick;
                            const onclickAttr = botao.getAttribute("onclick");
                            if (onclickAttr)
                                container.setAttribute("onclick", onclickAttr);

                            // Substituir elemento mantendo compatibilidade com eProc
                            try {
                                // Criar backup invis√≠vel do bot√£o original para compatibilidade com eProc
                                const botaoBackup = botao.cloneNode(true);
                                botaoBackup.style.display = "none";
                                botaoBackup.style.visibility = "hidden";
                                botaoBackup.style.position = "absolute";
                                botaoBackup.style.top = "-9999px";
                                botaoBackup.setAttribute(
                                    "data-eprobe-backup",
                                    "true",
                                );

                                // Inserir container e backup
                                botao.parentNode.insertBefore(container, botao);
                                botao.parentNode.insertBefore(
                                    botaoBackup,
                                    botao,
                                );
                                botao.parentNode.removeChild(botao);

                                console.log(
                                    `‚úÖ BOT√ÉO ${
                                        index + 1
                                    }: Substitu√≠do com sucesso por "Expandir lembrete"`,
                                );
                            } catch (error) {
                                console.log(
                                    `‚ùå BOT√ÉO ${
                                        index + 1
                                    }: Erro na substitui√ß√£o:`,
                                    error,
                                );
                                // Silencioso para m√°xima performance
                            }
                        }
                    });

                    // 4. Marcar lembretes como processados
                    const lembretes = document.querySelectorAll(
                        ".lista-lembretes .lembrete",
                    );
                    lembretes.forEach((lembrete) => {
                        lembrete.classList.add("eprobe-lembrete-processado");
                    });
                } catch (error) {
                    // Silencioso para n√£o afetar performance
                }
            }

            /**
             * üöÄ FUN√á√ÉO DE CORRE√á√ÉO COMPLETA - Diagnosticar e corrigir tooltip
             * Executa diagn√≥stico completo e for√ßa recria√ß√£o do tooltip DIRETO NO CARD
             */
            function diagnosticarECorrigirTooltip() {
                log("üöÄ DIAGN√ìSTICO COMPLETO: Iniciando com tooltip direto...");

                // 1. Verificar se h√° sess√µes detectadas
                const sessoesGlobais = window.SENT1_AUTO.todasSessoesDetectadas;
                log("üìä SESS√ïES GLOBAIS:", sessoesGlobais);

                // 2. Verificar card atual
                const card = document.getElementById("eprobe-data-sessao");
                if (!card) {
                    logError("‚ùå DIAGN√ìSTICO: Card n√£o encontrado");
                    return false;
                }

                log("‚úÖ DIAGN√ìSTICO: Card encontrado");

                // 3. Remover qualquer indicador existente (n√£o precisamos mais)
                const indicadorExistente = card.querySelector(
                    ".eprobe-figma-sessions-indicator",
                );
                if (indicadorExistente) {
                    log(" Ô∏è DIAGN√ìSTICO: Removendo indicador antigo...");
                    indicadorExistente.remove();
                }

                // 4. Se n√£o h√° sess√µes m√∫ltiplas, criar dados de teste
                let sessoesParaTeste = sessoesGlobais;
                if (!sessoesParaTeste || sessoesParaTeste.length <= 1) {
                    log(
                        "‚ö†Ô∏è DIAGN√ìSTICO: Criando dados de teste para tooltip...",
                    );
                    sessoesParaTeste = [
                        {
                            status: "Pautado",
                            data: "15/07/2025",
                            dataOriginal: "15/07/2025",
                            orgao: "4CCR",
                            tipoProcesso: "Apela√ß√£o",
                            prioridade: 1,
                        },
                        {
                            status: "Retirado",
                            data: "10/07/2025",
                            dataOriginal: "10/07/2025",
                            orgao: "4CCR",
                            tipoProcesso: "Apela√ß√£o",
                            prioridade: 2,
                        },
                        {
                            status: "Julgado",
                            data: "05/07/2025",
                            dataOriginal: "05/07/2025",
                            orgao: "4CCR",
                            tipoProcesso: "Apela√ß√£o",
                            prioridade: 3,
                        },
                    ];

                    // Armazenar globalmente
                    window.SENT1_AUTO.todasSessoesDetectadas = sessoesParaTeste;
                }

                // 5. Remover tooltip antigo
                const tooltipAntigo = document.getElementById(
                    "eprobe-rich-tooltip",
                );
                if (tooltipAntigo) {
                    tooltipAntigo.remove();
                    log("üóëÔ∏è DIAGN√ìSTICO: Tooltip antigo removido");
                }

                // 6. Aplicar tooltip DIRETO NO CARD
                log("üé® DIAGN√ìSTICO: Aplicando tooltip direto no card...");
                const resultado = adicionarTooltipDiretoNoCard(
                    card,
                    sessoesParaTeste,
                );

                if (resultado && resultado.status === "sucesso") {
                    logCritical(
                        "‚úÖ DIAGN√ìSTICO: Tooltip direto aplicado com sucesso!",
                    );
                } else {
                    logError("‚ùå DIAGN√ìSTICO: Falha ao aplicar tooltip direto");
                }

                // 7. Testar ap√≥s 500ms
                setTimeout(() => {
                    log("üß™ DIAGN√ìSTICO: Testando tooltip...");
                    testarTooltipRapido();
                }, 500);

                log("‚úÖ DIAGN√ìSTICO COMPLETO: Finalizado com tooltip direto!");
                return true;
            }

            /**
             * Obt√©m a classe CSS correspondente ao status
             * @param {string} status - Status da sess√£o
             * @returns {string} - Classe CSS correspondente
             */
            function obterClasseStatusPorTipo(status) {
                const statusLower = (status || "").toLowerCase();

                if (
                    statusLower.includes("pautado") ||
                    statusLower.includes("inclu√≠do")
                ) {
                    return "status-pautado";
                } else if (
                    statusLower.includes("julgado") ||
                    statusLower.includes("decidido")
                ) {
                    return "status-julgado";
                } else if (
                    statusLower.includes("retirado") ||
                    statusLower.includes("suspenso")
                ) {
                    return "status-retirado";
                }

                return "status-neutro";
            }

            /**
             * Obt√©m o √≠cone correspondente ao status
             * @param {string} status - Status da sess√£o
             * @returns {string} - HTML do √≠cone
             */
            function obterIconePorStatus(status) {
                const statusLower = (status || "").toLowerCase();

                if (
                    statusLower.includes("pautado") ||
                    statusLower.includes("inclu√≠do")
                ) {
                    return '<span class="material-icons">schedule</span>';
                } else if (
                    statusLower.includes("julgado") ||
                    statusLower.includes("decidido")
                ) {
                    return '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M6 3v12"/><circle cx="6" cy="3" r="3"/><path d="M6 21v-6"/><path d="M15 6a9 9 0 1 0 6 5.3c0.7-1.3 1-2.8 1-4.3 0-1.4-0.3-2.7-0.8-4z"/></svg>';
                } else if (
                    statusLower.includes("retirado") ||
                    statusLower.includes("suspenso")
                ) {
                    return '<span class="material-icons">pause_circle</span>';
                }

                return '<span class="material-icons">info</span>';
            }

            /**
             * Cria um card Material Design usando especifica√ß√µes EXATAS do Figma
             * @param {Object} dadosSessao - Dados da sess√£o detectada
             * @returns {HTMLElement} - Elemento do card criado
             */
            /**
             * üé® CONFIGURA√á√ïES DOS CARDS POR STATUS
             * Define cor do √≠cone e texto do header para cada status
             * @param {string} status - Status da sess√£o (pode ser null/undefined)
             * @returns {Object} - Configura√ß√£o com corIcon e statusText
             */
            function obterConfigCardPorStatus(status) {
                // Normalizar status (remover espa√ßos, lowercase)
                const statusNormalizado = (status || "").toLowerCase().trim();

                // Mapeamento completo dos 8 cards conforme especifica√ß√µes Figma
                const configuracoes = {
                    pautado: {
                        corIcon: "#5C85B4",
                        statusText: "Pautado",
                    },
                    retirado: {
                        corIcon: "#CE2D4F",
                        statusText: "Retirado",
                    },
                    vista: {
                        corIcon: "#FFBF46",
                        statusText: "Vista",
                    },
                    julgado: {
                        corIcon: "#3AB795",
                        statusText: "Julgado",
                    },
                    adiado: {
                        corIcon: "#F55D3E",
                        statusText: "Adiado",
                    },
                    adiado935: {
                        corIcon: "#731963",
                        statusText: "Adiado 935",
                    },
                    sobrestado: {
                        corIcon: "#FCB0B3",
                        statusText: "Sobrestado",
                    },
                    diligencia: {
                        corIcon: "#00171F",
                        statusText: "Dilig√™ncia",
                    },
                };

                // Buscar configura√ß√£o exata ou fallback para Pautado
                return (
                    configuracoes[statusNormalizado] || configuracoes["pautado"]
                );
            }

            /**
             * üé® CARD FIGMA - IMPLEMENTA√á√ÉO DIN√ÇMICA PARA TODOS OS STATUS
             * Base igual para todos, muda apenas texto do header e cor do √≠cone
             * @param {Object} dadosSessao - Dados da sess√£o (obrigat√≥rio)
             * @returns {HTMLElement|null} - Elemento do card ou null se erro
             */
            function criarCardMaterialDesign(dadosSessao) {
                // ‚ö†Ô∏è VALIDA√á√ÉO CR√çTICA: Card s√≥ funciona com dados da sess√£o
                if (!dadosSessao) {
                    log(
                        "‚ùå CARD FIGMA: Sem dados da sess√£o - n√£o criando card",
                    );
                    return null;
                }

                try {
                    // Obter configura√ß√£o baseada no status
                    const config = obterConfigCardPorStatus(dadosSessao.status);
                    log(
                        `üé® CRIANDO CARD ${config.statusText.toUpperCase()} (${
                            config.corIcon
                        }):`,
                        dadosSessao,
                    );

                    // 0. GARANTIR FONTE ROBOTO CARREGADA
                    if (
                        !document.querySelector(
                            'link[href*="fonts.googleapis.com"][href*="Roboto"]',
                        )
                    ) {
                        const linkRoboto = document.createElement("link");
                        linkRoboto.rel = "stylesheet";
                        linkRoboto.href =
                            "https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap";
                        document.head.appendChild(linkRoboto);
                    }

                    // 1. CONTAINER PRINCIPAL - Dimens√µes exatas: 169x60px conforme suas especifica√ß√µes
                    const cardContainer = document.createElement("div");
                    cardContainer.id = "eprobe-data-sessao";
                    cardContainer.className = "eprobe-figma-card-pautado";
                    cardContainer.style.cssText = `
                width: 190px;
                height: 60px;
                margin: 8px 4px;
                display: inline-block;
                position: relative;
                cursor: pointer;
                transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
                box-shadow: 0px 3px 3px rgba(0, 0, 0, 0.25);
                filter: drop-shadow(0px 4px 4px rgba(0, 0, 0, 0.3));
                border-radius: 9px;
            `;

                    // 2. SVG BASE - Dimens√µes atualizadas 190x60px para comportar "Conv. em Dilig√™ncia"
                    const svg = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "svg",
                    );
                    svg.setAttribute("width", "190");
                    svg.setAttribute("height", "60");
                    svg.setAttribute("viewBox", "0 0 190 60");
                    svg.setAttribute("fill", "none");

                    // 3. FUNDO DO CARD - COR EXATA FIGMA
                    const backgroundRect = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "rect",
                    );
                    backgroundRect.setAttribute("x", "0");
                    backgroundRect.setAttribute("y", "0");
                    backgroundRect.setAttribute("width", "190");
                    backgroundRect.setAttribute("height", "60");
                    backgroundRect.setAttribute("rx", "9");
                    backgroundRect.setAttribute("fill", "#FEF7FF");
                    backgroundRect.setAttribute("stroke", "#CAC4D0");
                    backgroundRect.setAttribute("stroke-width", "0.75");

                    // 4. √çCONE PAUTADO - CALEND√ÅRIO COM REL√ìGIO #5C85B4
                    // Dimens√µes exatas do Figma: 24.9 x 24.75px
                    const iconGroup = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "g",
                    );

                    // Posi√ß√£o do √≠cone conforme especifica√ß√µes Figma exatas (ajustada para nova largura)
                    // left: 6.51%, top: 27.65%, dimens√µes: 24.9 x 24.75px
                    const iconX = Math.round(190 * 0.0651); // 6.51% de 190px = ~12px
                    const iconY = Math.round(60 * 0.2765); // 27.65% de 60px = ~16.6px

                    // Container do √≠cone com dimens√µes exatas
                    const iconRect = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "rect",
                    );
                    iconRect.setAttribute("x", iconX);
                    iconRect.setAttribute("y", iconY);
                    iconRect.setAttribute("width", "24.9");
                    iconRect.setAttribute("height", "24.75");
                    iconRect.setAttribute("fill", "none"); // Invis√≠vel, apenas para definir √°rea

                    // SVG do calend√°rio com rel√≥gio - dimens√µes 24.9 x 24.75px
                    const iconPath = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "path",
                    );
                    iconPath.setAttribute(
                        "transform",
                        `translate(${iconX}, ${iconY})`,
                    );
                    iconPath.setAttribute(
                        "d",
                        "M2.48973 24.1623C1.80506 24.1623 1.21914 23.9317 0.731981 23.4705C0.244824 23.0093 0.00082991 22.4542 0 21.8052V5.3052C0 4.65698 0.243994 4.10227 0.731981 3.64105C1.21997 3.17984 1.80589 2.94884 2.48973 2.94805H3.7346V0.590912H6.22433V2.94805H16.1833V0.590912H18.673V2.94805H19.9179C20.6025 2.94805 21.1889 3.17905 21.6768 3.64105C22.1648 4.10305 22.4084 4.65777 22.4076 5.3052V10.815C22.4076 11.1489 22.2881 11.4291 22.0491 11.6553C21.81 11.8816 21.5146 11.9944 21.1627 11.9936C20.8108 11.9928 20.5154 11.8797 20.2764 11.6542C20.0374 11.4287 19.9179 11.1489 19.9179 10.815V10.0195H2.48973V21.8052H9.70995C10.0627 21.8052 10.3585 21.9183 10.5975 22.1446C10.8366 22.3709 10.9556 22.6506 10.9548 22.9838C10.954 23.3169 10.8345 23.597 10.5963 23.8241C10.3581 24.0512 10.0627 24.1639 9.70995 24.1623H2.48973ZM18.673 25.3409C16.9509 25.3409 15.4832 24.7662 14.2699 23.6167C13.0566 22.4672 12.4495 21.0776 12.4487 19.4481C12.4478 17.8185 13.0549 16.4289 14.2699 15.2794C15.4849 14.1299 16.9526 13.5552 18.673 13.5552C20.3934 13.5552 21.8615 14.1299 23.0773 15.2794C24.2931 16.4289 24.8998 17.8185 24.8973 19.4481C24.8948 21.0776 24.2877 22.4676 23.0761 23.6178C21.8644 24.7681 20.3967 25.3425 18.673 25.3409ZM20.7581 22.2472L21.6295 21.4222L19.2954 19.2123V15.9123H18.0506V19.6838L20.7581 22.2472Z",
                    );
                    iconPath.setAttribute("fill", config.corIcon);
                    iconPath.setAttribute("class", "eprobe-icon-dinamico");

                    iconGroup.appendChild(iconRect);
                    iconGroup.appendChild(iconPath);

                    // 5. TEXTO PRINCIPAL - "Pautado" (Header LP)
                    // Dimens√µes: 113.92 x 16.06px
                    // Posi√ß√£o: left: 26.04%, top: 23.33%, bottom: 49.9%
                    const textPrincipal = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "text",
                    );
                    // C√°lculos atualizados: 26.04% de 190px = ~49.5px, 23.33% de 60px = 14px
                    const headerX = Math.round(190 * 0.2604); // 26.04% = ~49.5px
                    const headerY = Math.round(60 * 0.2333) + 13.5; // 23.33% + font-size para baseline = ~27.5px

                    textPrincipal.setAttribute("x", headerX.toString());
                    textPrincipal.setAttribute("y", headerY.toString());
                    textPrincipal.setAttribute(
                        "font-family",
                        "Roboto, sans-serif",
                    );
                    textPrincipal.setAttribute("font-style", "normal");
                    textPrincipal.setAttribute("font-weight", "500");
                    textPrincipal.setAttribute("font-size", "13.5037px");
                    textPrincipal.setAttribute("line-height", "16");
                    textPrincipal.setAttribute("fill", "#1D1B20");
                    textPrincipal.setAttribute("text-anchor", "start");
                    textPrincipal.setAttribute("class", "eprobe-status-text");
                    textPrincipal.textContent = config.statusText;

                    // 6. SUBT√çTULO - "Sess√£o: getData()" (Subhead LP)
                    // Dimens√µes: 103.36 x 15.89px
                    // Posi√ß√£o: left: 26.04%, top: 50.1%, bottom: 24.9%
                    const dataExtraida = getData(dadosSessao);
                    const textData = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "text",
                    );
                    // C√°lculos atualizados: 26.04% de 190px = ~49.5px, 50.1% de 60px = 30px
                    const subheadX = Math.round(190 * 0.2604); // 26.04% = ~49.5px
                    const subheadY = Math.round(60 * 0.501) + 11; // 50.1% + font-size para baseline = ~41px

                    textData.setAttribute("x", subheadX.toString());
                    textData.setAttribute("y", subheadY.toString());
                    textData.setAttribute("font-family", "Roboto, sans-serif");
                    textData.setAttribute("font-style", "normal");
                    textData.setAttribute("font-weight", "400");
                    textData.setAttribute("font-size", "11px");
                    textData.setAttribute("line-height", "15");
                    textData.setAttribute("letter-spacing", "0.187552px");
                    textData.setAttribute("fill", "#1D1B20");
                    textData.setAttribute("text-anchor", "start");
                    textData.setAttribute("class", "eprobe-date-text");
                    textData.textContent = `Sess√£o: ${dataExtraida}`;

                    // 7. MONTAGEM DO SVG
                    svg.appendChild(backgroundRect);
                    svg.appendChild(iconGroup);
                    svg.appendChild(textPrincipal);
                    svg.appendChild(textData);

                    // 8. ADICIONAR AO CONTAINER
                    cardContainer.appendChild(svg);

                    // 8.1. CONFIGURAR TOOLTIP DIRETO NO CARD (SEM INDICADOR)
                    // ‚úÖ CORRE√á√ÉO: Configurar tooltip direto sem necessidade de indicador
                    const sessoesParaTooltip =
                        dadosSessao.todasSessoes ||
                        window.SENT1_AUTO.todasSessoesDetectadas ||
                        (dadosSessao.dataOriginal ? [dadosSessao] : []);

                    log(
                        `üîç CARD DEBUG: dadosSessao.todasSessoes=${
                            dadosSessao.todasSessoes?.length || 0
                        }, ` +
                            `window.SENT1_AUTO.todasSessoesDetectadas=${
                                window.SENT1_AUTO.todasSessoesDetectadas
                                    ?.length || 0
                            }, ` +
                            `sessoesParaTooltip=${sessoesParaTooltip.length}`,
                    );

                    if (sessoesParaTooltip && sessoesParaTooltip.length > 0) {
                        log(
                            `üéØ CARD: ${sessoesParaTooltip.length} sess√µes detectadas - configurando tooltip direto`,
                        );

                        // Configurar tooltip direto no card
                        setTimeout(() => {
                            const resultadoTooltip =
                                adicionarTooltipDiretoNoCard(
                                    cardContainer,
                                    sessoesParaTooltip,
                                );
                            if (
                                resultadoTooltip &&
                                resultadoTooltip.status === "sucesso"
                            ) {
                                log(
                                    "‚úÖ CARD: Tooltip direto configurado com sucesso!",
                                );
                            } else {
                                log(
                                    "‚ö†Ô∏è CARD: Falha ao configurar tooltip direto",
                                );
                            }
                        }, 100);
                    } else {
                        log(
                            "‚ÑπÔ∏è CARD: Apenas uma sess√£o - tooltip simples ser√° aplicado no hover",
                        );
                    }

                    // 8.1. APLICAR ESTILOS CSS ESPEC√çFICOS PARA GARANTIR ESPECIFICA√á√ïES FIGMA
                    const cardStyle = document.createElement("style");
                    if (!document.getElementById("eprobe-card-figma-styles")) {
                        cardStyle.id = "eprobe-card-figma-styles";
                        cardStyle.textContent = `
                    .eprobe-figma-card-pautado {
                        font-family: 'Roboto', sans-serif !important;
                    }
                    
                    .eprobe-figma-card-pautado text {
                        font-family: 'Roboto', sans-serif !important;
                        shape-rendering: crispEdges;
                        text-rendering: optimizeLegibility;
                        
                    }
                    
                    /* Header LP - Especifica√ß√µes exatas Figma */
                    .eprobe-status-text {
                        font-family: 'Roboto', sans-serif !important;
                        font-style: normal !important;
                        font-weight: 500 !important;
                        font-size: 13.5037px !important;
                        line-height: 16px !important;
                        fill: #1D1B20 !important;
                        font-stretch: 100 !important;
                        text-align: justify !important;
                    }
                    
                    /* Subhead LP - Especifica√ß√µes exatas Figma */
                    .eprobe-date-text {
                        font-family: 'Roboto', sans-serif !important;
                        font-style: normal !important;
                        font-weight: 400 !important;
                        font-size: 11px !important;
                        line-height: 15px !important;
                        letter-spacing: 0.187552px !important;
                        fill: #1D1B20 !important;
                    }
                    
                    /* IconAzul - Especifica√ß√µes Figma */
                    .eprobe-icon-azul {
                        background: #5C85B4 !important;
                        width: 24.9px !important;
                        height: 24.75px !important;
                    }
                `;
                        document.head.appendChild(cardStyle);
                    }

                    // 9. EFEITOS HOVER - MATERIAL DESIGN ELEVATION
                    addPassiveEventListener(cardContainer, "mouseenter", () => {
                        cardContainer.style.transform = "translateY(-2px)";
                        cardContainer.style.boxShadow =
                            "0px 8px 12px 6px rgba(0, 0, 0, 0.15)";
                        cardContainer.style.filter =
                            "drop-shadow(0px 6px 6px rgba(0, 0, 0, 0.35))";
                    });

                    addPassiveEventListener(cardContainer, "mouseleave", () => {
                        cardContainer.style.transform = "translateY(0)";
                        cardContainer.style.boxShadow =
                            "0px 3px 3px rgba(0, 0, 0, 0.25)";
                        cardContainer.style.filter =
                            "drop-shadow(0px 4px 4px rgba(0, 0, 0, 0.3))";
                    });

                    // 10. LOG DE SUCESSO
                    logCritical("‚úÖ CARD PAUTADO CRIADO:", {
                        id: cardContainer.id,
                        status: "Pautado",
                        data: dataExtraida,
                        cor: "#5C85B4",
                    });

                    return cardContainer;
                } catch (error) {
                    console.error("‚ùå ERRO AO CRIAR CARD PAUTADO:", error);
                    return null;
                }
            }

            /**
             * Aplica estilos √∫nicos para cards SVG do Figma
             */
            function aplicarEstilosSvgFigma() {
                if (document.getElementById("eprobe-figma-svg-styles")) return;

                const styleSvg = document.createElement("style");
                styleSvg.id = "eprobe-figma-svg-styles";
                styleSvg.textContent = `
            .eprobe-figma-card-svg {
                display: inline-block;
                margin: 8px 0;
                position: relative;
            }
            
            .eprobe-figma-svg-container {
                position: relative;
                display: inline-block;
            }
            
            .eprobe-figma-svg-container svg {
                transition: all 0.2s ease;
                display: block;
            }
            
            .eprobe-figma-card-svg:hover .eprobe-figma-svg-container svg {
                transform: translateY(-1px);
                filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
            }
            
            .eprobe-figma-data-overlay {
                position: absolute;
                bottom: 12px;
                left: 24px;
                right: 24px;
                pointer-events: none;
                z-index: 10;
            }
            
            .eprobe-figma-data-text {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 11px;
                font-weight: 500;
                color: #1D1B20;
                opacity: 0.9;
                text-align: left;
                display: block;
                line-height: 1.2;
                background: rgba(255, 255, 255, 0.8);
                padding: 2px 4px;
                border-radius: 4px;
                backdrop-filter: blur(4px);
            }
        `;
                document.head.appendChild(styleSvg);
            }

            /**
             * Obt√©m configura√ß√£o espec√≠fica para cada status baseada nos designs do Figma
             * @param {string} status - Status da sess√£o
             * @returns {Object} - Configura√ß√£o do design
             */
            function obterConfigFigmaStatus(status) {
                const configs = {
                    PAUTADO: {
                        cor: "#5C85B4",
                        statusText: "Pautado",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Processo inclu√≠do em pauta para julgamento",
                    },
                    RETIRADO: {
                        cor: "#CE2D4F",
                        statusText: "Retirado de Pauta",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Processo retirado de pauta",
                    },
                    VISTA: {
                        cor: "#FFBF46",
                        statusText: "Pedido de Vista",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Pedido de vista apresentado",
                    },
                    JULGADO: {
                        cor: "#3AB795",
                        statusText: "Julgado",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Processo julgado",
                    },
                    ADIADO: {
                        cor: "#F55D3E",
                        statusText: "Adiado",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Julgamento adiado",
                    },
                    ADIADO_935: {
                        cor: "#731963",
                        statusText: "Adiado (art. 935)",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Adiado conforme art. 935",
                    },
                    SOBRESTADO: {
                        cor: "#FCB0B3",
                        statusText: "Sobrestado (art. 942)",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                        descricao: "Sobrestado conforme art. 942",
                    },
                    DILIGENCIA: {
                        cor: "#00171F",
                        statusText: "Conv. em Dilig√™ncia",
                        corFundo: "#FEF7FF",
                        corBorda: "#CAC4D0",
                        corTexto: "#1D1B20",
                    },
                };

                // Normalizar o status para busca (mai√∫sculo, remover acentos e caracteres especiais)
                const statusNormalizado = status
                    ? status.toUpperCase().replace(/[^A-Z0-9_]/g, "_")
                    : "PAUTADO";

                // Tentar match exato primeiro
                if (configs[statusNormalizado]) {
                    log(`‚úÖ CONFIG: Status '${statusNormalizado}' encontrado`);
                    return configs[statusNormalizado];
                }

                // Fallback para status similar
                const statusFallback = Object.keys(configs).find((key) =>
                    key.includes(statusNormalizado.split("_")[0]),
                );

                if (statusFallback) {
                    log(
                        `‚ö†Ô∏è CONFIG: Usando fallback '${statusFallback}' para '${statusNormalizado}'`,
                    );
                    return configs[statusFallback];
                }

                // Fallback final para PAUTADO
                log(
                    `‚ö†Ô∏è CONFIG: Status '${statusNormalizado}' n√£o encontrado, usando PAUTADO`,
                );
                return configs.PAUTADO;
            }

            /**
             *  FUN√á√ÉO DE POSICIONAMENTO INTELIGENTE DO TOOLTIP
             * Calcula a melhor posi√ß√£o para o tooltip considerando:
             * - Bordas da viewport
             * - Posi√ß√£o do elemento de refer√™ncia
             * - Tamanho do tooltip
             * - Prefer√™ncias de posicionamento
             * @param {HTMLElement} tooltip - Elemento do tooltip
             * @param {HTMLElement} referencia - Elemento de refer√™ncia (indicador)
             * @returns {Object} - Coordenadas {left, top} calculadas
             */
            function calcularPosicaoTooltipInteligente(
                tooltip,
                referencia,
                cardElement = null,
            ) {
                // Obter dimens√µes dos elementos
                const refRect = referencia.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();

                // Se temos o card, usar suas dimens√µes tamb√©m
                const cardRect = cardElement
                    ? cardElement.getBoundingClientRect()
                    : refRect;

                // Obter dimens√µes da viewport
                const viewport = {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    scrollX: window.scrollX,
                    scrollY: window.scrollY,
                };

                // Margem de seguran√ßa das bordas
                const margem = 16;
                const espacamento = 8; // Dist√¢ncia pequena entre indicador e tooltip

                // NOVA ESTRAT√âGIA: POSICIONAR PR√ìXIMO AO INDICADOR, N√ÉO AO CARD
                // 1. Posi√ß√£o preferencial: √Ä direita do indicador
                // 2. Se n√£o couber √† direita: √Ä esquerda do indicador
                // 3. Se n√£o couber em nenhum lado: Abaixo do indicador

                let left, top;
                let posicao = "direita"; // Padr√£o

                // TENTAR POSICIONAR √Ä DIREITA DO INDICADOR
                left = refRect.right + espacamento;

                // Verificar se cabe √† direita
                if (left + tooltipRect.width > viewport.width - margem) {
                    // N√£o cabe √† direita, tentar √† esquerda
                    left = refRect.left - tooltipRect.width - espacamento;
                    posicao = "esquerda";

                    // Verificar se cabe √† esquerda
                    if (left < margem) {
                        // N√£o cabe nem √† direita nem √† esquerda, posicionar abaixo
                        left =
                            refRect.left +
                            refRect.width / 2 -
                            tooltipRect.width / 2;
                        posicao = "abaixo";

                        // Ajustar horizontalmente se necess√°rio
                        if (left < margem) {
                            left = margem;
                        } else if (
                            left + tooltipRect.width >
                            viewport.width - margem
                        ) {
                            left = viewport.width - tooltipRect.width - margem;
                        }
                    }
                }

                // POSICIONAMENTO VERTICAL
                if (posicao === "abaixo") {
                    // Posicionar abaixo do indicador
                    top = refRect.bottom + espacamento;
                } else {
                    // Posicionar alinhado verticalmente com o indicador (lateral)
                    top =
                        refRect.top +
                        refRect.height / 2 -
                        tooltipRect.height / 2;
                }

                // Verificar se o tooltip n√£o sai da viewport verticalmente
                if (top < margem) {
                    top = margem;
                } else if (
                    top + tooltipRect.height >
                    viewport.height - margem
                ) {
                    if (posicao !== "abaixo") {
                        // Se estava lateral, tentar posicionar acima
                        top = refRect.top - tooltipRect.height - espacamento;
                        if (top < margem) {
                            // Se n√£o couber acima, for√ßar dentro da viewport
                            top = viewport.height - tooltipRect.height - margem;
                        }
                    } else {
                        // Se estava abaixo, for√ßar dentro da viewport
                        top = viewport.height - tooltipRect.height - margem;
                    }
                }

                // Garantir que n√£o saia da viewport (valores finais)
                left = Math.max(
                    margem,
                    Math.min(left, viewport.width - tooltipRect.width - margem),
                );
                top = Math.max(
                    margem,
                    Math.min(
                        top,
                        viewport.height - tooltipRect.height - margem,
                    ),
                );

                log(
                    `üìê TOOLTIP: Posicionado "${posicao}" - left: ${left}, top: ${top}`,
                );

                return {
                    left: Math.round(left),
                    top: Math.round(top),
                    position: posicao,
                    cardPosition: posicao, // Para compatibilidade
                };
            }

            /**
             * üé® RICH TOOLTIP MATERIAL DESIGN para m√∫ltiplas sess√µes
             * @param {HTMLElement} cardElement - Elemento do card
             * @param {Array} todasSessoes - Array com todas as sess√µes detectadas
             */
            function adicionarRichTooltipMaterialDesign(
                cardElement,
                todasSessoes,
            ) {
                log(
                    "‚ö†Ô∏è DEPRECATED: adicionarRichTooltipMaterialDesign - usando fun√ß√£o unificada",
                );
                return adicionarTooltipUnificado(cardElement, todasSessoes);
            }

            /**
             * ‚ùå FUN√á√ÉO DUPLICADA DESATIVADA
             * Esta fun√ß√£o foi substitu√≠da por aplicarTooltipUnificado()
             * Redirecionando para evitar conflitos de tooltip
             */
            function adicionarTooltipDiretoNoCard(
                cardElement,
                todasSessoes = null,
            ) {
                console.log(
                    "‚ö†Ô∏è TOOLTIP DUPLICADO: Redirecionando para fun√ß√£o unificada...",
                );

                // üîÑ REDIRECIONAR PARA A FUN√á√ÉO UNIFICADA
                return aplicarTooltipUnificado(cardElement, todasSessoes);
            }

            // ‚ùå FUN√á√ïES DUPLICADAS REMOVIDAS - Use apenas adicionarTooltipDiretoNoCard()
            // Todas as fun√ß√µes de tooltip agora redirecionam para a fun√ß√£o ativa adicionarTooltipDiretoNoCard

            /**
             * ‚úÖ FUN√á√ÉO UNIFICADA DE TOOLTIP - REDIRECIONAMENTO PARA FUN√á√ÉO ATIVA
             * @param {HTMLElement} cardElement - Elemento do card
             * @param {Array} todasSessoes - Array com todas as sess√µes
             */
            function adicionarTooltipUnificado(
                cardElement,
                todasSessoes = null,
            ) {
                log(
                    "üîÑ REDIRECT: adicionarTooltipUnificado ‚Üí adicionarTooltipDiretoNoCard",
                );
                return adicionarTooltipDiretoNoCard(cardElement, todasSessoes);
            }

            /**
             * ‚úÖ FUN√á√ÉO TOOLTIP INTERATIVO - REDIRECIONAMENTO PARA FUN√á√ÉO ATIVA
             * @param {HTMLElement} cardElement - Elemento do card
             * @param {Array} todasSessoes - Array com todas as sess√µes
             */
            function adicionarTooltipInterativo(cardElement, todasSessoes) {
                log(
                    "üîÑ REDIRECT: adicionarTooltipInterativo ‚Üí adicionarTooltipDiretoNoCard",
                );
                return adicionarTooltipDiretoNoCard(cardElement, todasSessoes);
            }

            /**
             * ‚úÖ FUN√á√ÉO TOOLTIP SIMPLIFICADO - REDIRECIONAMENTO PARA FUN√á√ÉO ATIVA
             * @param {HTMLElement} cardElement - Elemento do card
             * @param {Array} todasSessoes - Array com todas as sess√µes
             */
            function criarTooltipSimplificado(cardElement, todasSessoes) {
                log(
                    "üîÑ REDIRECT: criarTooltipSimplificado ‚Üí adicionarTooltipDiretoNoCard",
                );
                return adicionarTooltipDiretoNoCard(cardElement, todasSessoes);
            }

            /**
             * Retorna √≠cone SVG apropriado para o status
             * @param {string} status - Status da sess√£o
             * @returns {string} - SVG do √≠cone
             */
            function getStatusIcon(status) {
                const icons = {
                    Julgado: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20 6L9 17l-5-5"></path>
            </svg>`,
                    Retirado: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="15" y1="9" x2="9" y2="15"></line>
                <line x1="9" y1="9" x2="15" y2="15"></line>
            </svg>`,
                    Sobrestado: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>`,
                    "Pedido de Vista": `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>`,
                    Pautado: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12,6 12,12 16,14"></polyline>
            </svg>`,
                    Adiado: `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M12 6v6l4 2"></path>
                <path d="M16 8a6 6 0 0 0-12 0"></path>
            </svg>`,
                };

                // Buscar √≠cone por palavra-chave
                for (const [key, icon] of Object.entries(icons)) {
                    if (
                        status.includes(key) ||
                        key.includes(status.split(" ")[0])
                    ) {
                        return icon;
                    }
                }

                // √çcone padr√£o
                return `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="16" x2="12" y2="12"></line>
            <line x1="12" y1="8" x2="12.01" y2="8"></line>
        </svg>`;
            }

            /**
             * Cria um item de informa√ß√£o para o card
             * @param {string} label - R√≥tulo da informa√ß√£o
             * @param {string} valor - Valor da informa√ß√£o
             * @param {string} icone - Nome do √≠cone Material
             * @returns {HTMLElement} - Elemento do item criado
             */
            function criarItemInformacao(label, valor, icone) {
                const item = document.createElement("div");
                item.className = "eprobe-info-item";

                const iconeEl = document.createElement("span");
                iconeEl.className = "material-icons eprobe-info-icon";
                iconeEl.textContent = icone;

                const textoContainer = document.createElement("div");
                textoContainer.className = "eprobe-info-text";

                const labelEl = document.createElement("div");
                labelEl.className = "eprobe-info-label";
                labelEl.textContent = label;

                const valorEl = document.createElement("div");
                valorEl.className = "eprobe-info-value";
                valorEl.textContent = valor;

                textoContainer.appendChild(labelEl);
                textoContainer.appendChild(valorEl);

                item.appendChild(iconeEl);
                item.appendChild(textoContainer);

                return item;
            }

            /**
             * üß™ FUN√á√ÉO DE DEBUG PARA TOOLTIP DIRETO NO CARD
             * Testa o sistema de tooltip com dados simulados diretamente no card
             */
            function debugTooltipUnificado() {
                console.group("üß™ DEBUG: Sistema de Tooltip Direto no Card");

                // Verificar se h√° card de sess√£o
                const card = document.getElementById("eprobe-data-sessao");
                if (!card) {
                    console.warn("‚ùå Card de sess√£o n√£o encontrado");
                    console.groupEnd();
                    return false;
                }

                console.log("‚úÖ Card encontrado:", card);

                // Remover qualquer indicador existente (n√£o precisamos mais)
                const indicadorExistente = card.querySelector(
                    ".eprobe-figma-sessions-indicator",
                );
                if (indicadorExistente) {
                    console.log("üóëÔ∏è Removendo indicador antigo...");
                    indicadorExistente.remove();
                }

                // Criar dados de teste
                const sessoesSimuladas = [
                    {
                        data: "15/01/2025",
                        status: "PAUTADO",
                        statusOriginal: "Inclu√≠do em Pauta",
                        codigo: "CIV1",
                        tipoProcesso: "C√≠vel",
                        orgao: "1¬™ C√¢mara de Direito Civil",
                        isAtual: true,
                    },
                    {
                        data: "10/01/2025",
                        status: "RETIRADO",
                        statusOriginal: "Retirado de Pauta",
                        codigo: "CIV1",
                        tipoProcesso: "C√≠vel",
                        orgao: "1¬™ C√¢mara de Direito Civil",
                        isAtual: false,
                    },
                    {
                        data: "05/01/2025",
                        status: "ADIADO",
                        statusOriginal: "Adiado em Pauta",
                        codigo: "CIV1",
                        tipoProcesso: "C√≠vel",
                        orgao: "1¬™ C√¢mara de Direito Civil",
                        isAtual: false,
                    },
                ];

                console.log("üìã Dados simulados:", sessoesSimuladas);

                // Aplicar tooltip direto no card
                console.log("üé® Aplicando tooltip direto no card...");
                const resultado = adicionarTooltipDiretoNoCard(
                    card,
                    sessoesSimuladas,
                );

                if (resultado && resultado.status === "sucesso") {
                    console.log("‚úÖ Tooltip direto aplicado com sucesso!");
                    console.log(
                        "üñ±Ô∏è Teste: Passe o mouse sobre o card para ver o tooltip",
                    );
                } else {
                    console.error(
                        "‚ùå Falha ao aplicar tooltip direto:",
                        resultado,
                    );
                }

                console.log(
                    "‚úÖ Debug conclu√≠do - tooltip configurado diretamente no card",
                );
                console.groupEnd();

                return true;
            }

            /**
             * üîß FUN√á√ÉO NORMALIZADORA - Extrai a data da sess√£o de qualquer estrutura
             * √öNICA FUN√á√ÉO para obter a data da sess√£o independente da origem dos dados
             * @param {Object|string} dadosSessao - Dados da sess√£o (qualquer formato)
             * @returns {string} - Data formatada como string (DD/MM/AAAA) ou fallback
             */
            function extrairDataSessaoNormalizada(dadosSessao) {
                // REGRA CR√çTICA: Sempre declarar vari√°veis antes de usar
                let dataExtraida = null;

                try {
                    // 1. Se dadosSessao √© string, retornar diretamente
                    if (typeof dadosSessao === "string") {
                        return dadosSessao;
                    }

                    // 2. Se dadosSessao √© null/undefined
                    if (!dadosSessao) {
                        logError(
                            "‚ö†Ô∏è NORMALIZA√á√ÉO: dadosSessao √© null/undefined",
                        );
                        return "Data n√£o dispon√≠vel";
                    }

                    // 3. Tentar dadosSessao.data (estrutura do detectarCardSessaoSimplificado)
                    if (typeof dadosSessao.data === "string") {
                        dataExtraida = dadosSessao.data;
                        log(
                            `‚úÖ NORMALIZA√á√ÉO: Usando dadosSessao.data = "${dataExtraida}"`,
                        );
                        return dataExtraida;
                    }

                    // 4. Tentar dadosSessao.dataFormatada (estrutura do validarDataBrasileira)
                    if (typeof dadosSessao.dataFormatada === "string") {
                        dataExtraida = dadosSessao.dataFormatada;
                        log(
                            `‚úÖ NORMALIZA√á√ÉO: Usando dadosSessao.dataFormatada = "${dataExtraida}"`,
                        );
                        return dataExtraida;
                    }

                    // 5. Tentar dadosSessao.data.dataFormatada (estrutura aninhada)
                    if (
                        dadosSessao.data &&
                        typeof dadosSessao.data.dataFormatada === "string"
                    ) {
                        dataExtraida = dadosSessao.data.dataFormatada;
                        log(
                            `‚úÖ NORMALIZA√á√ÉO: Usando dadosSessao.data.dataFormatada = "${dataExtraida}"`,
                        );
                        return dataExtraida;
                    }

                    // 6. Fallback: Procurar qualquer propriedade que pare√ßa uma data
                    const propriedadesPossiveis = [
                        "dataOriginal",
                        "dataString",
                        "dataSessao",
                    ];
                    for (const prop of propriedadesPossiveis) {
                        if (
                            dadosSessao[prop] &&
                            typeof dadosSessao[prop] === "string"
                        ) {
                            dataExtraida = dadosSessao[prop];
                            log(
                                `‚úÖ NORMALIZA√á√ÉO: Usando dadosSessao.${prop} = "${dataExtraida}"`,
                            );
                            return dataExtraida;
                        }
                    }

                    // 7. Log para debug se nenhuma propriedade foi encontrada
                    log(
                        "‚ùå NORMALIZA√á√ÉO: Nenhuma propriedade de data encontrada",
                    );
                    log("   Estrutura recebida:", Object.keys(dadosSessao));
                    log("   Dados completos:", dadosSessao);

                    return "Data n√£o dispon√≠vel";
                } catch (error) {
                    console.error(
                        "‚ùå NORMALIZA√á√ÉO: Erro ao extrair data:",
                        error,
                    );
                    return "Erro na data";
                }
            }

            /**
             * üéØ FUN√á√ÉO CURTA - Vers√£o concisa para uso di√°rio
             * @param {Object|string} d - Dados da sess√£o
             * @returns {string} - Data como string
             */
            function getData(d) {
                return extrairDataSessaoNormalizada(d);
            }

            /**
             * Atualiza o card existente com novos dados
             * VERS√ÉO CORRIGIDA - Usa fun√ß√£o normalizadora para extrair data
             * @param {Object} dadosSessao - Novos dados da sess√£o
             */
            function atualizarCardMaterialDesign(dadosSessao) {
                const cardExistente =
                    document.getElementById("eprobe-data-sessao");

                // üîß CORRE√á√ÉO: Usar fun√ß√£o curta para extrair data
                const dataExtraida = getData(dadosSessao);

                log(
                    `üìÖ MATERIAL: Data normalizada extra√≠da: "${dataExtraida}"`,
                );

                if (cardExistente) {
                    log(
                        "üîÑ MATERIAL: Card existente encontrado, verificando se precisa atualizar",
                    );

                    // Verificar se os dados realmente mudaram (usar data normalizada)
                    const statusAtual = cardExistente.querySelector(
                        ".eprobe-status-text",
                    )?.textContent;
                    const dataAtual =
                        cardExistente.querySelector(
                            ".eprobe-date-text",
                        )?.textContent;

                    if (
                        statusAtual === dadosSessao?.status &&
                        dataAtual?.includes(dataExtraida)
                    ) {
                        log(
                            "‚ÑπÔ∏è MATERIAL: Card j√° est√° atualizado, mantendo estado atual",
                        );
                        materialDesignState.cardAtivo = true;
                        materialDesignState.ultimaDeteccao = dadosSessao;
                        return;
                    }

                    log(
                        "üîÑ MATERIAL: Dados mudaram, atualizando card Material Design",
                    );

                    // Remover card antigo apenas se os dados mudaram
                    cardExistente.remove();

                    // USAR A FUN√á√ÉO INTERNA que retorna elemento DOM
                    const card = criarCardMaterialDesign(dadosSessao);

                    if (card) {
                        inserirCardNaInterface(card);
                        log("‚úÖ MATERIAL: Card atualizado com sucesso!");
                    } else {
                        console.error("‚ùå MATERIAL: Erro ao atualizar card");
                    }

                    materialDesignState.cardAtivo = true;
                    materialDesignState.ultimaDeteccao = dadosSessao;
                } else {
                    log("üÜï MATERIAL: Criando novo card Material Design");

                    // USAR A FUN√á√ÉO INTERNA que retorna elemento DOM
                    const card = criarCardMaterialDesign(dadosSessao);

                    if (card) {
                        inserirCardNaInterface(card);
                        log("‚úÖ MATERIAL: Card inserido com sucesso!");
                    } else {
                        console.error(
                            "‚ùå MATERIAL: Erro ao criar card - fun√ß√£o retornou null",
                        );
                    }

                    materialDesignState.cardAtivo = true;
                    materialDesignState.ultimaDeteccao = dadosSessao;
                }
            }

            /**
             * Insere o card na interface ao lado do lblMagistrado na row mt-2
             * VERS√ÉO CORRIGIDA - Posicionamento espec√≠fico conforme solicitado
             * @param {HTMLElement} card - Elemento do card a ser inserido
             */
            /**
             * Insere o card fixo ao lado direito do elemento espec√≠fico
             * POSICIONAMENTO ESPEC√çFICO: /html/body/div[2]/div[3]/div[2]/div/div[1]/form[2]/div[3]/div/div/fieldset[1]/div/div[2]/div[3]
             * @param {HTMLElement} card - Elemento do card a ser inserido
             */
            function inserirCardNaInterface(card) {
                log(
                    "üéØ INSER√á√ÉO: Procurando txtMagistrado para inserir card ao lado DIREITO...",
                );

                try {
                    // Buscar o span do magistrado correto (txtMagistrado)
                    const txtMagistrado =
                        document.getElementById("txtMagistrado");

                    if (txtMagistrado) {
                        log("‚úÖ INSER√á√ÉO: txtMagistrado encontrado!");
                        log(
                            "üìç INSER√á√ÉO: Texto do magistrado:",
                            txtMagistrado.textContent,
                        );
                        log(
                            "üìç INSER√á√ÉO: Tag:",
                            txtMagistrado.tagName,
                            "ID:",
                            txtMagistrado.id,
                        );

                        // Obter o container pai para posicionamento
                        const containerPai = txtMagistrado.parentElement;
                        if (containerPai) {
                            // Configurar o container pai para flex layout
                            containerPai.style.display = "flex";
                            containerPai.style.alignItems = "center";
                            containerPai.style.gap = "15px";

                            // Configurar o card para posicionamento flex√≠vel
                            card.style.position = "static";
                            card.style.flexShrink = "0";
                            card.style.marginLeft = "15px";

                            // Inserir o card DEPOIS do txtMagistrado (lado direito)
                            txtMagistrado.parentNode.insertBefore(
                                card,
                                txtMagistrado.nextSibling,
                            );

                            log(
                                "‚úÖ INSER√á√ÉO: Card posicionado ao lado DIREITO do txtMagistrado",
                            );
                            log(
                                "üéØ INSER√á√ÉO: Layout flex aplicado com gap de 15px",
                            );
                            return true;
                        } else {
                            log(
                                "‚ö†Ô∏è INSER√á√ÉO: Container pai do txtMagistrado n√£o encontrado",
                            );
                        }
                    } else {
                        log(
                            "‚ùå INSER√á√ÉO: txtMagistrado n√£o encontrado, tentando fallback lblMagistrado...",
                        );

                        // FALLBACK: Buscar lblMagistrado se txtMagistrado n√£o existir
                        const lblMagistrado =
                            document.getElementById("lblMagistrado");

                        if (lblMagistrado) {
                            log(
                                "‚úÖ INSER√á√ÉO: lblMagistrado encontrado como fallback!",
                            );

                            const containerPai = lblMagistrado.parentElement;
                            if (containerPai) {
                                // Aplicar layout flex
                                containerPai.style.display = "flex";
                                containerPai.style.alignItems = "center";
                                containerPai.style.gap = "15px";

                                // Configurar card
                                card.style.position = "static";
                                card.style.flexShrink = "0";
                                card.style.marginLeft = "15px";

                                // Inserir DEPOIS do label (lado direito)
                                lblMagistrado.parentNode.insertBefore(
                                    card,
                                    lblMagistrado.nextSibling,
                                );

                                log(
                                    "‚úÖ INSER√á√ÉO: Card inserido via fallback ao lado DIREITO do lblMagistrado",
                                );
                                return true;
                            }
                        }

                        // FALLBACK FINAL: XPath para magistrado
                        log(
                            "‚ö†Ô∏è INSER√á√ÉO: Tentando XPath para encontrar magistrado...",
                        );

                        const xpathMagistrado =
                            "//span[contains(@id, 'Magistrado') or contains(text(), 'ALEXANDRE MORAIS')]";
                        const spanMagistrado = document.evaluate(
                            xpathMagistrado,
                            document,
                            null,
                            XPathResult.FIRST_ORDERED_NODE_TYPE,
                            null,
                        ).singleNodeValue;

                        if (spanMagistrado) {
                            log(
                                "‚úÖ INSER√á√ÉO: Magistrado encontrado via XPath!",
                            );

                            const containerPai = spanMagistrado.parentElement;
                            if (containerPai) {
                                // Aplicar layout flex
                                containerPai.style.display = "flex";
                                containerPai.style.alignItems = "center";
                                containerPai.style.gap = "15px";

                                // Configurar card
                                card.style.position = "static";
                                card.style.flexShrink = "0";
                                card.style.marginLeft = "15px";

                                // Inserir DEPOIS do span (lado direito)
                                spanMagistrado.parentNode.insertBefore(
                                    card,
                                    spanMagistrado.nextSibling,
                                );

                                log(
                                    "‚úÖ INSER√á√ÉO: Card inserido via XPath ao lado DIREITO do magistrado",
                                );
                                return true;
                            }
                        }
                    }
                } catch (error) {
                    log("‚ùå INSER√á√ÉO: Erro ao buscar lblMagistrado:", error);
                }

                // FALLBACK FINAL: Posi√ß√£o fixa apenas se n√£o conseguir encontrar o local correto
                log("‚ö†Ô∏è INSER√á√ÉO: Usando fallback - posi√ß√£o fixa");

                card.style.position = "fixed";
                card.style.top = "200px";
                card.style.right = "30px";
                card.style.zIndex = "9999";
                card.style.maxWidth = "180px";

                document.body.appendChild(card);
                log("‚úÖ INSER√á√ÉO: Card inserido com fallback");
                return true;
            }

            /**
             * Torna o card de sessao clicavel - abre sessao de julgamento diretamente
             * Usa fetch silencioso para obter o link da sessao mais recente
             * sem exibir o modal intermediario do historico
             */
            /**
             * Remove o card Material Design da interface
             */
            function removerCardMaterialDesign() {
                const card = document.getElementById("eprobe-data-sessao");
                if (card) {
                    card.remove();
                    log("üóëÔ∏è MATERIAL: Card Material Design removido");

                    // Atualizar estado
                    materialDesignState.cardAtivo = false;
                    materialDesignState.ultimaDeteccao = null;

                    return true;
                }
                return false;
            }

            /**
             * Verifica se o card Material Design est√° presente na interface
             * @returns {boolean} - True se o card estiver presente
             */
            function cardMaterialDesignPresente() {
                return !!document.getElementById("eprobe-data-sessao");
            }

            // Fun√ß√£o auxiliar para configurar tooltip por tipo
            function configurarTooltipPorTipo(dados) {
                try {
                    if (
                        dados.tooltipTipo === "rico" &&
                        dados.tipo === "multiplas_sessoes"
                    ) {
                        log(
                            "üé® TOOLTIP: Aplicando tooltip rico para m√∫ltiplas sess√µes",
                        );
                        adicionarRichTooltipMaterialDesign();
                    } else if (dados.tooltipTipo === "simples") {
                        log("üé® TOOLTIP: Aplicando tooltip simples");
                        criarTooltipSimplificado(dados);
                    }
                } catch (error) {
                    console.error(
                        "‚ùå TOOLTIP: Erro na configura√ß√£o por tipo:",
                        error,
                    );
                }
            }

            // Fun√ß√£o para criar card com tooltip integrado
            function criarCardComTooltipIntegrado() {
                try {
                    log("üéØ CARD+TOOLTIP: Iniciando cria√ß√£o integrada...");

                    // 1. DETECTAR E CONFIGURAR DADOS
                    const dadosSessao = detectarEConfigurarTooltipUnificado();

                    if (!dadosSessao) {
                        log(
                            "‚ÑπÔ∏è CARD+TOOLTIP: Sem dados de sess√£o - n√£o criando card",
                        );
                        return null;
                    }

                    // 2. CRIAR CARD MATERIAL DESIGN
                    const cardCriado = criarCardMaterialDesign(dadosSessao);

                    if (!cardCriado) {
                        logError("‚ùå CARD+TOOLTIP: Falha na cria√ß√£o do card");
                        return null;
                    }

                    // 3. AGUARDAR E CONFIGURAR TOOLTIP
                    setTimeout(() => {
                        const cardElement = document.querySelector(
                            ".card-material-design",
                        );
                        if (cardElement && dadosSessao.temTooltip) {
                            configurarTooltipPorTipo(dadosSessao);
                            log(
                                "‚úÖ CARD+TOOLTIP: Card e tooltip configurados com sucesso",
                            );
                        } else {
                            log(
                                "‚ö†Ô∏è CARD+TOOLTIP: Card criado mas tooltip n√£o configurado",
                            );
                        }
                    }, 500);

                    return dadosSessao;
                } catch (error) {
                    console.error(
                        "‚ùå CARD+TOOLTIP: Erro na cria√ß√£o integrada:",
                        error,
                    );
                    return null;
                }
            }

            /**
             * Carrega os √≠cones Material Icons se n√£o estiverem dispon√≠veis
             */
            function carregarMaterialIcons() {
                // Verificar se os √≠cones j√° est√£o carregados
                if (document.querySelector('link[href*="material-icons"]')) {
                    logCritical(
                        "‚úÖ MATERIAL: √çcones Material Icons j√° carregados",
                    );
                    return Promise.resolve();
                }

                return new Promise((resolve) => {
                    log("üîÑ MATERIAL: Carregando √≠cones Material Icons...");

                    const linkElement = document.createElement("link");
                    linkElement.rel = "stylesheet";
                    linkElement.href =
                        "https://fonts.googleapis.com/icon?family=Material+Icons";

                    linkElement.onload = () => {
                        log(
                            "‚úÖ MATERIAL: √çcones Material Icons carregados com sucesso",
                        );
                        resolve();
                    };

                    linkElement.onerror = () => {
                        console.warn(
                            "‚ö†Ô∏è MATERIAL: Erro ao carregar √≠cones Material Icons, continuando sem √≠cones",
                        );
                        resolve();
                    };

                    document.head.appendChild(linkElement);

                    // Resolve ap√≥s 100ms mesmo se onload n√£o disparar (fallback r√°pido)
                    setTimeout(resolve, 100);
                });
            }

            /**
             * Inicializa√ß√£o autom√°tica do sistema Material Design
             * VERS√ÉO OTIMIZADA - Sem recria√ß√£o autom√°tica de cards
             */
            async function inicializarMaterialDesign() {
                // üî• PERFORMANCE: Pular se modo ultra-performance estiver ativo
                if (MODO_ULTRA_PERFORMANCE) {
                    log(
                        "üî• PERFORMANCE: Inicializa√ß√£o Material Design PULADA (modo ultra-performance ativo)",
                    );
                    return;
                }

                log(
                    "üöÄ MATERIAL: Inicializando sistema Material Design SIMPLIFICADO",
                );

                try {
                    // Aguardar um breve momento para garantir que a p√°gina esteja carregada
                    setTimeout(() => {
                        log(
                            "üîç MATERIAL: Executando detec√ß√£o de dados (sem cria√ß√£o autom√°tica de card)",
                        );

                        // Detectar dados dispon√≠veis, mas N√ÉO criar card automaticamente
                        const resultado =
                            window.SENT1_AUTO?.detectarCardSessaoSimplificado?.();

                        if (resultado) {
                            log(
                                "‚úÖ MATERIAL: Dados de sess√£o detectados e salvos (card ser√° exibido apenas se dados forem v√°lidos)",
                            );
                        } else {
                            log(
                                "‚ÑπÔ∏è MATERIAL: Nenhum dado de sess√£o detectado na p√°gina atual",
                            );
                        }
                    }, 500);

                    log(
                        "‚úÖ MATERIAL: Sistema Material Design simplificado inicializado com sucesso",
                    );
                } catch (error) {
                    console.error(
                        "‚ùå MATERIAL: Erro na inicializa√ß√£o do Material Design:",
                        error,
                    );
                }
            }

            /**
             * Aplica o CSS minimalista do Material Design
             */
            function aplicarCSSMaterialDesign() {
                // üî• PERFORMANCE: Pular se modo ultra-performance estiver ativo
                if (MODO_ULTRA_PERFORMANCE) {
                    log(
                        "üî• PERFORMANCE: Aplica√ß√£o de CSS Material Design PULADA (modo ultra-performance ativo)",
                    );
                    return;
                }

                log("üé® MATERIAL: Iniciando aplica√ß√£o do CSS minimalista");

                // Verificar se j√° foi aplicado
                const styleExistente = document.querySelector(
                    "style[data-eprobe-material-design]",
                );
                if (styleExistente) {
                    log("‚ÑπÔ∏è MATERIAL: CSS j√° aplicado, pulando aplica√ß√£o");
                    return;
                }

                const css = `
                    /* eProbe Card Micro Compacto - Tamanho Exato do Conte√∫do */
                    .eprobe-material-card-minimal {
                        background: #ffffff;
                        border: 1px solid #e5e7eb;
                        border-radius: 3px;
                        padding: 2px 4px;
                        margin: 1px 0;
                        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.06);
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        width: fit-content;
                        max-width: none;
                        font-size: 10px;
                        transition: all 0.2s ease;
                        display: inline-block;
                        line-height: 1.1;
                    }
                    
                    .eprobe-material-card-minimal:hover {
                        box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
                    }
                    
                    .eprobe-card-minimal-content {
                        display: flex;
                        flex-direction: column;
                        gap: 1px;
                        white-space: nowrap;
                    }
                    
                    .eprobe-status-row {
                        display: flex;
                        align-items: center;
                        gap: 3px;
                    }
                    
                    .eprobe-date-row {
                        display: flex;
                        align-items: center;
                        gap: 3px;
                    }
                    
                    .eprobe-status-icon,
                    .eprobe-date-icon {
                        width: 12px;
                        height: 12px;
                        flex-shrink: 0;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                    }
                    
                    .eprobe-status-text {
                        font-size: 10px;
                        font-weight: 600;
                        color: #1f2937;
                        line-height: 1.1;
                    }
                    
                    .eprobe-date-label {
                        font-size: 9px;
                        color: #6b7280;
                        font-weight: 500;
                        line-height: 1.1;
                    }
                    
                    .eprobe-date-text {
                        font-size: 10px;
                        color: #374151;
                        font-weight: 600;
                        line-height: 1.1;
                    }
                    
                    /* √çcones SVG micro otimizados */
                    .eprobe-icon-calendar::before {
                        content: "";
                        display: block;
                        width: 12px;
                        height: 12px;
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect width='18' height='18' x='3' y='4' rx='2' ry='2'/%3E%3Cline x1='16' x2='16' y1='2' y2='6'/%3E%3Cline x1='8' x2='8' y1='2' y2='6'/%3E%3Cline x1='3' x2='21' y1='10' y2='10'/%3E%3C/svg%3E");
                        background-repeat: no-repeat;
                        background-size: contain;
                        background-position: center;
                    }
                    
                    .eprobe-icon-check::before {
                        content: "";
                        display: block;
                        width: 12px;
                        height: 12px;
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2310b981' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20,6 9,17 4,12'/%3E%3C/svg%3E");
                        background-repeat: no-repeat;
                        background-size: contain;
                        background-position: center;
                    }
                    
                    .eprobe-icon-alert::before {
                        content: "";
                        display: block;
                        width: 12px;
                        height: 12px;
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23f59e0b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z'/%3E%3Cpath d='M12 9v4'/%3E%3Cpath d='m12 17 .01 0'/%3E%3C/svg%3E");
                        background-repeat: no-repeat;
                        background-size: contain;
                        background-position: center;
                    }
                    
                    .eprobe-icon-info::before {
                        content: "";
                        display: block;
                        width: 12px;
                        height: 12px;
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%233b82f6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='m9 12 2 2 4-4'/%3E%3C/svg%3E");
                        background-repeat: no-repeat;
                        background-size: contain;
                        background-position: center;
                    }
                    
                    /* Cores dos √≠cones por status */
                    .eprobe-status-icon.status-pautado .eprobe-icon-info::before {
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%233b82f6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='m9 12 2 2 4-4'/%3E%3C/svg%3E");
                    }
                    
                    .eprobe-status-icon.status-julgado .eprobe-icon-check::before {
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%2310b981' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20,6 9,17 4,12'/%3E%3C/svg%3E");
                    }
                    
                    .eprobe-status-icon.status-retirado .eprobe-icon-alert::before {
                        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23f59e0b' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z'/%3E%3Cpath d='M12 9v4'/%3E%3Cpath d='m12 17 .01 0'/%3E%3C/svg%3E");
                    }
                    
                    /* Responsividade */
                    @media (max-width: 768px) {
                        .eprobe-material-card-minimal {
                            max-width: 90vw;
                        }
                        
                        .eprobe-card-minimal-content {
                            white-space: normal;
                        }
                    }
                `;

                // Carregar √≠cones j√° inclu√≠dos no CSS
                const styleElement = document.createElement("style");
                styleElement.setAttribute(
                    "data-eprobe-material-design",
                    "true",
                );
                styleElement.textContent = css;
                document.head.appendChild(styleElement);

                log(
                    "‚úÖ MATERIAL: CSS minimalista aplicado com √≠cones SVG inclu√≠dos",
                );
            }

            // IMPORTANTE: Aplicar CSS imediatamente
            aplicarCSSMaterialDesign();

            /**
             * üîß FUN√á√ÉO DE CORRE√á√ÉO - For√ßar recria√ß√£o completa do card de sess√£o
             * Seguindo REGRAS CR√çTICAS: SEMPRE declarar vari√°veis e verificar exist√™ncia
             */
            function forcarRecriacaoCardSessao() {
                log(
                    "üîß CORRE√á√ÉO: For√ßando recria√ß√£o completa do card de sess√£o",
                );

                // REGRA CR√çTICA: Declarar todas as vari√°veis antes de usar
                let cardExistente = null;
                let dadosSessaoGlobais = null;
                let statusSessao = null;

                try {
                    // Verificar se h√° dados globais salvos
                    if (
                        typeof window.SENT1_AUTO !== "undefined" &&
                        window.SENT1_AUTO.showDadosGlobaisSessao
                    ) {
                        dadosSessaoGlobais =
                            window.SENT1_AUTO.showDadosGlobaisSessao();
                    }

                    // Obter status atual
                    if (typeof getStatusSessao === "function") {
                        statusSessao = getStatusSessao();
                    }

                    // Dados m√≠nimos para o card
                    const dadosCard = {
                        status: statusSessao?.status || "Pautado",
                        data: {
                            dataFormatada:
                                statusSessao?.data?.dataFormatada ||
                                "29/07/2025",
                        },
                    };

                    log("üìã CORRE√á√ÉO: Dados para o card:", dadosCard);

                    // Remover card existente
                    cardExistente =
                        document.getElementById("eprobe-data-sessao");
                    if (cardExistente) {
                        log("üóëÔ∏è CORRE√á√ÉO: Removendo card existente");
                        cardExistente.remove();
                    }

                    // For√ßar reaplica√ß√£o do CSS (apenas em p√°ginas permitidas)
                    if (isCapaProcessoPage()) {
                        forcarReaplicacaoIcones();
                    } else {
                        log(
                            "‚õî CORRE√á√ÉO: Reaplica√ß√£o de √≠cones bloqueada - p√°gina n√£o √© capa do processo",
                        );
                    }

                    // Aguardar um frame para garantir que o CSS foi aplicado
                    requestAnimationFrame(() => {
                        try {
                            // Criar novo card
                            const novoCard =
                                window.SENT1_AUTO.criarCardMaterialDesign(
                                    dadosCard,
                                );

                            // Inserir no local correto
                            const targetContainer =
                                encontrarContainerParaCard();
                            if (targetContainer && novoCard) {
                                targetContainer.appendChild(novoCard);
                                log(
                                    "‚úÖ CORRE√á√ÉO: Card recriado e inserido com sucesso",
                                );

                                // Diagnosticar ap√≥s inser√ß√£o
                                setTimeout(() => {
                                    diagnosticarIconesCSS();
                                }, 100);
                            } else {
                                log(
                                    "‚ùå CORRE√á√ÉO: Falha ao encontrar container ou criar card",
                                );
                            }
                        } catch (error) {
                            console.error(
                                "‚ùå CORRE√á√ÉO: Erro ao recriar card:",
                                error,
                            );
                        }
                    });
                } catch (error) {
                    console.error(
                        "‚ùå CORRE√á√ÉO: Erro geral na recria√ß√£o:",
                        error,
                    );
                }
            }

            /**
             * üîç FUN√á√ÉO AUXILIAR - Encontrar container adequado para o card
             * Seguindo REGRAS CR√çTICAS: SEMPRE retornar valor consistente
             */
            function encontrarContainerParaCard() {
                // REGRA CR√çTICA: Declarar vari√°vel antes de usar
                let container = null;

                // Estrat√©gia 1: Tentar encontrar container espec√≠fico do eProc
                const possiveisContainers = [
                    "#divInfraAreaProcesso",
                    "#conteudoMinutas",
                    "#fldMinutas",
                    ".infraAreaTabela",
                    "body",
                ];

                for (const seletor of possiveisContainers) {
                    container = document.querySelector(seletor);
                    if (container) {
                        log(`‚úÖ CONTAINER: Encontrado container: ${seletor}`);
                        break;
                    }
                }

                // Fallback garantido
                if (!container) {
                    container = document.body;
                    logError("‚ö†Ô∏è CONTAINER: Usando fallback para body");
                }

                return container;
            }

            // üîß FUN√á√ÉO DE CORRE√á√ÉO AUTOM√ÅTICA SIMPLES (movida para namespace principal)

            // üé® SISTEMA GLOBAL DE PERSONALIZA√á√ÉO DE BOT√ïES DO EPROC
            // Fun√ß√µes expostas globalmente para personalizar bot√µes (fora da IIFE)

            // Configura√ß√µes de temas para bot√µes
            const TEMAS_BOTOES_EPROC = {
                elegante: {
                    backgroundColor:
                        "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
                    color: "#ffffff",
                    border: "1px solid #5a67d8",
                    borderRadius: "8px",
                    boxShadow: "0 4px 15px rgba(102, 126, 234, 0.3)",
                    transition: "all 0.3s ease",
                    hover: {
                        boxShadow: "0 6px 20px rgba(102, 126, 234, 0.4)",
                    },
                    focus: {
                        boxShadow: "0 0 0 3px rgba(102, 126, 234, 0.3)",
                        outline: "none",
                    },
                },
                minimalista: {
                    backgroundColor: "#f8f9fa",
                    color: "#495057",
                    border: "1px solid #dee2e6",
                    borderRadius: "4px",
                    boxShadow: "none",
                    transition: "all 0.2s ease",
                    hover: {
                        backgroundColor: "#e9ecef",
                        borderColor: "#adb5bd",
                    },
                    focus: {
                        borderColor: "#80bdff",
                        boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
                    },
                },
                escuro: {
                    backgroundColor: "#343a40",
                    color: "#ffffff",
                    border: "1px solid #495057",
                    borderRadius: "6px",
                    boxShadow: "0 2px 8px rgba(0, 0, 0, 0.15)",
                    transition: "all 0.3s ease",
                    hover: {
                        backgroundColor: "#495057",
                        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.25)",
                    },
                    focus: {
                        boxShadow: "0 0 0 3px rgba(52, 58, 64, 0.3)",
                    },
                },

                profissional: {
                    backgroundColor: "#007ebd",
                    color: "#ffffff",
                    border: "1px solid #006ba6",
                    borderRadius: "4px",
                    boxShadow: "0 2px 4px rgba(0, 126, 189, 0.2)",
                    transition: "all 0.2s ease",
                    hover: {
                        backgroundColor: "#006ba6",
                        boxShadow: "0 4px 8px rgba(0, 126, 189, 0.3)",
                    },
                    focus: {
                        boxShadow: "0 0 0 3px rgba(0, 126, 189, 0.3)",
                    },
                },
            };

            // Fun√ß√£o principal para aplicar estilo personalizado aos bot√µes
            window.aplicarEstiloBotoesEproc = function (
                tema = "elegante",
                opcoes = {},
            ) {
                log(`üé® BOT√ïES: Aplicando tema "${tema}" aos bot√µes do eProc`);

                // üö® VERIFICA√á√ÉO CR√çTICA: N√ÉO aplicar tema de bot√µes na tela de edi√ß√£o de minutas
                const currentUrl = window.location.href;
                if (currentUrl.includes("acao=minuta_editar")) {
                    console.log(
                        "üö´ eProbe: Tema de bot√µes desabilitado na tela de edi√ß√£o de minutas",
                    );
                    return; // Sair imediatamente - n√£o aplicar tema de bot√µes
                }

                // Verificar se o tema existe
                if (!TEMAS_BOTOES_EPROC[tema]) {
                    console.warn(
                        `‚ö†Ô∏è BOT√ïES: Tema "${tema}" n√£o encontrado. Temas dispon√≠veis:`,
                        Object.keys(TEMAS_BOTOES_EPROC),
                    );
                    tema = "elegante"; // Fallback para tema padr√£o
                }

                const configuracaoTema = {
                    ...TEMAS_BOTOES_EPROC[tema],
                    ...opcoes,
                };

                // Seletores para todos os tipos de bot√µes do eProc (INCLUINDO bot√µes eProbe - EXCLUINDO pesquisa, navbar, infraLegendObrigatorio, btn-link, btn-sm e select2)
                const seletoresBotoes = [
                    ".bootstrap-styles .btn:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)",
                    ".bootstrap-styles .eproc-button:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)",
                    ".bootstrap-styles .eproc-button-primary:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)",
                    ".bootstrap-styles .infraButton:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)",
                    ".bootstrap-styles .infraButton.btn-primary:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)",
                    ".bootstrap-styles .infraButton.eproc-button-primary:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)",
                    ".bootstrap-styles .infraArvore .infraButton.infraArvoreNoSelecionado:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)",
                    'button[class*="infra"]:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)',
                    'input[type="button"]:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)',
                    'input[type="submit"]:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)',
                    'button[onclick*="abrirVisualizacao"]:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)',
                    'button[onclick*="processo"]:not(.btn-pesquisar):not(.btn-pesquisar-nova-janela):not(.search-button):not(#eprobe-navbar-element):not(#eprobe-navbar-element *):not(.infraLegendObrigatorio):not(.infraLegendObrigatorio *):not(.btn-link):not(.btn-sm):not(.select2-search-choice-close)',
                ];

                // Remover estilo anterior se existir
                const estiloAnterior = document.getElementById(
                    "eprobe-estilo-botoes-eproc",
                );
                if (estiloAnterior) {
                    estiloAnterior.remove();
                }

                // Criar novo estilo
                const estiloElemento = document.createElement("style");
                estiloElemento.id = "eprobe-estilo-botoes-eproc";

                // Gerar CSS baseado na configura√ß√£o do tema
                let css = `
        /* üé® eProbe - Estilo Personalizado dos Bot√µes do eProc - Tema: ${tema} */
        
        /* üéØ SINCRONIZA√á√ÉO: Elemento txtUnderline do eProc com mesma cor dos bot√µes */
        #txtUnderline {
            color: ${configuracaoTema.color} !important;
        }
        
        /* Estilo base dos bot√µes */
        ${seletoresBotoes.join(", ")} {
            background: ${configuracaoTema.backgroundColor} !important;
            color: ${configuracaoTema.color} !important;
            border: ${configuracaoTema.border} !important;
            border-radius: ${configuracaoTema.borderRadius} !important;
            box-shadow: ${configuracaoTema.boxShadow} !important;
            transition: ${configuracaoTema.transition} !important;
            font-weight: 500 !important;
            cursor: pointer !important;
        }
    `;

                // Adicionar estilos de hover se definidos
                if (configuracaoTema.hover) {
                    const hoverProps = Object.entries(configuracaoTema.hover)
                        .map(
                            ([prop, value]) =>
                                `${prop
                                    .replace(/([A-Z])/g, "-$1")
                                    .toLowerCase()}: ${value} !important;`,
                        )
                        .join("\n                ");

                    css += `
        /* Estilo hover */
        ${seletoresBotoes.map((s) => `${s}:hover`).join(", ")} {
            ${hoverProps}
        }
        `;
                }

                // Adicionar estilos de focus se definidos
                if (configuracaoTema.focus) {
                    const focusProps = Object.entries(configuracaoTema.focus)
                        .map(
                            ([prop, value]) =>
                                `${prop
                                    .replace(/([A-Z])/g, "-$1")
                                    .toLowerCase()}: ${value} !important;`,
                        )
                        .join("\n                ");

                    css += `
        /* Estilo focus */
        ${seletoresBotoes.map((s) => `${s}:focus`).join(", ")} {
            ${focusProps}
        }
        `;
                }

                // Adicionar estilos para estados ativos
                css += `
        /* Estilo disabled */
        ${seletoresBotoes.map((s) => `${s}:disabled`).join(", ")} {
            opacity: 0.6 !important;
            cursor: not-allowed !important;
            transform: none !important;
        }
                `;

                // L√≥gica especial para o tema "material" - adicionar pseudo-elementos
                if (tema === "material") {
                    css += `
        /* üõ°Ô∏è PROTE√á√ÉO ANTI-INJE√á√ÉO EPROC: Bloquear estilos inline para tema Material */
        ${seletoresBotoes.join(", ")} {
            background: inherit !important;
            width: auto !important;
            display: inline-block !important;
        }
        
        /* Tema Material - Pseudo-elementos ::before e ::after */
        ${seletoresBotoes.map((s) => `${s}::before`).join(", ")},
        ${seletoresBotoes.map((s) => `${s}::after`).join(", ")} {
            content: "" !important;
            display: block !important;
            height: 2px !important;
            width: 100% !important;
            position: absolute !important;
            left: 0 !important;
            background: #ada5a5 !important;
            transition: .3s !important;
            z-index: 1 !important;
        }
        
        ${seletoresBotoes.map((s) => `${s}::before`).join(", ")} {
            top: 0 !important;
        }
        
        ${seletoresBotoes.map((s) => `${s}::after`).join(", ")} {
            bottom: 0 !important;
        }
        `;
                }

                // CSS para margin-right do bot√£o - SOLU√á√ÉO SIMPLES QUE FUNCIONOU
                css += `

            /* üõ°Ô∏è EPROBE BUTTONS: Margin-right nos SVGs dos bot√µes personalizados */
            #documento-relevante-auto-button svg { margin-right: 3px !important; }
            .infraButton svg { margin-right: 3px !important; }
            .btn-primary svg { margin-right: 3px !important; }
            .eprobe-button svg { margin-right: 3px !important; }
            
            /* üõ°Ô∏è PROTE√á√ÉO: Garantir espa√ßamento correto em todos os bot√µes eProbe */
            button[id*="documento-relevante"] svg { margin-right: 3px !important; }
            `;

                // Adicionar prote√ß√£o espec√≠fica para bot√µes de pesquisa, navbar E infraLegendObrigatorio
                css +=
                    '\n\n    /* üéØ REGRA CR√çTICA OBRIGAT√ìRIA: .d-none.d-md-flex SEMPRE FLEX - ALTA PRIORIDADE */\n    .d-none.d-md-flex,\n    div.d-none.d-md-flex,\n    .navbar .d-none.d-md-flex,\n    #navbar .d-none.d-md-flex,\n    .navbar-nav .d-none.d-md-flex,\n    .navbar-collapse .d-none.d-md-flex {\n        display: flex !important;\n        align-items: center !important;\n        visibility: visible !important;\n        opacity: 1 !important;\n        height: auto !important;\n        width: auto !important;\n    }\n\n    /* üõ°Ô∏è PROTE√á√ÉO: Manter apar√™ncia original para elementos exclu√≠dos */\n    .btn-pesquisar, .btn-pesquisar-nova-janela, .search-button,\n    button[class*="btn-pesquisar"], .input-group-btn .btn,\n    .btn-pesquisar::before, .btn-pesquisar::after,\n    .btn-pesquisar-nova-janela::before, .btn-pesquisar-nova-janela::after,\n    .search-button::before, .search-button::after,\n    .infraLegendObrigatorio, .infraLegendObrigatorio *,\n    legend.infraLegendObrigatorio, legend.infraLegendObrigatorio * {\n        /* Preservar estilos originais sem resetar tudo */\n    }\n\n    /* üõ°Ô∏è INFRALEGEND: Garantir que infraLegendObrigatorio mantenha apar√™ncia original (EXCETO legMinutas) */\n    .infraLegendObrigatorio:not(#legMinutas), legend.infraLegendObrigatorio:not(#legMinutas) {\n        background: initial !important;\n        color: initial !important;\n        border: initial !important;\n        border-radius: initial !important;\n        box-shadow: initial !important;\n        transition: initial !important;\n        font-weight: initial !important;\n        cursor: initial !important;\n    }\n\n ';

                estiloElemento.textContent = css;
                document.head.appendChild(estiloElemento);

                // Salvar prefer√™ncia no localStorage
                try {
                    localStorage.setItem("eprobe_tema_botoes_eproc", tema);
                    localStorage.setItem(
                        "eprobe_opcoes_botoes_eproc",
                        JSON.stringify(opcoes),
                    );
                } catch (error) {
                    console.warn(
                        "‚ö†Ô∏è BOT√ïES: Erro ao salvar prefer√™ncias:",
                        error,
                    );
                }

                log(
                    `‚úÖ BOT√ïES: Tema "${tema}" aplicado com sucesso a todos os bot√µes do eProc`,
                );

                // Retornar informa√ß√µes sobre a aplica√ß√£o
                return {
                    tema: tema,
                    botoesAfetados: document.querySelectorAll(
                        seletoresBotoes.join(", "),
                    ).length,
                    configuracao: configuracaoTema,
                };
            };

            // Fun√ß√£o para restaurar tema salvo
            window.restaurarTemaBotoesEproc = function () {
                // üö® VERIFICA√á√ÉO CR√çTICA: N√ÉO restaurar tema na tela de edi√ß√£o de minutas
                const currentUrl = window.location.href;
                if (currentUrl.includes("acao=minuta_editar")) {
                    console.log(
                        "üö´ eProbe: Restaura√ß√£o de tema de bot√µes desabilitada na tela de edi√ß√£o de minutas",
                    );
                    return false; // Retornar false para indicar que n√£o foi restaurado
                }

                try {
                    const temaSalvo = localStorage.getItem(
                        "eprobe_tema_botoes_eproc",
                    );
                    const opcoesSalvas = localStorage.getItem(
                        "eprobe_opcoes_botoes_eproc",
                    );

                    if (temaSalvo) {
                        const opcoes = opcoesSalvas
                            ? JSON.parse(opcoesSalvas)
                            : {};
                        window.aplicarEstiloBotoesEproc(temaSalvo, opcoes);
                        log(
                            `üîÑ BOT√ïES: Tema salvo "${temaSalvo}" restaurado automaticamente`,
                        );
                        return true;
                    }
                } catch (error) {
                    console.warn(
                        "‚ö†Ô∏è BOT√ïES: Erro ao restaurar tema salvo:",
                        error,
                    );
                }
                return false;
            };

            // Fun√ß√£o para resetar estilos para o padr√£o do eProc
            window.resetarBotoesEproc = function () {
                const estiloPersonalizado = document.getElementById(
                    "eprobe-estilo-botoes-eproc",
                );
                if (estiloPersonalizado) {
                    estiloPersonalizado.remove();
                    localStorage.removeItem("eprobe_tema_botoes_eproc");
                    localStorage.removeItem("eprobe_opcoes_botoes_eproc");
                    log("üîÑ BOT√ïES: Estilos resetados para o padr√£o do eProc");
                    return true;
                }
                return false;
            };

            // Fun√ß√£o para listar temas dispon√≠veis
            window.listarTemasBotoesEproc = function () {
                log(
                    "üé® BOT√ïES: Temas dispon√≠veis:",
                    Object.keys(TEMAS_BOTOES_EPROC),
                );
                return Object.keys(TEMAS_BOTOES_EPROC);
            };

            // Fun√ß√£o para aplicar tema personalizado
            window.criarTemaPersonalizadoBotoes = function (
                nome,
                configuracao,
            ) {
                if (!nome || !configuracao) {
                    console.warn(
                        "‚ö†Ô∏è BOT√ïES: Nome e configura√ß√£o s√£o obrigat√≥rios para criar tema personalizado",
                    );
                    return false;
                }

                TEMAS_BOTOES_EPROC[nome] = configuracao;
                log(
                    `‚úÖ BOT√ïES: Tema personalizado "${nome}" criado com sucesso`,
                );
                return true;
            };

            // Auto-aplicar tema salvo quando a p√°gina carregar
            setTimeout(() => {
                if (!window.restaurarTemaBotoesEproc()) {
                    // Se n√£o h√° tema salvo, aplicar tema padr√£o elegante
                    // window.aplicarEstiloBotoesEproc('elegante');
                }
            }, 200); // ‚Üê REDUZIDO DE 1000ms PARA 200ms

            /**
             * üéØ NAVBAR SIMPLES: Fun√ß√£o otimizada sem complexidades desnecess√°rias
             */

            window.gerenciarNavbarEprobe = function () {
                // üö® VERIFICA√á√ÉO CR√çTICA: N√ÉO gerenciar navbar na tela de edi√ß√£o de minutas
                const currentUrl = window.location.href;
                if (currentUrl.includes("acao=minuta_editar")) {
                    console.log(
                        "üö´ eProbe: Gerenciamento de navbar desabilitado na tela de edi√ß√£o de minutas",
                    );
                    return; // Sair imediatamente - n√£o gerenciar navbar
                }

                if (window.navbarEprobeInicializada) return;
                window.navbarEprobeInicializada = true;

                // Fun√ß√£o simplificada para inserir elemento
                function inserir() {
                    const navbar = document.querySelector("nav#navbar");
                    const marketplace = navbar?.querySelector(
                        'a[href*="pdpj/marketplace_redirecionar"]',
                    );

                    if (
                        !marketplace ||
                        document.getElementById("eprobe-navbar-element")
                    ) {
                        return;
                    }

                    const link = document.createElement("a");
                    link.id = "eprobe-navbar-element";
                    link.href = "https://e-probe.vercel.app/";
                    link.target = "_blank";
                    link.style.cssText =
                        "padding: 5px 6px;text-decoration: none;display: flex !important; align-items: center !important;height: 50px";

                    // Verificar se chrome.runtime est√° dispon√≠vel (contexto de extens√£o)
                    if (
                        typeof chrome !== "undefined" &&
                        chrome.runtime &&
                        chrome.runtime.getURL
                    ) {
                        link.innerHTML = `<img src="${chrome.runtime.getURL(
                            "assets/40x.png",
                        )}" style="width:40px;height:40px">`;
                    } else {
                        // Fallback para teste local - usar caminho relativo
                        link.innerHTML = `<img src="assets/40x.png" style="width:40px;height:40px">`;
                    }

                    marketplace.parentNode.insertBefore(link, marketplace);

                    // Aplicar z-index elevado √† navbar para ficar acima de outros elementos
                    const navbarWrapper =
                        document.querySelector(
                            ".bootstrap-styles.navbar-wrapper",
                        ) ||
                        document.querySelector("nav#navbar") ||
                        navbar;
                    if (navbarWrapper) {
                        navbarWrapper.style.zIndex = "10000";
                    }
                }

                // Executar quando navbar estiver dispon√≠vel
                if (document.querySelector("nav#navbar")) {
                    inserir();
                } else {
                    // Observer simples sem overhead
                    const observer = new MutationObserver(() => {
                        if (document.querySelector("nav#navbar")) {
                            inserir();
                            observer.disconnect();
                        }
                    });
                    observer.observe(document.body, {
                        childList: true,
                        subtree: true,
                    });
                }
            };

            // üöÄ EXECU√á√ÉO IMEDIATA DA NAVBAR - ELIMINAR DELAY
            // üö® VERIFICA√á√ÉO CR√çTICA: N√ÉO executar navbar na tela de edi√ß√£o de minutas
            const currentUrl = window.location.href;
            if (!currentUrl.includes("acao=minuta_editar")) {
                // Executar gerenciamento da navbar IMEDIATAMENTE (sem timeout)
                if (window.gerenciarNavbarEprobe) {
                    log(
                        "‚ö° NAVBAR: Executando gerenciamento imediato da navbar",
                    );
                    window.gerenciarNavbarEprobe();
                } else {
                    // Se a fun√ß√£o ainda n√£o estiver dispon√≠vel, aguardar pouco e tentar novamente
                    setTimeout(() => {
                        if (window.gerenciarNavbarEprobe) {
                            log(
                                "‚ö° NAVBAR: Executando gerenciamento da navbar (tentativa 2)",
                            );
                            window.gerenciarNavbarEprobe();
                        }
                    }, 50);
                }
            } else {
                console.log(
                    "üö´ eProbe: Execu√ß√£o autom√°tica de navbar desabilitada na tela de edi√ß√£o de minutas",
                );
            }

            // ============================================
            // PERSONALIZA√á√ÉO DO CAMPO DE PESQUISA DA NAVBAR
            // ============================================

            /**
             * üîç NAVBAR: Personalizar campo de pesquisa de processo
             * Altera o placeholder e aplica estilo quase invis√≠vel
             */
            function personalizarCampoPesquisaNavbar() {
                log("üîç NAVBAR: Personalizando campo de pesquisa...");

                const campoPesquisa = document.querySelector(
                    "#txtNumProcessoPesquisaRapida",
                );

                if (campoPesquisa) {
                    // Alterar o placeholder
                    campoPesquisa.placeholder = "digite o n. do processo";

                    // Aplicar CSS para placeholder quase invis√≠vel
                    const style = document.createElement("style");
                    style.id = "eprobe-pesquisa-navbar-style";
                    style.textContent = `
            /* üîç PESQUISA NAVBAR: Placeholder quase invis√≠vel */
            #txtNumProcessoPesquisaRapida::placeholder {
                color: rgba(255, 255, 255, 1) !important;
                opacity: 0.4 !important;
                font-style: italic !important;
            }
            
            /* Para Firefox */
            #txtNumProcessoPesquisaRapida::-moz-placeholder {
                color: rgba(255, 255, 255, 1) !important;
                opacity: 0.4 !important;
                font-style: italic !important;
            }
            
            /* Para Edge/IE */
            #txtNumProcessoPesquisaRapida::-ms-input-placeholder {
                color: rgba(255, 255, 255, 1) !important;
                opacity: 0.4 !important;
                font-style: italic !important;
            }
        `;

                    // Verificar se o estilo j√° existe antes de adicionar
                    const estiloExistente = document.getElementById(
                        "eprobe-pesquisa-navbar-style",
                    );
                    if (!estiloExistente) {
                        document.head.appendChild(style);
                    }

                    log(
                        "‚úÖ NAVBAR: Campo de pesquisa personalizado com sucesso",
                    );
                    return true;
                } else {
                    logError("‚ö†Ô∏è NAVBAR: Campo de pesquisa n√£o encontrado");
                    return false;
                }
            }

            /**
             * üéØ NAVBAR: Monitorar e aplicar personaliza√ß√£o do campo de pesquisa
             * Executa com observer para garantir que funcione mesmo com carregamento din√¢mico
             */
            function inicializarPersonalizacaoPesquisaNavbar() {
                // Tentar aplicar imediatamente
                if (personalizarCampoPesquisaNavbar()) {
                    return;
                }

                // Se n√£o encontrou, usar observer para aguardar o elemento aparecer
                const observer = new MutationObserver(() => {
                    if (personalizarCampoPesquisaNavbar()) {
                        observer.disconnect();
                    }
                });

                observer.observe(document.body, {
                    childList: true,
                    subtree: true,
                });

                // Timeout de seguran√ßa para evitar observer infinito
                setTimeout(() => {
                    observer.disconnect();
                }, 10000);

                // Verifica√ß√£o final do status dos bot√µes ap√≥s inicializa√ß√£o completa
                setTimeout(() => {
                    log("=== STATUS FINAL DOS BOT√ïES ===");
                    const integratedButton = document.getElementById(
                        "documento-relevante-auto-button",
                    );
                    const floatingButton =
                        document.getElementById("sent1-auto-button");

                    log(
                        "Bot√£o integrado:",
                        integratedButton ? "‚úÖ Criado" : "‚ùå N√£o encontrado",
                    );
                    log(
                        "Bot√£o flutuante:",
                        floatingButton ? "‚úÖ Criado" : "‚ùå N√£o encontrado",
                    );
                    log("URL atual:", window.location.href);

                    // ‚úÖ VERIFICA√á√ÉO SEGURA das fun√ß√µes
                    let criterioIntegrado = "fun√ß√£o n√£o dispon√≠vel";
                    let criterioFlutuante = "fun√ß√£o n√£o dispon√≠vel";

                    try {
                        if (typeof shouldShowIntegratedButton === "function") {
                            criterioIntegrado = shouldShowIntegratedButton();
                        }
                    } catch (e) {
                        criterioIntegrado = "erro ao executar";
                    }

                    try {
                        if (typeof shouldShowFloatingButton === "function") {
                            criterioFlutuante = shouldShowFloatingButton();
                        }
                    } catch (e) {
                        criterioFlutuante = "erro ao executar";
                    }

                    log("Crit√©rio integrado:", criterioIntegrado);
                    log("Crit√©rio flutuante:", criterioFlutuante);

                    if (!integratedButton && !floatingButton) {
                        log(
                            "‚ö†Ô∏è ATEN√á√ÉO: Nenhum bot√£o foi criado - tentando uma √∫ltima vez",
                        );
                        ensureButtonExists();
                    }
                }, 5000);
            }

            // Expor fun√ß√£o globalmente para debug
            window.personalizarCampoPesquisaNavbar =
                personalizarCampoPesquisaNavbar;

            // =====================================================================
            // SISTEMA UNIFICADO DE SUBSTITUICAO DE ICONES - EPROBE
            // Fonte unica de verdade para todos os mapeamentos de icones.
            // Seletores exclusivamente por src/alt/id - sem wildcards genericos.
            // Ordem: seletores mais especificos primeiro (minuta_* antes de genericos).
            // =====================================================================

            const EPROBE_ICON_MAP = [
                // --- MINUTA-specific (devem vir antes dos genericos para evitar conflito) ---
                {
                    selector: 'img[src*="minuta_historico.gif"]',
                    name: "Historico Julgamento",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M12 7v5l4 2"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_versoes.gif"]',
                    name: "Versoes Minuta",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M21 7h-3a2 2 0 0 1-2-2V2"/><path d="M21 6v6.5c0 .8-.7 1.5-1.5 1.5h-7c-.8 0-1.5-.7-1.5-1.5v-9c0-.8.7-1.5 1.5-1.5H17Z"/><path d="M7 8v8.8c0 .3.2.6.4.8.2.2.5.4.8.4H15"/><path d="M3 12v8.8c0 .3.2.6.4.8.2.2.5.4.8.4H11"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_alterar.gif"]',
                    name: "Editar Minuta",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 5-2.414-2.414A2 2 0 0 0 14.172 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2"/><path d="M21.378 12.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/><path d="M8 18h1"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_editar.gif"]',
                    name: "Editar Minuta (editar)",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m18 5-2.414-2.414A2 2 0 0 0 14.172 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2"/><path d="M21.378 12.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/><path d="M8 18h1"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_assinar2.gif"]',
                    name: "Assinar Minuta",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" height="18px" viewBox="0 -960 960 960" width="18px" fill="currentColor"><path d="m495.35-537.67 41.08 41.32 199-199-41.08-41.08-199 198.76ZM205.8-206.57h39.09l217.76-217-40.32-40.32L205.8-246.13v39.56Zm366.63-181.76L387.57-572.67l122.95-123.96-50.24-48.72-206.8 206.81-71.63-71.39 214.98-212.98q26.63-26.63 65.45-26.63 38.83 0 65.7 26.63l54.41 54.41L655-839.35q17.43-17.43 40.85-17.43 23.41 0 40.85 17.43L838.35-737.7q17.19 17.44 16.69 41.35-.5 23.92-16.69 42.35L572.43-388.33Zm-283.1 283.11H104.22v-183.35l283.35-284.1 184.86 184.34-283.1 283.11Z"/></svg>',
                },

                // --- Icones genericos por src ---
                {
                    selector: 'img[src*="configuracao.gif"]',
                    name: "Configuracao",
                    svg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#9CA3AF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>',
                },
                {
                    selector: 'img[src*="refresh.gif"]',
                    name: "Refresh",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>',
                },
                {
                    selector: 'img[src*="valores.gif"]',
                    name: "Valores",
                    svg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>',
                },
                {
                    selector: 'img[src*="remover.gif"]',
                    name: "Remover",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>',
                },
                {
                    selector: 'img[src*="receber.gif"]',
                    name: "Receber",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3 4 7l4 4"/><path d="M4 7h16"/><path d="m16 21 4-4-4-4"/><path d="M20 17H4"/></svg>',
                },
                {
                    selector: 'img[src*="mais.gif"]',
                    name: "Mais",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><line x1="19" x2="19" y1="8" y2="14"/><line x1="22" x2="16" y1="11" y2="11"/></svg>',
                },
                {
                    selector: 'img[src*="microphone.png"]',
                    name: "Audiencia",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 10v3"/><path d="M6 6v11"/><path d="M10 3v18"/><path d="M14 8v7"/><path d="M18 5v13"/><path d="M22 10v3"/></svg>',
                },
                {
                    selector: 'img[src*="pdf.gif"]',
                    name: "PDF",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" height="18px" viewBox="0 -960 960 960" width="18px" fill="currentColor"><path d="M360-460h40v-80h40q17 0 28.5-11.5T480-580v-40q0-17-11.5-28.5T440-660h-80v200Zm40-120v-40h40v40h-40Zm120 120h80q17 0 28.5-11.5T640-500v-120q0-17-11.5-28.5T600-660h-80v200Zm40-40v-120h40v120h-40Zm120 40h40v-80h40v-40h-40v-40h40v-40h-80v200ZM320-240q-33 0-56.5-23.5T240-320v-480q0-33 23.5-56.5T320-880h480q33 0 56.5 23.5T880-800v480q0 33-23.5 56.5T800-240H320Zm0-80h480v-480H320v480ZM160-80q-33 0-56.5-23.5T80-160v-560h80v560h560v80H160Zm160-720v480-480Z"/></svg>',
                },
                {
                    selector: 'img[src*="anexos.gif"]',
                    name: "Anexos",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-4 8"/></svg>',
                },
                {
                    selector: 'img[src*="email.gif"]',
                    name: "Email",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7"/><rect x="2" y="4" width="20" height="16" rx="2"/></svg>',
                },
                {
                    selector: 'img[src*="marcar.gif"]',
                    name: "Marcar",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 21a8 8 0 0 1 10.821-7.487"/><path d="M21.378 16.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/><circle cx="10" cy="8" r="5"/></svg>',
                },
                {
                    selector: 'img[src*="encaminhar.gif"]',
                    name: "Encaminhar",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 12h-5"/><path d="M15 8h-5"/><path d="M19 17V5a2 2 0 0 0-2-2H4"/><path d="M8 21h12a2 2 0 0 0 2-2v-1a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v1a2 2 0 1 1-4 0V5a2 2 0 1 0-4 0v2a1 1 0 0 0 1 1h3"/></svg>',
                },
                {
                    selector: 'img[src*="assinar.gif"]',
                    name: "Assinar",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 16 6-12 6 12"/><path d="M8 12h8"/><path d="m16 20 2 2 4-4"/></svg>',
                },
                {
                    selector: 'img[src*="atualizar.gif"]',
                    name: "Atualizar",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z"/><path d="m2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z"/><path d="M7 21h10"/><path d="M12 3v18"/><path d="M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2"/></svg>',
                },
                {
                    selector: 'img[src*="predio.png"]',
                    name: "Predio",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z"/><path d="M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2"/><path d="M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2"/><path d="M10 6h4"/><path d="M10 10h4"/><path d="M10 14h4"/><path d="M10 18h4"/></svg>',
                },
                {
                    selector: 'img[src*="hierarquia.gif"]',
                    name: "Hierarquia",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="5" cy="6" r="3"/><path d="M5 9v12"/><circle cx="19" cy="18" r="3"/><path d="m15 9-3-3 3-3"/><path d="M12 6h5a2 2 0 0 1 2 2v7"/></svg>',
                },
                {
                    selector: 'img[src*="newspaper.png"]',
                    name: "Citacao",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 17V5a2 2 0 0 0-2-2H4"/><path d="M8 21h12a2 2 0 0 0 2-2v-1a1 1 0 0 0-1-1H11a1 1 0 0 0-1 1v1a2 2 0 1 1-4 0V5a2 2 0 1 0-4 0v2a1 1 0 0 0 1 1h3"/></svg>',
                },
                {
                    selector: 'img[src*="novo.gif"]',
                    name: "Novo",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M3 15h6"/><path d="M6 12v6"/></svg>',
                },
                {
                    selector: 'img[src*="alterar.gif"]',
                    name: "Alterar",
                    svg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#f97316" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14,2 14,8 20,8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10,9 9,9 8,9"/></svg>',
                },
                {
                    selector: 'img[src*="balao.gif"]',
                    name: "Balao",
                    svg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="#FEF3C7" stroke="#D97706" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>',
                },
                {
                    selector: 'img[src*="linkeditor.png"]',
                    name: "Link",
                    svg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#6B7280" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>',
                },
                {
                    selector: 'img[src*="html.gif"]',
                    name: "HTML",
                    svg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#4F83CC" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14,2 14,8 20,8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10,9 9,9 8,9"/></svg>',
                },
                {
                    selector: 'img[src*="tooltip.gif"]',
                    name: "Tooltip",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round"><path d="M16 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V8Z"/><path d="M15 3v4a2 2 0 0 0 2 2h4"/></svg>',
                },
                {
                    selector: 'img[src*="duvida.png"]',
                    name: "Ajuda",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>',
                },
                {
                    selector: 'img[src*="lupa.gif"]',
                    name: "Lupa",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="m21 21-4.34-4.34"/><circle cx="11" cy="11" r="8"/></svg>',
                },
                {
                    selector: 'img[src*="oral_video.png"]',
                    name: "Video",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5"/><rect x="2" y="6" width="14" height="12" rx="2"/></svg>',
                },
                {
                    selector: 'img[src*="menos.gif"]',
                    name: "Menos",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/></svg>',
                },

                // --- Seletores por alt (para icones do fieldset sem src obvio) ---
                {
                    selector: 'img[alt="arvore documento_listar"]',
                    name: "Arvore",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="16" y="16" width="6" height="6" rx="1"/><rect x="2" y="16" width="6" height="6" rx="1"/><rect x="9" y="2" width="6" height="6" rx="1"/><path d="M5 16v-3a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v3"/><path d="M12 12V8"/></svg>',
                },
                {
                    selector: 'img[alt="processo intimacao_bloco"]',
                    name: "Peritos",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 18h8"/><path d="M3 22h18"/><path d="M14 22a7 7 0 1 0 0-14h-1"/><path d="M9 14h2"/><path d="M9 12a2 2 0 0 1-2-2V6h6v4a2 2 0 0 1-2 2Z"/><path d="M12 6V3a1 1 0 0 0-1-1H9a1 1 0 0 0-1 1v3"/></svg>',
                },
                {
                    selector: 'img[alt="acoes preferenciais"]',
                    name: "AcoesPreferenciais",
                    svg: '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#9CA3AF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>',
                },
                {
                    selector: 'img[id="refresh"]',
                    name: "RefreshId",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"/><path d="M16 16h5v5"/></svg>',
                },
                {
                    selector: 'img[alt="Nova Minuta"]',
                    name: "NovaMinutaAlt",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4"/><path d="M14 2v4a2 2 0 0 0 2 2h4"/><path d="M3 15h6"/><path d="M6 12v6"/></svg>',
                },

                // --- Novos icones de minuta (Lucide) ---
                {
                    selector: 'img[src*="minuta_conferir.gif"]',
                    name: "Conferir Minuta",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#16a34a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z"/><path d="M14 2v5a1 1 0 0 0 1 1h5"/><path d="m9 15 2 2 4-4"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_paraconferir.gif"]',
                    name: "Encaminhar para Conferencia",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#2563eb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><rect width="8" height="4" x="8" y="2" rx="1" ry="1"/><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><path d="m9 14 2 2 4-4"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_lembrete.gif"]',
                    name: "Gerenciar Lembretes",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M10.268 21a2 2 0 0 0 3.464 0"/><path d="M3.262 15.326A1 1 0 0 0 4 17h16a1 1 0 0 0 .74-1.673C19.41 13.956 18 12.499 18 8A6 6 0 0 0 6 8c0 4.499-1.411 5.956-2.738 7.326"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_paraassinar.gif"]',
                    name: "Encaminhar para Assinatura",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#7c3aed" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="m18.226 5.226-2.52-2.52A2.4 2.4 0 0 0 14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-.351"/><path d="M21.378 12.626a1 1 0 0 0-3.004-3.004l-4.01 4.012a2 2 0 0 0-.506.854l-.837 2.87a.5.5 0 0 0 .62.62l2.87-.837a2 2 0 0 0 .854-.506z"/><path d="M8 18h1"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_devolver.gif"]',
                    name: "Devolver Minuta",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_disponibilizar_verde.gif"]',
                    name: "Minuta Disponibilizada",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#22c55e" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M12 3v12"/><path d="m17 8-5-5-5 5"/><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_disponibilizar.gif"]',
                    name: "Disponibilizar Minuta",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#b45309" stroke-width="2.25" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M12 3v12"/><path d="m17 8-5-5-5 5"/><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_excluir.gif"]',
                    name: "Excluir Minuta",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M10 11v6"/><path d="M14 11v6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M3 6h18"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_imprimir.gif"]',
                    name: "Imprimir Minuta",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><path d="M6 9V3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v6"/><rect x="6" y="14" width="12" height="8" rx="1"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_inserir_sessao_julgamento"]',
                    name: "Inserir em Sessao",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M16 19h6"/><path d="M16 2v4"/><path d="M19 16v6"/><path d="M21 12.598V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h8.5"/><path d="M3 10h18"/><path d="M8 2v4"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_atualizar_cabecalho.gif"]',
                    name: "Atualizar Cabecalho",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z"/><path d="M14 2v5a1 1 0 0 0 1 1h5"/><path d="M12 12v6"/><path d="m15 15-3-3-3 3"/></svg>',
                },
                {
                    selector: 'img[src*="minuta_transferir.png"]',
                    name: "Transferir Minuta",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M3.714 3.048a.498.498 0 0 0-.683.627l2.843 7.627a2 2 0 0 1 0 1.396l-2.842 7.627a.498.498 0 0 0 .682.627l18-8.5a.5.5 0 0 0 0-.904z"/><path d="M6 12h16"/></svg>',
                },

                // --- Novos icones utilitarios (Lucide) ---
                {
                    selector: 'img[src*="salvarcomomodelo.png"]',
                    name: "Salvar como Modelo",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M12 7v6"/><path d="M15 10H9"/><path d="M17 3a2 2 0 0 1 2 2v15a1 1 0 0 1-1.496.868l-4.512-2.578a2 2 0 0 0-1.984 0l-4.512 2.578A1 1 0 0 1 5 20V5a2 2 0 0 1 2-2z"/></svg>',
                },
                {
                    selector: 'img[src*="brasao.png"]',
                    name: "Atualizar Timbre",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z"/></svg>',
                },
                {
                    selector: 'img[src*="inteiro_teor.png"]',
                    name: "Inteiro Teor",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M12 7v14"/><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"/></svg>',
                },
                {
                    selector: 'img[src*="evento_automatizado.png"]',
                    name: "Evento Automatizado",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z"/></svg>',
                },
                {
                    selector: 'img[src*="transferir_item.png"]',
                    name: "Abrir em Nova Aba",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M15 3h6v6"/><path d="M10 14 21 3"/><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/></svg>',
                },
                {
                    selector: 'img[src*="ver_tudo.gif"]',
                    name: "Mostrar Tudo",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M3 5h.01"/><path d="M3 12h.01"/><path d="M3 19h.01"/><path d="M8 5h13"/><path d="M8 12h13"/><path d="M8 19h13"/></svg>',
                },
                {
                    selector: 'img[src*="ver_resumo.gif"]',
                    name: "Ocultar Lista",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="M16 5H3"/><path d="M11 12H3"/><path d="M16 19H3"/><path d="m15.5 9.5 5 5"/><path d="m20.5 9.5-5 5"/></svg>',
                },
                {
                    selector: 'img[src*="seta_acima.gif"]',
                    name: "Ordenar Ascendente",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="m18 15-6-6-6 6"/></svg>',
                },
                {
                    selector: 'img[src*="seta_abaixo_selecionada.gif"]',
                    name: "Ordenar Descendente Ativo",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="m6 9 6 6 6-6"/></svg>',
                },
                {
                    selector: 'img[src*="seta_abaixo.gif"]',
                    name: "Ordenar Descendente",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;"><path d="m6 9 6 6 6-6"/></svg>',
                },
            ];

            // Mapeamento por texto do link (para links sem imagem identificavel por src)
            const EPROBE_ICON_TEXT_MAP = {
                "Incluir em Pauta/Mesa":
                    '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 19h6"/><path d="M16 2v4"/><path d="M19 16v6"/><path d="M21 12.598V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h8.5"/><path d="M3 10h18"/><path d="M8 2v4"/></svg>',
            };

            // SVGs para lembretes Material Icons
            var LEMBRETE_EDIT_SVG =
                '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#545454"><path d="m478.61-517.54 41.62 41.62L736.31-692l-41.62-41.62-216.08 216.08ZM218.69-216h41.62l223.77-223.77-41.62-41.62-223.77 223.77V-216Zm320.62-204.69L423.77-536.61l148.31-148.31-43.69-43.69q-3.08-3.08-9.23-3.08-6.16 0-9.24 3.08L320.85-539.54l-37.15-36.38 191.23-189.85q18.69-18.69 45.3-18.69 26.62 0 45.31 18.69l43.69 43.69 54.54-54.53q12.85-12.85 31.11-12.85 18.27 0 31.12 12.85l54.84 54.84q12.85 12.85 11.97 29.85-.89 17-12.73 30.84L539.31-420.69ZM282.23-164H166.69v-115.54l256.7-257.07 115.92 115.92L282.23-164Z"/></svg>';
            var LEMBRETE_DELETE_SVG =
                '<svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#545454"><path d="M324.31-164q-26.62 0-45.47-18.84Q260-201.69 260-228.31V-696h-48v-52h172v-43.38h192V-748h172v52h-48v467.26q0 27.74-18.65 46.24Q662.7-164 635.69-164H324.31ZM648-696H312v467.69q0 5.39 3.46 8.85t8.85 3.46h311.38q4.62 0 8.46-3.85 3.85-3.84 3.85-8.46V-696ZM400.16-288h51.99v-336h-51.99v336Zm107.69 0h51.99v-336h-51.99v336ZM312-696v480-480Z"/></svg>';

            // üé® FUN√á√ÉO UTILIT√ÅRIA: Aplicar estilos padronizados aos containers de √≠cones
            function applyStandardIconStyles(container) {
                container.style.display = "inline-flex";
                container.style.alignItems = "center";
                container.style.marginRight = "4px";
                container.style.verticalAlign = "middle";

                // Marcar como container de √≠cone eProbe para CSS
                container.setAttribute("data-eprobe-icon-container", "true");

                // Aplicar estilos aos SVGs dentro do container
                const svg = container.querySelector("svg");
                if (svg) {
                    svg.style.flexShrink = "0";
                    svg.style.verticalAlign = "middle";
                }
            }

            // Fun√ß√£o para verificar se um elemento √© seguro para implementar altern√¢ncia
            function isElementSafeForToggle(imgElement) {
                try {
                    // Verificar se o elemento e seus pais existem
                    if (!imgElement || !imgElement.parentElement) {
                        return false;
                    }

                    // Encontrar o elemento clic√°vel
                    const linkElement =
                        imgElement.closest("a") || imgElement.parentElement;
                    if (!linkElement) {
                        return false;
                    }

                    // Verificar se tem onclick v√°lido
                    const onclickAttr = linkElement.getAttribute("onclick");
                    if (!onclickAttr) {
                        return false;
                    }

                    // Verificar se √© um onclick do tipo que queremos processar
                    const isValidOnclick =
                        onclickAttr.includes("infraAbrirFecharElementoHTML") ||
                        onclickAttr.includes("conteudoInternoMinutas") ||
                        onclickAttr.includes("conteudoMinutas");

                    if (!isValidOnclick) {
                        return false;
                    }

                    // Verificar se o elemento alvo existe
                    const match = onclickAttr.match(
                        /infraAbrirFecharElementoHTML\s*\(\s*['"]([^'"]+)['"](?:,\s*['"]([^'"]+)['"])?/,
                    );
                    if (match) {
                        const targetId = match[1];
                        const targetElement = document.getElementById(targetId);
                        if (!targetElement) {
                            console.warn(
                                `‚ö†Ô∏è ALTERN√ÇNCIA: Elemento alvo '${targetId}' n√£o encontrado`,
                            );
                            return false;
                        }
                    }

                    return true;
                } catch (error) {
                    console.warn(
                        "‚ö†Ô∏è ALTERN√ÇNCIA: Erro ao verificar elemento:",
                        error,
                    );
                    return false;
                }
            }

            // Fun√ß√£o para implementar altern√¢ncia de expandir/retrair para √≠cones mais.gif e menos.gif
            function implementarAlternanciaExpandirRetrair(
                imgOriginal,
                container,
                selector,
            ) {
                log(
                    `üîÑ ALTERN√ÇNCIA: Implementando funcionalidade para ${selector}`,
                );

                // Determinar o estado inicial baseado no nome do arquivo
                const isExpanded = selector.includes("menos.gif"); // menos.gif = expandido
                const isCollapsed = selector.includes("mais.gif"); // mais.gif = retra√≠do

                // Encontrar o elemento clic√°vel (normalmente o link pai)
                const linkElement =
                    imgOriginal.closest("a") || imgOriginal.parentElement;

                if (!linkElement) {
                    console.warn(
                        "‚ö†Ô∏è ALTERN√ÇNCIA: Link pai n√£o encontrado para",
                        selector,
                    );
                    return;
                }

                // Criar SVGs para os dois estados
                const iconExpanded =
                    '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg>'; // Seta para baixo (expandido)
                const iconCollapsed =
                    '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-right"><path d="m9 18 6-6-6-6"/></svg>'; // Seta para direita (retra√≠do)

                // Definir o √≠cone inicial
                const initialIcon = isExpanded ? iconExpanded : iconCollapsed;
                container.innerHTML = initialIcon;

                // Aplicar estilos ao SVG
                const svg = container.firstElementChild;
                if (svg) {
                    svg.classList.add("iconeAcao");
                    svg.style.width = "18px";
                    svg.style.height = "18px";
                    svg.style.cursor = "pointer";
                    svg.style.transition = "transform 0.2s ease";
                }

                // Armazenar o estado atual
                container.setAttribute("data-expanded", isExpanded.toString());

                // Adicionar funcionalidade de clique
                const handleClick = (event) => {
                    event.preventDefault();
                    event.stopPropagation();

                    const currentlyExpanded =
                        container.getAttribute("data-expanded") === "true";
                    const newExpanded = !currentlyExpanded;

                    // Alternar o √≠cone
                    container.innerHTML = newExpanded
                        ? iconExpanded
                        : iconCollapsed;

                    // Aplicar estilos ao novo SVG
                    const newSvg = container.firstElementChild;
                    if (newSvg) {
                        newSvg.classList.add("iconeAcao");
                        newSvg.style.width = "18px";
                        newSvg.style.height = "18px";
                        newSvg.style.cursor = "pointer";
                        newSvg.style.transition = "transform 0.2s ease";
                    }

                    // Atualizar o estado
                    container.setAttribute(
                        "data-expanded",
                        newExpanded.toString(),
                    );

                    // Encontrar e alternar o display do conte√∫do relacionado
                    const targetElement = findToggleTarget(linkElement);
                    if (targetElement) {
                        targetElement.style.display = newExpanded
                            ? "block"
                            : "none";
                        log(
                            `üîÑ ALTERN√ÇNCIA: Conte√∫do ${
                                newExpanded ? "expandido" : "retra√≠do"
                            }`,
                        );
                    }

                    // N√ÉO executar o clique original do eProc para evitar conflitos
                    // A fun√ß√£o infraAbrirFecharElementoHTML pode tentar acessar elementos que n√£o existem
                    // ou elementos que j√° foram modificados pelo nosso sistema
                    log(
                        `‚úÖ ALTERN√ÇNCIA: Clique processado pelo sistema eProbe - ${
                            newExpanded ? "expandido" : "retra√≠do"
                        }`,
                    );
                };

                // Adicionar listener no container
                container.addEventListener("click", handleClick);

                // Encontrar o elemento alvo inicial e definir seu estado
                const initialTarget = findToggleTarget(linkElement);
                if (initialTarget) {
                    initialTarget.style.display = isExpanded ? "block" : "none";
                }

                log(
                    `‚úÖ ALTERN√ÇNCIA: Configurado ${selector} - Estado inicial: ${
                        isExpanded ? "expandido" : "retra√≠do"
                    }`,
                );
            }

            // Fun√ß√£o auxiliar para encontrar o elemento que deve ser alternado
            function findToggleTarget(linkElement) {
                // Estrat√©gias espec√≠ficas para o eProc:

                // 1. Procurar por elementos espec√≠ficos das minutas
                const minutasTargets = [
                    "conteudoInternoMinutas_0",
                    "conteudoInternoMinutas_1",
                    "conteudoInternoMinutas_2",
                    "conteudoInternoMinutas_3",
                ];

                for (const targetId of minutasTargets) {
                    const element = document.getElementById(targetId);
                    if (element) {
                        log(
                            `üéØ ALTERN√ÇNCIA: Encontrado elemento alvo: ${targetId}`,
                        );
                        return element;
                    }
                }

                // 2. Procurar por padr√£o onclick do eProc
                const linkParent = linkElement.closest("button") || linkElement;
                const onclickAttr = linkParent.getAttribute("onclick");
                if (onclickAttr) {
                    // Extrair ID do onclick: infraAbrirFecharElementoHTML('conteudoInternoMinutas_0', 'imgMinutas_0')
                    const match = onclickAttr.match(
                        /infraAbrirFecharElementoHTML\s*\(\s*['"]([^'"]+)['"](?:,\s*['"]([^'"]+)['"])?/,
                    );
                    if (match) {
                        const targetId = match[1];
                        log(
                            `üéØ ALTERN√ÇNCIA: Extra√≠do ID do onclick: ${targetId}`,
                        );
                        const element = document.getElementById(targetId);
                        if (element) {
                            return element;
                        } else {
                            console.warn(
                                `‚ö†Ô∏è ALTERN√ÇNCIA: Elemento com ID '${targetId}' n√£o existe no DOM`,
                            );
                            return null; // Retornar null se o elemento n√£o existir
                        }
                    }
                }

                // 3. Procurar por fieldset e divs relacionados
                const fieldsetParent = linkElement.closest("fieldset");
                if (fieldsetParent) {
                    const internalDivs = fieldsetParent.querySelectorAll(
                        'div[id*="conteudoInterno"], div[id*="conteudo"]',
                    );
                    for (const div of internalDivs) {
                        if (div.id && div.id !== fieldsetParent.id) {
                            log(
                                `üéØ ALTERN√ÇNCIA: Encontrado div interno: ${div.id}`,
                            );
                            return div;
                        }
                    }
                }

                // 4. Procurar por elementos irm√£os que podem ser alternados
                let sibling = linkElement.nextElementSibling;
                while (sibling) {
                    if (
                        sibling.tagName === "DIV" &&
                        sibling.id &&
                        sibling.id.includes("conteudo")
                    ) {
                        log(
                            `üéØ ALTERN√ÇNCIA: Encontrado sibling: ${sibling.id}`,
                        );
                        return sibling;
                    }
                    sibling = sibling.nextElementSibling;
                }

                // 5. Procurar no elemento pai por containers espec√≠ficos
                const parent = linkElement.parentElement;
                if (parent) {
                    const containers = parent.querySelectorAll(
                        'div[id*="conteudoInterno"], div[id*="conteudo"], table.infraTable',
                    );
                    for (const container of containers) {
                        if (
                            container !== linkElement &&
                            !container.contains(linkElement)
                        ) {
                            log(
                                `üéØ ALTERN√ÇNCIA: Encontrado container: ${
                                    container.id || container.className
                                }`,
                            );
                            return container;
                        }
                    }
                }

                console.warn(
                    "‚ö†Ô∏è ALTERN√ÇNCIA: Elemento alvo n√£o encontrado para",
                    linkElement,
                );
                return null;
            }

            // üîç FUN√á√ÉO AUXILIAR: Verificar se estamos numa p√°gina de capa do processo
            function isCapaProcessoPage() {
                const currentUrl = window.location.href;

                // Verificar se a URL cont√©m o padr√£o de capa do processo
                const capaProcessoPatterns = [
                    "eproc1g.tjsc.jus.br/eproc/controlador.php?acao=processo_selecionar&",
                    "eproc2g.tjsc.jus.br/eproc/controlador.php?acao=processo_selecionar&",
                ];

                return capaProcessoPatterns.some((pattern) =>
                    currentUrl.includes(pattern),
                );
            }

            /**
             * üé® FUN√á√ÉO PARA APLICAR GRADIENTES NA CAPA DO PROCESSO
             * Substitui cores s√≥lidas de background por gradientes suaves no fieldset da capa
             * Baseado na documenta√ß√£o "cores capa do processo.md"
             */
            function aplicarGradientesCapaProcesso() {
                log("üé® GRADIENTES CAPA: Iniciando aplica√ß√£o de gradientes...");

                // Verificar se estamos na p√°gina correta
                if (!isCapaProcessoPage()) {
                    log(
                        "‚ùå GRADIENTES CAPA: N√£o √© uma p√°gina de capa de processo",
                    );
                    return false;
                }

                // Buscar o fieldset da capa
                const fieldsetCapa = document.querySelector(
                    "#fldCapa.infraFieldset.bootstrap-styles",
                );
                if (!fieldsetCapa) {
                    log("‚ùå GRADIENTES CAPA: Fieldset #fldCapa n√£o encontrado");
                    return false;
                }

                log("‚úÖ GRADIENTES CAPA: Fieldset encontrado:", fieldsetCapa);

                // DETECCAO PRIMARIA: Usar data-classe (robusto, nao depende de cor)
                const dataClasse = fieldsetCapa.getAttribute("data-classe");
                const dataCompetencia =
                    fieldsetCapa.getAttribute("data-competencia");
                log(
                    "üîç GRADIENTES CAPA: data-classe:",
                    dataClasse,
                    "data-competencia:",
                    dataCompetencia,
                );

                // Mapeamento de data-classe para gradientes (metodo primario)
                const mapeamentoClasses = {
                    // Classes criminais (rosa)
                    94: "linear-gradient(#FBAFDF, #F78DC7)",
                    283: "linear-gradient(#FBAFDF, #F78DC7)",
                    // Adicionar mais classes conforme documentadas
                };

                // Tentar deteccao por data-classe primeiro
                if (dataClasse && mapeamentoClasses[dataClasse]) {
                    const gradiente = mapeamentoClasses[dataClasse];
                    log(
                        `üéâ GRADIENTES CAPA: Match por data-classe=${dataClasse}`,
                    );
                    log(`   Gradiente: ${gradiente}`);
                    try {
                        fieldsetCapa.style.setProperty(
                            "background",
                            gradiente,
                            "important",
                        );
                        log(
                            "‚úÖ GRADIENTES CAPA: Gradiente aplicado via data-classe!",
                        );
                        return {
                            sucesso: true,
                            metodo: "data-classe",
                            classe: dataClasse,
                            gradienteAplicado: gradiente,
                            elemento: fieldsetCapa,
                        };
                    } catch (error) {
                        logError(
                            "‚ùå GRADIENTES CAPA: Erro ao aplicar gradiente via data-classe:",
                            error,
                        );
                    }
                }

                // FALLBACK: Deteccao por cor computada (metodo legado)
                log(
                    "üîÑ GRADIENTES CAPA: data-classe nao mapeada, usando fallback por cor...",
                );

                // Obter estilo computed atual
                const estiloComputado = window.getComputedStyle(fieldsetCapa);
                const corAtual = estiloComputado.backgroundColor;

                log("üîç GRADIENTES CAPA: Cor atual detectada:", corAtual);

                // Fun√ß√£o para converter RGB para hex
                function rgbParaHex(rgb) {
                    if (rgb.startsWith("#")) return rgb.toLowerCase();

                    const rgbMatch = rgb.match(
                        /rgb\((\d+),\s*(\d+),\s*(\d+)\)/,
                    );
                    if (rgbMatch) {
                        const r = parseInt(rgbMatch[1])
                            .toString(16)
                            .padStart(2, "0");
                        const g = parseInt(rgbMatch[2])
                            .toString(16)
                            .padStart(2, "0");
                        const b = parseInt(rgbMatch[3])
                            .toString(16)
                            .padStart(2, "0");
                        return `#${r}${g}${b}`;
                    }

                    return rgb;
                }

                // Mapeamento de cores para gradientes conforme documenta√ß√£o
                const mapeamentoCores = {
                    // AMARELO
                    "#efd88f": "linear-gradient(#F9EFAF, #F7E98D)",

                    // VERMELHO (formato rgb)
                    "#db8080": "linear-gradient(#FAAFAF, #F78D8D)",

                    // AZUL
                    "#c4dffb": "linear-gradient(#AFCFFA, #8DC0F7)",

                    // VERDE
                    "#a7eda7": "linear-gradient(#AFFAB6, #8DF792)",

                    // LARANJA
                    "#f5b574": "linear-gradient(#FAD3AF, #F7C68D)",

                    // CINZA
                    "#a0b9bf": "linear-gradient(#B5C9CF, #9CB0B7)",
                    "#A0B9BF": "linear-gradient(#B5C9CF, #9CB0B7)", // case insensitive

                    // ROSA
                    "#fbc4df": "linear-gradient(#FBAFDF, #F78DC7)",
                };

                // Verificar m√∫ltiplos formatos da cor atual
                const formatosPossiveisCor = [
                    corAtual,
                    corAtual.replace(/\s+/g, ""), // sem espa√ßos
                    rgbParaHex(corAtual),
                    rgbParaHex(corAtual).toUpperCase(),
                ];

                log(
                    "üîç GRADIENTES CAPA: Formatos testados:",
                    formatosPossiveisCor,
                );

                let gradienteEncontrado = null;
                let corCorrespondente = null;

                // Buscar correspond√™ncia nos mapeamentos
                for (const formato of formatosPossiveisCor) {
                    if (mapeamentoCores[formato]) {
                        gradienteEncontrado = mapeamentoCores[formato];
                        corCorrespondente = formato;
                        break;
                    }
                }

                if (gradienteEncontrado) {
                    log(`üéâ GRADIENTES CAPA: Correspond√™ncia encontrada!`);
                    log(`   Cor original: ${corCorrespondente}`);
                    log(`   Gradiente: ${gradienteEncontrado}`);

                    // Aplicar o gradiente seguindo padr√£o das outras fun√ß√µes
                    try {
                        fieldsetCapa.style.setProperty(
                            "background",
                            gradienteEncontrado,
                            "important",
                        );
                        log(
                            "‚úÖ GRADIENTES CAPA: Gradiente aplicado com sucesso!",
                        );

                        return {
                            sucesso: true,
                            corOriginal: corCorrespondente,
                            gradienteAplicado: gradienteEncontrado,
                            elemento: fieldsetCapa,
                        };
                    } catch (error) {
                        logError(
                            "‚ùå GRADIENTES CAPA: Erro ao aplicar gradiente:",
                            error,
                        );
                        return false;
                    }
                } else {
                    log(
                        `‚ùå GRADIENTES CAPA: Cor n√£o reconhecida para substitui√ß√£o: ${corAtual}`,
                    );
                    log(
                        "üí° GRADIENTES CAPA: Cores suportadas:",
                        Object.keys(mapeamentoCores),
                    );

                    return {
                        sucesso: false,
                        corNaoReconhecida: corAtual,
                        coresSuportadas: Object.keys(mapeamentoCores),
                    };
                }
            }

            /**
             * üé® FUN√á√ÉO PARA PERSONALIZAR LEGMINUTAS E TABELAS
             * Substitui cores s√≥lidas por gradientes suaves nos elementos de minutas
             * Baseado na documenta√ß√£o "cores legMinutas.md"
             */
            function aplicarGradientesLegMinutas() {
                log(
                    "üé® GRADIENTES: Iniciando aplica√ß√£o em TODOS os legMinutas...",
                );

                try {
                    // Buscar TODOS os elementos legMinutas com aria-label="Hist√≥rico"
                    const elementosLegMinutas = document.querySelectorAll(
                        'legend[aria-label="Hist√≥rico"]#legMinutas.infraLegendObrigatorio',
                    );

                    log(
                        `üîç Encontrados ${elementosLegMinutas.length} elementos legMinutas`,
                    );

                    if (elementosLegMinutas.length === 0) {
                        log("‚ùå Nenhum elemento legMinutas encontrado");
                        return { sucesso: false, processados: 0 };
                    }

                    // Mapa de cores completo
                    const cores = {
                        "rgb(152, 245, 255)":
                            "linear-gradient(#AFCFFA, #8DC0F7)", // AZUL #98F5FF
                        "rgb(255, 160, 122)":
                            "linear-gradient(#FFB8AF, #FF9C8D)", // LARANJA INTENSO #FFA07A
                        "rgb(255, 211, 155)":
                            "linear-gradient(#FAD3AF, #F7C68D)", // LARANJA CLARO #FFD39B
                        "rgb(255, 193, 37)":
                            "linear-gradient(#FFDE8F, #FFB84D)", // DOURADO #FFC125
                        "rgb(205, 181, 205)":
                            "linear-gradient(#D8C7D8, #C4A5C4)", // LIL√ÅS #CDB5CD
                        "rgb(211, 211, 211)":
                            "linear-gradient(#B5C9CF, #9CB0B7)", // CINZA #D3D3D3
                        "rgb(238, 99, 99)": "linear-gradient(#FAAFAF, #F78D8D)", // VERMELHA #EE6363
                        "rgb(255, 255, 0)": "linear-gradient(#FFFF8F, #F0F04D)", // VERDE LIM√ÉO #FFFF00
                        "rgb(255, 187, 255)":
                            "linear-gradient(#FFC9FF, #FF9CFF)", // ROSA CLARO #FFBBFF
                        "rgb(255, 246, 143)":
                            "linear-gradient(#F9EFAF, #F7E98D)", // AMARELA #FFF68F
                        "rgb(144, 238, 144)":
                            "linear-gradient(#AFFAB6, #8DF792)", // VERDE #90EE90
                    };

                    let processados = 0;

                    // Processar CADA elemento legMinutas
                    elementosLegMinutas.forEach((legMinutas, index) => {
                        const corAtual =
                            window.getComputedStyle(legMinutas).backgroundColor;

                        // Aplicar gradiente se encontrar cor correspondente
                        if (cores[corAtual]) {
                            legMinutas.style.setProperty(
                                "background",
                                cores[corAtual],
                                "important",
                            );
                            log(
                                `‚úÖ SUCESSO: legMinutas ${
                                    index + 1
                                } - Gradiente aplicado para ${corAtual}!`,
                            );
                            processados++;
                        } else {
                            log(
                                `‚ö†Ô∏è legMinutas ${
                                    index + 1
                                } - Cor n√£o mapeada: ${corAtual}`,
                            );
                        }
                    });

                    log(
                        `üéâ CONCLU√çDO: ${processados}/${elementosLegMinutas.length} elementos processados`,
                    );

                    // Configurar observer automaticamente na primeira execu√ß√£o
                    if (
                        processados > 0 &&
                        typeof setupObservadorLegendMinutas === "function"
                    ) {
                        setupObservadorLegendMinutas();
                    }

                    return {
                        sucesso: processados > 0,
                        processados: processados,
                    };
                } catch (error) {
                    logError("‚ùå ERRO:", error);
                    return {
                        sucesso: false,
                        processados: 0,
                        erro: error.message,
                    };
                }
            }

            /**
             * üîÑ OBSERVER PARA REAPLICAR GRADIENTES AUTOMATICAMENTE
             * Monitora mudan√ßas no DOM das minutas e reaplica gradientes
             */
            function setupObservadorLegendMinutas() {
                log(
                    "üîç OBSERVER ANTI-FLASH: Configurando observer otimizado para legendas...",
                );

                const containerMinutas =
                    document.querySelector("#conteudoMinutas");

                if (!containerMinutas) {
                    log(
                        "‚ö†Ô∏è OBSERVER: Container #conteudoMinutas n√£o encontrado",
                    );
                    return false;
                }

                // Fun√ß√£o de reaplica√ß√£o otimizada com anti-flash
                function reaplicarGradientesAntiFlash() {
                    const elementos = document.querySelectorAll(
                        'legend[aria-label="Hist√≥rico"]#legMinutas.infraLegendObrigatorio',
                    );

                    if (elementos.length === 0) return;

                    const cores = {
                        "rgb(152, 245, 255)":
                            "linear-gradient(#AFCFFA, #8DC0F7)",
                        "rgb(255, 160, 122)":
                            "linear-gradient(#FFB8AF, #FF9C8D)",
                        "rgb(255, 211, 155)":
                            "linear-gradient(#FAD3AF, #F7C68D)",
                        "rgb(255, 193, 37)":
                            "linear-gradient(#FFDE8F, #FFB84D)",
                        "rgb(205, 181, 205)":
                            "linear-gradient(#D8C7D8, #C4A5C4)",
                        "rgb(211, 211, 211)":
                            "linear-gradient(#B5C9CF, #9CB0B7)",
                        "rgb(238, 99, 99)": "linear-gradient(#FAAFAF, #F78D8D)",
                        "rgb(255, 255, 0)": "linear-gradient(#FFFF8F, #F0F04D)",
                        "rgb(255, 187, 255)":
                            "linear-gradient(#FFC9FF, #FF9CFF)",
                        "rgb(255, 246, 143)":
                            "linear-gradient(#F9EFAF, #F7E98D)",
                        "rgb(144, 238, 144)":
                            "linear-gradient(#AFFAB6, #8DF792)",
                    };

                    let reaplicados = 0;
                    elementos.forEach((el, i) => {
                        const bgColor =
                            window.getComputedStyle(el).backgroundColor;

                        // Aplicar gradiente se cor s√≥lida detectada ou for√ßar padr√£o
                        if (bgColor !== "rgba(0, 0, 0, 0)") {
                            const gradiente =
                                cores[bgColor] ||
                                "linear-gradient(#FFDE8F, #FFB84D)"; // Padr√£o dourado
                            el.style.setProperty(
                                "background",
                                gradiente,
                                "important",
                            );
                            reaplicados++;
                        }
                    });

                    if (reaplicados > 0) {
                        log(
                            `üé® OBSERVER: ${reaplicados} gradientes reaplicados (anti-flash)`,
                        );
                    }
                }

                // M√∫ltiplas tentativas com delays otimizados para anti-flash
                function reaplicarComBackoff() {
                    reaplicarGradientesAntiFlash(); // Imediato
                    setTimeout(reaplicarGradientesAntiFlash, 25);
                    setTimeout(reaplicarGradientesAntiFlash, 75);
                    setTimeout(reaplicarGradientesAntiFlash, 150);
                }

                // Observer otimizado com debounce m√≠nimo
                const observer = new MutationObserver(
                    window.debounce(() => {
                        log(
                            "üîÑ OBSERVER: Mudan√ßa detectada, reaplicando gradientes (anti-flash)...",
                        );
                        reaplicarComBackoff();
                    }, 10),
                ); // Debounce m√≠nimo

                // Observer agressivo
                observer.observe(containerMinutas, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ["style", "class"],
                    characterData: true,
                });

                // Click listener preventivo
                document.addEventListener("click", (e) => {
                    if (
                        e.target.closest(
                            'input[type="image"][title*="Atualizar"]',
                        ) ||
                        e.target.closest(
                            'input[type="button"][value*="Expandir"]',
                        ) ||
                        e.target.closest('input[title*="Expandir"]') ||
                        e.target.closest('input[onclick*="atualizaMinutas"]')
                    ) {
                        log(
                            "üñ±Ô∏è CLICK: Bot√£o detectado, aplica√ß√£o preventiva...",
                        );
                        reaplicarGradientesAntiFlash(); // Preventivo
                        setTimeout(reaplicarGradientesAntiFlash, 10);
                        setTimeout(reaplicarGradientesAntiFlash, 50);
                        setTimeout(reaplicarGradientesAntiFlash, 100);
                        setTimeout(reaplicarGradientesAntiFlash, 200);
                    }
                });

                // CSS preventivo para transi√ß√£o suave
                const stylePreventivo = document.createElement("style");
                stylePreventivo.id = "eprobe-anti-flash-gradientes";
                stylePreventivo.textContent = `
                    legend[aria-label="Hist√≥rico"]#legMinutas.infraLegendObrigatorio {
                        transition: background 0.1s ease-out !important;
                    }
                `;
                document.head.appendChild(stylePreventivo);

                log("‚úÖ OBSERVER ANTI-FLASH: Configurado com sucesso!");
                return true;
            }

            /**
             * üîÑ FUN√á√ÉO DE APLICA√á√ÉO ROBUSTA DE GRADIENTES MINUTAS - Com retry autom√°tico
             */
            function aplicarGradientesLegMinutasRobusta() {
                log(
                    "üîÑ GRADIENTES MINUTAS ROBUSTA: Iniciando aplica√ß√£o robusta de gradientes nas minutas...",
                );

                // Verificar se estamos na p√°gina correta primeiro
                if (!isCapaProcessoPage()) {
                    log(
                        "‚ÑπÔ∏è GRADIENTES MINUTAS ROBUSTA: N√£o √© uma p√°gina de capa de processo",
                    );
                    return false;
                }

                let tentativas = 0;
                const maxTentativas = 3;
                const intervalTentativas = 800; // 800ms entre tentativas

                const tentarAplicarGradientes = () => {
                    tentativas++;
                    log(
                        `üéØ GRADIENTES MINUTAS: Tentativa ${tentativas}/${maxTentativas}`,
                    );

                    const resultado = aplicarGradientesLegMinutas();
                    const sucesso = resultado && resultado.sucesso;

                    if (sucesso) {
                        log(
                            `‚úÖ GRADIENTES MINUTAS ROBUSTA: Aplica√ß√£o bem-sucedida na tentativa ${tentativas}!`,
                        );
                        log(
                            `üìä GRADIENTES MINUTAS: ${resultado.processados} elementos processados`,
                        );
                        return true;
                    } else {
                        log(
                            `‚ùå GRADIENTES MINUTAS: Tentativa ${tentativas} falhou`,
                        );
                        if (resultado?.motivo) {
                            log(`   Motivo: ${resultado.motivo}`);
                        }

                        if (tentativas < maxTentativas) {
                            log(
                                `üîÑ GRADIENTES MINUTAS: Reagendando tentativa em ${intervalTentativas}ms...`,
                            );
                            setTimeout(
                                tentarAplicarGradientes,
                                intervalTentativas,
                            );
                        } else {
                            log(
                                "‚ùå GRADIENTES MINUTAS ROBUSTA: Todas as tentativas falharam - desistindo",
                            );
                            return false;
                        }
                    }
                };

                // Executar primeira tentativa imediatamente
                return tentarAplicarGradientes();
            }

            /**
             * üîÑ FUN√á√ÉO DE APLICA√á√ÉO ROBUSTA DE GRADIENTES - Com detec√ß√£o inteligente e retry autom√°tico
             */
            function aplicarGradientesCapaProcessoRobusta() {
                log(
                    "üîÑ GRADIENTES ROBUSTA: Iniciando aplica√ß√£o robusta de gradientes...",
                );

                // Verificar se estamos na p√°gina correta primeiro
                if (!isCapaProcessoPage()) {
                    log(
                        "‚ÑπÔ∏è GRADIENTES ROBUSTA: N√£o √© uma p√°gina de capa de processo",
                    );
                    return false;
                }

                let tentativas = 0;
                const maxTentativas = 5;
                const intervalTentativas = 1000; // 1 segundo entre tentativas

                const tentarAplicarGradientes = () => {
                    tentativas++;
                    log(
                        `üéØ GRADIENTES: Tentativa ${tentativas}/${maxTentativas}`,
                    );

                    const resultado = aplicarGradientesCapaProcesso();
                    const sucesso = resultado && resultado.sucesso;

                    if (!sucesso && tentativas < maxTentativas) {
                        log(
                            `‚è≥ GRADIENTES: Aguardando ${intervalTentativas}ms para nova tentativa...`,
                        );
                        setTimeout(tentarAplicarGradientes, intervalTentativas);
                    } else if (sucesso) {
                        log(
                            "‚úÖ GRADIENTES ROBUSTA: Gradientes aplicados com sucesso!",
                        );
                        log(
                            `üìä RESULTADOS: Cor original: ${resultado.corOriginal}, Gradiente: ${resultado.gradienteAplicado}`,
                        );
                    } else {
                        log(
                            "‚ö†Ô∏è GRADIENTES ROBUSTA: N√£o foi poss√≠vel aplicar gradientes ap√≥s todas as tentativas",
                        );
                    }
                };

                // Iniciar primeira tentativa
                tentarAplicarGradientes();

                // Tamb√©m agendar uma verifica√ß√£o ap√≥s carregamento completo
                if (document.readyState !== "complete") {
                    window.addEventListener("load", () => {
                        setTimeout(() => {
                            log(
                                "üîÑ GRADIENTES: Verifica√ß√£o p√≥s-carregamento...",
                            );
                            aplicarGradientesCapaProcesso();
                        }, 500);
                    });
                }

                return true;
            }

            /**
             * FUNCAO PARA PADRONIZAR CORES DE BACKGROUND NA CAPA DO PROCESSO
             * Substitui cores solidas do eProc por gradientes suaves em TODOS os elementos
             * Documentacao: development/Anotacoes/cores detalhes capa do processo.md
             */
            function aplicarGradientesDetalhesCapa() {
                log("GRADIENTES DETALHES: Iniciando padronizacao de cores...");

                if (!isCapaProcessoPage()) {
                    return false;
                }

                // Cores RGB normalizadas (como getComputedStyle retorna)
                var mapeamentoRGB = {
                    "35,110,142": "linear-gradient(#5A8DB5, #4A7DA5)", // AZUL
                    "142,53,35": "linear-gradient(#D6807A, #C26B58)", // VERMELHO
                    "89,89,89": "linear-gradient(#8A9EA5, #778C93)", // CINZA
                    "105,142,35": "linear-gradient(#8CBF5A, #7AAF4A)", // VERDE
                };

                function extrairRGB(cor) {
                    if (!cor) return null;
                    var m = cor.match(
                        /rgb[a]?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/,
                    );
                    if (m) return m[1] + "," + m[2] + "," + m[3];
                    return null;
                }

                function buscarGradiente(corComputed) {
                    var rgb = extrairRGB(corComputed);
                    if (!rgb) return null;
                    return mapeamentoRGB[rgb] || null;
                }

                var processados = 0;

                try {
                    // Estrategia: varrer elementos especificos na pagina inteira
                    // usando seletores direcionados para performance
                    var todosElementos = document.querySelectorAll(
                        "#fldCapa *, #divInfraAreaProcesso *, label.infraEventoDescricao, span.infraEventoDescricao, a.infraNomeParte, #tblEventos *, #divInfraAreaTeor *",
                    );

                    log(
                        "GRADIENTES DETALHES: " +
                            todosElementos.length +
                            " elementos para verificar",
                    );

                    for (var i = 0; i < todosElementos.length; i++) {
                        var el = todosElementos[i];

                        // Pular se ja tem gradiente aplicado
                        var bgAtual = el.style.background || "";
                        if (bgAtual.indexOf("gradient") !== -1) continue;

                        // Verificar computed style
                        var computed = window.getComputedStyle(el);
                        var corBg = computed.backgroundColor;

                        var gradiente = buscarGradiente(corBg);
                        if (gradiente) {
                            el.style.setProperty(
                                "background",
                                gradiente,
                                "important",
                            );
                            processados++;
                            log(
                                "GRADIENTES DETALHES: " +
                                    el.tagName +
                                    (el.className
                                        ? "." + el.className.split(" ")[0]
                                        : "") +
                                    " " +
                                    corBg +
                                    " -> gradiente",
                            );
                        }
                    }

                    log(
                        "GRADIENTES DETALHES: " +
                            processados +
                            " elementos padronizados",
                    );
                    return {
                        sucesso: processados > 0,
                        processados: processados,
                    };
                } catch (error) {
                    console.error("GRADIENTES DETALHES: Erro:", error);
                    return {
                        sucesso: false,
                        motivo: error.message,
                        processados: processados,
                    };
                }
            }

            function aplicarGradientesDetalhesCapaRobusta() {
                if (!isCapaProcessoPage()) {
                    return false;
                }

                var tentativas = 0;
                var maxTentativas = 4;
                var intervalo = 800;

                var tentarAplicar = function () {
                    tentativas++;
                    log(
                        "GRADIENTES DETALHES: Tentativa " +
                            tentativas +
                            "/" +
                            maxTentativas,
                    );

                    var resultado = aplicarGradientesDetalhesCapa();
                    var sucesso = resultado && resultado.sucesso;

                    if (sucesso) {
                        log(
                            "GRADIENTES DETALHES ROBUSTA: " +
                                resultado.processados +
                                " elementos padronizados",
                        );
                    } else if (tentativas < maxTentativas) {
                        setTimeout(tentarAplicar, intervalo);
                    } else {
                        log(
                            "GRADIENTES DETALHES ROBUSTA: Nenhum elemento encontrado apos todas tentativas",
                        );
                    }
                };

                tentarAplicar();
                return true;
            }

            // üìè FUN√á√ÉO AUXILIAR: Aplicar dimensionamento espec√≠fico para √≠cones em divListaRecursosMinuta
            function aplicarDimensionamentoRecursosMinuta(svg) {
                try {
                    // Verificar se o SVG est√° dentro de divListaRecursosMinuta
                    const divListaRecursos = svg.closest(
                        "#divListaRecursosMinuta",
                    );

                    if (divListaRecursos) {
                        // Aplicar tamanho espec√≠fico de 17.59x17.59
                        svg.setAttribute("width", "17.59px");
                        svg.setAttribute("height", "17.59px");

                        // Aplicar via style tamb√©m para garantir
                        svg.style.width = "17.59px";
                        svg.style.height = "17.59px";

                        // CORRE√á√ÉO DE ALINHAMENTO: Aplicar propriedades de alinhamento vertical
                        svg.style.verticalAlign = "middle";
                        svg.style.display = "inline-block";
                        svg.style.margin = "0";
                        svg.style.padding = "0";
                        svg.style.lineHeight = "1";

                        // Verificar e corrigir o container pai tamb√©m
                        const container = svg.parentElement;
                        if (container && container.tagName === "SPAN") {
                            container.style.display = "inline-flex";
                            container.style.alignItems = "center";
                            container.style.justifyContent = "center";
                            container.style.verticalAlign = "middle";
                            container.style.lineHeight = "1";
                            container.style.width = "17.59px";
                            container.style.height = "17.59px";
                            container.style.margin = "0";
                            container.style.padding = "0";
                        }

                        // Marcar como redimensionado
                        svg.setAttribute(
                            "data-eprobe-recursos-minuta-sized",
                            "true",
                        );

                        log(
                            `üìè RECURSOS: √çcone redimensionado e alinhado para 17.59x17.59 em divListaRecursosMinuta`,
                        );
                        return true;
                    }
                } catch (error) {
                    console.warn(
                        "‚ö†Ô∏è RECURSOS: Erro ao aplicar dimensionamento:",
                        error,
                    );
                }
                return false;
            }

            // üîß FUN√á√ÉO ESPEC√çFICA: Corrigir alinhamento de todos os √≠cones em divListaRecursosMinuta
            function corrigirAlinhamentoRecursosMinuta() {
                try {
                    const divListaRecursos = document.getElementById(
                        "divListaRecursosMinuta",
                    );

                    if (!divListaRecursos) {
                        log(
                            "‚ö†Ô∏è RECURSOS: divListaRecursosMinuta n√£o encontrado",
                        );
                        return {
                            encontrado: false,
                            icones: 0,
                            iconesCorrigidos: 0,
                        };
                    }

                    log("üîß RECURSOS: Iniciando corre√ß√£o de alinhamento...");

                    // Corrigir todos os √≠cones SVG personalizados
                    const iconesSvg = divListaRecursos.querySelectorAll(
                        'svg[data-eprobe-icon-replaced="true"]',
                    );
                    let iconesCorrigidos = 0;

                    iconesSvg.forEach((svg, index) => {
                        if (aplicarDimensionamentoRecursosMinuta(svg)) {
                            iconesCorrigidos++;
                        }
                    });

                    // Corrigir todos os links e containers tamb√©m
                    const links = divListaRecursos.querySelectorAll("a");
                    links.forEach((link) => {
                        link.style.display = "inline-flex";
                        link.style.alignItems = "center";
                        link.style.verticalAlign = "middle";
                        link.style.lineHeight = "1";
                    });

                    // Aplicar CSS global para normalizar todos os elementos da div
                    const style = document.createElement("style");
                    style.id = "eprobe-recursos-minuta-fix";

                    // Remover estilo anterior se existir
                    const oldStyle = document.getElementById(
                        "eprobe-recursos-minuta-fix",
                    );
                    if (oldStyle) oldStyle.remove();

                    style.textContent = `
                        /* CORRE√á√ÉO CR√çTICA DE ALINHAMENTO PARA divListaRecursosMinuta */
                        #divListaRecursosMinuta {
                            line-height: 1 !important;
                        }
                        
                        #divListaRecursosMinuta * {
                            vertical-align: middle !important;
                            line-height: 1 !important;
                        }
                        
                        #divListaRecursosMinuta a {
                            display: inline-flex !important;
                            align-items: center !important;
                            vertical-align: middle !important;
                            line-height: 1 !important;
                        }
                        
                        #divListaRecursosMinuta img,
                        #divListaRecursosMinuta svg {
                            vertical-align: middle !important;
                            display: inline-block !important;
                            line-height: 1 !important;
                        }
                    `;

                    document.head.appendChild(style);

                    const resultado = {
                        encontrado: true,
                        icones: iconesSvg.length,
                        iconesCorrigidos,
                        linksCorrigidos: links.length,
                        cssAplicado: true,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };

                    log(
                        "‚úÖ RECURSOS: Corre√ß√£o de alinhamento conclu√≠da:",
                        resultado,
                    );

                    return resultado;
                } catch (error) {
                    console.error(
                        "‚ùå RECURSOS: Erro na corre√ß√£o de alinhamento:",
                        error,
                    );
                    return {
                        encontrado: false,
                        erro: error.message,
                    };
                }
            }

            // üëÅÔ∏è OBSERVADOR ESPEC√çFICO: Monitorar mudan√ßas em divListaRecursosMinuta
            function setupObservadorRecursosMinuta() {
                try {
                    const divListaRecursos = document.getElementById(
                        "divListaRecursosMinuta",
                    );

                    if (!divListaRecursos) {
                        log(
                            "üìè RECURSOS: divListaRecursosMinuta n√£o encontrado - observer n√£o configurado",
                        );
                        return false;
                    }

                    log(
                        "üëÅÔ∏è RECURSOS: Configurando observador para divListaRecursosMinuta",
                    );

                    const observer = new MutationObserver((mutations) => {
                        let needsProcessing = false;

                        mutations.forEach((mutation) => {
                            // Verificar se novos √≠cones SVG foram adicionados
                            if (mutation.type === "childList") {
                                mutation.addedNodes.forEach((node) => {
                                    if (node.nodeType === Node.ELEMENT_NODE) {
                                        // Verificar se √© um SVG ou cont√©m SVGs
                                        const svgs =
                                            node.tagName === "SVG"
                                                ? [node]
                                                : (node.querySelectorAll &&
                                                      node.querySelectorAll(
                                                          'svg[data-eprobe-icon-replaced="true"]',
                                                      )) ||
                                                  [];

                                        if (svgs.length > 0) {
                                            needsProcessing = true;
                                        }
                                    }
                                });
                            }

                            // Verificar se atributos de SVGs existentes mudaram
                            if (
                                mutation.type === "attributes" &&
                                mutation.target.tagName === "SVG" &&
                                mutation.target.hasAttribute(
                                    "data-eprobe-icon-replaced",
                                ) &&
                                (mutation.attributeName === "width" ||
                                    mutation.attributeName === "height" ||
                                    mutation.attributeName === "style")
                            ) {
                                needsProcessing = true;
                            }
                        });

                        if (needsProcessing) {
                            // Debounce para evitar m√∫ltiplas execu√ß√µes
                            clearTimeout(observer.debounceTimer);
                            observer.debounceTimer = setTimeout(() => {
                                log(
                                    "üîß RECURSOS: Aplicando dimensionamento ap√≥s mudan√ßa no DOM",
                                );

                                // Processar todos os √≠cones SVG na div
                                const iconesSvg =
                                    divListaRecursos.querySelectorAll(
                                        'svg[data-eprobe-icon-replaced="true"]',
                                    );
                                let processados = 0;

                                iconesSvg.forEach((svg) => {
                                    if (
                                        aplicarDimensionamentoRecursosMinuta(
                                            svg,
                                        )
                                    ) {
                                        processados++;
                                    }
                                });

                                if (processados > 0) {
                                    log(
                                        `üìè RECURSOS: ${processados} √≠cones redimensionados automaticamente`,
                                    );
                                }
                            }, 100);
                        }
                    });

                    // Observar mudan√ßas na div espec√≠fica
                    observer.observe(divListaRecursos, {
                        childList: true,
                        subtree: true,
                        attributes: true,
                        attributeFilter: [
                            "width",
                            "height",
                            "style",
                            "data-eprobe-icon-replaced",
                        ],
                    });

                    log(
                        "‚úÖ RECURSOS: Observador configurado com sucesso para divListaRecursosMinuta",
                    );
                    return observer;
                } catch (error) {
                    console.error(
                        "‚ùå RECURSOS: Erro ao configurar observador:",
                        error,
                    );
                    return false;
                }
            }

            // üîÑ OBSERVADOR ESPEC√çFICO: Monitorar atualiza√ß√µes de icones na se√ß√£o legMinutas
            function setupObservadorLegendMinutasIcones() {
                try {
                    // Observar #conteudoMinutas (abrange TUDO: legends, tabelas, botoes AJAX)
                    // Antes observava apenas legMinutas, que nao capturava mudancas no corpo das minutas
                    var containerMinutas =
                        document.getElementById("conteudoMinutas");
                    // Fallback para legMinutas se conteudoMinutas nao existir
                    if (!containerMinutas) {
                        containerMinutas =
                            document.getElementById("legMinutas");
                    }

                    if (!containerMinutas) {
                        log(
                            "MINUTAS: conteudoMinutas/legMinutas nao encontrado - observer nao configurado",
                        );
                        return false;
                    }

                    log(
                        "MINUTAS: Configurando observador para " +
                            containerMinutas.id +
                            " (icones)",
                    );

                    const observer = new MutationObserver((mutations) => {
                        let needsReprocessing = false;

                        for (var mi = 0; mi < mutations.length; mi++) {
                            var mutation = mutations[mi];
                            if (mutation.type === "childList") {
                                // Verificar se novos nodes <img> foram adicionados (eProc AJAX reinsere imgs)
                                for (
                                    var ni = 0;
                                    ni < mutation.addedNodes.length;
                                    ni++
                                ) {
                                    var node = mutation.addedNodes[ni];
                                    if (node.nodeType === 1) {
                                        if (
                                            node.tagName === "IMG" ||
                                            (node.querySelectorAll &&
                                                node.querySelectorAll("img")
                                                    .length > 0)
                                        ) {
                                            needsReprocessing = true;
                                            break;
                                        }
                                    }
                                }
                                if (needsReprocessing) break;
                            }
                        }

                        if (needsReprocessing) {
                            clearTimeout(observer.debounceTimer);
                            observer.debounceTimer = setTimeout(() => {
                                log(
                                    "MINUTAS: Reaplicando icones apos atualizacao AJAX...",
                                );

                                try {
                                    var totalReaplicados =
                                        substituirTodosIcones(
                                            containerMinutas,
                                            {
                                                force: true,
                                            },
                                        );

                                    if (totalReaplicados > 0) {
                                        log(
                                            "MINUTAS: " +
                                                totalReaplicados +
                                                " icones reaplicados apos atualizacao",
                                        );
                                    }
                                } catch (error) {
                                    console.error(
                                        "MINUTAS: Erro na reaplicacao de icones:",
                                        error,
                                    );
                                }
                            }, 400);
                        }
                    });

                    observer.observe(containerMinutas, {
                        childList: true,
                        subtree: true,
                        characterData: false,
                        attributes: false,
                    });

                    log(
                        "MINUTAS: Observador configurado com sucesso para " +
                            containerMinutas.id,
                    );
                    return observer;
                } catch (error) {
                    console.error(
                        "‚ùå MINUTAS: Erro ao configurar observador:",
                        error,
                    );
                    return false;
                }
            }

            //   ANTI-FLASH CR√çTICO: Ocultar √≠cones originais IMEDIATAMENTE e mostrar apenas personalizados
            function aplicarAntiFlashIcones() {
                try {
                    // Aplicar anti-flash total (√≠cones + navbar + bot√µes)
                    if (window.eprobeAntiFlash) {
                        window.eprobeAntiFlash.aplicarAntiFlashTotal();
                        log(
                            "‚ö° ANTI-FLASH TOTAL: Sistema ativo para todos os elementos",
                        );
                        return true;
                    } else {
                        log("‚ö†Ô∏è ANTI-FLASH: Sistema n√£o inicializado");
                        return false;
                    }
                } catch (error) {
                    console.error("‚ùå ANTI-FLASH: Erro:", error);
                    return false;
                }
            }

            //  Reaplicar icones: forca a reaplicacao apos atualizacao AJAX
            function reaplicarIconesAposAtualizacao(containerElement) {
                if (!containerElement) {
                    return 0;
                }
                // Delega para funcao unificada com force mode
                return substituirTodosIcones(containerElement, { force: true });
            }

            // üîÑ INTERCEPTOR M√öLTIPLO: Interceptar TODOS os bot√µes "Atualizar Minutas" (individuais por minuta)
            function setupInterceptorTodosBotoesAtualizar() {
                try {
                    // Buscar todos os botoes de atualizar minutas (principal + individuais)
                    var botoesAtualizar = document.querySelectorAll(
                        'a[aria-label="Atualizar Minutas"]',
                    );

                    if (botoesAtualizar.length === 0) {
                        return 0;
                    }

                    var interceptadosCount = 0;

                    botoesAtualizar.forEach(function (botao, index) {
                        // Verificar se ja foi interceptado
                        if (botao.hasAttribute("data-eprobe-intercepted")) {
                            return;
                        }

                        // NAO substituir onclick (main.js roda em ISOLATED, nao tem acesso a atualizaMinutas)
                        // O onclick original do eProc permanece intacto no mundo MAIN
                        // Usamos um listener adicional para agendar reaplicacao apos o AJAX
                        botao.addEventListener("click", function () {
                            log(
                                "MINUTAS: Botao Atualizar clicado - agendando reaplicacao...",
                            );

                            // Agendar multiplas tentativas de reaplicacao apos AJAX
                            var tentativas = [800, 1500, 3000];
                            tentativas.forEach(function (delay) {
                                setTimeout(function () {
                                    try {
                                        var legMinutas =
                                            document.getElementById(
                                                "legMinutas",
                                            );
                                        if (legMinutas) {
                                            var resultado =
                                                substituirTodosIcones(
                                                    legMinutas,
                                                    { force: true },
                                                );
                                            if (resultado > 0) {
                                                log(
                                                    "MINUTAS: " +
                                                        resultado +
                                                        " icones reaplicados (delay=" +
                                                        delay +
                                                        "ms)",
                                                );
                                            }
                                        }
                                    } catch (err) {
                                        console.warn(
                                            "MINUTAS: Erro na reaplicacao:",
                                            err,
                                        );
                                    }
                                }, delay);
                            });
                        }); // fim addEventListener

                        // Marcar como interceptado
                        botao.setAttribute("data-eprobe-intercepted", "true");
                        botao.setAttribute(
                            "data-eprobe-interceptor-index",
                            String(index),
                        );

                        interceptadosCount++;
                    });

                    return interceptadosCount;
                } catch (error) {
                    console.error(
                        "‚ùå MINUTAS M√öLTIPLAS: Erro ao configurar interceptors:",
                        error,
                    );
                    return 0;
                }
            }

            // Interceptor para botao principal atualizaMinutas
            // NAO substituir onclick (main.js roda em ISOLATED, nao tem acesso a atualizaMinutas)
            // Usa addEventListener para agendar reaplicacao apos AJAX concluir
            function setupInterceptorAtualizarMinutas() {
                try {
                    var botaoAtualizar =
                        document.getElementById("atualizaMinutas");
                    if (!botaoAtualizar) {
                        return false;
                    }
                    if (
                        botaoAtualizar.hasAttribute("data-eprobe-intercepted")
                    ) {
                        return true;
                    }

                    botaoAtualizar.addEventListener("click", function () {
                        log(
                            "MINUTAS: Botao Atualizar principal clicado - agendando reaplicacao...",
                        );
                        var tentativas = [800, 1500, 3000];
                        tentativas.forEach(function (delay) {
                            setTimeout(function () {
                                try {
                                    var legMinutas =
                                        document.getElementById("legMinutas");
                                    if (legMinutas) {
                                        var resultado = substituirTodosIcones(
                                            legMinutas,
                                            { force: true },
                                        );
                                        if (resultado > 0) {
                                            log(
                                                "MINUTAS: " +
                                                    resultado +
                                                    " icones reaplicados (delay=" +
                                                    delay +
                                                    "ms)",
                                            );
                                        }
                                    }
                                } catch (err) {
                                    console.warn(
                                        "MINUTAS: Erro na reaplicacao:",
                                        err,
                                    );
                                }
                            }, delay);
                        });
                    });

                    botaoAtualizar.setAttribute(
                        "data-eprobe-intercepted",
                        "true",
                    );
                    return true;
                } catch (error) {
                    console.error(
                        "MINUTAS: Erro ao configurar interceptor:",
                        error,
                    );
                    return false;
                }
            }

            // =====================================================================
            // FUNCAO UNIFICADA DE SUBSTITUICAO DE ICONES
            // Substitui todas as imagens GIF/PNG do eProc por SVGs modernos.
            // Usa EPROBE_ICON_MAP (por src/alt/id) + EPROBE_ICON_TEXT_MAP (por texto do link)
            // + substituicao de Material Icons em lembretes.
            // =====================================================================
            function substituirTodosIcones(containerEl, options) {
                var forceMode = options && options.force;

                // Restricao: So personalizar icones na pagina de capa do processo
                if (!isCapaProcessoPage()) {
                    return false;
                }

                // Excecao: Nao substituir em paginas de cadastro de minutas
                if (window.location.href.includes("minuta_cadastrar")) {
                    return false;
                }

                var container = containerEl || document;
                var substituicoes = 0;

                // Se force mode, limpar marcacoes para re-aplicar
                if (forceMode) {
                    // Remover spans SVG anteriores (imgs ocultos serao re-exibidos pelo eProc via AJAX)
                    var spansAntigos = container.querySelectorAll(
                        'span[data-eprobe-icon-container="true"]',
                    );
                    for (var s = 0; s < spansAntigos.length; s++) {
                        var spanAntigo = spansAntigos[s];
                        if (spanAntigo.parentNode) {
                            spanAntigo.parentNode.removeChild(spanAntigo);
                        }
                    }
                    // Re-exibir imgs que estavam ocultas
                    var imgsOcultas = container.querySelectorAll(
                        'img[data-eprobe-icon-replaced="true"]',
                    );
                    for (var h = 0; h < imgsOcultas.length; h++) {
                        imgsOcultas[h].style.cssText = "";
                        imgsOcultas[h].removeAttribute(
                            "data-eprobe-icon-replaced",
                        );
                    }
                    // Limpar marcacoes SVG restantes
                    var marcados = container.querySelectorAll(
                        'svg[data-eprobe-icon-replaced="true"]',
                    );
                    for (var m = 0; m < marcados.length; m++) {
                        marcados[m].removeAttribute(
                            "data-eprobe-icon-replaced",
                        );
                    }
                }

                // 1. Substituir imagens por EPROBE_ICON_MAP (src/alt/id selectors)
                for (var i = 0; i < EPROBE_ICON_MAP.length; i++) {
                    var entry = EPROBE_ICON_MAP[i];
                    var imgs = container.querySelectorAll(entry.selector);
                    for (var j = 0; j < imgs.length; j++) {
                        var img = imgs[j];
                        // Skip se ja substituido (a menos que force mode, ja limpou marcas)
                        if (img.hasAttribute("data-eprobe-icon-replaced"))
                            continue;
                        // Skip estrelas (protegidas de substituicao)
                        if (
                            img.src &&
                            (img.src.indexOf("EstrelaAcesa") !== -1 ||
                                img.src.indexOf("EstrelaApagada") !== -1)
                        )
                            continue;
                        // Skip se nao tem parent
                        if (!img.parentNode) continue;

                        try {
                            var span = document.createElement("span");
                            span.setAttribute(
                                "data-eprobe-icon-container",
                                "true",
                            );
                            span.style.display = "inline-flex";
                            span.style.alignItems = "center";
                            span.style.margin = "0";
                            span.style.verticalAlign = "middle";
                            span.style.justifyContent = "center";
                            span.style.lineHeight = "1";
                            span.style.pointerEvents = "auto";

                            span.innerHTML = entry.svg;
                            var svg = span.firstElementChild;
                            if (svg) {
                                svg.style.pointerEvents = "none";
                                svg.style.flexShrink = "0";
                                svg.style.verticalAlign = "middle";
                                svg.style.display = "inline-block";
                                svg.style.margin = "0";
                                svg.style.padding = "0";
                                svg.style.lineHeight = "1";
                                svg.setAttribute(
                                    "data-eprobe-icon-replaced",
                                    "true",
                                );
                                svg.classList.add(
                                    "infraImg",
                                    "substituted-icon",
                                );

                                // Dimensionamento especial para divListaRecursosMinuta
                                if (
                                    typeof aplicarDimensionamentoRecursosMinuta ===
                                    "function"
                                ) {
                                    aplicarDimensionamentoRecursosMinuta(svg);
                                }
                            }

                            // Transferir title do img original para o span
                            var imgTitle = img.getAttribute("title");
                            if (imgTitle) {
                                span.setAttribute("title", imgTitle);
                            }

                            // Transferir id do img para o span
                            // (infraAbrirFecharElementoHTML busca por id como imgMinutas_*)
                            var imgId = img.getAttribute("id");
                            if (imgId) {
                                span.setAttribute("id", imgId);
                                // Copiar src original para que eProc possa ler/alterar
                                var imgSrc = img.getAttribute("src");
                                if (imgSrc) {
                                    span.setAttribute("src", imgSrc);
                                }

                                // Observer para reagir a mudancas de titulo pelo eProc.
                                // infraAbrirFecharElementoHTML alterna entre "Expandir" e "Ocultar"
                                // e muda .src (que em <span> nao reflete no atributo, entao
                                // nao podemos observar src). Mas .title reflete no atributo
                                // em todos os HTMLElement, entao observer funciona.
                                var titleObserver = new MutationObserver(
                                    function (mutations) {
                                        for (
                                            var mo = 0;
                                            mo < mutations.length;
                                            mo++
                                        ) {
                                            if (
                                                mutations[mo].attributeName ===
                                                "title"
                                            ) {
                                                var targetSpan =
                                                    mutations[mo].target;
                                                var newTitle =
                                                    targetSpan.getAttribute(
                                                        "title",
                                                    ) || "";
                                                var newSvgStr = null;
                                                // "Expandir" -> precisa do icone ver_tudo (lista)
                                                // "Ocultar"  -> precisa do icone ver_resumo (X)
                                                for (
                                                    var mi = 0;
                                                    mi < EPROBE_ICON_MAP.length;
                                                    mi++
                                                ) {
                                                    var sel =
                                                        EPROBE_ICON_MAP[mi]
                                                            .selector;
                                                    if (
                                                        newTitle ===
                                                            "Expandir" &&
                                                        sel.indexOf(
                                                            "ver_tudo",
                                                        ) !== -1
                                                    ) {
                                                        newSvgStr =
                                                            EPROBE_ICON_MAP[mi]
                                                                .svg;
                                                        break;
                                                    }
                                                    if (
                                                        newTitle ===
                                                            "Ocultar" &&
                                                        sel.indexOf(
                                                            "ver_resumo",
                                                        ) !== -1
                                                    ) {
                                                        newSvgStr =
                                                            EPROBE_ICON_MAP[mi]
                                                                .svg;
                                                        break;
                                                    }
                                                }
                                                if (newSvgStr) {
                                                    targetSpan.innerHTML =
                                                        newSvgStr;
                                                    var newSvg =
                                                        targetSpan.firstElementChild;
                                                    if (newSvg) {
                                                        newSvg.style.pointerEvents =
                                                            "none";
                                                        newSvg.setAttribute(
                                                            "data-eprobe-icon-replaced",
                                                            "true",
                                                        );
                                                        newSvg.classList.add(
                                                            "infraImg",
                                                            "substituted-icon",
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                    },
                                );
                                titleObserver.observe(span, {
                                    attributes: true,
                                    attributeFilter: ["title"],
                                });
                            }

                            // Determinar se o img usa listeners programaticos AJAX do eProc
                            // (name="imgRecursoMinutaAjax" indica listeners registrados via JS
                            //  no mundo MAIN que usam atributos customizados como urlajax, acao, etc.
                            //  Esses listeners se perdem se o img for removido do DOM.)
                            // Para name="imgRecursoMinuta", a acao esta no <a> pai (href) ou
                            // no onclick do img - ambos transferiveis, nao precisa manter img.
                            var imgName = img.getAttribute("name") || "";
                            var isAjaxManaged =
                                imgName === "imgRecursoMinutaAjax";

                            if (isAjaxManaged && img.parentNode) {
                                // ESTRATEGIA AJAX: Esconder img e inserir SVG ao lado.
                                // O img oculto mantem event listeners do eProc (mundo MAIN).
                                // Click no span dispara click no img oculto.
                                img.style.cssText =
                                    "width:0 !important;height:0 !important;overflow:hidden !important;position:absolute !important;opacity:0 !important;pointer-events:none !important;";
                                img.setAttribute(
                                    "data-eprobe-icon-replaced",
                                    "true",
                                );
                                img.parentNode.insertBefore(span, img);
                                span.style.cursor = "pointer";
                                span.style.pointerEvents = "auto";
                                (function (originalImg) {
                                    span.addEventListener(
                                        "click",
                                        function (ev) {
                                            ev.stopPropagation();
                                            ev.preventDefault();
                                            originalImg.click();
                                        },
                                    );
                                })(img);
                                substituicoes++;
                            } else {
                                // Transferir onclick: usar CustomEvent bridge (ISOLATED -> MAIN)
                                var imgOnclick = img.getAttribute("onclick");
                                if (imgOnclick) {
                                    span.style.cursor = "pointer";
                                    (function (onclickCode) {
                                        span.addEventListener(
                                            "click",
                                            function (ev) {
                                                ev.stopPropagation();
                                                document.dispatchEvent(
                                                    new CustomEvent(
                                                        "eprobe-executar-onclick",
                                                        {
                                                            detail: {
                                                                onclick:
                                                                    onclickCode,
                                                            },
                                                        },
                                                    ),
                                                );
                                            },
                                        );
                                    })(imgOnclick);
                                }

                                if (
                                    img.parentNode &&
                                    img.parentNode.contains(img)
                                ) {
                                    img.parentNode.replaceChild(span, img);
                                    substituicoes++;
                                }
                            }
                        } catch (err) {
                            console.warn(
                                "ICONES: Erro ao substituir " +
                                    entry.name +
                                    ":",
                                err,
                            );
                        }
                    }
                }

                // 2. Substituir icones por texto do link (EPROBE_ICON_TEXT_MAP)
                var fieldset = document.querySelector(
                    "#fldAcoes.infraFieldset",
                );
                if (fieldset) {
                    var textKeys = Object.keys(EPROBE_ICON_TEXT_MAP);
                    for (var t = 0; t < textKeys.length; t++) {
                        var text = textKeys[t];
                        var svgStr = EPROBE_ICON_TEXT_MAP[text];
                        var links =
                            fieldset.querySelectorAll("a.infraButton, a");
                        for (var l = 0; l < links.length; l++) {
                            var link = links[l];
                            if (link.classList.contains("icon-processed"))
                                continue;
                            var linkText = link.textContent.trim();
                            if (linkText.indexOf(text) !== -1) {
                                var linkImg = link.querySelector("img");
                                if (
                                    linkImg &&
                                    !linkImg.hasAttribute(
                                        "data-eprobe-icon-replaced",
                                    )
                                ) {
                                    try {
                                        var tSpan =
                                            document.createElement("span");
                                        tSpan.setAttribute(
                                            "data-eprobe-icon-container",
                                            "true",
                                        );
                                        tSpan.style.display = "inline-flex";
                                        tSpan.style.alignItems = "center";
                                        tSpan.style.marginRight = "4px";
                                        tSpan.style.verticalAlign = "middle";
                                        tSpan.innerHTML = svgStr;
                                        var tSvg = tSpan.firstElementChild;
                                        if (tSvg) {
                                            tSvg.setAttribute(
                                                "data-eprobe-icon-replaced",
                                                "true",
                                            );
                                            tSvg.classList.add(
                                                "substituted-icon",
                                            );
                                            tSvg.style.pointerEvents = "none";
                                            tSvg.style.width = "18px";
                                            tSvg.style.height = "18px";
                                        }
                                        if (linkImg.parentNode) {
                                            linkImg.parentNode.replaceChild(
                                                tSpan,
                                                linkImg,
                                            );
                                            link.classList.add(
                                                "icon-processed",
                                            );
                                            substituicoes++;
                                        }
                                    } catch (err) {
                                        console.warn(
                                            "ICONES: Erro ao substituir icone por texto:",
                                            err,
                                        );
                                    }
                                } else if (
                                    !linkImg &&
                                    !link.classList.contains("icon-processed")
                                ) {
                                    // Link sem imagem - adicionar icone antes do texto
                                    try {
                                        var tSpan2 =
                                            document.createElement("span");
                                        tSpan2.setAttribute(
                                            "data-eprobe-icon-container",
                                            "true",
                                        );
                                        tSpan2.style.display = "inline-flex";
                                        tSpan2.style.alignItems = "center";
                                        tSpan2.style.marginRight = "4px";
                                        tSpan2.style.verticalAlign = "middle";
                                        tSpan2.innerHTML = svgStr;
                                        var tSvg2 = tSpan2.firstElementChild;
                                        if (tSvg2) {
                                            tSvg2.setAttribute(
                                                "data-eprobe-icon-replaced",
                                                "true",
                                            );
                                            tSvg2.classList.add(
                                                "substituted-icon",
                                            );
                                            tSvg2.style.pointerEvents = "none";
                                            tSvg2.style.width = "18px";
                                            tSvg2.style.height = "18px";
                                        }
                                        link.insertBefore(
                                            tSpan2,
                                            link.firstChild,
                                        );
                                        link.style.display = "inline-flex";
                                        link.style.alignItems = "center";
                                        link.classList.add("icon-processed");
                                        substituicoes++;
                                    } catch (err) {
                                        console.warn(
                                            "ICONES: Erro ao inserir icone no link:",
                                            err,
                                        );
                                    }
                                }
                            }
                        }
                    }
                }

                // 3. Substituir Material Icons de lembretes (edit -> ink_pen, delete -> delete)
                try {
                    var lembreteIcons = container.querySelectorAll(
                        'span.material-icons:not([data-eprobe-icon-replaced="true"]), span.material-symbols-outlined:not([data-eprobe-icon-replaced="true"])',
                    );
                    for (var li = 0; li < lembreteIcons.length; li++) {
                        var iconEl = lembreteIcons[li];
                        var textoIcone = iconEl.textContent.trim();
                        var parentLink = iconEl.closest("a");
                        if (!parentLink) continue;

                        var ariaLabel =
                            parentLink.getAttribute("aria-label") || "";
                        var linkHref = parentLink.href || "";

                        if (textoIcone === "edit") {
                            var isEditLembrete =
                                ariaLabel.indexOf("Alterar Lembrete") !== -1 ||
                                linkHref.indexOf(
                                    "processo_lembrete_destino_alterar",
                                ) !== -1;
                            if (isEditLembrete) {
                                try {
                                    var eSpan = document.createElement("span");
                                    eSpan.setAttribute(
                                        "data-eprobe-icon-container",
                                        "true",
                                    );
                                    eSpan.style.display = "inline-flex";
                                    eSpan.style.alignItems = "center";
                                    eSpan.innerHTML = LEMBRETE_EDIT_SVG;
                                    var eSvg = eSpan.firstElementChild;
                                    if (eSvg) {
                                        eSvg.setAttribute(
                                            "data-eprobe-icon-replaced",
                                            "true",
                                        );
                                        eSvg.classList.add("substituted-icon");
                                    }
                                    if (iconEl.parentNode) {
                                        iconEl.parentNode.replaceChild(
                                            eSpan,
                                            iconEl,
                                        );
                                        substituicoes++;
                                    }
                                } catch (err) {
                                    console.warn(
                                        "ICONES: Erro ao substituir edit de lembrete:",
                                        err,
                                    );
                                }
                            }
                        }

                        if (textoIcone === "delete") {
                            var isDeleteLembrete =
                                ariaLabel.indexOf("Desativar Lembrete") !==
                                    -1 ||
                                (parentLink.onclick
                                    ? parentLink.onclick
                                          .toString()
                                          .indexOf("desativarLembrete") !== -1
                                    : false);
                            if (isDeleteLembrete) {
                                try {
                                    var dSpan = document.createElement("span");
                                    dSpan.setAttribute(
                                        "data-eprobe-icon-container",
                                        "true",
                                    );
                                    dSpan.style.display = "inline-flex";
                                    dSpan.style.alignItems = "center";
                                    dSpan.innerHTML = LEMBRETE_DELETE_SVG;
                                    var dSvg = dSpan.firstElementChild;
                                    if (dSvg) {
                                        dSvg.setAttribute(
                                            "data-eprobe-icon-replaced",
                                            "true",
                                        );
                                        dSvg.classList.add("substituted-icon");
                                    }
                                    if (iconEl.parentNode) {
                                        iconEl.parentNode.replaceChild(
                                            dSpan,
                                            iconEl,
                                        );
                                        substituicoes++;
                                    }
                                } catch (err) {
                                    console.warn(
                                        "ICONES: Erro ao substituir delete de lembrete:",
                                        err,
                                    );
                                }
                            }
                        }
                    }
                } catch (err) {
                    console.warn(
                        "ICONES: Erro no processamento de Material Icons:",
                        err,
                    );
                }

                // 4. Corrigir alinhamento em divListaRecursosMinuta se houve substituicoes
                if (
                    substituicoes > 0 &&
                    typeof corrigirAlinhamentoRecursosMinuta === "function"
                ) {
                    try {
                        corrigirAlinhamentoRecursosMinuta();
                    } catch (err) {
                        console.warn(
                            "ICONES: Erro ao corrigir alinhamento:",
                            err,
                        );
                    }
                }

                if (substituicoes > 0) {
                    log(
                        "ICONES: " +
                            substituicoes +
                            " icones substituidos com sucesso",
                    );
                    // Corrigir pointer-events: links/botoes clicaveis, filhos transparentes
                    if (typeof corrigirPointerEventsBotoes === "function") {
                        corrigirPointerEventsBotoes();
                    }
                }
                return substituicoes;
            }

            // Funcao de debug unificada para inspecao de icones
            function debugIcones() {
                log("DEBUG ICONES: Analisando estado dos icones na pagina...");

                var resultado = {
                    totalImgsOriginais: 0,
                    totalSvgsSubstituidos: 0,
                    iconesPorCategoria: {},
                    naoSubstituidos: [],
                };

                // Contar SVGs substituidos
                var svgsSubstituidos = document.querySelectorAll(
                    '[data-eprobe-icon-replaced="true"]',
                );
                resultado.totalSvgsSubstituidos = svgsSubstituidos.length;

                // Contar imagens originais restantes (que poderiam ser substituidas)
                var imgsRestantes = document.querySelectorAll(
                    "img.infraImg, img[src*='.gif'], img[src*='.png']",
                );
                for (var i = 0; i < imgsRestantes.length; i++) {
                    var img = imgsRestantes[i];
                    var src = img.src || "";
                    // Verificar se existe no mapa
                    var temMapeamento = false;
                    for (var j = 0; j < EPROBE_ICON_MAP.length; j++) {
                        var selectorMatch = EPROBE_ICON_MAP[j].selector;
                        // Extrair o valor do src do seletor
                        var srcMatch = selectorMatch.match(/src\*="([^"]+)"/);
                        if (srcMatch && src.indexOf(srcMatch[1]) !== -1) {
                            temMapeamento = true;
                            resultado.naoSubstituidos.push({
                                src: src,
                                alt: img.alt || "",
                                mapeamento: EPROBE_ICON_MAP[j].name,
                                elemento: img,
                            });
                            break;
                        }
                    }
                    if (!temMapeamento) {
                        resultado.totalImgsOriginais++;
                    }
                }

                // Categorizar SVGs substituidos
                svgsSubstituidos.forEach(function (svg) {
                    var containerSpan = svg.closest(
                        "[data-eprobe-icon-container]",
                    );
                    var inRecursos = svg.closest("#divListaRecursosMinuta");
                    var inFieldset = svg.closest("#fldAcoes");
                    var categoria = inRecursos
                        ? "recursosMinuta"
                        : inFieldset
                          ? "fieldsetAcoes"
                          : "outro";
                    resultado.iconesPorCategoria[categoria] =
                        (resultado.iconesPorCategoria[categoria] || 0) + 1;
                });

                console.log("ICONES DEBUG:", resultado);
                console.table(
                    resultado.naoSubstituidos.map(function (item) {
                        return {
                            src: item.src.split("/").pop(),
                            alt: item.alt,
                            mapeamento: item.mapeamento,
                        };
                    }),
                );

                return resultado;
            }

            // üöÄ EXECU√á√ÉO AUTOM√ÅTICA - Aguardar navbar estar pronta
            setTimeout(() => {
                inicializarPersonalizacaoPesquisaNavbar();
            }, 1500);

            // üé® EXECU√á√ÉO AUTOM√ÅTICA - Configura√ß√µes de personaliza√ß√£o
            setTimeout(() => {
                log("üé® PERSONALIZA√á√ÉO: Inicializando configura√ß√µes...");
                try {
                    inicializarConfiguracoesPersalizacao();
                    logCritical(
                        "‚úÖ PERSONALIZA√á√ÉO: Configura√ß√µes inicializadas com sucesso",
                    );
                } catch (error) {
                    console.error(
                        "‚ùå PERSONALIZA√á√ÉO: Erro na inicializa√ß√£o:",
                        error,
                    );
                }
            }, 800); // Executar antes das outras inicializa√ß√µes para garantir estado correto

            // üé® EXECU√á√ÉO AUTOM√ÅTICA - Sistema de substitui√ß√£o de √≠cones
            setTimeout(() => {
                log("üé® √çCONES: Iniciando sistema automaticamente...");
                try {
                    // ‚õî VERIFICA√á√ÉO: S√≥ executar em p√°ginas de capa do processo
                    if (isCapaProcessoPage()) {
                        inicializarSubstituicaoIcones();
                        logCritical(
                            "‚úÖ √çCONES: Sistema inicializado com sucesso",
                        );
                    } else {
                        log(
                            "‚õî √çCONES: Inicializa√ß√£o autom√°tica bloqueada - p√°gina atual n√£o √© capa do processo",
                        );
                        log("üìç URL atual:", window.location.href);
                    }
                } catch (error) {
                    console.error("‚ùå √çCONES: Erro na inicializa√ß√£o:", error);
                }
            }, 2000);

            // üîç EXECU√á√ÉO AUTOM√ÅTICA - Inicializar observer de interface
            setTimeout(() => {
                log("üîç OBSERVER: Iniciando observer de interface...");
                try {
                    if (typeof setupInterfaceObserver === "function") {
                        setupInterfaceObserver();
                        log(
                            "‚úÖ OBSERVER: Interface observer inicializado com sucesso",
                        );
                    } else {
                        console.warn(
                            "‚ö†Ô∏è OBSERVER: Fun√ß√£o setupInterfaceObserver n√£o encontrada",
                        );
                    }

                    // üö® NOVO: Listeners adicionais para detectar cria√ß√£o de lembretes
                    log(
                        "üö® LISTENERS: Configurando listeners para cria√ß√£o de lembretes...",
                    );

                    // Listener para submiss√µes de formul√°rio
                    document.addEventListener("submit", function (event) {
                        // Verificar se √© um formul√°rio de lembrete
                        const form = event.target;
                        if (
                            form &&
                            (form.innerHTML.includes("lembrete") ||
                                form.innerHTML.includes("Lembrete"))
                        ) {
                            console.log(
                                "üö® FORM SUBMIT: Poss√≠vel cria√ß√£o de lembrete detectada",
                            );

                            // Verificar por novos bot√µes ap√≥s delay
                            setTimeout(() => {
                                if (
                                    typeof aplicarEstilizacaoImediataLembretes ===
                                    "function"
                                ) {
                                    console.log(
                                        "üö® FORM SUBMIT: Aplicando estiliza√ß√£o ap√≥s submit",
                                    );
                                    aplicarEstilizacaoImediataLembretes();
                                }
                            }, 1000);

                            setTimeout(() => {
                                if (
                                    typeof aplicarEstilizacaoImediataLembretes ===
                                    "function"
                                ) {
                                    console.log(
                                        "üö® FORM SUBMIT: Segunda tentativa ap√≥s submit",
                                    );
                                    aplicarEstilizacaoImediataLembretes();
                                }
                            }, 2000);
                        }
                    });

                    // Listener para clicks em bot√µes que podem criar lembretes
                    document.addEventListener("click", function (event) {
                        const target = event.target;
                        const text = target.textContent || "";

                        if (
                            text.includes("Salvar") ||
                            text.includes("Gravar") ||
                            text.includes("Incluir")
                        ) {
                            console.log(
                                "üö® CLICK: Poss√≠vel a√ß√£o de cria√ß√£o detectada:",
                                text,
                            );

                            // M√∫ltiplas verifica√ß√µes com delays crescentes
                            [1000, 2000, 3000, 5000].forEach((delay) => {
                                setTimeout(() => {
                                    if (
                                        typeof aplicarEstilizacaoImediataLembretes ===
                                        "function"
                                    ) {
                                        console.log(
                                            `üö® CLICK: Verificando bot√µes ap√≥s ${delay}ms`,
                                        );
                                        aplicarEstilizacaoImediataLembretes();
                                    }
                                }, delay);
                            });
                        }
                    });

                    log(
                        "‚úÖ LISTENERS: Listeners de cria√ß√£o de lembretes configurados",
                    );

                    // üö® AUTO-INICIALIZAR: Monitor agressivo de bot√µes "Ler Mais"
                    setTimeout(() => {
                        if (
                            window.SENT1_AUTO &&
                            typeof window.SENT1_AUTO
                                .iniciarMonitorBotoesLerMais === "function"
                        ) {
                            console.log(
                                "üö® AUTO-INIT: Iniciando monitor agressivo automaticamente...",
                            );
                            window.SENT1_AUTO.iniciarMonitorBotoesLerMais();
                        }
                    }, 3000); // Depois que tudo estiver inicializado
                } catch (error) {
                    console.error("‚ùå OBSERVER: Erro na inicializa√ß√£o:", error);
                }
            }, 2100);

            // üìè EXECU√á√ÉO AUTOM√ÅTICA - Inicializar observer espec√≠fico para divListaRecursosMinuta
            setTimeout(() => {
                // ‚õî VERIFICA√á√ÉO: S√≥ executar em p√°ginas de capa do processo
                if (isCapaProcessoPage()) {
                    log(
                        "üìè RECURSOS: Iniciando observer espec√≠fico para divListaRecursosMinuta...",
                    );
                    try {
                        if (
                            typeof setupObservadorRecursosMinuta === "function"
                        ) {
                            const observer = setupObservadorRecursosMinuta();
                            if (observer) {
                                log(
                                    "‚úÖ RECURSOS: Observer espec√≠fico inicializado com sucesso",
                                );
                            } else {
                                log(
                                    "‚ö†Ô∏è RECURSOS: Observer n√£o configurado - divListaRecursosMinuta n√£o encontrado",
                                );
                            }
                        } else {
                            console.warn(
                                "‚ö†Ô∏è RECURSOS: Fun√ß√£o setupObservadorRecursosMinuta n√£o encontrada",
                            );
                        }
                    } catch (error) {
                        console.error(
                            "‚ùå RECURSOS: Erro na inicializa√ß√£o do observer:",
                            error,
                        );
                    }
                } else {
                    log(
                        "‚õî RECURSOS: Observer espec√≠fico bloqueado - p√°gina atual n√£o √© capa do processo",
                    );
                }
            }, 2200);

            // üîß EXECU√á√ÉO AUTOM√ÅTICA - Corrigir alinhamento de √≠cones em divListaRecursosMinuta
            setTimeout(() => {
                // ‚õî VERIFICA√á√ÉO: S√≥ executar em p√°ginas de capa do processo
                if (isCapaProcessoPage()) {
                    log(
                        "üîß RECURSOS: Iniciando corre√ß√£o autom√°tica de alinhamento...",
                    );
                    try {
                        if (
                            typeof corrigirAlinhamentoRecursosMinuta ===
                            "function"
                        ) {
                            const resultado =
                                corrigirAlinhamentoRecursosMinuta();
                            if (resultado.encontrado) {
                                log(
                                    `‚úÖ RECURSOS: Alinhamento corrigido - ${resultado.iconesCorrigidos} √≠cones processados`,
                                );
                            } else {
                                log(
                                    "‚ö†Ô∏è RECURSOS: divListaRecursosMinuta n√£o encontrado para corre√ß√£o",
                                );
                            }
                        } else {
                            console.warn(
                                "‚ö†Ô∏è RECURSOS: Fun√ß√£o corrigirAlinhamentoRecursosMinuta n√£o encontrada",
                            );
                        }
                    } catch (error) {
                        console.error(
                            "‚ùå RECURSOS: Erro na corre√ß√£o de alinhamento:",
                            error,
                        );
                    }
                } else {
                    log(
                        "‚õî RECURSOS: Corre√ß√£o de alinhamento bloqueada - p√°gina atual n√£o √© capa do processo",
                    );
                }
            }, 2300);

            // üîÑ EXECU√á√ÉO AUTOM√ÅTICA - Inicializar observer para legMinutas (Hist√≥rico)
            setTimeout(() => {
                // ‚õî VERIFICA√á√ÉO: S√≥ executar em p√°ginas de capa do processo
                if (isCapaProcessoPage()) {
                    log(
                        "üîÑ MINUTAS: Iniciando observer para legMinutas (detectar atualiza√ß√µes)...",
                    );
                    try {
                        if (
                            typeof setupObservadorLegendMinutasIcones ===
                            "function"
                        ) {
                            const observer =
                                setupObservadorLegendMinutasIcones();
                            if (observer) {
                                log(
                                    "‚úÖ MINUTAS: Observer icones legMinutas inicializado",
                                );
                            } else {
                                log(
                                    "‚ö†Ô∏è MINUTAS: Observer n√£o configurado - legMinutas n√£o encontrado",
                                );
                            }
                        } else {
                            console.warn(
                                "‚ö†Ô∏è MINUTAS: Fun√ß√£o setupObservadorLegendMinutasIcones n√£o encontrada",
                            );
                        }
                    } catch (error) {
                        console.error(
                            "‚ùå MINUTAS: Erro na inicializa√ß√£o do observer:",
                            error,
                        );
                    }
                } else {
                    log(
                        "‚õî MINUTAS: Observer legMinutas bloqueado - p√°gina atual n√£o √© capa do processo",
                    );
                }
            }, 2400);

            // üéØ EXECU√á√ÉO AUTOM√ÅTICA - Inicializar interceptor para bot√£o "Atualizar Minutas"
            setTimeout(() => {
                // ‚õî VERIFICA√á√ÉO: S√≥ executar em p√°ginas de capa do processo
                if (isCapaProcessoPage()) {
                    log(
                        "üéØ MINUTAS: Iniciando interceptor para bot√£o 'Atualizar Minutas'...",
                    );
                    try {
                        if (
                            typeof setupInterceptorAtualizarMinutas ===
                            "function"
                        ) {
                            const interceptorAtivo =
                                setupInterceptorAtualizarMinutas();
                            if (interceptorAtivo) {
                                log(
                                    "‚úÖ MINUTAS: Interceptor configurado com sucesso para bot√£o 'Atualizar Minutas' principal",
                                );
                            } else {
                                log(
                                    "‚ö†Ô∏è MINUTAS: Interceptor n√£o configurado - bot√£o 'atualizaMinutas' principal n√£o encontrado",
                                );
                            }
                        } else {
                            console.warn(
                                "‚ö†Ô∏è MINUTAS: Fun√ß√£o setupInterceptorAtualizarMinutas n√£o est√° dispon√≠vel",
                            );
                        }

                        // üîÑ NOVO: Configurar interceptor para TODOS os bot√µes de minutas individuais
                        if (
                            typeof setupInterceptorTodosBotoesAtualizar ===
                            "function"
                        ) {
                            const botoesInterceptados =
                                setupInterceptorTodosBotoesAtualizar();
                            if (botoesInterceptados > 0) {
                                log(
                                    `‚úÖ MINUTAS M√öLTIPLAS: ${botoesInterceptados} bot√µes individuais interceptados com sucesso`,
                                );
                            } else {
                                log(
                                    "‚ö†Ô∏è MINUTAS M√öLTIPLAS: Nenhum bot√£o individual encontrado ou interceptado",
                                );
                            }
                        } else {
                            console.warn(
                                "‚ö†Ô∏è MINUTAS: Fun√ß√£o setupInterceptorTodosBotoesAtualizar n√£o est√° dispon√≠vel",
                            );
                        }
                    } catch (error) {
                        console.error(
                            "‚ùå MINUTAS: Erro na configura√ß√£o do interceptor:",
                            error,
                        );
                    }
                } else {
                    log(
                        "‚õî MINUTAS: Interceptor bloqueado - p√°gina atual n√£o √© capa do processo",
                    );
                }
            }, 2500);

            // üîß EXECU√á√ÉO AUTOM√ÅTICA - Corrigir pointer-events de bot√µes cr√≠ticos
            setTimeout(() => {
                log(
                    "üîß CORRE√á√ÉO: Aplicando corre√ß√£o autom√°tica de pointer-events...",
                );
                try {
                    if (typeof corrigirPointerEventsBotoes === "function") {
                        const resultado = corrigirPointerEventsBotoes();
                        log(
                            "‚úÖ CORRE√á√ÉO: Pointer-events corrigidos automaticamente:",
                            resultado,
                        );
                    } else {
                        console.warn(
                            "‚ö†Ô∏è CORRE√á√ÉO: Fun√ß√£o corrigirPointerEventsBotoes n√£o encontrada",
                        );
                    }
                } catch (error) {
                    console.error(
                        "‚ùå CORRE√á√ÉO: Erro na corre√ß√£o autom√°tica:",
                        error,
                    );
                }
            }, 750);

            // üîß EXECU√á√ÉO AUTOM√ÅTICA - Corrigir fun√ß√£o switchRelevanciaDocumento (VERS√ÉO ROBUSTA)
            setTimeout(() => {
                log(
                    "  CORRE√á√ÉO ROBUSTA: Aplicando corre√ß√£o autom√°tica da fun√ß√£o switchRelevanciaDocumento (vers√£o robusta)...",
                );
                try {
                    if (
                        typeof corrigirSwitchRelevanciaDocumentoRobusta ===
                        "function"
                    ) {
                        // DESABILITADO: const resultado = corrigirSwitchRelevanciaDocumentoRobusta();
                        log(
                            "‚ö†Ô∏è CORRE√á√ÉO DESABILITADA: switchRelevanciaDocumento N√ÉO corrigida para preservar funcionalidade",
                        );
                    } else if (
                        typeof corrigirSwitchRelevanciaDocumento === "function"
                    ) {
                        const resultado = corrigirSwitchRelevanciaDocumento();
                        log(
                            "‚úÖ CORRE√á√ÉO: switchRelevanciaDocumento corrigida automaticamente (vers√£o padr√£o):",
                            resultado,
                        );
                    } else {
                        console.warn(
                            "‚ö†Ô∏è CORRE√á√ÉO: Nenhuma fun√ß√£o de corre√ß√£o de switchRelevanciaDocumento encontrada",
                        );
                    }
                } catch (error) {
                    console.error(
                        "‚ùå CORRE√á√ÉO: Erro na corre√ß√£o da fun√ß√£o switchRelevanciaDocumento:",
                        error,
                    );
                }
            }, 1000);

            // üîß EXECU√á√ÉO ROBUSTA - Segunda tentativa para corre√ß√£o de inconsist√™ncias
            setTimeout(() => {
                log("üîß ROBUSTA: Verifica√ß√£o e corre√ß√£o de inconsist√™ncias...");

                // Verificar se modo ultra-performance est√° bloqueando
                if (MODO_ULTRA_PERFORMANCE) {
                    log(
                        "‚ö†Ô∏è ROBUSTA: Modo ultra-performance ativo - fun√ß√µes podem estar bloqueadas",
                    );
                } else {
                    // Verificar se √≠cones foram substitu√≠dos
                    const fieldsetAcoes = document.querySelector(
                        "#fldAcoes.infraFieldset",
                    );
                    if (fieldsetAcoes) {
                        const iconesGIF =
                            fieldsetAcoes.querySelectorAll('img[src*=".gif"]');
                        const iconesSVG =
                            fieldsetAcoes.querySelectorAll("svg.lucide");

                        if (iconesGIF.length > 0 && iconesSVG.length === 0) {
                            log(
                                "üîß ROBUSTA: √çcones n√£o foram substitu√≠dos - executando corre√ß√£o...",
                            );
                            try {
                                // ‚õî VERIFICA√á√ÉO: S√≥ executar em p√°ginas de capa do processo
                                if (isCapaProcessoPage()) {
                                    substituirTodosIcones();
                                } else {
                                    log(
                                        "‚õî ROBUSTA: Corre√ß√£o de √≠cones bloqueada - p√°gina n√£o √© capa do processo",
                                    );
                                }
                                log("‚úÖ ROBUSTA: Corre√ß√£o de √≠cones executada");
                            } catch (error) {
                                console.error(
                                    "‚ùå ROBUSTA: Erro na corre√ß√£o:",
                                    error,
                                );
                            }
                        }
                    }

                    // Verificar bot√£o Resumir Documento
                    const botaoResumir =
                        document.getElementById(
                            "documento-relevante-auto-button",
                        ) ||
                        document.getElementById("sent1-auto-button") ||
                        document.getElementById("eprobe-btn");
                    if (!botaoResumir) {
                        log(
                            "üîß ROBUSTA: Bot√£o n√£o encontrado - tentando cria√ß√£o...",
                        );
                        try {
                            if (typeof ensureButtonExists === "function") {
                                ensureButtonExists();
                                log(
                                    "‚úÖ ROBUSTA: Tentativa de cria√ß√£o de bot√£o executada",
                                );
                            }
                        } catch (error) {
                            console.error(
                                "‚ùå ROBUSTA: Erro na cria√ß√£o do bot√£o:",
                                error,
                            );
                        }
                    }
                }
            }, 5000);

            // =============================================
            // INICIALIZA√á√ÉO DO SISTEMA MATERIAL DESIGN
            // =============================================

            log(
                "üöÄ SISTEMA: Inicializando Material Design para cards de sess√£o",
            );

            // Aguardar carregamento da p√°gina antes de detectar cards
            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", () => {
                    setTimeout(inicializarMaterialDesign, 1000);
                });
            } else {
                setTimeout(inicializarMaterialDesign, 1000);
            }

            log(
                "‚úÖ NAMESPACE: Todos os fallbacks seguros configurados - extens√£o protegida contra ReferenceError",
            );

            log("üîß NAMESPACE: Sistema de fallback universal configurado");

            log(
                "‚úÖ NAMESPACE: Todos os fallbacks seguros configurados - extens√£o protegida contra ReferenceError",
            );

            log("üîß NAMESPACE: Sistema de fallback universal configurado");

            log(
                "‚úÖ FUN√á√ïES DE TESTE: Carregadas fora da IIFE - sempre dispon√≠veis",
            );

            // ============================================================================
            // üîß SISTEMA DE CONFIGURA√á√ÉO E INICIALIZA√á√ÉO
            // ============================================================================

            // ===== INSTRU√á√ïES DE USO - APENAS LAYOUT √öNICO =====
            log("  FUN√á√ïES PRINCIPAIS DISPON√çVEIS (√öNICA ESTRAT√âGIA):");
            log("- window.SENT1_AUTO.testarMaterialBaseLayout()");
            log("- window.SENT1_AUTO.testarXPathMaterialDesign()");
            logCritical(
                "‚úÖ eProbe Extension carregada com sucesso - LAYOUT MATERIAL √öNICO!",
            );

            // ===== CONTROLE GLOBAL DE EXECU√á√ïES - ANTI-LOOP =====
            window.eProbeExecucoes = {
                detectarDataSessao: 0,
                inserirInterface: 0,
                criarCard: 0,
                substituirIcones: 0,
                maxExecucoesPorFuncao: 5,

                // Verificar se fun√ß√£o pode executar
                podeExecutar: function (nomeFuncao) {
                    if (!this[nomeFuncao]) this[nomeFuncao] = 0;

                    if (this[nomeFuncao] >= this.maxExecucoesPorFuncao) {
                        log(
                            `üõë ANTI-LOOP: ${nomeFuncao} atingiu limite de execu√ß√µes (${this.maxExecucoesPorFuncao})`,
                        );
                        return false;
                    }

                    this[nomeFuncao]++;
                    log(
                        `üìä EXECU√á√ÉO: ${nomeFuncao} (#${this[nomeFuncao]}/${this.maxExecucoesPorFuncao})`,
                    );
                    return true;
                },

                // Resetar contadores (a cada 2 minutos)
                reset: function () {
                    log("üîÑ ANTI-LOOP: Resetando contadores de execu√ß√£o");
                    for (const key in this) {
                        if (typeof this[key] === "number") {
                            this[key] = 0;
                        }
                    }
                },
            };

            // Auto-reset a cada 2 minutos
            setInterval(() => {
                window.eProbeExecucoes.reset();
            }, 120000);

            // ============================================================================
            // üéØ CORRIGIR TOOLTIP NO CARD ORIGINAL MATERIAL DESIGN
            // ============================================================================

            // Fun√ß√£o para adicionar tooltip ao card original existente

            // Fun√ß√£o para extrair dados da sess√£o a partir do texto do bot√£o
            function extrairDadosSessao(texto, dadosCamara = null) {
                log("üîç EXTRAIR DADOS: Processando texto:", texto);
                log("üîç EXTRAIR DADOS: Dados da c√¢mara:", dadosCamara);

                // Padr√µes para extrair informa√ß√µes
                const padraoData = /(\d{2}\/\d{2}\/\d{4})/;
                const padraoStatus =
                    /(Inclu√≠do em Pauta|Inclu√≠do em Mesa|Retirado de Pauta|Pedido de Vista|Julgado em Pauta|Adiado|Sobrestado)/i;
                const padraoTipo = /(Apela√ß√£o|Agravo|Embargos|Recurso)[^,]*/i;

                const data = texto.match(padraoData)?.[1];
                const status = texto.match(padraoStatus)?.[1];
                let tipo = texto.match(padraoTipo)?.[1] || "Apela√ß√£o C√≠vel";

                // Tratamento especial para "Embargos" -> "Embargos de Declara√ß√£o"
                if (tipo && tipo.toLowerCase().includes("embargos")) {
                    tipo = "Embargos de Declara√ß√£o";
                }

                // Usar dados da c√¢mara do XPath se dispon√≠vel, sen√£o tentar extrair do texto
                let camara = dadosCamara || "C√¢mara n√£o identificada";
                if (!dadosCamara) {
                    const padraoCamara = /(\d+¬™\s+C√¢mara[^,]*)/i;
                    const camaraTexto = texto.match(padraoCamara)?.[1];
                    if (camaraTexto) {
                        camara = camaraTexto;
                    }
                }

                if (!data || !status) {
                    logError("‚ùå EXTRAIR DADOS: Dados insuficientes no texto");
                    return null;
                }

                // Determinar cor baseada no status
                let cor = "#6B7280"; // Cinza padr√£o
                if (status.toLowerCase().includes("inclu√≠do")) {
                    cor = "#007acc"; // Azul para atual
                } else if (status.toLowerCase().includes("retirado")) {
                    cor = "#CE2D4F"; // Vermelho
                } else if (status.toLowerCase().includes("vista")) {
                    cor = "#FFBF46"; // Amarelo
                } else if (status.toLowerCase().includes("julgado")) {
                    cor = "#10B981"; // Verde
                } else if (status.toLowerCase().includes("adiado")) {
                    cor = "#F59E0B"; // Laranja
                } else if (status.toLowerCase().includes("sobrestado")) {
                    cor = "#8B5CF6"; // Roxo
                }

                const dadosSessao = {
                    data: data,
                    status: status,
                    camara: camara,
                    tipo: tipo,
                    cor: cor,
                    isAtual: status.toLowerCase().includes("inclu√≠do"),
                };

                log("‚úÖ DADOS EXTRA√çDOS:", dadosSessao);
                return dadosSessao;
            }

            // Fun√ß√£o para gerar HTML do card da sess√£o
            function gerarHtmlCardSessao(sessao, isAtual = false) {
                const borderStyle = isAtual
                    ? `border: 2px solid ${sessao.cor}`
                    : `border: 1px solid #E6E0E9`;
                const backgroundColor = isAtual
                    ? `background: ${sessao.cor}`
                    : `background: #FFFBFE`;
                const tagAtual = isAtual
                    ? `<div style="background: ${sessao.cor}; color: #FFFFFF; font-size: 9px; font-weight: 600; padding: 3px 8px; border-radius: 12px; text-transform: uppercase; letter-spacing: 0.5px; position: absolute; top: 8px; right: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.15); z-index: 10;">ATUAL</div>`
                    : "";

                return `
        <div style="min-width: 140px; padding: 12px; ${borderStyle}; border-radius: 8px; ${backgroundColor}; position: relative; transition: all 0.2s ease; cursor: pointer;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                <span style="color: ${sessao.cor}; font-size: 16px;">‚óè</span>
                <div style="font-size: 12px; font-weight: 500; color: #1C1B1F; flex: 1;">${sessao.status}</div>
            </div>
            ${tagAtual}
            <div style="font-size: 13px; font-weight: 600; color: #1C1B1F; line-height: 18px; margin-bottom: 4px;">${sessao.data}</div>
            <div style="font-size: 11px; color: #49454F; line-height: 14px; margin-bottom: 2px;">${sessao.camara}</div>
            <div style="font-size: 11px; color: #79747E; line-height: 12px; font-style: italic;">${sessao.tipo}</div>
        </div> `;
            }

            log(
                "ü§ñ AUTO-EXECU√á√ÉO: Tooltip ser√° corrigido no card original em 2 segundos",
            );

            let nsRunFullAutomation = async function () {
                console.error(
                    "‚ùå NAMESPACE: runFullAutomation n√£o est√° dispon√≠vel",
                );
                return false;
            };

            let nsAutoOpenDocumentoRelevante = async function () {
                console.error(
                    "‚ùå NAMESPACE: autoOpenDocumentoRelevante n√£o est√° dispon√≠vel",
                );
                return false;
            };

            let nsAutoExtractText = async function () {
                console.error(
                    "‚ùå NAMESPACE: autoExtractText n√£o est√° dispon√≠vel",
                );
                return null;
            };

            let nsCopyToClipboard = async function (text) {
                console.error(
                    "‚ùå NAMESPACE: copyToClipboard n√£o est√° dispon√≠vel",
                );
                return false;
            };

            let nsSendToPerplexity = async function (texto) {
                console.error(
                    "‚ùå NAMESPACE: sendToPerplexity n√£o est√° dispon√≠vel",
                );
                return false;
            };

            let nsSendToPerplexityWithPrompt = async function (
                texto,
                promptType,
            ) {
                console.error(
                    "‚ùå NAMESPACE: sendToPerplexityWithPrompt n√£o est√° dispon√≠vel",
                );
                return false;
            };

            // Wrapper que chama a fun√ß√£o real quando for executada
            let nsShowPromptSelectionModal = async function (
                aiName,
                url,
                texto,
            ) {
                return await showPromptSelectionModal(aiName, url, texto);
            };

            let nsShowPerplexityPromptModal = async function (texto) {
                console.error(
                    "‚ùå NAMESPACE: showPerplexityPromptModal n√£o est√° dispon√≠vel",
                );
                return false;
            };

            let nsOpenAIWithCustomPrompt = async function (
                aiName,
                url,
                prompt,
            ) {
                console.error(
                    "‚ùå NAMESPACE: openAIWithCustomPrompt n√£o est√° dispon√≠vel",
                );
                return false;
            };

            let nsDetectPageType = function () {
                console.error(
                    "‚ùå NAMESPACE: detectPageType n√£o est√° dispon√≠vel",
                );
                return "unknown";
            };

            let nsIsValidPageForButton = function () {
                console.warn(
                    "‚ö†Ô∏è NAMESPACE: Usando fallback para isValidPageForButton",
                );

                // Implementar l√≥gica b√°sica de valida√ß√£o
                const url = window.location.href;
                const hasProcessForm =
                    !!document.querySelector("#frmProcessoLista");
                const hasProcessTitle = document
                    .querySelector("h1")
                    ?.textContent.includes(
                        "Consulta Processual - Detalhes do Processo",
                    );

                return (
                    (hasProcessForm && hasProcessTitle) ||
                    (url.includes("eproc") &&
                        (url.includes("documento") || url.includes("processo")))
                );
            };

            let nsFindDocumentosRelevantes = function () {
                console.error(
                    "‚ùå NAMESPACE: findDocumentosRelevantes n√£o est√° dispon√≠vel",
                );
                return [];
            };

            let nsShowDocumentSelectionModal = function (docs) {
                console.error(
                    "‚ùå NAMESPACE: showDocumentSelectionModal n√£o est√° dispon√≠vel",
                );
                return false;
            };

            let nsShowSentenceProcessingOptions = function () {
                console.error(
                    "‚ùå NAMESPACE: showSentenceProcessingOptions n√£o est√° dispon√≠vel",
                );
                return false;
            };

            // Fun√ß√µes de API e armazenamento
            let nsGetStoredApiKey = async function () {
                console.error(
                    "‚ùå NAMESPACE: getStoredApiKey n√£o est√° dispon√≠vel",
                );
                return null;
            };

            let nsExtractTextFromPDF = async function () {
                if (typeof extractTextFromPDF === "function") {
                    return await extractTextFromPDF();
                } else {
                    console.error(
                        "‚ùå NAMESPACE: extractTextFromPDF n√£o est√° dispon√≠vel",
                    );
                    return null;
                }
            };

            // Fun√ß√µes de utilidade
            let nsCleanInvisibleChars = function (text) {
                console.error(
                    "‚ùå NAMESPACE: cleanInvisibleChars n√£o est√° dispon√≠vel",
                );
                return text || "";
            };

            let nsStoreApiKey = async function (apiKey) {
                console.error("‚ùå NAMESPACE: storeApiKey n√£o est√° dispon√≠vel");
                return false;
            };

            // Fun√ß√µes de debug e API
            let nsRemoveStoredApiKey = async function () {
                console.error(
                    "‚ùå NAMESPACE: removeStoredApiKey n√£o est√° dispon√≠vel",
                );
                return false;
            };

            let nsDebugEventStructure = function (linkElement) {
                console.error(
                    "‚ùå NAMESPACE: debugEventStructure n√£o est√° dispon√≠vel",
                );
                return {};
            };

            let nsShouldShowIntegratedButton = function () {
                console.error(
                    "‚ùå NAMESPACE: shouldShowIntegratedButton n√£o est√° dispon√≠vel",
                );
                return false;
            };

            let nsShouldShowFloatingButton = function () {
                console.error(
                    "‚ùå NAMESPACE: shouldShowFloatingButton n√£o est√° dispon√≠vel",
                );
                return false;
            };

            let nsEnsureButtonExists = function () {
                console.error(
                    "‚ùå NAMESPACE: ensureButtonExists n√£o est√° dispon√≠vel",
                );
                return false;
            };

            log("üîß NAMESPACE: Fun√ß√µes principais preparadas para o namespace");

            // ##### SISTEMA DE FALLBACK UNIVERSAL #####
            // Criar vers√µes seguras para TODAS as fun√ß√µes do namespace que podem n√£o estar dispon√≠veis

            const createSafeFallback = (funcName, returnValue = null) => {
                return function (...args) {
                    console.warn(
                        `‚ö†Ô∏è FALLBACK: ${funcName} usando fallback seguro`,
                    );
                    return returnValue;
                };
            };

            const createAsyncSafeFallback = (funcName, returnValue = null) => {
                return async function (...args) {
                    console.warn(
                        `‚ö†Ô∏è FALLBACK: ${funcName} usando fallback seguro (async)`,
                    );
                    return returnValue;
                };
            };

            // Verificar e criar fallbacks seguros para todas as fun√ß√µes cr√≠ticas
            const safeFunctions = {
                testApiKey: createAsyncSafeFallback("testApiKey", false),
                showErrorLogs: createSafeFallback("showErrorLogs", false),
                debugApiCall: createSafeFallback("debugApiCall", {}),
                showApiQuotaInfo: createSafeFallback("showApiQuotaInfo", false),
                getDataSessaoPautado: createSafeFallback(
                    "getDataSessaoPautado",
                    null,
                ),
                hasDataSessaoPautado: createSafeFallback(
                    "hasDataSessaoPautado",
                    false,
                ),
                resetDataSessaoPautado: createSafeFallback(
                    "resetDataSessaoPautado",
                    true,
                ),
                showDataSessaoPautadoInfo: createSafeFallback(
                    "showDataSessaoPautadoInfo",
                    false,
                ),
                validarDataBrasileira: createSafeFallback(
                    "validarDataBrasileira",
                    false,
                ),

                // Fun√ß√µes de interface
                inserirDataSessaoNaInterface: createSafeFallback(
                    "inserirDataSessaoNaInterface",
                    false,
                ),
                removerDataSessaoDaInterface: createSafeFallback(
                    "removerDataSessaoDaInterface",
                    false,
                ),
                atualizarDataSessaoNaInterface: createSafeFallback(
                    "atualizarDataSessaoNaInterface",
                    false,
                ),
                forcarInsercaoCardSemValidacao: createSafeFallback(
                    "forcarInsercaoCardSemValidacao",
                    false,
                ),

                // Fun√ß√µes de dados de sess√£o
                buscarDadosSessoes: createAsyncSafeFallback(
                    "buscarDadosSessoes",
                    [],
                ),
                parsearDadosSessoes: createSafeFallback(
                    "parsearDadosSessoes",
                    [],
                ),
                extrairDadosLinhaSessao: createSafeFallback(
                    "extrairDadosLinhaSessao",
                    null,
                ),
                buscarSessaoPorData: createSafeFallback(
                    "buscarSessaoPorData",
                    null,
                ),
                cruzarDadosDataSessao: createAsyncSafeFallback(
                    "cruzarDadosDataSessao",
                    null,
                ),

                // detectarDataSessaoExperimental: REMOVIDA - substitu√≠da por detectarCardSessaoSimplificado √öNICA
            };

            // Fallbacks seguros para fun√ß√µes de interface e bot√µes
            const interfaceFunctions = {
                criarBotaoEleganteeProc: createSafeFallback(
                    "criarBotaoEleganteeProc",
                    null,
                ),
                botaoBrancoCapaProcesso: createSafeFallback(
                    "botaoBrancoCapaProcesso",
                    null,
                ),
                criarInfraButtonPrimary: createSafeFallback(
                    "criarInfraButtonPrimary",
                    null,
                ),
                botaoAzuleProc: createSafeFallback("botaoAzuleProc", null),
            };

            // Fallbacks seguros para fun√ß√µes de localizadores
            const localizadorFunctions = {
                detectarPaginaLocalizadores: createSafeFallback(
                    "detectarPaginaLocalizadores",
                    false,
                ),
                processarTabelaLocalizadores: createSafeFallback(
                    "processarTabelaLocalizadores",
                    [],
                ),
                destacarLocalizadoresUrgentes: createSafeFallback(
                    "destacarLocalizadoresUrgentes",
                    0,
                ),
            };

            // Fallbacks seguros para fun√ß√µes de status
            const statusFunctions = {
                detectarStatusSessao: createSafeFallback(
                    "detectarStatusSessao",
                    null,
                ),
                // detectarDataSessaoComStatus: REMOVIDA - substitu√≠da por detectarCardSessaoSimplificado √öNICA
                obterTextoCardPorStatus: createSafeFallback(
                    "obterTextoCardPorStatus",
                    "Status n√£o encontrado",
                ),
                obterCorCardPorStatus: createSafeFallback(
                    "obterCorCardPorStatus",
                    "#6B7280",
                ),
                getStatusSessao: createSafeFallback("getStatusSessao", null),
                hasStatusSessao: createSafeFallback("hasStatusSessao", false),
                resetStatusSessao: createSafeFallback(
                    "resetStatusSessao",
                    true,
                ),
                showStatusSessaoInfo: createSafeFallback(
                    "showStatusSessaoInfo",
                    false,
                ),
            };

            // Fallbacks seguros para fun√ß√µes de dados completos de sess√£o
            const sessionDataFunctions = {
                getDadosCompletosSessionJulgamento: createSafeFallback(
                    "getDadosCompletosSessionJulgamento",
                    null,
                ),
                hasDadosCompletosSessionJulgamento: createSafeFallback(
                    "hasDadosCompletosSessionJulgamento",
                    false,
                ),
                resetDadosCompletosSessionJulgamento: createSafeFallback(
                    "resetDadosCompletosSessionJulgamento",
                    true,
                ),
                showDadosCompletosSessionJulgamento: createSafeFallback(
                    "showDadosCompletosSessionJulgamento",
                    false,
                ),
            };

            // Fallbacks seguros para fun√ß√µes de debug e interface
            const debugInterfaceFunctions = {
                debugButtonCreation: createSafeFallback(
                    "debugButtonCreation",
                    true,
                ),
                forceCreateButton: createSafeFallback(
                    "forceCreateButton",
                    false,
                ),
                getCachedBoundingRect: createSafeFallback(
                    "getCachedBoundingRect",
                    {},
                ),
                setupInterfaceObserver: createSafeFallback(
                    "setupInterfaceObserver",
                    true,
                ),

                // Fun√ß√µes de diagn√≥stico e sistema
                diagnosticarCompleto: createSafeFallback(
                    "diagnosticarCompleto",
                    {},
                ),
                corrigirProblemas: createSafeFallback(
                    "corrigirProblemas",
                    true,
                ),
                forcarReaplicacaoIcones: createSafeFallback(
                    "forcarReaplicacaoIcones",
                    0,
                ),
                inicializarSubstituicaoIcones: createSafeFallback(
                    "inicializarSubstituicaoIcones",
                    true,
                ),
                diagnosticarIconesCSS: createSafeFallback(
                    "diagnosticarIconesCSS",
                    {},
                ),
            };

            // ##### FALLBACKS UNIVERSAIS PARA TODAS AS FUN√á√ïES PROBLEM√ÅTICAS #####
            const allMissingFunctions = {
                // Fun√ß√µes de localizadores
                detectarPaginaLocalizadores: createSafeFallback(
                    "detectarPaginaLocalizadores",
                    false,
                ),
                processarTabelaLocalizadores: createSafeFallback(
                    "processarTabelaLocalizadores",
                    [],
                ),
                destacarLocalizadoresUrgentes: createSafeFallback(
                    "destacarLocalizadoresUrgentes",
                    0,
                ),

                // Fun√ß√µes de card e sess√£o (detectarCardSessaoSimplificado movido para linha 19345)
                criarCardSessaoMaterial: createSafeFallback(
                    "criarCardSessaoMaterial",
                    null,
                ),
                obterConfigFigmaStatus: createSafeFallback(
                    "obterConfigFigmaStatus",
                    {},
                ),

                // Fun√ß√µes de tooltip
                adicionarTooltipInterativo: createSafeFallback(
                    "adicionarTooltipInterativo",
                    false,
                ),
                adicionarRichTooltipMaterialDesign: createSafeFallback(
                    "adicionarRichTooltipMaterialDesign",
                    false,
                ),
                criarTooltipSimplificado: createSafeFallback(
                    "criarTooltipSimplificado",
                    false,
                ),
                testarFuncaoTooltip: createSafeFallback(
                    "testarFuncaoTooltip",
                    true,
                ),

                // Fun√ß√µes de estiliza√ß√£o
                debugDivLembrete: createSafeFallback("debugDivLembrete", {}),
                estilizarDivLembrete: createSafeFallback(
                    "estilizarDivLembrete",
                    true,
                ),

                // Fun√ß√µes de debug para status
                debugPadraoRetirado: createSafeFallback(
                    "debugPadraoRetirado",
                    {},
                ),
                debugStatusCompleto: createSafeFallback(
                    "debugStatusCompleto",
                    {},
                ),
                forcarAtualizacaoStatus: createSafeFallback(
                    "forcarAtualizacaoStatus",
                    true,
                ),
                testarCasoRetirado: createSafeFallback(
                    "testarCasoRetirado",
                    {},
                ),
                testarSistemaStatusSessao: createSafeFallback(
                    "testarSistemaStatusSessao",
                    {},
                ),

                // Fun√ß√µes de altern√¢ncia
                findToggleTarget: createSafeFallback("findToggleTarget", null),
                implementarAlternanciaExpandirRetrair: createSafeFallback(
                    "implementarAlternanciaExpandirRetrair",
                    false,
                ),
                isElementSafeForToggle: createSafeFallback(
                    "isElementSafeForToggle",
                    false,
                ),

                // Fun√ß√µes de teste simplificado
                debugPadroesStatusSessao: createSafeFallback(
                    "debugPadroesStatusSessao",
                    {},
                ),
                forcarStatusSessao: createSafeFallback(
                    "forcarStatusSessao",
                    false,
                ),
                encontrarTextoRetirado: createSafeFallback(
                    "encontrarTextoRetirado",
                    null,
                ),
                forcarDeteccaoCompleta: createSafeFallback(
                    "forcarDeteccaoCompleta",
                    {},
                ),

                // Funcoes de icones - aliases para funcao unificada
                substituirIconesFieldsetAcoes: createSafeFallback(
                    "substituirTodosIcones",
                    0,
                ),
                substituirIconesFerramentas: createSafeFallback(
                    "substituirTodosIcones",
                    0,
                ),
                substituirIconesGlobalmente: createSafeFallback(
                    "substituirTodosIcones",
                    0,
                ),
                debugIconesSubstituicao: createSafeFallback("debugIcones", {}),
                testarFuncoesIcones: createSafeFallback(
                    "substituirTodosIcones",
                    true,
                ),
                debugIconesNaPagina: createSafeFallback("debugIcones", {}),
                debugIncluirPautaMesa: createSafeFallback("debugIcones", {}),

                // Fun√ß√µes de card avan√ßadas
                forcarRecriacaoCardSessao: createSafeFallback(
                    "forcarRecriacaoCardSessao",
                    false,
                ),
                encontrarContainerParaCard: createSafeFallback(
                    "encontrarContainerParaCard",
                    null,
                ),

                // Fun√ß√µes de dados globais de sess√£o
                getTipoJulgamentoProcessoPautado: createSafeFallback(
                    "getTipoJulgamentoProcessoPautado",
                    null,
                ),
                setTipoJulgamentoProcessoPautado: createSafeFallback(
                    "setTipoJulgamentoProcessoPautado",
                    true,
                ),
                getStatusJulgamento: createSafeFallback(
                    "getStatusJulgamento",
                    null,
                ),
                setStatusJulgamento: createSafeFallback(
                    "setStatusJulgamento",
                    true,
                ),
                getDataSessao: createSafeFallback("getDataSessao", null),
                setDataSessao: createSafeFallback("setDataSessao", true),
                resetDadosGlobaisSessao: createSafeFallback(
                    "resetDadosGlobaisSessao",
                    true,
                ),
                showDadosGlobaisSessao: createSafeFallback(
                    "showDadosGlobaisSessao",
                    {},
                ),

                // processarTextoFieldsetSessao: REMOVIDA - substitu√≠da por detectarCardSessaoSimplificado √öNICA
            };

            log(
                "‚úÖ NAMESPACE: Todos os fallbacks seguros configurados - extens√£o protegida contra ReferenceError",
            );

            log("üîß NAMESPACE: Sistema de fallback universal configurado");

            // ============================================================
            // üîß IMPLEMENTA√á√ÉO DAS FUN√á√ïES FALTANTES PARA NAMESPACE
            // ============================================================

            /**
             * üîç DIAGN√ìSTICO ESTRUTURA DOM MINUTAS
             * Analisa a estrutura DOM das minutas para debug
             */
            function diagnosticarEstruturaDOMMinutas() {
                try {
                    log(
                        "üîç DIAGN√ìSTICO DOM: Iniciando an√°lise da estrutura das minutas...",
                    );

                    const resultados = {
                        fieldsetPrincipal: null,
                        minutasEncontradas: [],
                        estrutura: {},
                        recomendacoes: [],
                        problemaDetectado: null,
                    };

                    // 1. Buscar o fieldset principal #fldMinutas
                    const fieldsetPrincipal =
                        document.querySelector("#fldMinutas");
                    if (!fieldsetPrincipal) {
                        logCritical(
                            "‚ùå DIAGN√ìSTICO: fieldset#fldMinutas N√ÉO ENCONTRADO!",
                        );
                        resultados.recomendacoes.push(
                            "Verificar se est√° na p√°gina correta de minutas",
                        );
                        return resultados;
                    }

                    resultados.fieldsetPrincipal = {
                        encontrado: true,
                        id: fieldsetPrincipal.id,
                        classes: fieldsetPrincipal.className,
                        filhos: fieldsetPrincipal.children.length,
                    };

                    log("‚úÖ DIAGN√ìSTICO: fieldset#fldMinutas encontrado!");

                    // 2. Verificar hierarquia espec√≠fica do problema
                    const conteudoMinutas =
                        fieldsetPrincipal.querySelector("#conteudoMinutas");
                    if (!conteudoMinutas) {
                        resultados.problemaDetectado =
                            "Elemento #conteudoMinutas n√£o encontrado";
                        logCritical(
                            "‚ùå PROBLEMA: #conteudoMinutas n√£o encontrado!",
                        );
                        return resultados;
                    }

                    const conteudoDinamico = conteudoMinutas.querySelector(
                        'div[id^="conteudoMinutas_"]',
                    );
                    if (!conteudoDinamico) {
                        resultados.problemaDetectado =
                            "Div din√¢mica conteudoMinutas_ n√£o encontrada";
                        logCritical(
                            "‚ùå PROBLEMA: Div din√¢mica conteudoMinutas_ n√£o encontrada!",
                        );
                        return resultados;
                    }

                    log("‚úÖ DIAGN√ìSTICO: Hierarquia DOM at√© div din√¢mica OK");

                    // 3. FOCO NO PROBLEMA: Analisar todos os bot√µes na div din√¢mica
                    const todosBotoes =
                        conteudoDinamico.querySelectorAll("button");
                    log(
                        `üîç DIAGN√ìSTICO: ${todosBotoes.length} bot√µes encontrados na div din√¢mica`,
                    );

                    const analiseBotoes = [];
                    todosBotoes.forEach((botao, index) => {
                        const analise = {
                            indice: index + 1,
                            classes: botao.className,
                            temTexto: !!botao.textContent?.trim(),
                            texto: botao.textContent?.trim().substring(0, 100),
                            innerHTML: botao.innerHTML?.substring(0, 100),
                            matchesSeletor: botao.matches(
                                "button.infraLegendObrigatorio.btn.btn-link.btn-sm.p-0",
                            ),
                            matchesInfraLegend: botao.matches(
                                "button.infraLegendObrigatorio",
                            ),
                            matchesBtnLink: botao.matches("button.btn-link"),
                        };
                        analiseBotoes.push(analise);

                        log(`   Bot√£o ${index + 1}:`, analise);
                    });

                    resultados.analiseBotoes = analiseBotoes;

                    // 4. Tentar seletores alternativos
                    const seletoresAlternativos = [
                        "button.infraLegendObrigatorio",
                        "button[class*='infraLegend']",
                        "button.btn-link",
                        "button",
                        ".infraLegendObrigatorio",
                    ];

                    const testeSeletores = {};
                    seletoresAlternativos.forEach((seletor) => {
                        const elemento =
                            conteudoDinamico.querySelector(seletor);
                        testeSeletores[seletor] = {
                            encontrado: !!elemento,
                            temTexto: elemento
                                ? !!elemento.textContent?.trim()
                                : false,
                            texto: elemento
                                ? elemento.textContent?.trim().substring(0, 50)
                                : null,
                            classes: elemento ? elemento.className : null,
                        };
                    });

                    resultados.testeSeletores = testeSeletores;
                    log(
                        "üîç DIAGN√ìSTICO: Teste de seletores alternativos:",
                        testeSeletores,
                    );

                    // 5. Analisar fieldsets internos (m√©todo original)
                    const minutasFieldsets = fieldsetPrincipal.querySelectorAll(
                        "div > div:nth-child(2) > fieldset",
                    );
                    log(
                        `üîç DIAGN√ìSTICO: ${minutasFieldsets.length} fieldsets de minutas encontrados`,
                    );

                    minutasFieldsets.forEach((fieldset, index) => {
                        const botao = fieldset.querySelector(
                            "legend > span:first-child > button",
                        );
                        const textoMinuta =
                            botao?.textContent?.trim() || "Sem texto";

                        resultados.minutasEncontradas.push({
                            indice: index + 1,
                            temBotao: !!botao,
                            texto: textoMinuta,
                            comprimento: textoMinuta.length,
                        });
                    });

                    log(
                        `üìã MINUTA ${index + 1}: ${textoMinuta.substring(
                            0,
                            100,
                        )}...`,
                    );

                    // 3. Estrutura geral
                    resultados.estrutura = {
                        totalMinutas: minutasFieldsets.length,
                        minutasComTexto: resultados.minutasEncontradas.filter(
                            (m) => m.texto !== "Sem texto",
                        ).length,
                        minutasComBotao: resultados.minutasEncontradas.filter(
                            (m) => m.temBotao,
                        ).length,
                    };

                    // 4. Recomenda√ß√µes
                    if (minutasFieldsets.length === 0) {
                        resultados.recomendacoes.push(
                            "Nenhuma minuta encontrada - verificar seletor CSS",
                        );
                    } else if (resultados.estrutura.minutasComTexto === 0) {
                        resultados.recomendacoes.push(
                            "Minutas encontradas mas sem texto - verificar estrutura interna",
                        );
                    } else {
                        resultados.recomendacoes.push(
                            `Sistema funcionando: ${resultados.estrutura.minutasComTexto} minutas com texto`,
                        );
                    }

                    logCritical(
                        `üéØ DIAGN√ìSTICO COMPLETO: ${JSON.stringify(
                            resultados.estrutura,
                        )}`,
                    );
                    return resultados;
                } catch (error) {
                    console.error(
                        "‚ùå DIAGN√ìSTICO: Erro na an√°lise DOM:",
                        error,
                    );
                    return {
                        erro: error.message,
                        recomendacoes: [
                            "Erro interno - verificar console para detalhes",
                        ],
                    };
                }
            }

            /**
             * üß™ TESTE ROBUSTO DE DETEC√á√ÉO
             * Executa testes completos do sistema de detec√ß√£o
             */
            function testarDeteccaoRobusta() {
                try {
                    log("üß™ TESTE ROBUSTO: Iniciando bateria de testes...");

                    const resultados = {
                        timestamp: new Date().toLocaleString(),
                        processo: obterNumeroProcesso() || "N/A",
                        url: window.location.href,
                        testes: {},
                    };

                    // TESTE 1: Diagn√≥stico DOM
                    log("üîç TESTE 1: Diagn√≥stico da estrutura DOM...");
                    resultados.testes.diagnosticoDOM =
                        diagnosticarEstruturaDOMMinutas();

                    // TESTE 2: Deteccao simplificada
                    log("TESTE 2: Deteccao simplificada de sessao...");
                    const deteccaoSimplificada = detectarSessoesUnificado();
                    resultados.testes.deteccaoSimplificada = {
                        sucesso: !!deteccaoSimplificada,
                        dados: deteccaoSimplificada,
                        sessaoEncontrada: !!dataSessaoPautado,
                    };

                    // TESTE 3: Verifica√ß√£o de cache
                    log("üîç TESTE 3: Verifica√ß√£o de dados em cache...");
                    resultados.testes.cache = {
                        dataSessaoPautado: dataSessaoPautado,
                        processoComDataSessao: processoComDataSessao,
                        dadosCompletosMinutas:
                            window.dadosCompletosMinutas || null,
                    };

                    // TESTE 4: Cria√ß√£o de card
                    log("üîç TESTE 4: Teste de cria√ß√£o de card...");
                    if (deteccaoSimplificada) {
                        try {
                            criarCardSessaoMaterial(deteccaoSimplificada);
                            resultados.testes.criacaoCard = { sucesso: true };
                        } catch (cardError) {
                            resultados.testes.criacaoCard = {
                                sucesso: false,
                                erro: cardError.message,
                            };
                        }
                    } else {
                        resultados.testes.criacaoCard = {
                            sucesso: false,
                            motivo: "Nenhum dado de sess√£o encontrado",
                        };
                    }

                    // RELAT√ìRIO FINAL
                    const totalTestes = Object.keys(resultados.testes).length;
                    const testesPassaram = Object.values(
                        resultados.testes,
                    ).filter(
                        (t) =>
                            t.sucesso === true ||
                            (t.diagnosticoDOM &&
                                t.diagnosticoDOM.fieldsetPrincipal
                                    ?.encontrado) ||
                            (t.cache &&
                                (t.cache.dataSessaoPautado ||
                                    t.cache.dadosCompletosMinutas)),
                    ).length;

                    logCritical(
                        `üéØ TESTE ROBUSTO CONCLU√çDO: ${testesPassaram}/${totalTestes} testes passaram`,
                    );
                    logCritical(
                        `üìä RESULTADOS: ${JSON.stringify(resultados, null, 2)}`,
                    );

                    return resultados;
                } catch (error) {
                    console.error(
                        "‚ùå TESTE ROBUSTO: Erro durante testes:",
                        error,
                    );
                    return {
                        erro: error.message,
                        timestamp: new Date().toLocaleString(),
                    };
                }
            }

            /**
             * EXPORTAR ESTRUTURA DOM PARA DEBUG
             * Captura a estrutura DOM real do eProc com redacao de dados sensiveis.
             * Uso: window.SENT1_AUTO.exportarEstruturaDOM()
             * Retorna JSON estruturado pronto para documentacao.
             */
            function exportarEstruturaDOM() {
                try {
                    var url = window.location.href;
                    var urlObj = new URL(url);
                    var acaoParam =
                        urlObj.searchParams.get("acao") || "desconhecida";
                    var dominio = urlObj.hostname;
                    var grau = dominio.includes("eproc2g")
                        ? "2o Grau"
                        : dominio.includes("eproc1g")
                          ? "1o Grau"
                          : "Desconhecido";

                    // Regex para redacao de dados sensiveis
                    var regexProcessoFormatado =
                        /\d{7}-\d{2}\.\d{4}\.\d{1}\.\d{2}\.\d{4}/g;
                    var regexProcessoNumerico = /\b\d{20}\b/g;
                    var regexHash = /hash=[a-f0-9]{32}/gi;
                    var regexNomeProprio =
                        /[A-Z][a-z]+\s[A-Z][a-z]+(?:\s[A-Z][a-z]+)*/g;

                    function redactar(texto) {
                        if (!texto) return texto;
                        return texto
                            .replace(
                                regexProcessoFormatado,
                                "PROCESSO_REDACTED",
                            )
                            .replace(regexProcessoNumerico, "NUM_REDACTED")
                            .replace(regexHash, "hash=REDACTED")
                            .replace(regexNomeProprio, "NOME_REDACTED");
                    }

                    // Seletores criticos por tipo de pagina
                    var seletoresPorPagina = {
                        processo_selecionar: [
                            "#divInfraAreaProcesso",
                            "#conteudoMinutas",
                            "#fldMinutas",
                            "#tblEventos",
                            "#fldCapa",
                            "#divCapaProcesso",
                            "#divListaRecursosMinuta",
                            ".navbar.bg-instancia",
                            "#conteudoInternoMinutas_0",
                            "#LegNovaMinuta",
                        ],
                        minuta_editar: [
                            "#divInfraAreaProcesso",
                            "#frmEditor",
                            "#divEditor",
                            ".navbar.bg-instancia",
                            "fieldset.infraFieldset",
                            "#txtConteudo",
                            "#divInfraBarraComandosSuperior",
                        ],
                        sessao_julgamento_listar: [
                            "#divInfraAreaProcesso",
                            ".navbar.bg-instancia",
                            "#tblSessoes",
                            "fieldset.infraFieldset",
                            "#divInfraBarraComandosSuperior",
                        ],
                        sessao_julgamento_exibir_painel: [
                            "#divInfraAreaProcesso",
                            ".navbar.bg-instancia",
                            "#divPainel",
                            "fieldset.infraFieldset",
                        ],
                        usuario_tipo_monitoramento_localizador_listar: [
                            "#divInfraAreaProcesso",
                            ".navbar.bg-instancia",
                            "#tblLocalizadores",
                            "fieldset.infraFieldset",
                        ],
                    };

                    // Selecionar seletores para a pagina atual
                    var seletoresBase = [
                        "#divInfraAreaProcesso",
                        "#conteudoMinutas",
                        "#fldMinutas",
                        "#tblEventos",
                        "#fldCapa",
                        ".navbar.bg-instancia",
                    ];
                    var seletores =
                        seletoresPorPagina[acaoParam] || seletoresBase;

                    // Funcao para extrair arvore esqueleto (hierarquia sem conteudo)
                    function extrairArvore(elemento, profundidade, maxProf) {
                        if (!elemento || profundidade > (maxProf || 4))
                            return null;
                        var filhos = [];
                        var childElements = elemento.children;
                        var maxFilhos = Math.min(childElements.length, 25);
                        for (var i = 0; i < maxFilhos; i++) {
                            var filho = childElements[i];
                            var nodo = {
                                tag: filho.tagName.toLowerCase(),
                            };
                            if (filho.id) nodo.id = redactar(filho.id);
                            if (
                                filho.className &&
                                typeof filho.className === "string" &&
                                filho.className.trim()
                            ) {
                                nodo.classes = filho.className
                                    .trim()
                                    .split(/\s+/)
                                    .slice(0, 8);
                            }
                            // Atributos data-*
                            var dataAttrs = {};
                            for (var j = 0; j < filho.attributes.length; j++) {
                                var attr = filho.attributes[j];
                                if (attr.name.startsWith("data-")) {
                                    dataAttrs[attr.name] = redactar(
                                        attr.value.substring(0, 80),
                                    );
                                }
                            }
                            if (Object.keys(dataAttrs).length > 0)
                                nodo.dataAttrs = dataAttrs;
                            // Filhos recursivos
                            if (filho.children.length > 0) {
                                var subArvore = extrairArvore(
                                    filho,
                                    profundidade + 1,
                                    maxProf,
                                );
                                if (subArvore && subArvore.length > 0)
                                    nodo.filhos = subArvore;
                            }
                            filhos.push(nodo);
                        }
                        if (childElements.length > maxFilhos) {
                            filhos.push({
                                tag:
                                    "...mais " +
                                    (childElements.length - maxFilhos) +
                                    " elementos",
                            });
                        }
                        return filhos;
                    }

                    // Coletar dados de cada seletor
                    var elementos = {};
                    seletores.forEach(function (sel) {
                        var el = document.querySelector(sel);
                        if (el) {
                            var info = {
                                encontrado: true,
                                tagName: el.tagName,
                                id: el.id || null,
                                classes:
                                    el.className &&
                                    typeof el.className === "string"
                                        ? el.className.trim().split(/\s+/)
                                        : [],
                                filhosDirectos: el.children.length,
                                filhosIDs: Array.from(el.children)
                                    .slice(0, 30)
                                    .map(function (c) {
                                        return (
                                            (c.id
                                                ? "#" + redactar(c.id)
                                                : c.tagName.toLowerCase()) +
                                            (c.className &&
                                            typeof c.className === "string"
                                                ? "." +
                                                  c.className
                                                      .trim()
                                                      .split(/\s+/)
                                                      .slice(0, 3)
                                                      .join(".")
                                                : "")
                                        );
                                    }),
                                arvore: extrairArvore(el, 0, 3),
                            };
                            // Atributos data-* do elemento raiz
                            var rootDataAttrs = {};
                            for (var j = 0; j < el.attributes.length; j++) {
                                var attr = el.attributes[j];
                                if (attr.name.startsWith("data-")) {
                                    rootDataAttrs[attr.name] = redactar(
                                        attr.value.substring(0, 80),
                                    );
                                }
                            }
                            if (Object.keys(rootDataAttrs).length > 0)
                                info.dataAttrs = rootDataAttrs;
                            // Dimensoes
                            var rect = el.getBoundingClientRect();
                            info.dimensoes = {
                                width: Math.round(rect.width),
                                height: Math.round(rect.height),
                                visivel: rect.width > 0 && rect.height > 0,
                            };
                            // Estilos computados relevantes
                            var computed = window.getComputedStyle(el);
                            info.estilos = {
                                display: computed.display,
                                visibility: computed.visibility,
                                position: computed.position,
                            };
                            elementos[sel] = info;
                        } else {
                            elementos[sel] = { encontrado: false };
                        }
                    });

                    // Detectar elementos eProbe injetados
                    var eprobeInjetados = {
                        iconesSubstituidos: document.querySelectorAll(
                            "[data-eprobe-icon-replaced]",
                        ).length,
                        iconContainers: document.querySelectorAll(
                            "[data-eprobe-icon-container]",
                        ).length,
                        navbarElement: !!document.querySelector(
                            "#eprobe-navbar-element",
                        ),
                        botaoSent1:
                            !!document.querySelector("#sent1-auto-button"),
                        cardsEprobe: document.querySelectorAll(
                            '[class*="eprobe-figma"]',
                        ).length,
                        estilosEprobe: document.querySelectorAll(
                            'style[id*="eprobe"]',
                        ).length,
                    };

                    // Colunas da tabela de eventos (se existir)
                    var colunasEventos = null;
                    var tblEventos = document.querySelector(
                        "#tblEventos thead tr",
                    );
                    if (tblEventos) {
                        colunasEventos = Array.from(tblEventos.children).map(
                            function (th, i) {
                                return {
                                    indice: i + 1,
                                    texto:
                                        redactar(th.textContent.trim()) ||
                                        "(icone)",
                                    width: th.getAttribute("width") || "auto",
                                    classe: th.className || null,
                                };
                            },
                        );
                    }

                    // Linhas de evento (amostra das 3 primeiras)
                    var amostraEventos = null;
                    var linhasEvento = document.querySelectorAll(
                        "#tblEventos tbody tr",
                    );
                    if (linhasEvento.length > 0) {
                        amostraEventos = {
                            totalLinhas: linhasEvento.length,
                            amostra: Array.from(linhasEvento)
                                .slice(0, 3)
                                .map(function (tr) {
                                    return {
                                        id: tr.id || null,
                                        classes: tr.className,
                                        dataParte:
                                            tr.getAttribute("data-parte") ||
                                            null,
                                        celulas: Array.from(tr.children).map(
                                            function (td) {
                                                return {
                                                    classe:
                                                        td.className || null,
                                                    textoReduzido:
                                                        redactar(
                                                            td.textContent
                                                                .trim()
                                                                .substring(
                                                                    0,
                                                                    60,
                                                                ),
                                                        ) || "(vazio)",
                                                };
                                            },
                                        ),
                                    };
                                }),
                        };
                    }

                    var resultado = {
                        metadados: {
                            tipoPagina: acaoParam,
                            tribunal: "TJSC",
                            grau: grau,
                            dominio: dominio,
                            urlRedactada: redactar(url),
                            timestamp: new Date().toISOString(),
                            versaoFuncao: "1.0",
                        },
                        elementos: elementos,
                        eprobeInjetados: eprobeInjetados,
                        colunasEventos: colunasEventos,
                        amostraEventos: amostraEventos,
                    };

                    console.log("=== ESTRUTURA DOM eProbe ===");
                    console.log(JSON.stringify(resultado, null, 2));
                    console.log("=== FIM ===");

                    // Tentar copiar para clipboard via API do DevTools
                    if (typeof copy === "function") {
                        copy(JSON.stringify(resultado, null, 2));
                        console.log(
                            "Resultado copiado para o clipboard automaticamente.",
                        );
                    }

                    return resultado;
                } catch (error) {
                    console.error("exportarEstruturaDOM: Erro:", error);
                    return {
                        erro: error.message,
                        timestamp: new Date().toISOString(),
                    };
                }
            }

            /**
             * EXPORTAR ESTRUTURA DOM EM FORMATO MARKDOWN
             * Gera output formatado em Markdown pronto para colar em documentacao.
             * Uso: window.SENT1_AUTO.exportarEstruturaDOM_copyMarkdown()
             */
            function exportarEstruturaDOM_copyMarkdown() {
                try {
                    var dados = exportarEstruturaDOM();
                    if (dados.erro) return dados;

                    var md = [];
                    var meta = dados.metadados;
                    md.push("# DOM Snapshot - Estrutura Real do eProc");
                    md.push("");
                    md.push("**Pagina**: `" + meta.tipoPagina + "`");
                    md.push(
                        "**Tribunal**: " +
                            meta.tribunal +
                            " - " +
                            meta.grau +
                            " (" +
                            meta.dominio +
                            ")",
                    );
                    md.push("**Data da captura**: " + meta.timestamp);
                    md.push("");

                    // Funcao para renderizar arvore em formato indentado
                    function renderArvore(nodes, indent) {
                        if (!nodes) return;
                        var prefixo = indent || "";
                        for (var i = 0; i < nodes.length; i++) {
                            var node = nodes[i];
                            var isLast = i === nodes.length - 1;
                            var conector = isLast ? "L-- " : "|-- ";
                            var subPrefixo = isLast ? "    " : "|   ";
                            var desc = node.tag;
                            if (node.id) desc += "#" + node.id;
                            if (node.classes && node.classes.length > 0)
                                desc += "." + node.classes.join(".");
                            if (node.dataAttrs) {
                                var attrs = Object.keys(node.dataAttrs).map(
                                    function (k) {
                                        return (
                                            k + '="' + node.dataAttrs[k] + '"'
                                        );
                                    },
                                );
                                desc += " [" + attrs.join(", ") + "]";
                            }
                            md.push(prefixo + conector + desc);
                            if (node.filhos) {
                                renderArvore(node.filhos, prefixo + subPrefixo);
                            }
                        }
                    }

                    // Elementos encontrados
                    var seletores = Object.keys(dados.elementos);
                    for (var s = 0; s < seletores.length; s++) {
                        var sel = seletores[s];
                        var el = dados.elementos[sel];
                        md.push("## " + sel);
                        md.push("");
                        if (!el.encontrado) {
                            md.push("**Nao encontrado na pagina.**");
                            md.push("");
                            continue;
                        }
                        md.push("- **Tag**: `" + el.tagName + "`");
                        if (el.id) md.push("- **ID**: `" + el.id + "`");
                        if (el.classes.length > 0)
                            md.push(
                                "- **Classes**: `" +
                                    el.classes.join("`, `") +
                                    "`",
                            );
                        md.push("- **Filhos diretos**: " + el.filhosDirectos);
                        md.push(
                            "- **Dimensoes**: " +
                                el.dimensoes.width +
                                "x" +
                                el.dimensoes.height +
                                "px (visivel: " +
                                el.dimensoes.visivel +
                                ")",
                        );
                        md.push(
                            "- **Display**: `" +
                                el.estilos.display +
                                "`, Visibility: `" +
                                el.estilos.visibility +
                                "`, Position: `" +
                                el.estilos.position +
                                "`",
                        );
                        if (el.dataAttrs) {
                            md.push(
                                "- **Data attrs**: " +
                                    JSON.stringify(el.dataAttrs),
                            );
                        }
                        md.push("");
                        if (el.filhosIDs && el.filhosIDs.length > 0) {
                            md.push("### Filhos diretos");
                            md.push("");
                            el.filhosIDs.forEach(function (fid) {
                                md.push("- `" + fid + "`");
                            });
                            md.push("");
                        }
                        if (el.arvore && el.arvore.length > 0) {
                            md.push("### Hierarquia DOM");
                            md.push("");
                            md.push("```");
                            md.push(sel);
                            renderArvore(el.arvore, "");
                            md.push("```");
                            md.push("");
                        }
                    }

                    // Colunas de eventos
                    if (dados.colunasEventos) {
                        md.push("## Tabela de Eventos (#tblEventos)");
                        md.push("");
                        md.push("| # | Texto | Width | Classe |");
                        md.push("|---|-------|-------|--------|");
                        dados.colunasEventos.forEach(function (col) {
                            md.push(
                                "| " +
                                    col.indice +
                                    " | " +
                                    col.texto +
                                    " | " +
                                    col.width +
                                    " | " +
                                    (col.classe || "") +
                                    " |",
                            );
                        });
                        md.push("");
                    }

                    // Amostra eventos
                    if (dados.amostraEventos) {
                        md.push(
                            "### Amostra de Linhas (" +
                                dados.amostraEventos.totalLinhas +
                                " total)",
                        );
                        md.push("");
                        dados.amostraEventos.amostra.forEach(function (linha) {
                            md.push(
                                "- `" +
                                    (linha.id || "sem-id") +
                                    "` classes=`" +
                                    linha.classes +
                                    "` parte=`" +
                                    (linha.dataParte || "N/A") +
                                    "`",
                            );
                        });
                        md.push("");
                    }

                    // Elementos eProbe
                    md.push("## Elementos eProbe Injetados");
                    md.push("");
                    var ep = dados.eprobeInjetados;
                    md.push("| Elemento | Quantidade |");
                    md.push("|----------|-----------|");
                    md.push(
                        "| Icones substituidos | " +
                            ep.iconesSubstituidos +
                            " |",
                    );
                    md.push("| Icon containers | " + ep.iconContainers + " |");
                    md.push(
                        "| Navbar eProbe | " +
                            (ep.navbarElement ? "Sim" : "Nao") +
                            " |",
                    );
                    md.push(
                        "| Botao SENT1 | " +
                            (ep.botaoSent1 ? "Sim" : "Nao") +
                            " |",
                    );
                    md.push("| Cards Figma | " + ep.cardsEprobe + " |");
                    md.push("| Estilos injetados | " + ep.estilosEprobe + " |");
                    md.push("");

                    var markdownFinal = md.join("\n");
                    console.log(markdownFinal);

                    if (typeof copy === "function") {
                        copy(markdownFinal);
                        console.log(
                            "Markdown copiado para o clipboard automaticamente.",
                        );
                    }

                    return markdownFinal;
                } catch (error) {
                    console.error(
                        "exportarEstruturaDOM_copyMarkdown: Erro:",
                        error,
                    );
                    return { erro: error.message };
                }
            }

            // ============================================================
            // üîß FIM DAS IMPLEMENTA√á√ïES - FUN√á√ïES PRONTAS PARA NAMESPACE
            // ============================================================

            // ##### INICIO DO NAMESPACE CONSOLIDADO #####
            // Namespace consolidado - exposto como window.SENT1_AUTO antes do fechamento da IIFE

            const eProbeNamespaceFunctions = {
                runFullAutomation: nsRunFullAutomation,
                autoOpenDocumentoRelevante: nsAutoOpenDocumentoRelevante,
                autoExtractText: nsAutoExtractText,
                copyToClipboard: nsCopyToClipboard,
                sendToPerplexity: nsSendToPerplexity,
                sendToPerplexityWithPrompt: nsSendToPerplexityWithPrompt,
                showPromptSelectionModal: nsShowPromptSelectionModal,
                showPerplexityPromptModal: nsShowPerplexityPromptModal,
                showPerplexityTextInputModal: showPerplexityTextInputModal,
                openAIWithCustomPrompt: nsOpenAIWithCustomPrompt,
                detectPageType: nsDetectPageType,
                isValidPageForButton: nsIsValidPageForButton,
                findDocumentosRelevantes: nsFindDocumentosRelevantes,
                showDocumentSelectionModal: nsShowDocumentSelectionModal,
                showSentenceProcessingOptions: nsShowSentenceProcessingOptions,
                getStoredApiKey: nsGetStoredApiKey,
                storeApiKey: nsStoreApiKey,
                removeStoredApiKey: nsRemoveStoredApiKey,
                testApiKey: safeFunctions.testApiKey,
                showErrorLogs: safeFunctions.showErrorLogs,
                debugApiCall: safeFunctions.debugApiCall,
                showApiQuotaInfo: safeFunctions.showApiQuotaInfo,
                cleanInvisibleChars: nsCleanInvisibleChars,
                debugEventStructure: nsDebugEventStructure,
                extractTextFromPDF: extractTextFromPDF,
                tryAutomaticSelection: tryAutomaticSelection,
                isValidLegalDocument: isValidLegalDocument,
                cleanExtractedText: cleanExtractedText,
                debugPDFExtracao: function () {
                    console.log(
                        "üîç DEBUG PDF EPROC: Analisando p√°gina atual...",
                    );

                    const url = window.location.href;
                    const urlParams = new URLSearchParams(
                        window.location.search,
                    );
                    const dadosIconLink = urlParams.get("dadosIconLink");

                    let mimeTypeInfo = "N/A";
                    if (dadosIconLink) {
                        try {
                            const decoded = atob(dadosIconLink);
                            mimeTypeInfo = decoded.includes(
                                '"MimeType";s:3:"pdf"',
                            )
                                ? "PDF detectado!"
                                : "N√£o √© PDF";
                        } catch (e) {
                            mimeTypeInfo = "Erro ao decodificar";
                        }
                    }

                    const info = {
                        url: url,
                        isEprocDocument: url.includes("acessar_documento"),
                        dadosIconLink: dadosIconLink
                            ? dadosIconLink.substring(0, 50) + "..."
                            : "N/A",
                        mimeTypeInfo: mimeTypeInfo,
                        detectPageTypeResult:
                            window.SENT1_AUTO.detectPageType(),

                        // Elementos PDF na p√°gina
                        temIframes: document.querySelectorAll("iframe").length,
                        temEmbeds: document.querySelectorAll("embed").length,
                        temObjects: document.querySelectorAll("object").length,

                        // Teste de seletores espec√≠ficos
                        plugin: !!document.querySelector("#plugin"),
                        iframePdf:
                            !!document.querySelector('iframe[src*="pdf"]'),
                        embedPdf:
                            !!document.querySelector('embed[type*="pdf"]'),
                    };

                    console.log("üìä RELAT√ìRIO COMPLETO:", info);
                    return info;
                },
                // Novas fun√ß√µes de detec√ß√£o de data de sess√£o - CORRIGIDA ESTRUTURA DOM
                detectarDataSessao: function () {
                    log(
                        "‚ö†Ô∏è FUN√á√ÉO REDIRECIONADA: Use window.SENT1_AUTO.detectarSessoesUnificado() com nova estrutura DOM",
                    );
                    return window.SENT1_AUTO.detectarSessoesUnificado();
                },
                getDataSessaoPautado: getDataSessaoPautado,
                hasDataSessaoPautado: hasDataSessaoPautado,
                resetDataSessaoPautado: resetDataSessaoPautado,
                showDataSessaoPautadoInfo: showDataSessaoPautadoInfo,
                validarDataBrasileira: validarDataBrasileira,
                // Fun√ß√µes de interface para data da sess√£o
                inserirDataSessaoNaInterface: inserirDataSessaoNaInterface,
                removerDataSessaoDaInterface: removerDataSessaoDaInterface,
                atualizarDataSessaoNaInterface: atualizarDataSessaoNaInterface,
                forcarInsercaoCardSemValidacao:
                    safeFunctions.forcarInsercaoCardSemValidacao,
                // Fun√ß√µes de cruzamento de dados de sess√£o
                buscarDadosSessoes: safeFunctions.buscarDadosSessoes,
                parsearDadosSessoes: safeFunctions.parsearDadosSessoes,
                extrairDadosLinhaSessao: safeFunctions.extrairDadosLinhaSessao,
                buscarSessaoPorData: safeFunctions.buscarSessaoPorData,
                cruzarDadosDataSessao: safeFunctions.cruzarDadosDataSessao,

                // üèõÔ∏è FUN√á√ïES DE TRADU√á√ÉO DE √ìRG√ÉOS TJSC
                traduzirSiglaOrgao: traduzirSiglaOrgao,

                // üéØ FUN√á√ïES DE EXTRA√á√ÉO DE TIPO DE SESS√ÉO
                extrairTipoSessao: extrairTipoSessao,

                getDadosCompletosSessionJulgamento:
                    sessionDataFunctions.getDadosCompletosSessionJulgamento,
                hasDadosCompletosSessionJulgamento:
                    sessionDataFunctions.hasDadosCompletosSessionJulgamento,
                resetDadosCompletosSessionJulgamento:
                    sessionDataFunctions.resetDadosCompletosSessionJulgamento,
                showDadosCompletosSessionJulgamento:
                    sessionDataFunctions.showDadosCompletosSessionJulgamento,
                // Fun√ß√µes de interface reutiliz√°vel
                criarBotaoEleganteeProc:
                    interfaceFunctions.criarBotaoEleganteeProc,
                botaoBrancoCapaProcesso:
                    interfaceFunctions.botaoBrancoCapaProcesso,
                criarInfraButtonPrimary:
                    interfaceFunctions.criarInfraButtonPrimary,
                botaoAzuleProc: interfaceFunctions.botaoAzuleProc,
                // Fun√ß√µes de localizadores (agora dispon√≠veis globalmente)
                detectarPaginaLocalizadores: window.detectarPaginaLocalizadores,
                processarTabelaLocalizadores:
                    window.processarTabelaLocalizadores,
                destacarLocalizadoresUrgentes:
                    window.destacarLocalizadoresUrgentes,
                adicionarFiltroBuscaLocalizador:
                    window.adicionarFiltroBuscaLocalizador,
                debugLocalizadores: function () {
                    const currentUrl = window.location.href;
                    const isLocalizadoresPage = currentUrl.includes(
                        "acao=usuario_tipo_monitoramento_localizador_listar",
                    );
                    const tabela = document.querySelector(
                        'table.infraTable[summary*="Localizadores"]',
                    );
                    const toolbar = document.getElementById(
                        "eprobe-separadores-toolbar",
                    );

                    console.log("üêõ DEBUG LOCALIZADORES:", {
                        url: currentUrl,
                        isLocalizadoresPage: isLocalizadoresPage,
                        tabelaEncontrada: !!tabela,
                        toolbarCriado: !!toolbar,
                        urlPattern:
                            "acao=usuario_tipo_monitoramento_localizador_listar",
                        numeroLinhas: tabela
                            ? tabela.querySelectorAll(
                                  "tbody tr:not(.eprobe-divisor-linha)",
                              ).length
                            : 0,
                    });

                    if (!isLocalizadoresPage) {
                        console.log("‚ö†Ô∏è N√£o est√° na p√°gina de localizadores");
                    } else {
                        console.log("‚úÖ Est√° na p√°gina de localizadores");
                        if (tabela) {
                            console.log(
                                "‚úÖ Tabela encontrada - for√ßando reprocessamento",
                            );
                            // For√ßar re-processamento
                            window.processarTabelaLocalizadores();
                        } else {
                            console.log("‚ùå Tabela n√£o encontrada");
                        }
                    }

                    return {
                        isLocalizadoresPage,
                        tabelaEncontrada: !!tabela,
                        toolbarCriado: !!toolbar,
                    };
                },
                testarSeparadoresHover: function () {
                    console.log("üß™ TESTE: Verificando hover dos separadores");
                    const separadores = document.querySelectorAll(
                        ".eprobe-divisor-linha",
                    );
                    console.log(
                        `üîç Encontrados ${separadores.length} separadores`,
                    );

                    separadores.forEach((separador, index) => {
                        const botaoRemover = separador.querySelector(
                            ".eprobe-remove-button",
                        );
                        const titulo = separador.querySelector(
                            ".eprobe-container-hover",
                        );

                        console.log(`üìã Separador ${index + 1}:`, {
                            temBotaoRemover: !!botaoRemover,
                            temTitulo: !!titulo,
                            visibilidadeBotao: botaoRemover
                                ? window.getComputedStyle(botaoRemover).opacity
                                : "N/A",
                        });
                    });

                    return separadores.length;
                },
                corrigirVisibilidadeBotoes: function () {
                    console.log(
                        "üîß CORRIGIR: Ajustando visibilidade dos bot√µes de remo√ß√£o",
                    );

                    const css = `
                    .eprobe-remove-button {
                        opacity: 0 !important;
                        transition: opacity 0.2s ease !important;
                    }
                    .eprobe-container-hover:hover .eprobe-remove-button {
                        opacity: 1 !important;
                    }
                `;

                    let styleElement =
                        document.getElementById("eprobe-hover-fix");
                    if (!styleElement) {
                        styleElement = document.createElement("style");
                        styleElement.id = "eprobe-hover-fix";
                        document.head.appendChild(styleElement);
                    }

                    styleElement.textContent = css;
                    console.log("‚úÖ CORRIGIR: CSS de hover aplicado");

                    return true;
                },
                forcarInicializacaoLocalizadores: function () {
                    console.log(
                        "üöÄ FOR√áA: Inicializando sistema de localizadores manualmente",
                    );

                    // For√ßar detec√ß√£o e processamento
                    detectarPaginaLocalizadores();

                    // Aguardar um momento e processar novamente se necess√°rio
                    setTimeout(() => {
                        const tabela = document.querySelector(
                            'table.infraTable[summary*="Localizadores"]',
                        );
                        if (tabela) {
                            console.log(
                                "‚úÖ FOR√áA: Tabela encontrada, reprocessando...",
                            );
                            processarTabelaLocalizadores();
                        } else {
                            console.log("‚ùå FOR√áA: Tabela n√£o encontrada");
                        }
                    }, 500);

                    return "Inicializa√ß√£o for√ßada - verifique o console para resultados";
                },
                diagnosticarMenuContexto: function () {
                    console.log(
                        "üîç DIAGN√ìSTICO COMPLETO: Menu de contexto dos localizadores",
                    );

                    const currentUrl = window.location.href;
                    const isLocalizadoresPage = currentUrl.includes(
                        "acao=usuario_tipo_monitoramento_localizador_listar",
                    );
                    const tabela = document.querySelector(
                        'table.infraTable[summary*="Localizadores"]',
                    );
                    const linhas = tabela
                        ? tabela.querySelectorAll(
                              "tbody tr:not(.eprobe-divisor-linha)",
                          )
                        : [];
                    const infoSeparadores = document.getElementById(
                        "eprobe-info-separadores",
                    );

                    // Verificar event listeners nas linhas
                    let linhasComEventListener = 0;
                    if (linhas.length > 0) {
                        linhas.forEach((linha, index) => {
                            // Verificar se tem cursor de contexto
                            const hasContextCursor =
                                linha.style.cursor === "context-menu";
                            const hasTitle =
                                linha.title &&
                                linha.title.includes("bot√£o direito");

                            if (hasContextCursor || hasTitle) {
                                linhasComEventListener++;
                            }

                            console.log(`üìã Linha ${index + 1}:`, {
                                hasContextCursor,
                                hasTitle,
                                title: linha.title || "sem title",
                            });
                        });
                    }

                    const relatorio = {
                        url: currentUrl,
                        isLocalizadoresPage,
                        tabelaEncontrada: !!tabela,
                        numeroLinhas: linhas.length,
                        linhasComEventListener,
                        infoSeparadoresExiste: !!infoSeparadores,
                        funcaoDetectarDisponivel:
                            typeof detectarPaginaLocalizadores === "function",
                        funcaoProcessarDisponivel:
                            typeof processarTabelaLocalizadores === "function",
                        funcaoMenuContextoDisponivel:
                            typeof adicionarMenuContextoLinhas === "function",
                    };

                    console.log("üìä RELAT√ìRIO DIAGN√ìSTICO:", relatorio);

                    // Sugest√µes baseadas no diagn√≥stico
                    if (!isLocalizadoresPage) {
                        console.log(
                            "‚ùå PROBLEMA: N√£o est√° na p√°gina de localizadores",
                        );
                        console.log(
                            "üí° SOLU√á√ÉO: Navegue para 'Controle de Processos > Meus Localizadores'",
                        );
                    } else if (!tabela) {
                        console.log(
                            "‚ùå PROBLEMA: Tabela de localizadores n√£o encontrada",
                        );
                        console.log(
                            "üí° SOLU√á√ÉO: Verifique se a p√°gina carregou completamente",
                        );
                    } else if (linhasComEventListener === 0) {
                        console.log(
                            "‚ùå PROBLEMA: Linhas n√£o t√™m event listeners configurados",
                        );
                        console.log(
                            "üí° SOLU√á√ÉO: Execute window.SENT1_AUTO.forcarInicializacaoLocalizadores()",
                        );
                    } else {
                        console.log(
                            "‚úÖ STATUS: Sistema parece estar configurado corretamente",
                        );
                        console.log(
                            "üí° TESTE: Clique com bot√£o direito em qualquer linha da tabela",
                        );
                    }

                    return relatorio;
                },
                testarMenuContextoForcado: function () {
                    console.log(
                        "üß™ TESTE: Simulando clique direito para testar menu",
                    );

                    const tabela = document.querySelector(
                        'table.infraTable[summary*="Localizadores"]',
                    );
                    if (!tabela) {
                        console.log("‚ùå TESTE: Tabela n√£o encontrada");
                        return false;
                    }

                    const linhas = tabela.querySelectorAll(
                        "tbody tr:not(.eprobe-divisor-linha)",
                    );
                    if (linhas.length === 0) {
                        console.log("‚ùå TESTE: Nenhuma linha encontrada");
                        return false;
                    }

                    // Testar na primeira linha
                    const primeiraLinha = linhas[0];
                    console.log(
                        "üéØ TESTE: Testando primeira linha:",
                        primeiraLinha,
                    );

                    // Criar evento de contexto simulado
                    const eventoContexto = new MouseEvent("contextmenu", {
                        bubbles: true,
                        cancelable: true,
                        clientX: 100,
                        clientY: 100,
                        button: 2,
                    });

                    console.log("üì§ TESTE: Disparando evento contextmenu...");
                    const resultado =
                        primeiraLinha.dispatchEvent(eventoContexto);

                    // Verificar se o menu foi criado
                    setTimeout(() => {
                        const menu = document.getElementById(
                            "eprobe-menu-contexto-separador",
                        );
                        if (menu) {
                            console.log(
                                "‚úÖ TESTE: Menu criado com sucesso!",
                                menu,
                            );
                            // Remover o menu ap√≥s 3 segundos
                            setTimeout(() => {
                                menu.remove();
                                console.log(
                                    "üóëÔ∏è TESTE: Menu removido automaticamente",
                                );
                            }, 3000);
                        } else {
                            console.log("‚ùå TESTE: Menu n√£o foi criado");
                        }
                    }, 100);

                    return resultado;
                },
                testarMenuCompleto: function () {
                    console.log(
                        "üß™ TESTE COMPLETO: Sistema de menu de contexto para separadores",
                    );

                    // 1. Verificar se estamos na p√°gina correta
                    const currentUrl = window.location.href;
                    const isLocalizadoresPage = currentUrl.includes(
                        "acao=usuario_tipo_monitoramento_localizador_listar",
                    );

                    if (!isLocalizadoresPage) {
                        console.log(
                            "‚ùå ERRO: N√£o est√° na p√°gina de localizadores",
                        );
                        console.log(
                            "üí° SOLU√á√ÉO: Navegue para 'Controle de Processos > Meus Localizadores'",
                        );
                        return false;
                    }

                    // 2. Verificar tabela
                    const tabela = document.querySelector(
                        'table.infraTable[summary*="Localizadores"]',
                    );
                    if (!tabela) {
                        console.log(
                            "‚ùå ERRO: Tabela de localizadores n√£o encontrada",
                        );
                        return false;
                    }

                    // 3. Verificar linhas
                    const linhas = tabela.querySelectorAll(
                        "tbody tr:not(.eprobe-divisor-linha)",
                    );
                    console.log(
                        `‚úÖ Encontradas ${linhas.length} linhas de localizadores`,
                    );

                    // 4. Verificar se as linhas t√™m event listeners configurados
                    let linhasComListener = 0;
                    linhas.forEach((linha, index) => {
                        if (
                            linha.style.cursor === "context-menu" ||
                            (linha.title &&
                                linha.title.includes("bot√£o direito"))
                        ) {
                            linhasComListener++;
                        }
                    });

                    console.log(
                        `‚úÖ ${linhasComListener} linhas t√™m event listeners configurados`,
                    );

                    // 5. Teste de cria√ß√£o de menu simulado com overlay
                    if (linhas.length > 0) {
                        console.log(
                            "üß™ Simulando clique direito na primeira linha com sistema de overlay...",
                        );

                        const primeiraLinha = linhas[0];
                        const rect = primeiraLinha.getBoundingClientRect();
                        const evento = new MouseEvent("contextmenu", {
                            bubbles: true,
                            cancelable: true,
                            clientX: rect.left + 100, // Posi√ß√£o vis√≠vel na tela
                            clientY: rect.top + 10, // Posi√ß√£o vis√≠vel na tela
                            button: 2,
                        });

                        primeiraLinha.dispatchEvent(evento);

                        // Verificar se menu e overlay foram criados
                        setTimeout(() => {
                            const menu = document.getElementById(
                                "eprobe-menu-contexto-separador",
                            );
                            const overlay = document.getElementById(
                                "eprobe-menu-overlay",
                            );

                            if (menu && overlay) {
                                console.log(
                                    "‚úÖ SUCESSO: Menu com overlay criado!",
                                    { menu, overlay },
                                );
                                console.log("üéØ POSI√á√ÉO DO MENU:", {
                                    left: menu.style.left,
                                    top: menu.style.top,
                                    zIndex: menu.style.zIndex,
                                });
                                console.log(
                                    "üõ°Ô∏è OVERLAY Z-INDEX:",
                                    overlay.style.zIndex,
                                );
                                console.log(
                                    "üö´ MENU NATIVO BLOQUEADO: Overlay ativo",
                                );

                                // Remover menu ap√≥s 3 segundos
                                setTimeout(() => {
                                    overlay.remove(); // Remove overlay e menu junto
                                    console.log(
                                        "üóëÔ∏è Menu e overlay removidos automaticamente",
                                    );
                                }, 3000);
                            } else {
                                console.log(
                                    "‚ùå FALHA: Menu ou overlay n√£o foi criado",
                                );
                                if (!menu)
                                    console.log("  - Menu principal ausente");
                                if (!overlay)
                                    console.log(
                                        "  - Overlay de bloqueio ausente",
                                    );
                            }
                        }, 100);
                    }

                    const resultado = {
                        paginaCorreta: isLocalizadoresPage,
                        tabelaEncontrada: !!tabela,
                        numeroLinhas: linhas.length,
                        linhasComListener: linhasComListener,
                        percentualConfigurado: Math.round(
                            (linhasComListener / linhas.length) * 100,
                        ),
                    };

                    console.log("üìä RESULTADO FINAL:", resultado);
                    console.log(
                        resultado.percentualConfigurado === 100
                            ? "‚úÖ SISTEMA 100% FUNCIONAL"
                            : "‚ö†Ô∏è SISTEMA PARCIALMENTE CONFIGURADO",
                    );

                    return resultado;
                },
                // Fun√ß√µes de status de sess√£o
                detectarStatusSessao: statusFunctions.detectarStatusSessao,
                obterTextoCardPorStatus:
                    statusFunctions.obterTextoCardPorStatus,
                obterCorCardPorStatus: statusFunctions.obterCorCardPorStatus,
                getStatusSessao: statusFunctions.getStatusSessao,
                hasStatusSessao: statusFunctions.hasStatusSessao,
                resetStatusSessao: statusFunctions.resetStatusSessao,
                showStatusSessaoInfo: statusFunctions.showStatusSessaoInfo,

                // üîç FUN√á√ïES DE DEBUG PARA STATUS DE SESS√ÉO - IMPLEMENTA√á√ïES DIRETAS
                debugDeteccaoStatusSessao: function () {
                    log("DEBUG: Detectando status de sessao manualmente...");
                    return detectarSessoesUnificado();
                },
                debugStatusSessao: function () {
                    log(
                        "üîç DEBUG: Mostrando informa√ß√µes do status da sess√£o...",
                    );
                    return statusFunctions.showStatusSessaoInfo();
                },

                // üéØ SISTEMA UNIFICADO DE SESS√ïES - √öNICA IMPLEMENTA√á√ÉO
                detectarSessoesUnificado: detectarSessoesUnificado,
                detectarCardSessaoSimplificado: detectarSessoesUnificado, // Alias para compatibilidade
                aplicarTooltipUnificado: aplicarTooltipUnificado,
                diagnosticarSistemaCompleto: diagnosticarSistemaCompleto,
                obterCorPorStatus: obterCorPorStatus,
                extrairDadosPautaMesa: extrairDadosPautaMesa, // üéØ NOVA: Extra√ß√£o de dados de pauta/mesa

                // üß™ TESTE ESPEC√çFICO PARA DADOS DE PAUTA/MESA
                testarExtracaoPautaMesa: function (dataTeste = "21/08/2025") {
                    console.log(
                        "üß™ TESTE PAUTA/MESA: Iniciando teste de extra√ß√£o...",
                    );
                    console.log(
                        `üìÖ TESTE PAUTA/MESA: Data para teste: ${dataTeste}`,
                    );

                    // Verificar se estamos na p√°gina correta
                    const tabelaEventos = document.querySelector("#tblEventos");
                    if (!tabelaEventos) {
                        console.log(
                            "‚ùå TESTE PAUTA/MESA: Tabela #tblEventos n√£o encontrada",
                        );
                        console.log(
                            "üí° TESTE PAUTA/MESA: Este teste deve ser executado na p√°gina de detalhes do processo",
                        );
                        return { erro: "Tabela de eventos n√£o encontrada" };
                    }

                    console.log(
                        "‚úÖ TESTE PAUTA/MESA: Tabela de eventos encontrada",
                    );

                    // Executar extra√ß√£o
                    const resultado = extrairDadosPautaMesa(dataTeste);

                    if (resultado) {
                        console.log(
                            "üéâ TESTE PAUTA/MESA: Dados extra√≠dos com sucesso!",
                        );
                        console.table(resultado);

                        // Verificar estrutura dos dados
                        const estruturaCorreta = {
                            temTipoInclusao:
                                resultado.hasOwnProperty("tipoInclusao"),
                            temModalidade:
                                resultado.hasOwnProperty("modalidade"),
                            temSequencial:
                                resultado.hasOwnProperty("sequencial"),
                            temDataEncontrada:
                                resultado.hasOwnProperty("dataEncontrada"),
                            temEventoId: resultado.hasOwnProperty("eventoId"),
                        };

                        console.log(
                            "üîç TESTE PAUTA/MESA: Verifica√ß√£o de estrutura:",
                            estruturaCorreta,
                        );

                        return {
                            sucesso: true,
                            dados: resultado,
                            estrutura: estruturaCorreta,
                        };
                    } else {
                        console.log(
                            "‚ùå TESTE PAUTA/MESA: Nenhum dado encontrado para a data especificada",
                        );

                        // Listar todos os eventos para debug
                        const linhasEvento =
                            tabelaEventos.querySelectorAll(
                                'tr[id^="trEvento"]',
                            );
                        console.log(
                            `üîç TESTE PAUTA/MESA: ${linhasEvento.length} eventos encontrados na tabela:`,
                        );

                        linhasEvento.forEach((linha, index) => {
                            const labelDescricao = linha.querySelector(
                                "label.infraEventoDescricao",
                            );
                            const texto = labelDescricao
                                ? labelDescricao.textContent
                                : "N/A";
                            console.log(
                                `   ${index + 1}. ${
                                    linha.id
                                }: ${texto.substring(0, 100)}...`,
                            );
                        });

                        return {
                            sucesso: false,
                            totalEventos: linhasEvento.length,
                        };
                    }
                },

                // üß™ FUN√á√ÉO DE TESTE PARA PADR√ÉO ESPEC√çFICO
                testarPadraoEspecifico: function () {
                    console.log(
                        "üß™ TESTE ESPEC√çFICO: Testando padr√£o do usu√°rio...",
                    );

                    const textoTeste =
                        "M√©rito (Julgado em Pauta em 01/07/2025 - CAMPUB5)";
                    const padraoUnificado =
                        /^([A-Za-z√Ä-√ø\s]+?)\s*\((Julgado|Retirado|Inclu√≠do)\s+em\s+Pauta\s+em\s+(\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9\-¬∫]+(?:\s+[A-Z]+)*)\)$/;

                    console.log("üìù Texto de teste:", textoTeste);
                    console.log("üéØ Regex unificado:", padraoUnificado);

                    const match = textoTeste.match(padraoUnificado);

                    if (match) {
                        const [, tipo, status, data, orgao] = match;
                        const sessao = {
                            tipo: tipo.trim(),
                            status: status.trim(),
                            data: data.trim(),
                            orgao: orgao.trim(),
                            textoCompleto: textoTeste,
                            cor: obterCorPorStatus(status.trim()),
                        };

                        console.log("‚úÖ SUCESSO! Sess√£o detectada:", sessao);

                        // Tentar criar tooltip se card existir
                        const card =
                            document.getElementById("eprobe-data-sessao");
                        if (card) {
                            aplicarTooltipUnificado(card, [sessao]);
                            console.log("üé® Tooltip aplicado ao card");
                        }

                        return sessao;
                    } else {
                        console.log("‚ùå FALHA: Padr√£o n√£o correspondeu");
                        return null;
                    }
                },
                testarPadraoEspecifico: function () {
                    console.log(
                        "üß™ TESTE ESPEC√çFICO: Testando padr√£o do usu√°rio...",
                    );

                    const textoTeste =
                        "M√©rito (Julgado em Pauta em 01/07/2025 - CAMPUB5)";
                    const padraoUnificado =
                        /^([A-Za-z√Ä-√ø\s]+?)\s*\((Julgado|Retirado|Inclu√≠do)\s+em\s+Pauta\s+em\s+(\d{1,2}\/\d{1,2}\/\d{4})\s*-\s*([A-Z0-9\-¬∫]+(?:\s+[A-Z]+)*)\)$/;

                    console.log("üìù Texto de teste:", textoTeste);
                    console.log("üéØ Regex unificado:", padraoUnificado);

                    const match = textoTeste.match(padraoUnificado);

                    if (match) {
                        const [, tipo, status, data, orgao] = match;
                        const sessao = {
                            tipo: tipo.trim(),
                            status: status.trim(),
                            data: data.trim(),
                            orgao: orgao.trim(),
                            textoCompleto: textoTeste,
                            cor: this.obterCorPorStatus(status.trim()),
                        };

                        console.log("‚úÖ SUCESSO! Sess√£o detectada:", sessao);
                        return sessao;
                    } else {
                        console.log("‚ùå FALHA: Padr√£o n√£o correspondeu");
                        return null;
                    }
                },
                criarCardSessaoMaterial: criarCardSessaoMaterial,
                tornarCardSessaoClicavel: tornarCardSessaoClicavel,

                // üîç FUN√á√ïES DE DIAGN√ìSTICO E TESTE IMPLEMENTADAS
                diagnosticarEstruturaDOMMinutas:
                    diagnosticarEstruturaDOMMinutas,
                testarDeteccaoRobusta: testarDeteccaoRobusta,
                // EXPORTACAO DE ESTRUTURA DOM PARA DEBUG
                exportarEstruturaDOM: exportarEstruturaDOM,
                exportarEstruturaDOM_copyMarkdown:
                    exportarEstruturaDOM_copyMarkdown,

                // ‚úÖ FUN√á√ïES DE LOCALIZADORES (refer√™ncia corrigida - removida duplica√ß√£o)
                // As fun√ß√µes de localizadores j√° est√£o definidas acima na linha 20410
                // üéØ TOOLTIP UNIFICADO - √öNICA IMPLEMENTA√á√ÉO
                adicionarTooltipUnificado: adicionarTooltipUnificado, // ‚Üê FUN√á√ÉO PRINCIPAL

                // üö´ FUN√á√ïES DESCONTINUADAS (redirecionam para a unificada)
                adicionarTooltipInterativo: adicionarTooltipInterativo, // deprecated
                adicionarRichTooltipMaterialDesign:
                    adicionarRichTooltipMaterialDesign, // deprecated
                criarTooltipSimplificado: criarTooltipSimplificado, // deprecated
                testarFuncaoTooltip: function () {
                    // deprecated
                    log(
                        "‚ö†Ô∏è DEPRECATED: testarFuncaoTooltip - use adicionarTooltipUnificado()",
                    );
                    return false;
                },
                // üé® FUN√á√ïES DE ESTILIZA√á√ÉO divLembrete - SISTEMA INTELIGENTE
                debugDivLembrete,
                estilizarDivLembrete,
                estilizarDivLembreteVermelho,
                estilizarDivLembreteAzul,
                estilizarDivLembreteVerde,
                estilizarDivLembreteLaranja,
                estilizarTodosDivLembrete,
                debugTodosDivLembrete,
                aplicarEstilizacaoLembretesRobusta,

                // üé® GRADIENTES PARA CAPA DO PROCESSO
                aplicarGradientesCapaProcesso, // üéØ NOVA: Aplica gradientes na capa do processo
                aplicarGradientesCapaProcessoRobusta, // üîÑ NOVA: Aplica√ß√£o robusta com retry autom√°tico
                aplicarGradientesLegMinutas, // üéØ NOVA: Aplica gradientes nas legendas e tabelas de minutas
                aplicarGradientesLegMinutasRobusta, // üîÑ NOVA: Aplica√ß√£o robusta com retry para minutas
                aplicarGradientesDetalhesCapa, // Padroniza cores de background na capa (partes, descricoes)
                aplicarGradientesDetalhesCapaRobusta, // Aplicacao robusta com retry para detalhes capa

                // üß† NOVA DETEC√á√ÉO INTELIGENTE DE LEMBRETES
                detectarTiposLembretesNaPagina,

                // üîÑ TESTES DO SISTEMA CORRIGIDO
                testarSistemaEstilizacaoCorrigido: function () {
                    log("üß™ TESTE: Sistema de estiliza√ß√£o inteligente...");
                    log("1Ô∏è‚É£ Detectando tipos de lembretes...");
                    const deteccao = detectarTiposLembretesNaPagina();
                    log("2Ô∏è‚É£ Aplicando estiliza√ß√£o robusta...");
                    aplicarEstilizacaoLembretesRobusta();
                    return deteccao;
                },

                // üö® DIAGN√ìSTICO COMPLETO DE LEMBRETES
                diagnosticarLembretesCompleto: function () {
                    log(
                        "üîç DIAGN√ìSTICO COMPLETO: Analisando sistema de lembretes...",
                    );

                    // 1. Verificar se as fun√ß√µes existem
                    const funcoesExistem = {
                        detectarTiposLembretesNaPagina:
                            typeof detectarTiposLembretesNaPagina ===
                            "function",
                        aplicarEstilizacaoImediataLembretes:
                            typeof aplicarEstilizacaoImediataLembretes ===
                            "function",
                        aplicarEstilizacaoLembretesRobusta:
                            typeof aplicarEstilizacaoLembretesRobusta ===
                            "function",
                        estilizarTodosDivLembrete:
                            typeof estilizarTodosDivLembrete === "function",
                    };

                    log("üìä FUN√á√ïES DISPON√çVEIS:", funcoesExistem);

                    // 2. Detectar lembretes na p√°gina
                    const deteccao = detectarTiposLembretesNaPagina();
                    log("üéØ DETEC√á√ÉO:", deteccao);

                    // 3. Tentar m√∫ltiplos seletores
                    const seletoresTeste = [
                        "div.divLembrete",
                        ".lista-lembretes .lembrete",
                        'div[style*="#efef8f"]',
                        'div[style*="#db8080"]',
                        'div[style*="#87adcd"]',
                        'div[style*="#a7eda7"]',
                        'div[style*="#f5b574"]',
                    ];

                    const resultadosSeletores = {};
                    seletoresTeste.forEach((seletor) => {
                        const elementos = document.querySelectorAll(seletor);
                        resultadosSeletores[seletor] = elementos.length;
                        if (elementos.length > 0) {
                            log(
                                `‚úÖ ${seletor}: ${elementos.length} elementos encontrados`,
                            );
                        }
                    });

                    // 4. For√ßar estiliza√ß√£o se elementos existem
                    let totalEstilizados = 0;
                    if (deteccao.coresEncontradas.length > 0) {
                        log("üé® FOR√áANDO ESTILIZA√á√ÉO...");
                        totalEstilizados =
                            estilizarTodosDivLembrete().total || 0;
                    }

                    const diagnostico = {
                        funcoesExistem,
                        deteccao,
                        resultadosSeletores,
                        totalEstilizados,
                        sucesso: totalEstilizados > 0,
                    };

                    log("üèÅ DIAGN√ìSTICO FINAL:", diagnostico);
                    return diagnostico;
                },

                // üîß FOR√áAR ESTILIZA√á√ÉO MANUAL
                forcarEstilizacaoLembretes: function () {
                    log(
                        "üöÄ FOR√áA: For√ßando estiliza√ß√£o manual de lembretes...",
                    );

                    try {
                        // Tentar detec√ß√£o primeiro
                        const deteccao = detectarTiposLembretesNaPagina();

                        if (deteccao.coresEncontradas.length === 0) {
                            log(
                                "‚ö†Ô∏è Nenhum lembrete encontrado, tentando seletores alternativos...",
                            );

                            // Tentar seletores gen√©ricos
                            const seletoresGen√©ricos = [
                                'div[style*="background-color"]',
                                ".lista-lembretes div",
                                "div.divLembrete",
                            ];

                            for (const seletor of seletoresGen√©ricos) {
                                const elementos =
                                    document.querySelectorAll(seletor);
                                if (elementos.length > 0) {
                                    log(
                                        `‚úÖ Encontrados ${elementos.length} elementos com ${seletor}`,
                                    );

                                    elementos.forEach((elem, i) => {
                                        const style =
                                            elem.getAttribute("style") || "";
                                        if (
                                            style.includes("background-color")
                                        ) {
                                            log(
                                                `üé® Estilizando elemento ${
                                                    i + 1
                                                }:`,
                                                style,
                                            );

                                            // Aplicar gradiente baseado na cor
                                            if (style.includes("#efef8f")) {
                                                elem.style.background =
                                                    "linear-gradient(#F9EFAF, #F7E98D)";
                                            } else if (
                                                style.includes("#db8080")
                                            ) {
                                                elem.style.background =
                                                    "linear-gradient(#FAAFAF, #F78D8D)";
                                            } else if (
                                                style.includes("#87adcd")
                                            ) {
                                                elem.style.background =
                                                    "linear-gradient(#AFCFFA, #8DC0F7)";
                                            } else if (
                                                style.includes("#a7eda7")
                                            ) {
                                                elem.style.background =
                                                    "linear-gradient(#AFFAB6, #8DF792)";
                                            } else if (
                                                style.includes("#f5b574")
                                            ) {
                                                elem.style.background =
                                                    "linear-gradient(#FAD3AF, #F7C68D)";
                                            }

                                            // Aplicar estilos adicionais
                                            elem.style.padding = "20px";
                                            elem.style.boxShadow =
                                                "0 4px 6px rgba(0, 0, 0, 0.1)";
                                            elem.style.transition =
                                                "box-shadow 0.5s ease";
                                        }
                                    });
                                    break;
                                }
                            }
                        } else {
                            // Usar detec√ß√£o inteligente
                            aplicarEstilizacaoLembretesRobusta();
                        }

                        log("‚úÖ FOR√áA: Estiliza√ß√£o manual conclu√≠da");
                        return true;
                    } catch (error) {
                        log(
                            "‚ùå FOR√áA: Erro durante estiliza√ß√£o manual:",
                            error,
                        );
                        return false;
                    }
                },
                // üîç FUN√á√ïES DE DEBUG PARA STATUS
                debugPadraoRetirado: allMissingFunctions.debugPadraoRetirado,
                debugStatusCompleto: allMissingFunctions.debugStatusCompleto,
                forcarAtualizacaoStatus:
                    allMissingFunctions.forcarAtualizacaoStatus,
                testarCasoRetirado: allMissingFunctions.testarCasoRetirado,
                debugStatusSessao: showStatusSessaoInfo,
                testarSistemaStatusSessao:
                    allMissingFunctions.testarSistemaStatusSessao,
                // üîÑ FUN√á√ïES DE DEBUG PARA ALTERN√ÇNCIA
                findToggleTarget: allMissingFunctions.findToggleTarget,
                implementarAlternanciaExpandirRetrair:
                    allMissingFunctions.implementarAlternanciaExpandirRetrair,
                isElementSafeForToggle:
                    allMissingFunctions.isElementSafeForToggle,

                // ========== FUN√á√ïES CONSOLIDADAS (anteriormente espalhadas) ==========

                // üß™ FUN√á√ïES DE TESTE SIMPLIFICADO
                debugPadroesStatusSessao:
                    allMissingFunctions.debugPadroesStatusSessao,
                forcarStatusSessao: allMissingFunctions.forcarStatusSessao,
                encontrarTextoRetirado:
                    allMissingFunctions.encontrarTextoRetirado,
                forcarDeteccaoCompleta:
                    allMissingFunctions.forcarDeteccaoCompleta,

                // üß™ TESTE CR√çTICO PARA DETEC√á√ÉO DIN√ÇMICA DE FIELDSET
                testarDeteccaoDinamicaFieldset: testarDeteccaoDinamicaFieldset,

                // üîß FUN√á√ïES AUXILIARES - Extra√ß√£o e normaliza√ß√£o de dados
                getData: getData,
                extrairDataSessaoNormalizada: extrairDataSessaoNormalizada,

                // Funcoes de icones - aliases para funcao unificada
                substituirTodosIcones: substituirTodosIcones,
                debugIcones: debugIcones,
                substituirIconesFieldsetAcoes: substituirTodosIcones,
                substituirIconesFerramentas: substituirTodosIcones,
                substituirIconesGlobalmente: substituirTodosIcones,
                substituirIconesLembretes: substituirTodosIcones,
                // üîÑ NOVO: Reaplica√ß√£o for√ßada de √≠cones ap√≥s atualiza√ß√£o AJAX
                reaplicarIconesAposAtualizacao: reaplicarIconesAposAtualizacao,
                // ‚ö° NOVO: Anti-flash cr√≠tico para √≠cones
                aplicarAntiFlashIcones: aplicarAntiFlashIcones,
                // Interceptor para multiplos botoes de atualizar minutas
                setupInterceptorTodosBotoesAtualizar:
                    setupInterceptorTodosBotoesAtualizar,
                setupInterceptorAtualizarMinutas:
                    setupInterceptorAtualizarMinutas,
                testarIconesLembretes: substituirTodosIcones,
                // Funcoes para eliminar flash visual
                aplicarEstilizacaoImediataLembretes:
                    aplicarEstilizacaoImediataLembretes,
                substituirIconesLembretesImediato: substituirTodosIcones,
                debugIconesSubstituicao: debugIcones,
                configurarAlternanciaEstrelas: function () {
                    log(
                        "‚ö†Ô∏è ESTRELAS: Fun√ß√£o configurarAlternanciaEstrelas foi removida (preven√ß√£o de erros)",
                    );
                    return 0; // Retorna 0 estrelas configuradas
                },

                // üîç FUN√á√ïES DE DIAGN√ìSTICO E CORRE√á√ÉO - IMPLEMENTA√á√ïES REAIS
                diagnosticarCompleto:
                    debugInterfaceFunctions.diagnosticarCompleto,
                corrigirProblemas: debugInterfaceFunctions.corrigirProblemas,
                corrigirPointerEventsBotoes: corrigirPointerEventsBotoes, // CORRE√á√ÉO CR√çTICA para bot√µes bloqueados
                corrigirSwitchRelevanciaDocumento:
                    corrigirSwitchRelevanciaDocumento, // CORRE√á√ÉO CR√çTICA para fun√ß√£o de relev√¢ncia
                corrigirSwitchRelevanciaDocumentoRobusta:
                    corrigirSwitchRelevanciaDocumentoRobusta, // NOVA VERS√ÉO ROBUSTA - usa implementa√ß√£o pr√≥pria
                forcarReaplicacaoIcones: forcarReaplicacaoIcones, // Implementa√ß√£o real
                inicializarSubstituicaoIcones: inicializarSubstituicaoIcones, // Implementa√ß√£o real
                diagnosticarIconesCSS:
                    debugInterfaceFunctions.diagnosticarIconesCSS,

                // üé® FUN√á√ïES DE CONTROLE DE PERSONALIZA√á√ÉO DA NAVBAR
                ativarPersonalizacaoNavbar: ativarPersonalizacaoNavbar,
                desativarPersonalizacaoNavbar: desativarPersonalizacaoNavbar,
                verificarStatusPersonalizacaoNavbar:
                    verificarStatusPersonalizacaoNavbar,
                inicializarConfiguracoesPersalizacao:
                    inicializarConfiguracoesPersalizacao,

                // Fun√ß√£o de teste para verificar restri√ß√µes de personaliza√ß√£o
                testarRestricaoPersonalizacaoIcones: () => {
                    const urlAtual = window.location.href;
                    const isCapaProcesso = isCapaProcessoPage();

                    console.log("üîç TESTE RESTRI√á√ÉO PERSONALIZA√á√ÉO:");
                    console.log("üìç URL atual:", urlAtual);
                    console.log(
                        "üè† √â p√°gina de capa do processo:",
                        isCapaProcesso,
                    );

                    if (isCapaProcesso) {
                        console.log(
                            "‚úÖ PERMITIDO: Personaliza√ß√£o de √≠cones habilitada",
                        );
                        console.log("üé® Testando inicializa√ß√£o de √≠cones...");
                        if (
                            typeof inicializarSubstituicaoIcones === "function"
                        ) {
                            const resultado = inicializarSubstituicaoIcones();
                            console.log("üìä Resultado:", resultado);
                        }
                    } else {
                        console.log(
                            "‚õî BLOQUEADO: Personaliza√ß√£o restrita a p√°ginas de capa",
                        );
                        console.log(
                            "üí° Para testar, navegue para uma p√°gina que contenha:",
                        );
                        console.log(
                            "   ‚Ä¢ eproc1g.tjsc.jus.br/eproc/controlador.php?acao=processo_selecionar&",
                        );
                        console.log(
                            "   ‚Ä¢ eproc2g.tjsc.jus.br/eproc/controlador.php?acao=processo_selecionar&",
                        );
                    }

                    return {
                        urlAtual,
                        isCapaProcesso,
                        personalizacaoPermitida: isCapaProcesso,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };
                },

                // üìè Fun√ß√£o de teste para verificar dimensionamento em divListaRecursosMinuta
                testarDimensionamentoRecursosMinuta: () => {
                    console.log("üìè TESTE DIMENSIONAMENTO RECURSOS MINUTA:");

                    const divListaRecursos = document.getElementById(
                        "divListaRecursosMinuta",
                    );

                    if (!divListaRecursos) {
                        console.log(
                            "‚ö†Ô∏è divListaRecursosMinuta n√£o encontrado na p√°gina atual",
                        );
                        return {
                            encontrado: false,
                            icones: 0,
                            iconesCorretos: 0,
                            timestamp: new Date().toLocaleString("pt-BR"),
                        };
                    }

                    console.log(
                        "‚úÖ divListaRecursosMinuta encontrado:",
                        divListaRecursos,
                    );

                    // Buscar todos os √≠cones SVG dentro da div
                    const iconesSvg = divListaRecursos.querySelectorAll(
                        'svg[data-eprobe-icon-replaced="true"]',
                    );
                    console.log(
                        `üìä Total de √≠cones SVG eProbe encontrados: ${iconesSvg.length}`,
                    );

                    let iconesCorretos = 0;
                    const detalhes = [];

                    iconesSvg.forEach((svg, index) => {
                        const width =
                            svg.style.width ||
                            svg.getAttribute("width") ||
                            "n√£o definido";
                        const height =
                            svg.style.height ||
                            svg.getAttribute("height") ||
                            "n√£o definido";
                        const isCorreto =
                            width === "17.59px" && height === "17.59px";

                        if (isCorreto) iconesCorretos++;

                        const detalhe = {
                            indice: index + 1,
                            width,
                            height,
                            tamanhoCorreto: isCorreto,
                            temMarcacao: svg.hasAttribute(
                                "data-eprobe-recursos-minuta-sized",
                            ),
                            originalType:
                                svg.getAttribute("data-original-name") ||
                                "desconhecido",
                        };

                        detalhes.push(detalhe);

                        console.log(`üìê √çcone ${index + 1}:`, detalhe);

                        // Se n√£o estiver no tamanho correto, aplicar corre√ß√£o
                        if (!isCorreto) {
                            console.log(
                                `üîß Corrigindo dimens√£o do √≠cone ${
                                    index + 1
                                }...`,
                            );
                            aplicarDimensionamentoRecursosMinuta(svg);
                        }
                    });

                    const resultado = {
                        encontrado: true,
                        divId: "divListaRecursosMinuta",
                        icones: iconesSvg.length,
                        iconesCorretos,
                        porcentagemCorretos:
                            iconesSvg.length > 0
                                ? (
                                      (iconesCorretos / iconesSvg.length) *
                                      100
                                  ).toFixed(1) + "%"
                                : "0%",
                        detalhes,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };

                    console.log("üìä RESULTADO FINAL:", resultado);

                    if (
                        iconesCorretos === iconesSvg.length &&
                        iconesSvg.length > 0
                    ) {
                        console.log(
                            "‚úÖ Todos os √≠cones est√£o no tamanho correto (17.59x17.59)!",
                        );
                    } else if (iconesSvg.length === 0) {
                        console.log(
                            "‚ö†Ô∏è Nenhum √≠cone eProbe encontrado em divListaRecursosMinuta",
                        );
                    } else {
                        console.log(
                            `‚ö†Ô∏è ${
                                iconesSvg.length - iconesCorretos
                            } √≠cones precisam de corre√ß√£o`,
                        );

                        // Aplicar corre√ß√£o autom√°tica de alinhamento se necess√°rio
                        console.log(
                            "üîß Aplicando corre√ß√£o autom√°tica de alinhamento...",
                        );
                        if (
                            typeof corrigirAlinhamentoRecursosMinuta ===
                            "function"
                        ) {
                            const correcao =
                                corrigirAlinhamentoRecursosMinuta();
                            resultado.correcaoAlinhamento = correcao;
                            console.log("üìä Resultado da corre√ß√£o:", correcao);
                        }
                    }

                    return resultado;
                },

                // üîß Fun√ß√£o para corrigir alinhamento em divListaRecursosMinuta
                corrigirAlinhamentoRecursosMinuta: () => {
                    console.log("üîß CORRE√á√ÉO ALINHAMENTO RECURSOS MINUTA:");

                    if (
                        typeof corrigirAlinhamentoRecursosMinuta === "function"
                    ) {
                        const resultado = corrigirAlinhamentoRecursosMinuta();
                        console.log("üìä Resultado da corre√ß√£o:", resultado);

                        if (resultado.encontrado) {
                            console.log(
                                `‚úÖ Corre√ß√£o aplicada: ${resultado.iconesCorrigidos} √≠cones processados`,
                            );
                            console.log(
                                `üîó Links corrigidos: ${resultado.linksCorrigidos}`,
                            );
                            console.log(
                                `üíÖ CSS aplicado: ${resultado.cssAplicado}`,
                            );
                        } else {
                            console.log(
                                "‚ö†Ô∏è divListaRecursosMinuta n√£o encontrado",
                            );
                        }

                        return resultado;
                    } else {
                        console.log(
                            "‚ùå Fun√ß√£o corrigirAlinhamentoRecursosMinuta n√£o dispon√≠vel",
                        );
                        return { erro: "fun√ß√£o n√£o dispon√≠vel" };
                    }
                },

                // üëÅÔ∏è Fun√ß√£o para diagn√≥stico visual de alinhamento em divListaRecursosMinuta
                diagnosticarAlinhamentoVisual: () => {
                    console.log("üëÅÔ∏è DIAGN√ìSTICO VISUAL RECURSOS MINUTA:");

                    const divListaRecursos = document.getElementById(
                        "divListaRecursosMinuta",
                    );

                    if (!divListaRecursos) {
                        console.log(
                            "‚ö†Ô∏è divListaRecursosMinuta n√£o encontrado na p√°gina atual",
                        );
                        return { encontrado: false };
                    }

                    // Aplicar estilos visuais tempor√°rios para debug
                    const diagnosticStyle = document.createElement("style");
                    diagnosticStyle.id = "eprobe-diagnostic-style";

                    // Remover estilo anterior se existir
                    const oldDiagnostic = document.getElementById(
                        "eprobe-diagnostic-style",
                    );
                    if (oldDiagnostic) oldDiagnostic.remove();

                    diagnosticStyle.textContent = `
                        /* DIAGN√ìSTICO VISUAL TEMPOR√ÅRIO */
                        #divListaRecursosMinuta {
                            background: rgba(255, 255, 0, 0.1) !important;
                            border: 2px dashed orange !important;
                            padding: 5px !important;
                        }
                        
                        #divListaRecursosMinuta * {
                            outline: 1px solid rgba(255, 0, 0, 0.3) !important;
                        }
                        
                        #divListaRecursosMinuta img {
                            background: rgba(0, 255, 0, 0.3) !important;
                            outline: 2px solid green !important;
                        }
                        
                        #divListaRecursosMinuta svg[data-eprobe-icon-replaced="true"] {
                            background: rgba(0, 0, 255, 0.3) !important;
                            outline: 2px solid blue !important;
                        }
                        
                        #divListaRecursosMinuta a {
                            background: rgba(255, 0, 255, 0.2) !important;
                        }
                    `;

                    document.head.appendChild(diagnosticStyle);

                    // Coletar informa√ß√µes detalhadas
                    const icones =
                        divListaRecursos.querySelectorAll("img, svg");
                    const links = divListaRecursos.querySelectorAll("a");
                    const iconesPersonalizados =
                        divListaRecursos.querySelectorAll(
                            'svg[data-eprobe-icon-replaced="true"]',
                        );

                    const detalhes = {
                        totalIcones: icones.length,
                        iconesPersonalizados: iconesPersonalizados.length,
                        iconesOriginais:
                            icones.length - iconesPersonalizados.length,
                        totalLinks: links.length,
                    };

                    console.log("üìä Estrutura encontrada:");
                    console.log("üü° Fundo amarelo: divListaRecursosMinuta");
                    console.log("üü¢ Contorno verde: √çcones originais (IMG)");
                    console.log(
                        "üîµ Contorno azul: √çcones personalizados (SVG eProbe)",
                    );
                    console.log("üü£ Fundo roxo: Links (A)");
                    console.log("üî¥ Contorno vermelho: Todos os elementos");

                    console.table(detalhes);

                    // An√°lise individual dos √≠cones
                    iconesPersonalizados.forEach((svg, index) => {
                        const rect = svg.getBoundingClientRect();
                        const computed = getComputedStyle(svg);

                        console.log(`üîµ √çcone personalizado ${index + 1}:`, {
                            width:
                                svg.style.width ||
                                svg.getAttribute("width") ||
                                "n√£o definido",
                            height:
                                svg.style.height ||
                                svg.getAttribute("height") ||
                                "n√£o definido",
                            computedWidth: computed.width,
                            computedHeight: computed.height,
                            verticalAlign: computed.verticalAlign,
                            display: computed.display,
                            boundingRect: {
                                width: rect.width,
                                height: rect.height,
                                x: Math.round(rect.x),
                                y: Math.round(rect.y),
                            },
                        });
                    });

                    // Auto-remover o estilo ap√≥s 10 segundos
                    setTimeout(() => {
                        const styleToRemove = document.getElementById(
                            "eprobe-diagnostic-style",
                        );
                        if (styleToRemove) {
                            styleToRemove.remove();
                            console.log(
                                "üëÅÔ∏è Diagn√≥stico visual removido automaticamente",
                            );
                        }
                    }, 10000);

                    console.log("‚è∞ Diagn√≥stico visual ativo por 10 segundos");
                    console.log(
                        "üîß Para corrigir problemas encontrados, execute: window.SENT1_AUTO.corrigirAlinhamentoRecursosMinuta()",
                    );

                    return {
                        encontrado: true,
                        ...detalhes,
                        diagnosticoAtivo: true,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };
                },

                //   Fun√ß√£o para testar reaplica√ß√£o de √≠cones em legMinutas
                testarReaplicacaoIconesMinutas: () => {
                    console.log("üîÑ TESTE REAPLICA√á√ÉO √çCONES MINUTAS:");

                    const legMinutas = document.getElementById("legMinutas");

                    if (!legMinutas) {
                        console.log(
                            "‚ö†Ô∏è legMinutas n√£o encontrado na p√°gina atual",
                        );
                        return {
                            encontrado: false,
                            erro: "legMinutas n√£o encontrado",
                        };
                    }

                    console.log("‚úÖ legMinutas encontrado:", legMinutas);

                    // Verificar estado atual dos √≠cones
                    const iconesOriginais = legMinutas.querySelectorAll(
                        "img:not([data-eprobe-protected])",
                    );
                    const iconesPersonalizados = legMinutas.querySelectorAll(
                        'svg[data-eprobe-icon-replaced="true"]',
                    );
                    const divListaRecursos = legMinutas.querySelector(
                        "#divListaRecursosMinuta",
                    );

                    const estadoAntes = {
                        iconesOriginais: iconesOriginais.length,
                        iconesPersonalizados: iconesPersonalizados.length,
                        temDivListaRecursos: !!divListaRecursos,
                    };

                    console.log("üìä Estado ANTES da reaplica√ß√£o:", estadoAntes);

                    // For√ßar reaplica√ß√£o de todas as substitui√ß√µes
                    let totalReaplicados = 0;

                    try {
                        // Reaplicar todos os icones via funcao unificada
                        totalReaplicados = substituirTodosIcones(legMinutas, {
                            force: true,
                        });
                        console.log("Icones reaplicados:", totalReaplicados);
                    } catch (error) {
                        console.error("Erro durante reaplicacao:", error);
                    }

                    // Verificar estado final
                    const iconesOriginaisDepois = legMinutas.querySelectorAll(
                        "img:not([data-eprobe-protected])",
                    );
                    const iconesPersonalizadosDepois =
                        legMinutas.querySelectorAll(
                            'svg[data-eprobe-icon-replaced="true"]',
                        );

                    const estadoDepois = {
                        iconesOriginais: iconesOriginaisDepois.length,
                        iconesPersonalizados: iconesPersonalizadosDepois.length,
                        temDivListaRecursos: !!divListaRecursos,
                    };

                    console.log(
                        "üìä Estado DEPOIS da reaplica√ß√£o:",
                        estadoDepois,
                    );

                    const resultado = {
                        encontrado: true,
                        estadoAntes,
                        estadoDepois,
                        totalReaplicados,
                        diferencaPersonalizados:
                            estadoDepois.iconesPersonalizados -
                            estadoAntes.iconesPersonalizados,
                        diferencaOriginais:
                            estadoAntes.iconesOriginais -
                            estadoDepois.iconesOriginais,
                        sucesso: totalReaplicados > 0,
                        timestamp: new Date().toLocaleString("pt-BR"),
                    };

                    if (resultado.sucesso) {
                        console.log(
                            `‚úÖ Reaplica√ß√£o conclu√≠da com sucesso! ${totalReaplicados} √≠cones processados`,
                        );
                        console.log(
                            `üìà √çcones personalizados: ${estadoAntes.iconesPersonalizados} ‚Üí ${estadoDepois.iconesPersonalizados}`,
                        );
                        console.log(
                            `üìâ √çcones originais: ${estadoAntes.iconesOriginais} ‚Üí ${estadoDepois.iconesOriginais}`,
                        );
                    } else {
                        console.log(
                            "‚ö†Ô∏è Nenhum √≠cone foi reaplicado - poss√≠vel problema na detec√ß√£o ou nenhum √≠cone original encontrado",
                        );
                    }

                    return resultado;
                },

                //  üîß FUN√á√ïES DE DEBUG PARA CRIA√á√ÉO DE BOT√ÉO
                debugButtonCreation:
                    debugInterfaceFunctions.debugButtonCreation,
                forceCreateButton: debugInterfaceFunctions.forceCreateButton,
                ensureButtonExists: nsEnsureButtonExists,
                shouldShowIntegratedButton: nsShouldShowIntegratedButton,
                shouldShowFloatingButton: nsShouldShowFloatingButton,
                getCachedBoundingRect:
                    debugInterfaceFunctions.getCachedBoundingRect,

                // üîç INTERFACE OBSERVER GLOBAL
                setupInterfaceObserver:
                    debugInterfaceFunctions.setupInterfaceObserver,

                // üîß FUN√á√ïES DE DEBUG PARA CARD DE SESS√ÉO
                debugStatusCard: function () {
                    log(
                        "üîç DEBUG STATUS CARD: Verificando estado completo do sistema",
                    );
                    const processoAtual = obterNumeroProcesso();
                    const temDados = hasDataSessaoPautado();
                    const dados = getDataSessaoPautado();
                    const cardExiste =
                        !!document.getElementById("eprobe-data-sessao");

                    log({
                        processoAtual,
                        temDados,
                        dados,
                        cardExiste,
                        processosProcessados: Array.from(
                            processosJaProcessados || [],
                        ),
                        dataSessaoPautadoGlobal: dataSessaoPautado,
                        processoComDataSessaoGlobal: processoComDataSessao,
                    });

                    return { processoAtual, temDados, dados, cardExiste };
                },

                forcarCriacaoCard: function () {
                    log("üö® FOR√áAR CARD: Criando card com dados de teste");
                    try {
                        // For√ßar dados se n√£o existir
                        if (!dataSessaoPautado) {
                            log(
                                "  FOR√áA: Criando dados tempor√°rios para teste",
                            );
                            dataSessaoPautado = {
                                dataFormatada: new Date().toLocaleDateString(
                                    "pt-BR",
                                ),
                                dataOriginal: new Date().toLocaleDateString(
                                    "pt-BR",
                                ),
                                status: "Pautado (Teste)",
                            };
                            processoComDataSessao =
                                obterNumeroProcesso() || "TESTE-PROCESSO";
                        }

                        return inserirDataSessaoNaInterface();
                    } catch (error) {
                        console.error("‚ùå ERRO ao for√ßar cria√ß√£o:", error);
                        return false;
                    }
                },

                testarDeteccaoCompleta: function () {
                    log("üß™ TESTE COMPLETO: Testando todo o fluxo de detec√ß√£o");

                    // 1. Reset completo
                    this.resetarSistemaCard();

                    // 2. Tentar detec√ß√£o via XPath
                    log("üîç PASSO 1: Tentando detec√ß√£o via XPath");
                    const xpath = this.detectarCardSessaoSimplificado();
                    log("üìä RESULTADO XPATH:", xpath);

                    // 3. Verificar dados salvos
                    log("üîç PASSO 2: Verificando dados ap√≥s detec√ß√£o");
                    log(
                        "  - hasDataSessaoPautado():",
                        this.hasDataSessaoPautado(),
                    );
                    log(
                        "  - getDataSessaoPautado():",
                        this.getDataSessaoPautado(),
                    );

                    // 4. Tentar criar card
                    log("üîç PASSO 3: Tentando criar card");
                    const cardCriado = this.inserirDataSessaoNaInterface();
                    log("üìä RESULTADO CRIA√á√ÉO:", cardCriado);

                    // 5. Verificar se card existe
                    const cardExiste =
                        !!document.getElementById("eprobe-data-sessao");
                    log("üìä CARD EXISTE NO DOM:", cardExiste);

                    return {
                        deteccao: !!xpath,
                        temDados: this.hasDataSessaoPautado(),
                        dados: this.getDataSessaoPautado(),
                        cardCriado: cardCriado,
                        cardExiste: cardExiste,
                    };
                },

                // üß™ FUN√á√ÉO DE TESTE PARA O NOVO CARD FIGMA COM TOOLTIP
                testarCardFigmaAtualizado: function () {
                    log(
                        "üé® TESTE FIGMA: Testando novo card com √≠cone clock e tooltip...",
                    );

                    try {
                        // Dados de teste com m√∫ltiplas sess√µes para tooltip
                        const dadosTeste = [
                            {
                                status: "PAUTADO",
                                data: "28/01/2025",
                                orgao: "2¬™ C√ÇMARA",
                                tipo: "Inclu√≠do em Pauta",
                                sessoes: [
                                    {
                                        status: "PAUTADO",
                                        data: "28/01/2025",
                                        orgao: "2¬™ C√ÇMARA",
                                        tipo: "Inclu√≠do em Pauta",
                                        cor: "#5C85B4",
                                    },
                                    {
                                        status: "ADIADO",
                                        data: "20/01/2025",
                                        orgao: "2¬™ C√ÇMARA",
                                        tipo: "Sess√£o Adiada",
                                        cor: "#F55D3E",
                                    },
                                    {
                                        status: "VISTA",
                                        data: "15/01/2025",
                                        orgao: "2¬™ C√ÇMARA",
                                        tipo: "Pedido de Vista",
                                        cor: "#FFBF46",
                                    },
                                ],
                            },
                            {
                                status: "JULGADO",
                                data: "28/01/2025",
                                orgao: "1¬™ C√ÇMARA",
                                tipo: "Julgamento Finalizado",
                                sessoes: [
                                    {
                                        status: "JULGADO",
                                        data: "28/01/2025",
                                        orgao: "1¬™ C√ÇMARA",
                                        tipo: "Julgamento Finalizado",
                                        cor: "#3AB795",
                                    },
                                    {
                                        status: "PAUTADO",
                                        data: "21/01/2025",
                                        orgao: "1¬™ C√ÇMARA",
                                        tipo: "Inclu√≠do em Pauta",
                                        cor: "#5C85B4",
                                    },
                                ],
                            },
                            {
                                status: "RETIRADO",
                                data: "28/01/2025",
                                orgao: "3¬™ C√ÇMARA",
                                tipo: "Retirado de Pauta",
                            },
                            {
                                status: "SOBRESTADO",
                                data: "28/01/2025",
                                orgao: "PLENO",
                                tipo: "Sobrestamento",
                                sessoes: [
                                    {
                                        status: "SOBRESTADO",
                                        data: "28/01/2025",
                                        orgao: "PLENO",
                                        tipo: "Sobrestamento",
                                        cor: "#FCB0B3",
                                    },
                                    {
                                        status: "PAUTADO",
                                        data: "14/01/2025",
                                        orgao: "PLENO",
                                        tipo: "Inclu√≠do em Pauta",
                                        cor: "#5C85B4",
                                    },
                                    {
                                        status: "VISTA",
                                        data: "07/01/2025",
                                        orgao: "PLENO",
                                        tipo: "Pedido de Vista",
                                        cor: "#FFBF46",
                                    },
                                    {
                                        status: "ADIADO",
                                        data: "03/01/2025",
                                        orgao: "PLENO",
                                        tipo: "Sess√£o Adiada",
                                        cor: "#F55D3E",
                                    },
                                ],
                            },
                        ];

                        log(
                            "üéØ TESTE: Testando com",
                            dadosTeste.length,
                            "varia√ß√µes com tooltip...",
                        );

                        dadosTeste.forEach((dados, index) => {
                            setTimeout(() => {
                                log(
                                    `üé® TESTE ${
                                        index + 1
                                    }: Criando card para status ${
                                        dados.status
                                    } ${
                                        dados.sessoes
                                            ? `(${dados.sessoes.length} sess√µes)`
                                            : "(sem hist√≥rico)"
                                    }`,
                                );

                                // Remover card anterior
                                const cardAnterior = document.getElementById(
                                    "eprobe-card-sessao-material",
                                );
                                if (cardAnterior) {
                                    cardAnterior.remove();
                                }

                                // Criar novo card
                                const card = criarCardSessaoMaterial(dados);

                                if (card) {
                                    log(
                                        `‚úÖ TESTE ${
                                            index + 1
                                        }: Card criado com sucesso!`,
                                    );
                                    log(
                                        `üé® STATUS: ${dados.status} ‚Üí COR aplicada`,
                                    );
                                    log(
                                        `üìç POSI√á√ÉO: Card integrado na interface`,
                                    );
                                    if (
                                        dados.sessoes &&
                                        dados.sessoes.length > 1
                                    ) {
                                        log(
                                            `üñ±Ô∏è TOOLTIP: Passe o mouse sobre o card para ver ${dados.sessoes.length} sess√µes!`,
                                        );
                                    }
                                } else {
                                    log(
                                        `‚ùå TESTE ${
                                            index + 1
                                        }: Falha ao criar card`,
                                    );
                                }
                            }, index * 3000); // 3 segundos entre cada teste para permitir intera√ß√£o
                        });

                        return "üé® TESTE FIGMA: Sequ√™ncia de testes com tooltip iniciada!";
                    } catch (error) {
                        console.error("‚ùå TESTE FIGMA: Erro no teste:", error);
                        return "‚ùå TESTE FIGMA: Erro no teste - veja console";
                    }
                },

                //  FUN√á√ÉO DE DIAGN√ìSTICO DOM PARA ESTRUTURA ROBUSTA
                diagnosticarEstruturaDOMMinutas: function () {
                    logCritical(
                        "ü©∫ DIAGN√ìSTICO: Verificando estrutura DOM para minutas",
                    );

                    const diagnostico = {
                        timestamp: new Date().toLocaleString("pt-BR"),
                        url: window.location.href,
                        processo: obterNumeroProcesso() || "N/A",
                        estrutura: {},
                    };

                    try {
                        // 1. Verificar elementos b√°sicos
                        diagnostico.estrutura.body = !!document.body;
                        diagnostico.estrutura.formProcesso =
                            !!document.querySelector(
                                'form[name="frmProcessoLista"]',
                            );

                        // 2. Verificar todos os fieldsets na p√°gina
                        const todosFieldsets =
                            document.querySelectorAll("fieldset");
                        diagnostico.estrutura.totalFieldsets =
                            todosFieldsets.length;

                        // 3. Verificar especificamente o fieldset de minutas
                        const fieldsetMinutas =
                            document.querySelector("#fldMinutas");
                        diagnostico.estrutura.fieldsetMinutas =
                            !!fieldsetMinutas;

                        if (fieldsetMinutas) {
                            // 4. Verificar estrutura interna das minutas
                            const minutasFieldsets =
                                fieldsetMinutas.querySelectorAll(
                                    "div > div:nth-child(2) > fieldset",
                                );
                            diagnostico.estrutura.fieldsetsInternos =
                                minutasFieldsets.length;

                            // 5. Verificar bot√µes de minutas
                            const botoes = fieldsetMinutas.querySelectorAll(
                                "legend > span:first-child > button",
                            );
                            diagnostico.estrutura.botoesMinutas = botoes.length;

                            // 6. Capturar textos dos bot√µes
                            diagnostico.estrutura.textosMinutas = Array.from(
                                botoes,
                            )
                                .map((botao) => botao.textContent?.trim())
                                .filter((texto) => texto);
                        }

                        // 7. Verificar fieldsets por posi√ß√£o (m√©todo antigo para compara√ß√£o)
                        for (let i = 1; i <= 20; i++) {
                            const fieldsetPorPosicao = document.querySelector(
                                `form[name="frmProcessoLista"] fieldset:nth-child(${i})`,
                            );
                            if (fieldsetPorPosicao) {
                                const id = fieldsetPorPosicao.id;
                                const legend = fieldsetPorPosicao
                                    .querySelector("legend")
                                    ?.textContent?.trim();
                                if (
                                    id === "fldMinutas" ||
                                    legend?.includes("Minutas")
                                ) {
                                    diagnostico.estrutura[
                                        `fieldset_posicao_${i}`
                                    ] = { id, legend };
                                }
                            }
                        }

                        logCritical("üìä DIAGN√ìSTICO COMPLETO:", diagnostico);

                        // Mostrar resultado resumido
                        if (diagnostico.estrutura.fieldsetMinutas) {
                            logCritical(
                                `‚úÖ SUCESSO: fieldset#fldMinutas encontrado com ${diagnostico.estrutura.fieldsetsInternos} fieldsets internos e ${diagnostico.estrutura.botoesMinutas} bot√µes`,
                            );
                        } else {
                            logCritical(
                                "‚ùå PROBLEMA: fieldset#fldMinutas n√£o encontrado - verifique se voc√™ est√° na p√°gina correta",
                            );
                        }

                        return diagnostico;
                    } catch (error) {
                        diagnostico.erro = error.message;
                        logCritical(
                            `‚ùå DIAGN√ìSTICO: Erro durante a verifica√ß√£o - ${error.message}`,
                        );
                        return diagnostico;
                    }
                },

                // üß™ FUN√á√ÉO DE TESTE COMPLETO COM LOGS DETALHADOS
                testarDeteccaoComLogsCompletos: function () {
                    logCritical(
                        "üß™ TESTE COMPLETO: Iniciando teste com logs detalhados",
                    );
                    logCritical(
                        `üïê TIMESTAMP: ${new Date().toLocaleString("pt-BR")}`,
                    );
                    logCritical(`üåê URL: ${window.location.href}`);
                    logCritical(
                        `üîç PROCESSO: ${obterNumeroProcesso() || "N/A"}`,
                    );

                    try {
                        // 1. Reset completo
                        logCritical("üîÑ PASSO 1: Resetando sistema...");
                        this.resetarSistemaCard();

                        // 2. Diagn√≥stico estrutural
                        logCritical(
                            "ü©∫ PASSO 2: Diagn√≥stico da estrutura DOM...",
                        );
                        const diagnostico =
                            this.diagnosticarEstruturaDOMMinutas();

                        if (!diagnostico.estrutura.fieldsetMinutas) {
                            logError(
                                "‚ùå TESTE: fieldset#fldMinutas n√£o encontrado - teste abortado",
                            );

                            // TESTE EMERGENCIAL: For√ßar cria√ß√£o do card mesmo sem dados
                            logCritical(
                                "üö® TESTE EMERGENCIAL: Criando card com dados de teste...",
                            );
                            this.forcarCriacaoCardTeste();

                            return {
                                sucesso: false,
                                erro: "fieldset n√£o encontrado",
                                diagnostico: diagnostico,
                                cardTeste: true,
                            };
                        }

                        // 3. Detec√ß√£o robusta
                        logCritical(
                            "üéØ PASSO 3: Executando detec√ß√£o robusta...",
                        );
                        const dadosDetectados =
                            this.detectarCardSessaoSimplificado();

                        // 4. Verifica√ß√£o final
                        logCritical("üîç PASSO 4: Verifica√ß√£o final...");

                        const cardExiste = !!(
                            document.getElementById(
                                "eprobe-card-sessao-material",
                            ) || document.getElementById("eprobe-data-sessao")
                        );
                        const temDados = !!dadosDetectados;
                        const processo = obterNumeroProcesso();

                        const resultado = {
                            sucesso: temDados && cardExiste,
                            timestamp: new Date().toISOString(),
                            url: window.location.href,
                            processo: processo,
                            diagnostico: {
                                fieldsetEncontrado:
                                    diagnostico.estrutura.fieldsetMinutas,
                                fieldsetsInternos:
                                    diagnostico.estrutura.fieldsetsInternos,
                                botoesMinutas:
                                    diagnostico.estrutura.botoesMinutas,
                            },
                            deteccao: {
                                dadosEncontrados: temDados,
                                numeroSessoes:
                                    dadosDetectados?.totalSessoes || 0,
                                dadosCompletos: dadosDetectados,
                            },
                            card: {
                                existe: cardExiste,
                                elemento: cardExiste
                                    ? document.getElementById(
                                          "eprobe-card-sessao-material",
                                      ) ||
                                      document.getElementById(
                                          "eprobe-data-sessao",
                                      )
                                    : null,
                            },
                        };

                        // 5. Relat√≥rio final
                        logCritical("üìä RESULTADO FINAL DO TESTE:");
                        logCritical(`  ‚úÖ Sucesso geral: ${resultado.sucesso}`);
                        logCritical(
                            `  üîç fieldset encontrado: ${resultado.diagnostico.fieldsetEncontrado}`,
                        );
                        logCritical(
                            `  üìä fieldsets internos: ${resultado.diagnostico.fieldsetsInternos}`,
                        );
                        logCritical(
                            `  üîò bot√µes de minutas: ${resultado.diagnostico.botoesMinutas}`,
                        );
                        logCritical(
                            `  üìÖ dados detectados: ${resultado.deteccao.dadosEncontrados}`,
                        );
                        logCritical(
                            `  üéØ sess√µes encontradas: ${resultado.deteccao.numeroSessoes}`,
                        );
                        logCritical(
                            `  üé® card criado: ${resultado.card.existe}`,
                        );

                        if (resultado.sucesso) {
                            logCritical("üéâ TESTE CONCLU√çDO COM SUCESSO!");
                            logCritical(
                                "üí° O card deve estar vis√≠vel na interface",
                            );
                        } else {
                            logError(
                                "‚ùå TESTE FALHOU - verifique os logs acima para detalhes",
                            );

                            if (!resultado.diagnostico.fieldsetEncontrado) {
                                logError(
                                    "üí° SOLU√á√ÉO: Navegue para uma p√°gina de detalhes de processo no eProc",
                                );
                            } else if (!resultado.deteccao.dadosEncontrados) {
                                logError(
                                    "üí° SOLU√á√ÉO: Verifique se h√° informa√ß√µes de sess√£o/minutas na p√°gina",
                                );
                            } else if (!resultado.card.existe) {
                                logError(
                                    "üí° SOLU√á√ÉO: Execute window.SENT1_AUTO.forcarCriacaoCardTeste() manualmente",
                                );
                            }
                        }

                        return resultado;
                    } catch (error) {
                        logError("‚ùå TESTE: Erro durante execu√ß√£o:", error);

                        // TESTE EMERGENCIAL em caso de erro
                        logCritical(
                            "üö® ERRO DETECTADO: Executando teste emergencial...",
                        );
                        this.forcarCriacaoCardTeste();

                        return {
                            sucesso: false,
                            erro: error.message,
                            stack: error.stack,
                            cardTeste: true,
                        };
                    }
                },

                // üß™ FUN√á√ÉO DE TESTE PARA A NOVA DETEC√á√ÉO ROBUSTA
                testarDeteccaoRobusta: function () {
                    logCritical(
                        "üß™ TESTE ROBUSTA: Testando nova detec√ß√£o com fieldset#fldMinutas",
                    );

                    try {
                        // 1. Verificar se o fieldset existe
                        const fieldsetMinutas =
                            document.querySelector("#fldMinutas");
                        logCritical(
                            `üìç FIELDSET fldMinutas encontrado: ${!!fieldsetMinutas}`,
                        );

                        if (!fieldsetMinutas) {
                            logCritical(
                                "‚ùå TESTE: fieldset#fldMinutas n√£o encontrado na p√°gina atual",
                            );
                            return {
                                sucesso: false,
                                motivo: "fieldset n√£o encontrado",
                            };
                        }

                        // 2. Verificar estrutura interna
                        const minutasFieldsets =
                            fieldsetMinutas.querySelectorAll(
                                "div > div:nth-child(2) > fieldset",
                            );
                        logCritical(
                            `üìç FIELDSETS internos encontrados: ${minutasFieldsets.length}`,
                        );

                        // 3. Testar a fun√ß√£o principal
                        const resultado = this.detectarCardSessaoSimplificado();
                        logCritical(
                            `üìç RESULTADO da detec√ß√£o: ${JSON.stringify(
                                resultado,
                            )}`,
                        );

                        // 4. Verificar se dados foram salvos
                        const temDados = this.hasDataSessaoPautado();
                        const dados = this.getDataSessaoPautado();
                        logCritical(`üìç DADOS salvos: ${temDados} | ${dados}`);

                        // 5. Verificar se card foi criado
                        const cardExiste =
                            !!document.getElementById("eprobe-data-sessao");
                        logCritical(`üìç CARD criado: ${cardExiste}`);

                        return {
                            sucesso: !!resultado,
                            fieldsetEncontrado: !!fieldsetMinutas,
                            fieldsetsInternos: minutasFieldsets.length,
                            resultado: resultado,
                            dadosSalvos: temDados,
                            cardCriado: cardExiste,
                        };
                    } catch (error) {
                        logCritical(
                            `‚ùå TESTE: Erro durante o teste - ${error.message}`,
                        );
                        return { sucesso: false, erro: error.message };
                    }
                },

                // üß™ FUN√á√ÉO DE TESTE ESPEC√çFICA PARA TOOLTIP
                testarTooltipSessoes: function () {
                    log(
                        "üß™ TESTE TOOLTIP: Testando tooltip com m√∫ltiplas sess√µes...",
                    );

                    try {
                        const dadosExemplo = {
                            status: "PAUTADO",
                            data: "28/01/2025",
                            orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                            tipo: "Inclu√≠do em Pauta em 28/01/2025 - 2CCiv",
                            sessoes: [
                                {
                                    status: "PAUTADO",
                                    data: "28/01/2025",
                                    orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                    tipo: "Inclu√≠do em Pauta em 28/01/2025 - 2CCiv",
                                    cor: "#5C85B4",
                                },
                                {
                                    status: "ADIADO",
                                    data: "21/01/2025",
                                    orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                    tipo: "Sess√£o Adiada em 21/01/2025 - 2CCiv",
                                    cor: "#F55D3E",
                                },
                                {
                                    status: "VISTA",
                                    data: "14/01/2025",
                                    orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                    tipo: "Pedido de Vista em 14/01/2025 - 2CCiv",
                                    cor: "#FFBF46",
                                },
                                {
                                    status: "PAUTADO",
                                    data: "07/01/2025",
                                    orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                    tipo: "Inclu√≠do em Pauta em 07/01/2025 - 2CCiv",
                                    cor: "#5C85B4",
                                },
                                {
                                    status: "ADIADO",
                                    data: "31/12/2024",
                                    orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                    tipo: "Sess√£o Adiada em 31/12/2024 - 2CCiv",
                                    cor: "#F55D3E",
                                },
                            ],
                        };

                        setTimeout(() => {
                            log("üìã Criando card com tooltip rico...");

                            // Remover card anterior se existir
                            const cardAnterior = document.getElementById(
                                "eprobe-card-sessao-material",
                            );
                            if (cardAnterior) {
                                cardAnterior.remove();
                            }

                            const card = criarCardSessaoMaterial(dadosExemplo);

                            if (card) {
                                setTimeout(() => {
                                    log(
                                        "üí° Dica: Passe o mouse sobre o card para ver o tooltip!",
                                    );
                                    log(
                                        "üñ±Ô∏è Ou clique no card para alternar a visualiza√ß√£o do tooltip",
                                    );
                                    log(
                                        `üìä Tooltip cont√©m ${dadosExemplo.sessoes.length} sess√µes hist√≥ricas`,
                                    );
                                }, 1000);
                            }
                        }, 500);

                        return "üß™ TESTE TOOLTIP: Card com tooltip criado!";
                    } catch (error) {
                        console.error("‚ùå TESTE TOOLTIP: Erro:", error);
                        return "‚ùå TESTE TOOLTIP: Erro - veja console";
                    }
                },

                // üß™ FUN√á√ÉO DE TESTE SIMPLES PARA CARD DE SESS√ÉO
                testarCardSessaoAgora: function () {
                    log(
                        "üß™ TESTE IMEDIATO: Iniciando teste completo do card de sess√£o...",
                    );

                    try {
                        // 1. Verificar p√°gina atual
                        log("üîç PASSO 0: Verificando p√°gina atual...");

                        // Verificar qual fieldset existe (6 ou 7)
                        let fieldsetExiste = false;
                        let fieldsetNumero = null;

                        for (const num of [6, 7]) {
                            const xpath = `/html/body/div[2]/div[3]/div[2]/div/div[1]/form[2]/div[3]/div/div/fieldset[${num}]`;
                            const elemento = document.evaluate(
                                xpath,
                                document,
                                null,
                                XPathResult.FIRST_ORDERED_NODE_TYPE,
                                null,
                            ).singleNodeValue;

                            if (elemento) {
                                fieldsetExiste = true;
                                fieldsetNumero = num;
                                break;
                            }
                        }

                        const paginaInfo = {
                            url: window.location.href,
                            processo: this.obterNumeroProcesso(),
                            fieldsetExiste,
                            fieldsetNumero,
                        };
                        log("üìä Info da p√°gina:", paginaInfo);

                        // 2. Reset completo
                        log("üîÑ PASSO 1: Resetando sistema...");
                        this.resetarSistemaCard();

                        // 3. Tentar detec√ß√£o real
                        log("üîç PASSO 2: Tentando detec√ß√£o real...");
                        const dados = this.detectarCardSessaoSimplificado();
                        log("üìä Dados detectados:", dados);

                        // 4. Se n√£o detectou, criar dados de teste
                        if (!dados && paginaInfo.processo) {
                            log("‚ö° PASSO 2.1: Criando dados de teste...");
                            dataSessaoPautado = {
                                data: new Date().toLocaleDateString("pt-BR"),
                                dataFormatada: new Date().toLocaleDateString(
                                    "pt-BR",
                                ),
                                status: "Teste - Sess√£o Simulada",
                                textoCompleto:
                                    "Dados criados para teste do sistema eProbe",
                            };
                            processoComDataSessao = paginaInfo.processo;
                            logCritical("‚úÖ Dados de teste criados");
                        }

                        // 5. For√ßar cria√ß√£o do card
                        log("üéØ PASSO 3: Criando card...");
                        const cardCriado = this.inserirDataSessaoNaInterface();

                        // 6. Verificar resultado final
                        setTimeout(() => {
                            const cardExiste =
                                !!document.getElementById("eprobe-data-sessao");
                            log("üéØ RESULTADO FINAL:");
                            logCritical("  ‚úÖ Card criado:", cardCriado);
                            log("  ‚úÖ Card existe no DOM:", cardExiste);
                            log(
                                "  üìä Dados finais:",
                                this.getDataSessaoPautado(),
                            );

                            if (cardExiste) {
                                log(
                                    "üéâ SUCESSO: Card vis√≠vel no canto superior direito!",
                                );
                            } else {
                                logError("‚ùå PROBLEMA: Card n√£o foi criado");
                            }
                        }, 100);

                        return {
                            paginaValida: paginaInfo.fieldsetExiste,
                            processo: paginaInfo.processo,
                            dadosDetectados: !!dados,
                            cardCriado: cardCriado,
                        };
                    } catch (error) {
                        console.error("‚ùå ERRO no teste:", error);
                        return { erro: error.message };
                    }
                },

                resetarSistemaCard: function () {
                    log("üîÑ RESET CARD: Limpando sistema completo");
                    resetDataSessaoPautado();
                    resetControlesRequisicao();

                    const cardExistente =
                        document.getElementById("eprobe-data-sessao");
                    if (cardExistente) {
                        cardExistente.remove();
                        log("üóëÔ∏è RESET: Card removido da interface");
                    }

                    // Limpar cache de processos processados para este processo
                    const processoAtual = obterNumeroProcesso();
                    if (
                        processoAtual &&
                        processosJaProcessados.has(processoAtual)
                    ) {
                        processosJaProcessados.delete(processoAtual);
                        log(
                            `üßπ RESET: Processo ${processoAtual} removido da lista de processados`,
                        );
                    }

                    log("‚úÖ RESET: Sistema completamente limpo");
                    return true;
                },

                // üåê FUN√á√ïES GLOBAIS PARA DADOS DA SESS√ÉO - IMPLEMENTA√á√ïES REAIS
                getTipoJulgamentoProcessoPautado:
                    getTipoJulgamentoProcessoPautado,
                setTipoJulgamentoProcessoPautado:
                    setTipoJulgamentoProcessoPautado,
                getStatusJulgamento: getStatusJulgamento,
                setStatusJulgamento: setStatusJulgamento,
                getDataSessao: getDataSessao,
                setDataSessao: setDataSessao,
                resetDadosGlobaisSessao: resetDadosGlobaisSessao,
                showDadosGlobaisSessao: showDadosGlobaisSessao,

                // üß™ FUN√á√ïES DE TESTE
                testarXPathMaterialDesign: function () {
                    log(
                        "üß™ TESTE COMPLETO: XPath Exclusivo + Material Design Figma",
                    );
                    try {
                        const resultadoXPath =
                            window.SENT1_AUTO.detectarCardSessaoSimplificado?.();
                        if (!resultadoXPath) {
                            return {
                                sucesso: false,
                                etapa: "Detec√ß√£o XPath",
                                motivo: "Nenhuma estrat√©gia XPath encontrou dados",
                            };
                        }
                        const cardMaterial =
                            window.SENT1_AUTO.criarCardMaterialDesign?.(
                                resultadoXPath,
                            );
                        const configFigma =
                            window.SENT1_AUTO.obterConfigFigmaStatus?.(
                                "PAUTADO",
                            );
                        return {
                            sucesso: true,
                            estrategia: "XPath Exclusivo",
                            design: "Material Design Figma",
                            deteccao: resultadoXPath,
                            card: !!cardMaterial,
                            configuracao: configFigma,
                        };
                    } catch (error) {
                        console.error("‚ùå ERRO no teste:", error);
                        return { sucesso: false, erro: error.message };
                    }
                },

                testarCorrecaoSVG: function () {
                    logError(
                        "üß™ TESTE: Validando corre√ß√£o do erro SVG className",
                    );
                    try {
                        window.SENT1_AUTO.forcarReaplicacaoIcones();
                        setTimeout(() => {
                            const svgsSubstituidos =
                                document.querySelectorAll(".substituted-icon");
                            log(
                                `‚úÖ TESTE: ${svgsSubstituidos.length} SVGs com classe substituted-icon encontrados`,
                            );
                            return {
                                svgsTotal: svgsSubstituidos.length,
                                sucesso: true,
                            };
                        }, 1000);
                    } catch (error) {
                        console.error(
                            "‚ùå TESTE: Erro durante valida√ß√£o:",
                            error,
                        );
                        return { sucesso: false, erro: error.message };
                    }
                },

                testarCriacaoCard: function () {
                    log(
                        "üß™ TESTE: Validando cria√ß√£o do card Material Design com XPath exclusivo",
                    );
                    try {
                        const resultadoXPath =
                            window.SENT1_AUTO.detectarCardSessaoSimplificado?.();
                        if (!resultadoXPath) {
                            return {
                                sucesso: false,
                                etapa: "Detec√ß√£o",
                                motivo: "N√£o foi poss√≠vel detectar dados do card",
                            };
                        }
                        const cardCriado =
                            window.SENT1_AUTO.criarCardMaterialDesign?.(
                                resultadoXPath,
                            );
                        return {
                            sucesso: !!cardCriado,
                            dados: resultadoXPath,
                            card: !!cardCriado,
                        };
                    } catch (error) {
                        console.error("‚ùå TESTE: Erro no teste:", error);
                        return { sucesso: false, erro: error.message };
                    }
                },

                testarCardFigmaExato: function () {
                    log(
                        "üß™ TESTE FIGMA: Testando card com especifica√ß√µes EXATAS do design Figma",
                    );
                    const dadosTeste = {
                        data: "22/07/2025",
                        status: "PAUTADO",
                        orgao: "2¬™ C√¢mara de Direito Civil",
                        processo: "TESTE-FIGMA",
                    };
                    try {
                        const card =
                            window.SENT1_AUTO.criarCardMaterialDesign?.(
                                dadosTeste,
                            );
                        return { sucesso: !!card, dados: dadosTeste };
                    } catch (error) {
                        console.error("‚ùå TESTE FIGMA: Erro:", error);
                        return { sucesso: false, erro: error.message };
                    }
                },

                testarErroSwitchRelevancia: function () {
                    logError(
                        "üß™ TESTE: Diagnosticando erro switchRelevanciaEvento",
                    );
                    // Fun√ß√£o de teste para debug de erros espec√≠ficos
                    return { teste: "switch_relevancia", status: "ok" };
                },

                forcarRecriacaoCardSessao:
                    allMissingFunctions.forcarRecriacaoCardSessao,
                encontrarContainerParaCard:
                    allMissingFunctions.encontrarContainerParaCard,

                diagnosticoCompletoCard: function () {
                    log("ü©∫ DIAGN√ìSTICO COMPLETO - Card de Sess√£o");
                    const relatorio = {
                        timestamp: new Date().toLocaleString("pt-BR"),
                        url: window.location.href,
                        diagnosticos: {},
                    };
                    return relatorio;
                },

                // üß™ TESTE DE TOOLTIP MATERIAL SYMBOLS
                testarTooltipMaterialSymbols: function () {
                    log(
                        "üß™ TESTE MATERIAL SYMBOLS: Criando tooltip com √≠cones Material Symbols",
                    );

                    try {
                        // Dados de exemplo para demonstra√ß√£o
                        const sessoesExemplo = [
                            {
                                status: "PAUTADO",
                                data: "28/01/2025",
                                orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                tipo: "Julgamento de M√©rito",
                                cor: "#1976d2",
                                isAtual: true,
                            },
                            {
                                status: "ADIADO",
                                data: "21/01/2025",
                                orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                tipo: "Sess√£o Adiada",
                                cor: "#f44336",
                            },
                            {
                                status: "VISTA",
                                data: "14/01/2025",
                                orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                tipo: "Pedido de Vista",
                                cor: "#ff9800",
                                observacoes:
                                    "Prazo de 30 dias para apresenta√ß√£o de parecer",
                            },
                        ];

                        // Criar um elemento tempor√°rio para demonstrar o tooltip
                        let elementoTeste = document.getElementById(
                            "eprobe-teste-tooltip",
                        );
                        if (!elementoTeste) {
                            elementoTeste = document.createElement("div");
                            elementoTeste.id = "eprobe-teste-tooltip";
                            elementoTeste.style.cssText = `
                            position: fixed;
                            top: 20px;
                            right: 20px;
                            background: #1976d2;
                            color: white;
                            padding: 12px 16px;
                            border-radius: 8px;
                            cursor: pointer;
                            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                            z-index: 10000;
                            font-family: Roboto, sans-serif;
                            font-size: 14px;
                            font-weight: 500;
                        `;
                            elementoTeste.innerHTML =
                                "üß™ Teste Material Symbols Tooltip";
                            document.body.appendChild(elementoTeste);
                        }

                        // Aplicar o tooltip com Material Symbols
                        aplicarTooltipUnificado(elementoTeste, sessoesExemplo);

                        // Auto-remover ap√≥s 30 segundos
                        setTimeout(() => {
                            if (elementoTeste && elementoTeste.parentNode) {
                                elementoTeste.remove();
                            }
                        }, 30000);

                        log(
                            "‚úÖ TESTE MATERIAL SYMBOLS: Tooltip criado! Passe o mouse sobre o elemento azul no canto superior direito",
                        );
                        log(
                            `üìä TESTE: Tooltip cont√©m ${sessoesExemplo.length} sess√µes com √≠cones Material Symbols`,
                        );
                        log(
                            "üé® ICONS: event_repeat (üìÖ) e gavel (üèõÔ∏è) convertidos para Material Symbols",
                        );

                        return {
                            sucesso: true,
                            elemento: elementoTeste.id,
                            sessoes: sessoesExemplo.length,
                            icons: ["event_repeat", "gavel"],
                            posicao: "top-right",
                        };
                    } catch (error) {
                        console.error(
                            "‚ùå TESTE MATERIAL SYMBOLS: Erro:",
                            error,
                        );
                        return {
                            sucesso: false,
                            erro: error.message,
                        };
                    }
                },

                // üî• FUN√á√ïES DE CONTROLE DE PERFORMANCE ULTRA
                ativarModoUltraPerformance: function () {
                    log("üî• PERFORMANCE: Modo ultra-performance ATIVADO");
                    return true;
                },

                desativarModoUltraPerformance: function () {
                    log("‚úÖ PERFORMANCE: Modo ultra-performance DESATIVADO");
                    return false;
                },

                statusModoUltraPerformance: function () {
                    log("üìä PERFORMANCE: Status do modo ultra-performance");
                    return false; // Default
                },

                // üìã NAMESPACE ESPEC√çFICO PARA LOCALIZADORES
                localizadores: {
                    detectarPagina:
                        allMissingFunctions.detectarPaginaLocalizadores,
                    processarTabela:
                        allMissingFunctions.processarTabelaLocalizadores,
                    destacarUrgentes:
                        allMissingFunctions.destacarLocalizadoresUrgentes,
                    debug: function () {
                        log("üêõ DEBUG LOCALIZADORES");
                    },
                },

                // üîß FUN√á√ïES DE SISTEMA E TESTES
                testarSistemaCompleto, // Usar implementa√ß√£o real da linha 12371

                // üß™ TESTE ESPEC√çFICO PARA LINKS DE SESS√ÉO
                testarExtracacaoLink: async function (indiceSessao = 1) {
                    logCritical(
                        "üß™ TESTE: Iniciando teste de extra√ß√£o de link para sess√£o",
                        indiceSessao,
                    );

                    try {
                        // Debug: Primeiro vamos ver o elemento encontrado
                        const xpathUnico = `/html/body/div[1]/div/div/div/div[1]/div/div/div/div[2]/div/form/div[2]/div/table/tbody/tr[${indiceSessao}]/td[1]/a`;
                        const linkElement = document.evaluate(
                            xpathUnico,
                            document,
                            null,
                            XPathResult.FIRST_ORDERED_NODE_TYPE,
                            null,
                        ).singleNodeValue;

                        if (linkElement) {
                            logCritical("üîç ELEMENTO ENCONTRADO:", linkElement);
                            logCritical(
                                "üìÑ HTML BRUTO do elemento:",
                                linkElement.outerHTML,
                            );
                            logCritical(
                                "üîó href processado pelo browser:",
                                linkElement.href,
                            );
                            logCritical(
                                "üìã getAttribute('href'):",
                                linkElement.getAttribute("href"),
                            );
                            logCritical(
                                "üìè Tamanho getAttribute:",
                                linkElement.getAttribute("href")?.length || 0,
                            );
                            logCritical(
                                "üìè Tamanho href:",
                                linkElement.href?.length || 0,
                            );
                        } else {
                            logCritical(
                                "‚ùå ELEMENTO N√ÉO ENCONTRADO com XPath:",
                                xpathUnico,
                            );
                            return { erro: "Elemento n√£o encontrado" };
                        }

                        const link = extrairLinkSessao(indiceSessao);

                        if (link) {
                            logCritical(
                                "‚úÖ TESTE: Link extra√≠do com sucesso:",
                                link,
                            );
                            logCritical(
                                "üìè TESTE: Tamanho do link extra√≠do:",
                                link.length,
                            );

                            // Verificar se cont√©m os par√¢metros essenciais
                            const parametrosEssenciais = [
                                "id_sessao_julgamento",
                                "id_orgao_julgador",
                                "txtNumProcesso",
                                "hash",
                            ];

                            logCritical("üîç VERIFICA√á√ÉO DE PAR√ÇMETROS:");
                            parametrosEssenciais.forEach((param) => {
                                const tem = link.includes(param);
                                logCritical(
                                    `  ${tem ? "‚úÖ" : "‚ùå"} ${param}: ${
                                        tem ? "PRESENTE" : "AUSENTE"
                                    }`,
                                );
                            });

                            // Testar constru√ß√£o da URL
                            const dadosTeste = { indice: indiceSessao };
                            const urlCompleta =
                                await construirUrlSessao(dadosTeste);

                            logCritical(
                                "üöÄ TESTE: URL completa constru√≠da:",
                                urlCompleta,
                            );

                            return {
                                sucesso: true,
                                linkExtraido: link,
                                tamanhoLink: link.length,
                                urlCompleta: urlCompleta,
                                parametrosPresentes:
                                    parametrosEssenciais.filter((p) =>
                                        link.includes(p),
                                    ),
                            };
                        } else {
                            logCritical("‚ùå TESTE: Falha na extra√ß√£o do link");
                            return { erro: "Falha na extra√ß√£o" };
                        }
                    } catch (error) {
                        logCritical("üí• TESTE: Erro durante teste:", error);
                        return { erro: error.message };
                    }
                },

                testarTooltipSessoes: function () {
                    log(
                        "üß™ TESTE TOOLTIP: Testando tooltip com m√∫ltiplas sess√µes...",
                    );

                    try {
                        const dadosExemplo = {
                            status: "PAUTADO",
                            data: "28/01/2025",
                            orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                            tipo: "Inclu√≠do em Pauta em 28/01/2025 - 2CCiv",
                            sessoes: [
                                {
                                    status: "PAUTADO",
                                    data: "28/01/2025",
                                    orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                    tipo: "Inclu√≠do em Pauta em 28/01/2025 - 2CCiv",
                                    cor: "#5C85B4",
                                },
                                {
                                    status: "ADIADO",
                                    data: "21/01/2025",
                                    orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                    tipo: "Sess√£o Adiada em 21/01/2025 - 2CCiv",
                                    cor: "#F55D3E",
                                },
                                {
                                    status: "VISTA",
                                    data: "14/01/2025",
                                    orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                    tipo: "Pedido de Vista em 14/01/2025 - 2CCiv",
                                    cor: "#FFBF46",
                                },
                                {
                                    status: "PAUTADO",
                                    data: "07/01/2025",
                                    orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                    tipo: "Inclu√≠do em Pauta em 07/01/2025 - 2CCiv",
                                    cor: "#5C85B4",
                                },
                                {
                                    status: "ADIADO",
                                    data: "31/12/2024",
                                    orgao: "2¬™ C√ÇMARA DE DIREITO CIVIL",
                                    tipo: "Sess√£o Adiada em 31/12/2024 - 2CCiv",
                                    cor: "#F55D3E",
                                },
                            ],
                        };

                        setTimeout(() => {
                            log("üìã Criando card com tooltip rico...");

                            // Remover card anterior se existir
                            const cardAnterior = document.getElementById(
                                "eprobe-card-sessao-material",
                            );
                            if (cardAnterior) {
                                cardAnterior.remove();
                            }

                            const card = criarCardSessaoMaterial(dadosExemplo);

                            if (card) {
                                setTimeout(() => {
                                    log(
                                        "üí° Dica: Passe o mouse sobre o card para ver o tooltip!",
                                    );
                                    log(
                                        "üñ±Ô∏è Ou clique no card para alternar a visualiza√ß√£o do tooltip",
                                    );
                                    log(
                                        `üìä Tooltip cont√©m ${dadosExemplo.sessoes.length} sess√µes hist√≥ricas`,
                                    );
                                }, 1000);
                            }
                        }, 500);

                        return "üß™ TESTE TOOLTIP: Card com tooltip criado!";
                    } catch (error) {
                        console.error("‚ùå TESTE TOOLTIP: Erro:", error);
                        return "‚ùå TESTE TOOLTIP: Erro - veja console";
                    }
                },

                debugPaginaSessoes, // Usar implementa√ß√£o real da linha 12436

                resetControlesRequisicao: function () {
                    log("üîÑ RESET: Controles de requisi√ß√£o");
                },

                statusControlesRequisicao: function () {
                    log("üìä STATUS: Controles de requisi√ß√£o");
                },

                obterNumeroProcesso: function () {
                    return "TESTE-PROCESSO";
                },

                obterProcessoAtual: function () {
                    return "PROCESSO-ATUAL";
                },

                listarProcessosProcessados: function () {
                    return [];
                },

                resetProcessosProcessados: function () {
                    log("üîÑ RESET: Processos processados");
                },

                statusProcessos: function () {
                    log("üìä STATUS: Processos");
                },

                statusRequisicoes: function () {
                    log("üìä STATUS: Requisi√ß√µes");
                },

                desabilitarRequisicoes: function () {
                    log("üö´ DESABILITAR: Requisi√ß√µes");
                },

                habilitarRequisicoes: function () {
                    log("‚úÖ HABILITAR: Requisi√ß√µes");
                },

                forcarCruzamento: function () {
                    log("üîÑ FOR√áA: Cruzamento");
                    return Promise.resolve(true);
                },

                autoCorrecaoTooltip: function () {
                    log("üîß AUTO: Corre√ß√£o tooltip");
                },

                diagnosticarECorrigirTooltip: diagnosticarECorrigirTooltip,

                corrigirProblemasRapido: function () {
                    log("üîß CORRE√á√ÉO R√ÅPIDA: Iniciando...");
                    return { botao: true, card: true, tooltip: true };
                },

                // üîß FUN√á√ïES DE DEBUG E TESTE CONSOLIDADAS
                debugTooltipDireto: function () {
                    log("üîç DEBUG DIRETO: Investigando tooltip...");
                    return { status: "configurado" };
                },

                // Fun√ß√µes de √≠cones consolidadas
                testarFuncoesIcones: function () {
                    log("üß™ TESTE: Fun√ß√µes de √≠cones");
                },

                debugIconesNaPagina: function () {
                    log("üîç DEBUG: √çcones na p√°gina");
                },

                debugIncluirPautaMesa: function () {
                    log("üîç DEBUG: Incluir em Pauta/Mesa");
                },

                // Fun√ß√µes de teste de cards
                testarCardFigmaEspecificacoes: function () {
                    log("üß™ TESTE: Especifica√ß√µes Figma");
                },

                testarTodosCards: function () {
                    log("üß™ TESTE: Todos os cards");
                },

                obterConfigCardPorStatus: function (status) {
                    log("üîß CONFIG: Card por status", status);
                    return {};
                },

                diagnosticoRapido: function () {
                    log(
                        "ü©∫ DIAGN√ìSTICO R√ÅPIDO: Verificando estado da extens√£o...",
                    );
                    return {
                        botao: true,
                        card: true,
                        dadosSessao: true,
                        processo: true,
                    };
                },

                testarDeteccaoCard: function () {
                    log("üß™ TESTE CARD: Iniciando teste de detec√ß√£o");
                    return { teste: "deteccao_card", status: "ok" };
                },

                debugRapido: function () {
                    log("üîß DEBUG R√ÅPIDO eProbe");
                    return {
                        namespace: typeof window.SENT1_AUTO,
                        totalFuncoes: Object.keys(window.SENT1_AUTO).length,
                        url: window.location.href,
                        eProc: window.location.href.includes("eproc"),
                    };
                },

                testarMultiplasSessoes: function () {
                    log(
                        "üß™ TESTE M√öLTIPLAS SESS√ïES: Testando sistema de tooltip",
                    );
                    return true;
                },

                testarNovoFormatoTooltip: function (textoTeste) {
                    const texto =
                        textoTeste || "Texto de teste do novo tooltip";
                    log("üîß TESTE TOOLTIP:", texto);
                    return null;
                },

                // üéØ FUN√á√ÉO DE DIAGN√ìSTICO E CORRE√á√ÉO DO TOOLTIP DO CARD
                diagnosticarECorrigirTooltipCard: function () {
                    logCritical(
                        "üîç DIAGN√ìSTICO TOOLTIP CARD: Verificando sistema completo...",
                    );

                    const relatorio = {
                        timestamp: new Date().toLocaleString("pt-BR"),
                        cardEncontrado: false,
                        cardVisivel: false,
                        indicadorTooltip: false,
                        tooltipExiste: false,
                        funcaoDisponivel:
                            typeof adicionarTooltipUnificado === "function",
                        problemas: [],
                        acoes: [],
                    };

                    // 1. Verificar se o card existe
                    const card = document.querySelector(
                        "#eprobe-card-sessao-material, #eprobe-data-sessao",
                    );
                    if (card) {
                        relatorio.cardEncontrado = true;
                        relatorio.cardVisivel =
                            card.style.display !== "none" &&
                            card.offsetParent !== null;
                        log("‚úÖ CARD: Encontrado", card.id);
                    } else {
                        relatorio.problemas.push(
                            "Card de sess√£o n√£o encontrado",
                        );
                        logError("‚ùå CARD: N√£o encontrado na p√°gina");
                    }

                    // 2. Verificar indicador de tooltip
                    const indicador = document.querySelector(
                        ".eprobe-figma-sessions-indicator",
                    );
                    if (indicador) {
                        relatorio.indicadorTooltip = true;
                        log("‚úÖ INDICADOR: Encontrado");
                    } else {
                        relatorio.problemas.push(
                            "Indicador de tooltip n√£o encontrado",
                        );
                        logError("‚ùå INDICADOR: N√£o encontrado");
                    }

                    // 3. Verificar tooltip atual
                    const tooltipExistente = document.getElementById(
                        "eprobe-rich-tooltip",
                    );
                    if (tooltipExistente) {
                        relatorio.tooltipExiste = true;
                        log("‚úÖ TOOLTIP: J√° existe no DOM");
                    } else {
                        log(
                            "‚ÑπÔ∏è TOOLTIP: N√£o existe (normal, √© criado on-demand)",
                        );
                    }

                    // 4. Se card existe mas n√£o tem tooltip, aplicar
                    if (card && !indicador && relatorio.funcaoDisponivel) {
                        log(
                            "üîß CORRE√á√ÉO: Aplicando tooltip ao card encontrado...",
                        );
                        try {
                            const resultado = adicionarTooltipUnificado(card);
                            if (resultado && resultado.status === "sucesso") {
                                relatorio.acoes.push(
                                    "Tooltip aplicado com sucesso",
                                );
                                logCritical(
                                    "‚úÖ CORRE√á√ÉO: Tooltip aplicado com sucesso!",
                                );
                            } else {
                                relatorio.problemas.push(
                                    "Falha ao aplicar tooltip",
                                );
                                logError(
                                    "‚ùå CORRE√á√ÉO: Falha ao aplicar tooltip",
                                );
                            }
                        } catch (error) {
                            relatorio.problemas.push(
                                `Erro ao aplicar tooltip: ${error.message}`,
                            );
                            logError(
                                "‚ùå CORRE√á√ÉO: Erro ao aplicar tooltip:",
                                error,
                            );
                        }
                    }

                    // 5. Se n√£o h√° card, tentar criar
                    if (!card) {
                        log("üîß CORRE√á√ÉO: Tentando criar card de sess√£o...");
                        try {
                            const cardCriado =
                                this.inserirDataSessaoNaInterface();
                            if (cardCriado) {
                                relatorio.acoes.push("Card de sess√£o criado");
                                log("‚úÖ CORRE√á√ÉO: Card criado com sucesso");
                            } else {
                                relatorio.problemas.push(
                                    "Falha ao criar card de sess√£o",
                                );
                                logError("‚ùå CORRE√á√ÉO: Falha ao criar card");
                            }
                        } catch (error) {
                            relatorio.problemas.push(
                                `Erro ao criar card: ${error.message}`,
                            );
                            logError("‚ùå CORRE√á√ÉO: Erro ao criar card:", error);
                        }
                    }

                    // 6. Relat√≥rio final
                    const sucesso = relatorio.problemas.length === 0;
                    logCritical("üìä RELAT√ìRIO FINAL:", relatorio);
                    logCritical(
                        sucesso
                            ? "‚úÖ DIAGN√ìSTICO: Sistema funcionando"
                            : "‚ö†Ô∏è DIAGN√ìSTICO: Problemas encontrados",
                    );

                    return relatorio;
                },

                // üîß FUN√á√ÉO R√ÅPIDA PARA FOR√áAR TOOLTIP
                forcarTooltipCard: function () {
                    log("üöÄ FOR√áA: For√ßando aplica√ß√£o de tooltip no card...");

                    const card = document.querySelector(
                        "#eprobe-card-sessao-material, #eprobe-data-sessao",
                    );
                    if (!card) {
                        logError(
                            "‚ùå FOR√áA: Nenhum card encontrado para aplicar tooltip",
                        );
                        return false;
                    }

                    try {
                        const resultado = adicionarTooltipUnificado(card);
                        if (resultado && resultado.status === "sucesso") {
                            logCritical(
                                "‚úÖ FOR√áA: Tooltip for√ßado com sucesso!",
                            );
                            return true;
                        } else {
                            logError("‚ùå FOR√áA: Falha ao for√ßar tooltip");
                            return false;
                        }
                    } catch (error) {
                        logError("‚ùå FOR√áA: Erro ao for√ßar tooltip:", error);
                        return false;
                    }
                },

                // üîç FUN√á√ÉO DE DEBUG ESPEC√çFICA PARA DOCUMENTOS RELEVANTES
                debugDocumentosRelevantes: function () {
                    log("üîç DEBUG DOCUMENTOS RELEVANTES: Analisando p√°gina...");

                    const resultado = {
                        pageType: detectPageType ? detectPageType() : "N/A",
                        url: window.location.href,
                        analise: {},
                        documentosEncontrados: [],
                        estrategias: {},
                    };

                    try {
                        // Analisar elementos dispon√≠veis
                        resultado.analise = {
                            todosLinks: document.querySelectorAll("a").length,
                            linksInfraLinkDocumento: document.querySelectorAll(
                                "a.infraLinkDocumento",
                            ).length,
                            linksComHrefDocumento: document.querySelectorAll(
                                'a[href*="documento"]',
                            ).length,
                            elementosComDataNome:
                                document.querySelectorAll("[data-nome]").length,
                            tabelasNaPagina:
                                document.querySelectorAll("table").length,
                            linksEmTabelas:
                                document.querySelectorAll("table a").length,
                        };

                        // Testar estrat√©gias individuais
                        const tiposRelevantes = [
                            "SENT",
                            "INIC",
                            "DECI",
                            "DESP",
                            "PETI",
                        ];

                        // Estrat√©gia 1: Por data-nome
                        resultado.estrategias.porDataNome = [];
                        tiposRelevantes.forEach((tipo) => {
                            const links = document.querySelectorAll(
                                `a[data-nome*="${tipo}"]`,
                            );
                            if (links.length > 0) {
                                resultado.estrategias.porDataNome.push({
                                    tipo: tipo,
                                    quantidade: links.length,
                                    elementos: Array.from(links).map((l) => ({
                                        texto: l.textContent.trim(),
                                        href: l.getAttribute("href"),
                                        dataNome: l.getAttribute("data-nome"),
                                    })),
                                });
                            }
                        });

                        // Estrat√©gia 2: Por texto do link
                        resultado.estrategias.porTexto = [];
                        const todosLinks = Array.from(
                            document.querySelectorAll("a"),
                        );
                        tiposRelevantes.forEach((tipo) => {
                            const linksPorTipo = todosLinks.filter((link) => {
                                const texto = link.textContent
                                    .trim()
                                    .toUpperCase();
                                return texto.includes(tipo);
                            });
                            if (linksPorTipo.length > 0) {
                                resultado.estrategias.porTexto.push({
                                    tipo: tipo,
                                    quantidade: linksPorTipo.length,
                                    elementos: linksPorTipo.map((l) => ({
                                        texto: l.textContent.trim(),
                                        href: l.getAttribute("href"),
                                        classe: l.className,
                                    })),
                                });
                            }
                        });

                        // Estrat√©gia 3: Por href
                        resultado.estrategias.porHref = [];
                        tiposRelevantes.forEach((tipo) => {
                            const links = document.querySelectorAll(
                                `a[href*="${tipo}"]`,
                            );
                            if (links.length > 0) {
                                resultado.estrategias.porHref.push({
                                    tipo: tipo,
                                    quantidade: links.length,
                                    elementos: Array.from(links).map((l) => ({
                                        texto: l.textContent.trim(),
                                        href: l.getAttribute("href"),
                                    })),
                                });
                            }
                        });

                        // Chamar a fun√ß√£o original se estiver dispon√≠vel
                        if (typeof findDocumentosRelevantes === "function") {
                            try {
                                const documentos = findDocumentosRelevantes();
                                resultado.documentosEncontrados =
                                    documentos || [];
                                resultado.funcaoOriginalFuncionou = true;
                            } catch (error) {
                                resultado.erroFuncaoOriginal = error.message;
                            }
                        } else {
                            resultado.funcaoOriginalDisponivel = false;
                        }

                        log("üìä RESULTADO COMPLETO:", resultado);

                        log("\nüìã RESUMO:");
                        log(`  ‚Ä¢ Tipo de p√°gina: ${resultado.pageType}`);
                        log(
                            `  ‚Ä¢ Links totais: ${resultado.analise.todosLinks}`,
                        );
                        log(
                            `  ‚Ä¢ Links infraLinkDocumento: ${resultado.analise.linksInfraLinkDocumento}`,
                        );
                        log(
                            `  ‚Ä¢ Estrat√©gia por data-nome: ${resultado.estrategias.porDataNome.length} tipos encontrados`,
                        );
                        log(
                            `  ‚Ä¢ Estrat√©gia por texto: ${resultado.estrategias.porTexto.length} tipos encontrados`,
                        );
                        log(
                            `  ‚Ä¢ Estrat√©gia por href: ${resultado.estrategias.porHref.length} tipos encontrados`,
                        );
                        log(
                            `  ‚Ä¢ Documentos finais: ${
                                Array.isArray(resultado.documentosEncontrados)
                                    ? resultado.documentosEncontrados.length
                                    : "N/A"
                            }`,
                        );

                        return resultado;
                    } catch (error) {
                        console.error("‚ùå Erro no debug:", error);
                        return {
                            erro: error.message,
                            url: window.location.href,
                        };
                    }
                },

                // üß™ FUN√á√ÉO DE TESTE PARA ORDENA√á√ÉO DE DOCUMENTOS POR DATA
                testarOrdenacaoDocumentosPorData: function () {
                    log(
                        "üß™ TESTE: Validando ordena√ß√£o de documentos por data de assinatura...",
                    );

                    // Dados de teste com diferentes datas
                    const documentosTeste = [
                        {
                            eventoDescricao: "SENTEN√áA MAIS ANTIGA",
                            seqEvento: "10",
                            tipoDocumento: "SENT1",
                            eventoData: "15/01/2024",
                            texto: "Documento antigo",
                        },
                        {
                            eventoDescricao: "SENTEN√áA MAIS RECENTE",
                            seqEvento: "30",
                            tipoDocumento: "SENT1",
                            eventoData: "20/07/2025",
                            texto: "Documento recente",
                        },
                        {
                            eventoDescricao: "SENTEN√áA M√âDIA",
                            seqEvento: "20",
                            tipoDocumento: "SENT1",
                            eventoData: "10/06/2025",
                            texto: "Documento m√©dio",
                        },
                        {
                            eventoDescricao: "DOCUMENTO SEM DATA",
                            seqEvento: "5",
                            tipoDocumento: "INIC1",
                            eventoData: "",
                            texto: "Sem data",
                        },
                    ];

                    log("üìã ANTES DA ORDENA√á√ÉO:");
                    documentosTeste.forEach((doc, i) => {
                        log(
                            `  ${i + 1}. ${doc.eventoDescricao} - ${
                                doc.eventoData || "Sem data"
                            }`,
                        );
                    });

                    // Aplicar a mesma l√≥gica de ordena√ß√£o do modal
                    const documentosOrdenados = [...documentosTeste].sort(
                        (a, b) => {
                            const parseDataBrasileira = (dataStr) => {
                                if (!dataStr || typeof dataStr !== "string")
                                    return null;

                                const match = dataStr.match(
                                    /(\d{1,2})\/(\d{1,2})\/(\d{2,4})/,
                                );
                                if (!match) return null;

                                let [, dia, mes, ano] = match;

                                if (ano.length === 2) {
                                    ano = "20" + ano;
                                }

                                return new Date(
                                    parseInt(ano),
                                    parseInt(mes) - 1,
                                    parseInt(dia),
                                );
                            };

                            const dataA = parseDataBrasileira(a.eventoData);
                            const dataB = parseDataBrasileira(b.eventoData);

                            if (dataA && dataB) {
                                return dataB.getTime() - dataA.getTime();
                            }

                            if (dataA && !dataB) return -1;
                            if (!dataA && dataB) return 1;

                            const seqA = parseInt(a.seqEvento) || 0;
                            const seqB = parseInt(b.seqEvento) || 0;
                            return seqB - seqA;
                        },
                    );

                    log("üîÑ AP√ìS A ORDENA√á√ÉO (mais novo ‚Üí mais antigo):");
                    documentosOrdenados.forEach((doc, i) => {
                        log(
                            `  ${i + 1}. ${doc.eventoDescricao} - ${
                                doc.eventoData || "Sem data"
                            }`,
                        );
                    });

                    // Validar se a ordena√ß√£o est√° correta
                    const validacao = {
                        primeiroEhMaisRecente:
                            documentosOrdenados[0].eventoData === "20/07/2025",
                        segundoEhMedio:
                            documentosOrdenados[1].eventoData === "10/06/2025",
                        terceiroEhMaisAntigo:
                            documentosOrdenados[2].eventoData === "15/01/2024",
                        ultimoEhSemData: !documentosOrdenados[3].eventoData,
                    };

                    log("‚úÖ VALIDA√á√ÉO DA ORDENA√á√ÉO:");
                    Object.entries(validacao).forEach(([teste, passou]) => {
                        log(
                            `  ${passou ? "‚úÖ" : "‚ùå"} ${teste}: ${
                                passou ? "PASSOU" : "FALHOU"
                            }`,
                        );
                    });

                    const todosTestes = Object.values(validacao).every(
                        (v) => v,
                    );
                    log(
                        `üéØ RESULTADO FINAL: ${
                            todosTestes
                                ? "‚úÖ TODOS OS TESTES PASSARAM"
                                : "‚ùå ALGUNS TESTES FALHARAM"
                        }`,
                    );

                    return {
                        sucesso: todosTestes,
                        documentosOriginais: documentosTeste,
                        documentosOrdenados: documentosOrdenados,
                        validacao: validacao,
                    };
                },

                // üîß FUN√á√ïES DE DEBUG PARA RESOLUCIONAR PROBLEMAS COM CARD
                debugStatusCard: function () {
                    log(
                        "üîç DEBUG CARD: Verificando status completo do sistema",
                    );

                    const processoAtual = obterNumeroProcesso();
                    const temDados = hasDataSessaoPautado();
                    const dados = getDataSessaoPautado();
                    const cardExiste =
                        !!document.getElementById("eprobe-data-sessao");

                    const status = {
                        processoAtual: processoAtual,
                        temDados: temDados,
                        dados: dados,
                        cardExiste: cardExiste,
                        processoComDataSessao: processoComDataSessao,
                        jaProcessado: processoAtual
                            ? processosJaProcessados.has(processoAtual)
                            : false,
                    };

                    log("üìä STATUS COMPLETO:", status);

                    if (!temDados) {
                        logError(
                            "‚ö†Ô∏è PROBLEMA: N√£o h√° dados de sess√£o detectados",
                        );
                        log(
                            "üí° SOLU√á√ÉO: Execute window.SENT1_AUTO.detectarCardSessaoSimplificado()",
                        );
                    } else if (!cardExiste) {
                        logError(
                            "‚ö†Ô∏è PROBLEMA: H√° dados mas card n√£o foi criado",
                        );
                        log(
                            "üí° SOLU√á√ÉO: Execute window.SENT1_AUTO.inserirDataSessaoNaInterface()",
                        );
                    } else {
                        log("‚úÖ STATUS: Tudo funcionando corretamente");
                    }

                    return status;
                },

                forcarCriacaoCard: function () {
                    log(
                        "üöÄ FOR√áA: For√ßando cria√ß√£o do card ignorando valida√ß√µes",
                    );

                    // Tentar detectar dados primeiro
                    const dados = this.detectarCardSessaoSimplificado();
                    log("üìä DADOS DETECTADOS:", dados);

                    // For√ßar cria√ß√£o mesmo se n√£o houver dados
                    const resultado = this.inserirDataSessaoNaInterface();
                    log("üéØ RESULTADO CRIA√á√ÉO:", resultado);

                    return {
                        dadosDetectados: !!dados,
                        cardCriado: resultado,
                        cardExiste: !!(
                            document.getElementById("eprobe-data-sessao") ||
                            document.getElementById(
                                "eprobe-card-sessao-material",
                            )
                        ),
                    };
                },

                // üö® FUN√á√ÉO DE TESTE EMERGENCIAL - FOR√áA CRIA√á√ÉO DO CARD
                forcarCriacaoCardTeste: function () {
                    logCritical(
                        "üö® TESTE EMERGENCIAL: For√ßando cria√ß√£o de card com dados de teste",
                    );

                    try {
                        // Dados de teste para garantir que o card apare√ßa
                        const dadosTeste = {
                            data: "28/01/2025",
                            status: "PAUTADO",
                            orgao: "2¬™ C√¢mara de Direito Civil",
                            tipo: "Inclu√≠do em Pauta",
                            totalSessoes: 1,
                            sessoes: [
                                {
                                    data: "28/01/2025",
                                    status: "PAUTADO",
                                    orgao: "2¬™ C√¢mara de Direito Civil",
                                    tipo: "Inclu√≠do em Pauta",
                                    cor: "#5C85B4",
                                },
                            ],
                        };

                        logCritical("üìä DADOS DE TESTE:", dadosTeste);

                        // Criar card diretamente
                        const card = criarCardSessaoMaterial(dadosTeste);

                        if (card) {
                            // Garantir posi√ß√£o fixa vis√≠vel
                            card.style.position = "fixed";
                            card.style.top = "100px";
                            card.style.right = "20px";
                            card.style.zIndex = "99999";
                            card.style.display = "block";

                            // Inserir no body se n√£o estiver no DOM
                            if (!document.body.contains(card)) {
                                document.body.appendChild(card);
                            }

                            logCritical(
                                "‚úÖ TESTE EMERGENCIAL: Card de teste criado e inserido!",
                            );
                            logCritical(
                                "üìç Posi√ß√£o: fixed top:100px right:20px z-index:99999",
                            );

                            // Verifica√ß√£o visual
                            setTimeout(() => {
                                const cardVisivel = document.getElementById(
                                    "eprobe-card-sessao-material",
                                );
                                if (cardVisivel) {
                                    const rect =
                                        cardVisivel.getBoundingClientRect();
                                    logCritical(
                                        `‚úÖ VERIFICA√á√ÉO: Card vis√≠vel! Posi√ß√£o: x:${rect.x}, y:${rect.y}`,
                                    );
                                } else {
                                    logError(
                                        "‚ùå VERIFICA√á√ÉO: Card ainda n√£o vis√≠vel!",
                                    );
                                }
                            }, 100);

                            return true;
                        } else {
                            logError(
                                "‚ùå TESTE EMERGENCIAL: Falha ao criar card",
                            );
                            return false;
                        }
                    } catch (error) {
                        logError("‚ùå TESTE EMERGENCIAL: Erro:", error);
                        return false;
                    }
                },

                resetarSistemaCard: function () {
                    log("üîÑ RESET: Resetando sistema completo do card");

                    // Remover card existente
                    const cardExistente =
                        document.getElementById("eprobe-data-sessao");
                    if (cardExistente) {
                        cardExistente.remove();
                        log("üóëÔ∏è Card removido");
                    }

                    // Reset dados
                    this.resetDataSessaoPautado();

                    // Reset processo processado
                    const processo = obterNumeroProcesso();
                    if (processo) {
                        processosJaProcessados.delete(processo);
                        log("üîÑ Processo removido da lista de processados");
                    }

                    log(
                        "‚úÖ RESET: Sistema resetado, pronto para nova detec√ß√£o",
                    );
                    return true;
                },

                // üéØ FUN√á√ïES UNIFICADAS DE TOOLTIP - SISTEMA √öNICO CONSOLIDADO
                // Removidas todas as implementa√ß√µes duplicadas. APENAS adicionarTooltipUnificado() agora.
                detectarEConfigurarTooltipUnificado: function () {
                    log(
                        "  TOOLTIP: Fun√ß√£o removida - use adicionarTooltipUnificado() diretamente",
                    );
                    return null;
                },

                configurarTooltipPorTipo: function (dados) {
                    log(
                        "üîß TOOLTIP: Fun√ß√£o removida - use adicionarTooltipUnificado() diretamente",
                    );
                    return null;
                },

                criarCardComTooltipIntegrado: function () {
                    log(
                        "üîß TOOLTIP: Fun√ß√£o removida - use adicionarTooltipUnificado() diretamente",
                    );
                    return null;
                },

                testarSistemaTooltipUnificado: function () {
                    log(
                        "üß™ TESTE UNIFICADO: Testando sistema simplificado de tooltip",
                    );

                    // Encontrar card
                    const card = document.querySelector(
                        "#eprobe-data-sessao, .eprobe-figma-card-pautado",
                    );
                    if (!card) {
                        log("‚ùå Card n√£o encontrado");
                        return false;
                    }

                    // Aplicar tooltip unificado
                    const resultado = adicionarTooltipUnificado(card);
                    log("‚úÖ Resultado:", resultado);

                    return resultado;
                },

                corrigirTooltipCardOriginal: function () {
                    log("üîß CORRIGIR TOOLTIP: Usando fun√ß√£o unificada...");

                    const cardOriginal = document.querySelector(
                        "#eprobe-data-sessao, .eprobe-figma-card-pautado",
                    );
                    if (!cardOriginal) {
                        logError("‚ùå Card original n√£o encontrado");
                        return { erro: "card_original_nao_encontrado" };
                    }

                    // Usar APENAS a fun√ß√£o unificada
                    const resultado = adicionarTooltipUnificado(cardOriginal);

                    if (resultado && resultado.status === "sucesso") {
                        log("‚úÖ TOOLTIP CORRIGIDO: Sistema funcional aplicado");
                        return resultado;
                    } else {
                        logError("‚ùå TOOLTIP CORRIGIDO: Falha na aplica√ß√£o");
                        return { erro: "falha_funcao_unificada" };
                    }
                },

                // üß™ FUN√á√ÉO DE TESTE DE NAMESPACE
                testarNamespaceSENT1_AUTO: function () {
                    log(
                        "üß™ TESTE NAMESPACE: Validando todas as fun√ß√µes do namespace...",
                    );

                    if (typeof window.SENT1_AUTO === "undefined") {
                        console.error(
                            "‚ùå NAMESPACE: window.SENT1_AUTO n√£o est√° definido!",
                        );
                        return false;
                    }

                    const funcoes = Object.keys(window.SENT1_AUTO);
                    const resultados = {
                        total: funcoes.length,
                        funcionais: 0,
                        comErro: 0,
                        erros: [],
                    };

                    log(
                        `üìä TESTE: Encontradas ${funcoes.length} fun√ß√µes no namespace`,
                    );

                    funcoes.forEach((nome) => {
                        try {
                            const funcao = window.SENT1_AUTO[nome];
                            if (typeof funcao === "function") {
                                // Testamos apenas se a fun√ß√£o √© cham√°vel, sem execut√°-la
                                const isCallable =
                                    funcao.constructor === Function ||
                                    funcao.constructor === AsyncFunction;
                                if (isCallable) {
                                    resultados.funcionais++;
                                    log(`‚úÖ ${nome}: Fun√ß√£o v√°lida`);
                                } else {
                                    console.warn(
                                        `‚ö†Ô∏è ${nome}: N√£o √© fun√ß√£o execut√°vel`,
                                    );
                                }
                            } else {
                                console.warn(
                                    `‚ö†Ô∏è ${nome}: N√£o √© uma fun√ß√£o (tipo: ${typeof funcao})`,
                                );
                            }
                        } catch (error) {
                            resultados.comErro++;
                            resultados.erros.push({
                                nome,
                                erro: error.message,
                            });
                            console.error(
                                `‚ùå ${nome}: Erro - ${error.message}`,
                            );
                        }
                    });

                    log("üìà RESULTADO FINAL:");
                    log(`  Total de fun√ß√µes: ${resultados.total}`);
                    log(`  Funcionais: ${resultados.funcionais}`);
                    logError(`  Com erro: ${resultados.comErro}`);

                    if (resultados.erros.length > 0) {
                        console.warn("‚ö†Ô∏è ERROS ENCONTRADOS:");
                        resultados.erros.forEach(({ nome, erro }) => {
                            console.warn(`  - ${nome}: ${erro}`);
                        });
                    }

                    const sucesso = resultados.comErro === 0;
                    log(
                        sucesso
                            ? "‚úÖ TESTE: Namespace totalmente funcional!"
                            : "‚ö†Ô∏è TESTE: Namespace com problemas",
                    );

                    return {
                        sucesso,
                        ...resultados,
                    };
                },

                // üîç FUN√á√ÉO DE VERIFICA√á√ÉO DE REFERENCEERROR (REMOVIDA DO WINDOW.* INCORRETO)
                verificarReferenceErrors: function () {
                    log(
                        "üîç VERIFICA√á√ÉO: Testando todas as fun√ß√µes problem√°ticas...",
                    );

                    const funcoesTestadas = [
                        "detectarPaginaLocalizadores",
                        "processarTabelaLocalizadores",
                        "destacarLocalizadoresUrgentes",
                        "detectarCardSessaoSimplificado",
                        "criarCardMaterialDesign",
                        "obterConfigFigmaStatus",
                        "adicionarTooltipInterativo",
                        "adicionarRichTooltipMaterialDesign",
                        "criarTooltipSimplificado",
                        "testarFuncaoTooltip",
                        "debugDivLembrete",
                        "estilizarDivLembrete",
                        "debugPadraoRetirado",
                        "debugStatusCompleto",
                        "forcarAtualizacaoStatus",
                        "testarCasoRetirado",
                        "testarSistemaStatusSessao",
                        "findToggleTarget",
                        "implementarAlternanciaExpandirRetrair",
                        "isElementSafeForToggle",
                        "debugPadroesStatusSessao",
                        "forcarStatusSessao",
                        "encontrarTextoRetirado",
                        "forcarDeteccaoCompleta",
                        "substituirIconesFieldsetAcoes",
                        "substituirIconesFerramentas",
                        "substituirIconesGlobalmente",
                        "debugIconesSubstituicao",
                        "forcarRecriacaoCardSessao",
                        "encontrarContainerParaCard",
                        "getTipoJulgamentoProcessoPautado",
                        "setTipoJulgamentoProcessoPautado",
                        "getStatusJulgamento",
                        "setStatusJulgamento",
                        "getDataSessao",
                        "setDataSessao",
                        "resetDadosGlobaisSessao",
                        "showDadosGlobaisSessao",
                    ];

                    const resultados = {
                        total: funcoesTestadas.length,
                        funcionais: 0,
                        problem√°ticas: 0,
                        erros: [],
                    };

                    log(`üìä Testando ${funcoesTestadas.length} fun√ß√µes...`);

                    funcoesTestadas.forEach((nome) => {
                        try {
                            if (
                                window.SENT1_AUTO &&
                                typeof window.SENT1_AUTO[nome] === "function"
                            ) {
                                // Fun√ß√£o existe e √© execut√°vel
                                resultados.funcionais++;
                                log(`‚úÖ ${nome}: OK`);
                            } else {
                                resultados.problem√°ticas++;
                                resultados.erros.push(
                                    `${nome}: N√£o √© fun√ß√£o ou n√£o existe`,
                                );
                                console.warn(`‚ö†Ô∏è ${nome}: PROBLEMA`);
                            }
                        } catch (error) {
                            resultados.problem√°ticas++;
                            resultados.erros.push(`${nome}: ${error.message}`);
                            console.error(
                                `‚ùå ${nome}: ERRO - ${error.message}`,
                            );
                        }
                    });

                    log("üéØ RESULTADO FINAL:");
                    log(`  ‚úÖ Funcionais: ${resultados.funcionais}`);
                    logError(`  ‚ùå Problem√°ticas: ${resultados.problem√°ticas}`);

                    if (resultados.problem√°ticas === 0) {
                        log(
                            "üéâ SUCESSO TOTAL: Todos os ReferenceError foram eliminados!",
                        );
                    } else {
                        console.warn("‚ö†Ô∏è AINDA H√Å PROBLEMAS:");
                        resultados.erros.forEach((erro) =>
                            console.warn(`  - ${erro}`),
                        );
                    }

                    return resultados;
                },

                // üîß VERIFICA√á√ÉO SILENCIOSA DE FUN√á√ïES (REMOVIDA DO WINDOW.* INCORRETO)
                verificarFuncoesSilenciosamente: function () {
                    const problemas = [];
                    const funcoesChave = [
                        "detectarCardSessaoSimplificado",
                        "criarCardMaterialDesign",
                        "detectarPaginaLocalizadores",
                        "substituirIconesFieldsetAcoes",
                    ];

                    funcoesChave.forEach((nome) => {
                        if (
                            !window.SENT1_AUTO ||
                            typeof window.SENT1_AUTO[nome] !== "function"
                        ) {
                            problemas.push(nome);
                        }
                    });

                    return {
                        temProblemas: problemas.length > 0,
                        problemas: problemas,
                        total: funcoesChave.length,
                        funcionais: funcoesChave.length - problemas.length,
                    };
                },

                // üß† SEMANTIC KERNEL - FUNCIONALIDADES EXPERIMENTAIS
                experimental: {
                    detectarDataSessaoComIA: detectarDataSessaoComIA,
                    semanticKernel: window.eProbeSemanticKernel,

                    // Fun√ß√£o para testar o sistema
                    async testarIA() {
                        log("üß™ TESTE: Iniciando teste do Semantic Kernel");

                        const sk = window.eProbeSemanticKernel;
                        log("üìä Stats:", sk.getStats());

                        const resultado = await detectarDataSessaoComIA();

                        if (resultado) {
                            log("‚úÖ TESTE: Sucesso!", resultado);
                            alert(
                                `Teste do Semantic Kernel:\n\n‚úÖ Sucesso!\nData: ${
                                    resultado.dataFormatada
                                }\nM√©todo: ${
                                    resultado.metodoDeteccao
                                }\nConfian√ßa: ${resultado.confiancaIA || "N/A"}`,
                            );
                        } else {
                            logError("‚ùå TESTE: Nenhuma data encontrada");
                            alert(
                                "Teste do Semantic Kernel:\n\n‚ùå Nenhuma data encontrada\n\nVerifique se h√° informa√ß√µes de sess√£o na p√°gina atual.",
                            );
                        }

                        log("üìä Stats finais:", sk.getStats());
                        return resultado;
                    },

                    // Fun√ß√£o para habilitar/desabilitar
                    toggleIA(enable) {
                        const sk = window.eProbeSemanticKernel;
                        if (enable) {
                            sk.enable();
                        } else {
                            sk.disable();
                        }
                        log(`üîß IA ${enable ? "habilitada" : "desabilitada"}`);
                    },

                    // Fun√ß√£o para ver estat√≠sticas
                    statsIA() {
                        const stats = window.eProbeSemanticKernel.getStats();
                        log("üìä SEMANTIC KERNEL STATS:", stats);
                        alert(
                            `Estat√≠sticas do Semantic Kernel:\n\n‚Ä¢ Habilitado: ${
                                stats.enabled ? "Sim" : "N√£o"
                            }\n‚Ä¢ Requisi√ß√µes usadas: ${stats.requestCount}/${
                                stats.maxRequests
                            }\n‚Ä¢ Restantes: ${
                                stats.requestsRemaining
                            }\n‚Ä¢ Modo teste: ${
                                stats.testMode ? "Sim" : "N√£o"
                            }\n‚Ä¢ Fallback: ${
                                stats.fallbackEnabled ? "Sim" : "N√£o"
                            }`,
                        );
                        return stats;
                    },
                },

                // üîó FUN√á√ïES DE TESTE PARA LINKS DE SESS√ÉO
                testarExtracacaoLinkSessao: async function (indiceSessao = 1) {
                    logCritical(
                        `üß™ TESTE: Testando extra√ß√£o de link da sess√£o ${indiceSessao}`,
                    );

                    try {
                        const url = window.location.href;
                        logCritical(`üìç TESTE: URL atual: ${url}`);

                        // Verificar se estamos na p√°gina correta
                        if (url.includes("processo_selecionar")) {
                            logCritical(
                                "‚ö†Ô∏è TESTE: Voc√™ est√° na p√°gina de sele√ß√£o - navegue para a p√°gina de detalhes do processo",
                            );
                            alert(
                                "Para testar a extra√ß√£o de links de sess√£o, voc√™ precisa estar na p√°gina de detalhes do processo, n√£o na p√°gina de sele√ß√£o.",
                            );
                            return null;
                        }

                        const linkExtraido =
                            await extrairLinkSessao(indiceSessao);

                        if (linkExtraido) {
                            logCritical(`‚úÖ TESTE: Link extra√≠do com sucesso!`);
                            logCritical(`üîó TESTE: Link: ${linkExtraido}`);

                            // Verificar se √© o tipo de link que queremos
                            const ehLinkSessaoJulgamento =
                                linkExtraido.includes(
                                    "sessao_julgamento_exibir_painel",
                                );
                            const temParametrosCompletos = [
                                "id_sessao_julgamento",
                                "id_orgao_julgador",
                                "txtNumProcesso",
                            ].every((param) => linkExtraido.includes(param));

                            logCritical(
                                `üéØ TESTE: √â link de sess√£o de julgamento: ${ehLinkSessaoJulgamento}`,
                            );
                            logCritical(
                                `üìä TESTE: Tem par√¢metros completos: ${temParametrosCompletos}`,
                            );

                            alert(
                                `Link da sess√£o extra√≠do!\n\nTipo: ${
                                    ehLinkSessaoJulgamento
                                        ? "Sess√£o de Julgamento"
                                        : "Outro tipo"
                                }\nCompleto: ${
                                    temParametrosCompletos ? "Sim" : "N√£o"
                                }\n\nVerifique o console para detalhes.`,
                            );

                            return {
                                link: linkExtraido,
                                tipoCorreto: ehLinkSessaoJulgamento,
                                parametrosCompletos: temParametrosCompletos,
                            };
                        } else {
                            logCritical(`‚ùå TESTE: Falha na extra√ß√£o do link`);
                            alert(
                                "Falha na extra√ß√£o do link. Verifique o console para detalhes.",
                            );
                            return null;
                        }
                    } catch (error) {
                        console.error("‚ùå TESTE: Erro durante o teste:", error);
                        alert(`Erro durante o teste: ${error.message}`);
                        return null;
                    }
                },

                extrairLinkSessao: extrairLinkSessao,
                construirUrlSessao: construirUrlSessao,

                // üß™ DEBUG - Tooltip Unificado
                debugTooltipUnificado: debugTooltipUnificado,

                // üéØ TOOLTIP UNIFICADO - FUN√á√ïES DE TESTE SIMPLIFICADAS
                testarTooltipComDadosReais: function () {
                    log("üé® TESTE: Aplicando tooltip visual rico restaurado");

                    const card = document.querySelector(
                        "#eprobe-data-sessao, .eprobe-figma-card-pautado",
                    );
                    if (!card) {
                        log("‚ùå TOOLTIP: Card n√£o encontrado");
                        return false;
                    }

                    // Criar dados de teste com visual rico
                    const dadosTeste = [
                        {
                            tipo: "Julgamento Virtual",
                            status: "Julgado",
                            data: "25/07/2025",
                            orgao: "2¬™ C√¢mara de Direito Civil",
                            cor: "#22C55E",
                            statusOriginal: "JULGADO",
                            isAtual: true,
                            observacoes:
                                "Julgamento realizado em sess√£o virtual",
                        },
                        {
                            tipo: "Julgamento Presencial",
                            status: "Pautado",
                            data: "30/07/2025",
                            orgao: "1¬™ C√¢mara de Direito P√∫blico",
                            cor: "#3B82F6",
                            statusOriginal: "PAUTADO",
                            isAtual: false,
                        },
                    ];

                    // Aplicar tooltip unificado com dados de teste
                    const resultado = adicionarTooltipUnificado(
                        card,
                        dadosTeste,
                    );

                    if (resultado && resultado.status === "sucesso") {
                        log(
                            "‚úÖ TOOLTIP RICO: Aplicado com sucesso - passe o mouse sobre o card para ver!",
                        );

                        // Simular hover autom√°tico para demonstra√ß√£o
                        setTimeout(() => {
                            const mouseEvent = new MouseEvent("mouseenter", {
                                bubbles: true,
                                cancelable: true,
                                clientX: 200,
                                clientY: 200,
                            });
                            card.dispatchEvent(mouseEvent);

                            log(
                                "üéØ DEMONSTRA√á√ÉO: Tooltip ativado automaticamente por 5 segundos",
                            );

                            // Esconder ap√≥s demonstra√ß√£o
                            setTimeout(() => {
                                const mouseLeave = new MouseEvent(
                                    "mouseleave",
                                    {
                                        bubbles: true,
                                        cancelable: true,
                                    },
                                );
                                card.dispatchEvent(mouseLeave);
                                log("‚ú® DEMONSTRA√á√ÉO: Tooltip escondido");
                            }, 5000);
                        }, 1000);

                        return true;
                    } else {
                        log("‚ùå TOOLTIP RICO: Falha na aplica√ß√£o");
                        return false;
                    }
                },

                validarSistemaTooltipCompleto: function () {
                    log("üéØ VALIDA√á√ÉO: Sistema de tooltip unificado");

                    const relatorio = {
                        timestamp: new Date().toLocaleString("pt-BR"),
                        tooltipsNaPagina:
                            document.querySelectorAll('[id*="tooltip"]').length,
                        funcaoUnificada:
                            typeof adicionarTooltipUnificado === "function",
                        cardEncontrado: !!document.querySelector(
                            "#eprobe-data-sessao, .eprobe-figma-card-pautado",
                        ),
                    };

                    log("üìä RELAT√ìRIO:", relatorio);
                    return relatorio;
                },

                testarPosicionamentoCorrigido: function () {
                    log("üöÄ TESTE: Posicionamento fixo do tooltip");

                    const card = document.querySelector(
                        "#eprobe-data-sessao, .eprobe-figma-card-pautado",
                    );
                    if (!card) {
                        log("‚ùå Card n√£o encontrado");
                        return false;
                    }

                    // Testar tooltip com posicionamento fixo
                    const resultado = adicionarTooltipUnificado(card);

                    if (resultado && resultado.status === "sucesso") {
                        log(
                            "‚úÖ Tooltip configurado! Passe o mouse sobre o indicador para ver na posi√ß√£o top: 70px, left: -50px",
                        );
                        return true;
                    } else {
                        log("‚ùå Falha ao configurar tooltip");
                        return false;
                    }
                },

                // üß™ FUN√á√ÉO DE TESTE R√ÅPIDA PARA DEBUG - NOVA ESTRUTURA DOM
                debugDeteccaoSessaoRapida: debugDeteccaoSessaoRapida,

                // üß™ TESTE ESPEC√çFICO PARA REGEX
                testarRegexEspecifica: testarRegexEspecifica,

                // üß™ TESTE PARA EXTRA√á√ÉO DE TIPOS
                testarExtracaoTipos: testarExtracaoTipos,

                // üîç DEBUG ESPEC√çFICO PARA TOOLTIP E TIPO
                debugTooltipComTipo: debugTooltipComTipo,

                // üîç NOVA FUN√á√ÉO: Verificar se o tipo de sess√£o est√° sendo capturado corretamente
                debugTipoSessaoTooltip: function () {
                    log("üîç DEBUG: Verificando captura do tipo de sess√£o...");

                    // 1. Verificar dados detectados
                    const dadosSessoes =
                        window.SENT1_AUTO.detectarSessoesUnificado(true);
                    if (!dadosSessoes || !dadosSessoes.todasSessoes) {
                        console.error("‚ùå Nenhuma sess√£o detectada");
                        return false;
                    }

                    log("üìä SESS√ïES DETECTADAS:", dadosSessoes);

                    // 2. Verificar cada sess√£o individualmente
                    dadosSessoes.todasSessoes.forEach((sessao, index) => {
                        log(`üîç SESS√ÉO ${index + 1}:`, {
                            tipo: sessao.tipo,
                            status: sessao.status,
                            data: sessao.data,
                            orgao: sessao.orgao,
                            textoCompleto:
                                sessao.textoCompleto?.substring(0, 100) + "...",
                        });

                        // Verificar se o tipo est√° vazio ou indefinido
                        if (!sessao.tipo || sessao.tipo.trim() === "") {
                            console.warn(
                                `‚ö†Ô∏è SESS√ÉO ${
                                    index + 1
                                }: Tipo vazio ou indefinido!`,
                            );

                            // Tentar extrair o tipo novamente do texto completo
                            if (sessao.textoCompleto) {
                                const match =
                                    sessao.textoCompleto.match(/^([^(]+)/);
                                if (match) {
                                    const tipoExtraido = match[1].trim();
                                    log(`üí° TIPO EXTRA√çDO: "${tipoExtraido}"`);
                                }
                            }
                        } else {
                            log(
                                `‚úÖ SESS√ÉO ${index + 1}: Tipo OK - "${
                                    sessao.tipo
                                }"`,
                            );
                        }
                    });

                    // 3. Verificar tooltip atual
                    const card = document.querySelector(".eprobe-card-sessao");
                    if (card) {
                        log("üéØ TESTANDO TOOLTIP:");

                        // Simular hover para ativar tooltip
                        const event = new MouseEvent("mouseenter", {
                            bubbles: true,
                            cancelable: true,
                        });
                        card.dispatchEvent(event);

                        setTimeout(() => {
                            const tooltip = document.querySelector(
                                ".eprobe-tooltip-unificado",
                            );
                            if (tooltip) {
                                const conteudo = tooltip.innerHTML;
                                log(
                                    "üìù CONTE√öDO DO TOOLTIP:",
                                    conteudo.substring(0, 500) + "...",
                                );

                                // Verificar se h√° men√ß√£o aos tipos
                                const tiposEncontrados = conteudo.match(
                                    /Embargos|Apela√ß√£o|Agravo|Recurso/gi,
                                );
                                if (tiposEncontrados) {
                                    log(
                                        "‚úÖ TIPOS ENCONTRADOS NO TOOLTIP:",
                                        tiposEncontrados,
                                    );
                                } else {
                                    console.warn(
                                        "‚ö†Ô∏è NENHUM TIPO ENCONTRADO NO TOOLTIP",
                                    );
                                }
                            }
                        }, 200);
                    }

                    return true;
                },

                // üé® FUN√á√ÉO UNIFICADA DE NAVBAR - SOLU√á√ÉO CONSOLIDADA
                unificarNavbarStyles: unificarNavbarStyles,

                // üéØ FUN√á√ÉO OBRIGAT√ìRIA: For√ßar flexbox na navbar - CR√çTICA
                forcarFlexboxNavbar: () => {
                    const elementosNavbar =
                        document.querySelectorAll(".d-none.d-md-flex");
                    elementosNavbar.forEach((elemento) => {
                        elemento.style.setProperty(
                            "display",
                            "flex",
                            "important",
                        );
                        elemento.style.setProperty(
                            "align-items",
                            "center",
                            "important",
                        );
                        elemento.style.setProperty(
                            "visibility",
                            "visible",
                            "important",
                        );
                        elemento.style.setProperty("opacity", "1", "important");
                    });

                    if (elementosNavbar.length > 0) {
                        console.log(
                            `üéØ NAVBAR CR√çTICO: Flexbox for√ßado em ${elementosNavbar.length} elementos via namespace principal`,
                        );
                    }
                    return elementosNavbar.length;
                },
            };

            // Fim da se√ß√£o de funcionalidades

            // Exportar namespace consolidado para escopo global
            window.SENT1_AUTO = eProbeNamespaceFunctions;

            // ##### FIM DO NAMESPACE CONSOLIDADO #####
        })(); // ‚Üê FECHAMENTO DA FUN√á√ÉO ASYNC INTERNA

        // üé® DEFINIR FUN√á√ïES DE GRADIENTES ANTES DO NAMESPACE

        // üîç FUN√á√ÉO AUXILIAR: Verificar se estamos numa p√°gina de capa do processo
        function isCapaProcessoPage() {
            const url = window.location.href;
            // Verificar se a URL cont√©m o padr√£o de capa do processo
            return (
                url.includes("acao=processo_selecionar") &&
                (url.includes("eproc1g.tjsc.jus.br") ||
                    url.includes("eproc2g.tjsc.jus.br"))
            );
        }

        /**
         * üé® FUN√á√ÉO PARA APLICAR GRADIENTES NA CAPA DO PROCESSO
         * Substitui cores s√≥lidas de background por gradientes suaves no fieldset da capa
         * Baseado na documenta√ß√£o "cores capa do processo.md"
         */
        function aplicarGradientesCapaProcesso() {
            log("üé® GRADIENTES CAPA: Iniciando aplica√ß√£o de gradientes...");

            // Verificar se estamos na p√°gina correta
            if (!isCapaProcessoPage()) {
                log("‚ùå GRADIENTES CAPA: N√£o √© uma p√°gina de capa de processo");
                return false;
            }

            // Buscar o fieldset da capa
            const fieldsetCapa = document.querySelector(
                "#fldCapa.infraFieldset.bootstrap-styles",
            );
            if (!fieldsetCapa) {
                log("‚ùå GRADIENTES CAPA: Fieldset #fldCapa n√£o encontrado");
                return false;
            }

            log("‚úÖ GRADIENTES CAPA: Fieldset encontrado:", fieldsetCapa);

            // DETECCAO PRIMARIA: Usar data-classe (robusto, nao depende de cor)
            const dataClasse = fieldsetCapa.getAttribute("data-classe");
            const dataCompetencia =
                fieldsetCapa.getAttribute("data-competencia");
            log(
                "üîç GRADIENTES CAPA: data-classe:",
                dataClasse,
                "data-competencia:",
                dataCompetencia,
            );

            // Mapeamento de data-classe para gradientes (metodo primario)
            const mapeamentoClasses = {
                // Classes criminais (rosa)
                94: "linear-gradient(#FBAFDF, #F78DC7)",
                283: "linear-gradient(#FBAFDF, #F78DC7)",
                // Adicionar mais classes conforme documentadas
            };

            // Tentar deteccao por data-classe primeiro
            if (dataClasse && mapeamentoClasses[dataClasse]) {
                const gradiente = mapeamentoClasses[dataClasse];
                log(`üéâ GRADIENTES CAPA: Match por data-classe=${dataClasse}`);
                log(`   Gradiente: ${gradiente}`);
                try {
                    fieldsetCapa.style.setProperty(
                        "background",
                        gradiente,
                        "important",
                    );
                    log(
                        "‚úÖ GRADIENTES CAPA: Gradiente aplicado via data-classe!",
                    );
                    return {
                        sucesso: true,
                        metodo: "data-classe",
                        classe: dataClasse,
                        gradienteAplicado: gradiente,
                        elemento: fieldsetCapa,
                    };
                } catch (error) {
                    logError(
                        "‚ùå GRADIENTES CAPA: Erro ao aplicar gradiente via data-classe:",
                        error,
                    );
                }
            }

            // FALLBACK: Deteccao por cor computada (metodo legado)
            log(
                "üîÑ GRADIENTES CAPA: data-classe nao mapeada, usando fallback por cor...",
            );

            // Obter estilo computed atual
            const estiloComputado = window.getComputedStyle(fieldsetCapa);
            const corAtual = estiloComputado.backgroundColor;

            log("üîç GRADIENTES CAPA: Cor atual detectada:", corAtual);

            // Fun√ß√£o para converter RGB para hex
            function rgbParaHex(rgb) {
                if (rgb.startsWith("#")) return rgb.toLowerCase();

                const rgbMatch = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1])
                        .toString(16)
                        .padStart(2, "0");
                    const g = parseInt(rgbMatch[2])
                        .toString(16)
                        .padStart(2, "0");
                    const b = parseInt(rgbMatch[3])
                        .toString(16)
                        .padStart(2, "0");
                    return `#${r}${g}${b}`;
                }

                return rgb;
            }

            // Mapeamento de cores para gradientes conforme documenta√ß√£o
            const mapeamentoCores = {
                // AMARELO
                "#efd88f": "linear-gradient(#F9EFAF, #F7E98D)",

                // VERMELHO (formato rgb)
                "rgb(142, 53, 35)": "linear-gradient(#FAAFAF, #F78D8D)",
                "rgb(142,53,35)": "linear-gradient(#FAAFAF, #F78D8D)", // sem espa√ßos

                // AZUL
                "#c4dffb": "linear-gradient(#AFCFFA, #8DC0F7)",

                // VERDE
                "#a7eda7": "linear-gradient(#AFFAB6, #8DF792)",

                // LARANJA
                "#f5b574": "linear-gradient(#FAD3AF, #F7C68D)",

                // CINZA
                "#a0b9bf": "linear-gradient(#B5C9CF, #9CB0B7)",
                "#A0B9BF": "linear-gradient(#B5C9CF, #9CB0B7)", // case insensitive

                // ROSA
                "#fbc4df": "linear-gradient(#FBAFDF, #F78DC7)",
            };

            // Verificar m√∫ltiplos formatos da cor atual
            const formatosPossiveisCor = [
                corAtual,
                corAtual.replace(/\s+/g, ""), // sem espa√ßos
                rgbParaHex(corAtual),
                rgbParaHex(corAtual).toUpperCase(),
            ];

            log("üîç GRADIENTES CAPA: Formatos testados:", formatosPossiveisCor);

            let gradienteEncontrado = null;
            let corCorrespondente = null;

            // Buscar correspond√™ncia nos mapeamentos
            for (const formato of formatosPossiveisCor) {
                if (mapeamentoCores[formato]) {
                    gradienteEncontrado = mapeamentoCores[formato];
                    corCorrespondente = formato;
                    break;
                }
            }

            if (gradienteEncontrado) {
                log(`üéâ GRADIENTES CAPA: Correspond√™ncia encontrada!`);
                log(`   Cor original: ${corCorrespondente}`);
                log(`   Gradiente: ${gradienteEncontrado}`);

                // Aplicar o gradiente seguindo padr√£o das outras fun√ß√µes
                try {
                    fieldsetCapa.style.setProperty(
                        "background",
                        gradienteEncontrado,
                        "important",
                    );
                    log("‚úÖ GRADIENTES CAPA: Gradiente aplicado com sucesso!");

                    return {
                        sucesso: true,
                        corOriginal: corCorrespondente,
                        gradienteAplicado: gradienteEncontrado,
                        elemento: fieldsetCapa,
                    };
                } catch (error) {
                    logError(
                        "‚ùå GRADIENTES CAPA: Erro ao aplicar gradiente:",
                        error,
                    );
                    return false;
                }
            } else {
                log(
                    `‚ùå GRADIENTES CAPA: Cor n√£o reconhecida para substitui√ß√£o: ${corAtual}`,
                );
                log(
                    "üí° GRADIENTES CAPA: Cores suportadas:",
                    Object.keys(mapeamentoCores),
                );

                return {
                    sucesso: false,
                    corNaoReconhecida: corAtual,
                    coresSuportadas: Object.keys(mapeamentoCores),
                };
            }
        }

        /**
         * üîÑ FUN√á√ÉO DE APLICA√á√ÉO ROBUSTA DE GRADIENTES - Com detec√ß√£o inteligente e retry autom√°tico
         */
        function aplicarGradientesCapaProcessoRobusta() {
            log(
                "üîÑ GRADIENTES ROBUSTA: Iniciando aplica√ß√£o robusta de gradientes...",
            );

            // Verificar se estamos na p√°gina correta primeiro
            if (!isCapaProcessoPage()) {
                log(
                    "‚ÑπÔ∏è GRADIENTES ROBUSTA: N√£o √© uma p√°gina de capa de processo",
                );
                return false;
            }

            let tentativas = 0;
            const maxTentativas = 5;
            const intervalTentativas = 1000; // 1 segundo entre tentativas

            const tentarAplicarGradientes = () => {
                tentativas++;
                log(`üéØ GRADIENTES: Tentativa ${tentativas}/${maxTentativas}`);

                const resultado = aplicarGradientesCapaProcesso();
                const sucesso = resultado && resultado.sucesso;

                if (!sucesso && tentativas < maxTentativas) {
                    log(
                        `‚è≥ GRADIENTES: Aguardando ${intervalTentativas}ms para nova tentativa...`,
                    );
                    setTimeout(tentarAplicarGradientes, intervalTentativas);
                } else if (sucesso) {
                    log(
                        "‚úÖ GRADIENTES ROBUSTA: Gradientes aplicados com sucesso!",
                    );
                    log(
                        `üìä RESULTADOS: Cor original: ${resultado.corOriginal}, Gradiente: ${resultado.gradienteAplicado}`,
                    );
                } else {
                    log(
                        "‚ö†Ô∏è GRADIENTES ROBUSTA: N√£o foi poss√≠vel aplicar gradientes ap√≥s todas as tentativas",
                    );
                }
            };

            // Iniciar primeira tentativa
            tentarAplicarGradientes();

            // Tamb√©m agendar uma verifica√ß√£o ap√≥s carregamento completo
            if (document.readyState !== "complete") {
                window.addEventListener("load", () => {
                    setTimeout(() => {
                        log("üîÑ GRADIENTES: Verifica√ß√£o p√≥s-carregamento...");
                        aplicarGradientesCapaProcesso();
                    }, 500);
                });
            }

            return true;
        }

        /**
         * üé® FUN√á√ÉO PARA PERSONALIZAR LEGMINUTAS E TABELAS
         * Substitui cores s√≥lidas por gradientes suaves nos elementos de minutas
         * Baseado na documenta√ß√£o "cores legMinutas.md"
         */
        function aplicarGradientesLegMinutas() {
            log(
                "üé® GRADIENTES MINUTAS: Iniciando aplica√ß√£o de gradientes nas minutas...",
            );

            // Verificar se estamos na p√°gina correta
            if (!isCapaProcessoPage()) {
                log(
                    "‚õî GRADIENTES MINUTAS: Fun√ß√£o restrita √† capa do processo",
                );
                return { sucesso: false, motivo: "p√°gina n√£o permitida" };
            }

            // Mapeamento de cores para gradientes - legMinutas
            const mapeamentoCoresLegendas = {
                "#98F5FF": "linear-gradient(#AFCFFA, #8DC0F7)", // AZUL
                "#FFA07A": "linear-gradient(#FFB8AF, #FF9C8D)", // LARANJA INTENSO
                "#FFD39B": "linear-gradient(#FAD3AF, #F7C68D)", // LARANJA CLARO
                "#FFC125": "linear-gradient(#FFDE8F, #FFB84D)", // DOURADO
                "#CDB5CD": "linear-gradient(#D8C7D8, #C4A5C4)", // LIL√ÅS
                "#D3D3D3": "linear-gradient(#B5C9CF, #9CB0B7)", // CINZA
                "#EE6363": "linear-gradient(#FAAFAF, #F78D8D)", // VERMELHA
                "#FFFF00": "linear-gradient(#FFFF8F, #F0F04D)", // VERDE LIM√ÉO
                "#FFBBFF": "linear-gradient(#FFC9FF, #FF9CFF)", // ROSA CLARO
                "#FFF68F": "linear-gradient(#F9EFAF, #F7E98D)", // AMARELA
                "#90EE90": "linear-gradient(#AFFAB6, #8DF792)", // VERDE
            };

            // Mapeamento de cores para tabelas - infraTrClara (tons claros)
            const mapeamentoCoresInfraClara = {
                "#98F5FF": "linear-gradient(#AFCFFA, #8DC0F7)", // AZUL
                "#FFA07A": "linear-gradient(#FFB8AF, #FF9C8D)", // LARANJA INTENSO
                "#FFD39B": "linear-gradient(#FAD3AF, #F7C68D)", // LARANJA CLARO
                "#FFC125": "linear-gradient(#FFDE8F, #FFB84D)", // DOURADO
                "#CDB5CD": "linear-gradient(#D8C7D8, #C4A5C4)", // LIL√ÅS
                "#D3D3D3": "linear-gradient(#B5C9CF, #9CB0B7)", // CINZA
                "#EE6363": "linear-gradient(#FAAFAF, #F78D8D)", // VERMELHA
                "#FFFF00": "linear-gradient(#FFFF8F, #F0F04D)", // VERDE LIM√ÉO
                "#FFBBFF": "linear-gradient(#FFC9FF, #FF9CFF)", // ROSA CLARO
                "#FFF68F": "linear-gradient(#F9EFAF, #F7E98D)", // AMARELA
                "#90EE90": "linear-gradient(#AFFAB6, #8DF792)", // VERDE
            };

            // Mapeamento de cores para tabelas - infraTrEscura (tons escuros)
            const mapeamentoCoresInfraEscura = {
                "#98F5FF": "linear-gradient(#7AB5F3, #5A9DEF)", // AZUL
                "#FFA07A": "linear-gradient(#FF8D7A, #FF6B58)", // LARANJA INTENSO
                "#FFD39B": "linear-gradient(#F5B87A, #F2A558)", // LARANJA CLARO
                "#FFC125": "linear-gradient(#FFA93A, #FF9520)", // DOURADO
                "#CDB5CD": "linear-gradient(#B593B5, #A082A0)", // LIL√ÅS
                "#D3D3D3": "linear-gradient(#8A9EA5, #778C93)", // CINZA
                "#EE6363": "linear-gradient(#F47A7A, #F15858)", // VERMELHA
                "#FFFF00": "linear-gradient(#E6E63A, #CCCC20)", // VERDE LIM√ÉO
                "#FFBBFF": "linear-gradient(#FF7AFF, #FF58FF)", // ROSA CLARO
                "#FFF68F": "linear-gradient(#F5DC7A, #F3D058)", // AMARELA
                "#90EE90": "linear-gradient(#7AF381, #58EF5F)", // VERDE
            };

            let processados = 0;

            // Fun√ß√£o para converter RGB para hex
            function rgbParaHex(rgb) {
                if (rgb.startsWith("#")) return rgb.toLowerCase();

                const rgbMatch = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1])
                        .toString(16)
                        .padStart(2, "0");
                    const g = parseInt(rgbMatch[2])
                        .toString(16)
                        .padStart(2, "0");
                    const b = parseInt(rgbMatch[3])
                        .toString(16)
                        .padStart(2, "0");
                    return `#${r}${g}${b}`;
                }

                return rgb;
            }

            try {
                // 1. PROCESSAR LEGENDA MINUTAS - USAR QUERYSELECTORALL PARA TODOS OS ELEMENTOS
                const elementosLegMinutas = document.querySelectorAll(
                    'legend[aria-label="Hist√≥rico"]#legMinutas.infraLegendObrigatorio',
                );

                log(
                    `üîç GRADIENTES MINUTAS: Encontrados ${elementosLegMinutas.length} elementos legMinutas`,
                );

                elementosLegMinutas.forEach((legMinutas, index) => {
                    const corAtual = rgbParaHex(
                        window.getComputedStyle(legMinutas).backgroundColor,
                    );
                    if (
                        corAtual &&
                        mapeamentoCoresLegendas[corAtual.toUpperCase()]
                    ) {
                        const novoGradiente =
                            mapeamentoCoresLegendas[corAtual.toUpperCase()];
                        legMinutas.style.setProperty(
                            "background",
                            novoGradiente,
                            "important",
                        );
                        log(
                            `‚úÖ GRADIENTES MINUTAS: legMinutas ${
                                index + 1
                            } ${corAtual} ‚Üí ${novoGradiente}`,
                        );
                        processados++;
                    } else {
                        log(
                            `‚ö†Ô∏è GRADIENTES MINUTAS: legMinutas ${
                                index + 1
                            } cor n√£o mapeada: ${corAtual}`,
                        );
                    }
                });

                // 2. PROCESSAR TABELAS DENTRO DOS CONTAINERS DE MINUTAS
                const containersMinutas = document.querySelectorAll(
                    '[id^="conteudoInternoMinutas_"]',
                );
                containersMinutas.forEach((container, index) => {
                    log(
                        `üîç GRADIENTES MINUTAS: Processando container ${
                            index + 1
                        }: ${container.id}`,
                    );

                    // Processar linhas claras (infraTrClara)
                    const linhasClaras =
                        container.querySelectorAll("tr.infraTrClara");
                    linhasClaras.forEach((linha, linhaIndex) => {
                        const corAtual = rgbParaHex(
                            window.getComputedStyle(linha).backgroundColor,
                        );
                        if (
                            corAtual &&
                            mapeamentoCoresInfraClara[corAtual.toUpperCase()]
                        ) {
                            const novoGradiente =
                                mapeamentoCoresInfraClara[
                                    corAtual.toUpperCase()
                                ];
                            linha.style.setProperty(
                                "background",
                                novoGradiente,
                                "important",
                            );
                            log(
                                `‚úÖ GRADIENTES MINUTAS: infraTrClara[${linhaIndex}] ${corAtual} ‚Üí ${novoGradiente}`,
                            );
                            processados++;
                        }
                    });

                    // Processar linhas escuras (infraTrEscura)
                    const linhasEscuras =
                        container.querySelectorAll("tr.infraTrEscura");
                    linhasEscuras.forEach((linha, linhaIndex) => {
                        const corAtual = rgbParaHex(
                            window.getComputedStyle(linha).backgroundColor,
                        );
                        if (
                            corAtual &&
                            mapeamentoCoresInfraEscura[corAtual.toUpperCase()]
                        ) {
                            const novoGradiente =
                                mapeamentoCoresInfraEscura[
                                    corAtual.toUpperCase()
                                ];
                            linha.style.setProperty(
                                "background",
                                novoGradiente,
                                "important",
                            );
                            log(
                                `‚úÖ GRADIENTES MINUTAS: infraTrEscura[${linhaIndex}] ${corAtual} ‚Üí ${novoGradiente}`,
                            );
                            processados++;
                        }
                    });
                });

                log(
                    `‚úÖ GRADIENTES MINUTAS: ${processados} elementos processados com sucesso`,
                );
                return {
                    sucesso: true,
                    processados,
                    legMinutasEncontrado: !!document.querySelector(
                        "#legMinutas.infraLegendObrigatorio",
                    ),
                    containersEncontrados: containersMinutas.length,
                };
            } catch (error) {
                console.error(
                    "‚ùå GRADIENTES MINUTAS: Erro durante aplica√ß√£o:",
                    error,
                );
                return {
                    sucesso: false,
                    motivo: error.message,
                    processados,
                };
            }
        }

        /**
         * üîÑ FUN√á√ÉO DE APLICA√á√ÉO ROBUSTA DE GRADIENTES MINUTAS - Com retry autom√°tico
         */
        function aplicarGradientesLegMinutasRobusta() {
            log(
                "üîÑ GRADIENTES MINUTAS ROBUSTA: Iniciando aplica√ß√£o robusta de gradientes nas minutas...",
            );

            // Verificar se estamos na p√°gina correta primeiro
            if (!isCapaProcessoPage()) {
                log(
                    "‚ÑπÔ∏è GRADIENTES MINUTAS ROBUSTA: N√£o √© uma p√°gina de capa de processo",
                );
                return false;
            }

            let tentativas = 0;
            const maxTentativas = 3;
            const intervalTentativas = 800; // 800ms entre tentativas

            const tentarAplicarGradientes = () => {
                tentativas++;
                log(
                    `üéØ GRADIENTES MINUTAS: Tentativa ${tentativas}/${maxTentativas}`,
                );

                const resultado = aplicarGradientesLegMinutas();
                const sucesso = resultado && resultado.sucesso;

                if (sucesso) {
                    log(
                        `‚úÖ GRADIENTES MINUTAS ROBUSTA: Aplica√ß√£o bem-sucedida na tentativa ${tentativas}!`,
                    );
                    log(
                        `üìä GRADIENTES MINUTAS: ${resultado.processados} elementos processados`,
                    );
                    return true;
                } else {
                    log(
                        `‚ùå GRADIENTES MINUTAS: Tentativa ${tentativas} falhou`,
                    );
                    if (resultado?.motivo) {
                        log(`   Motivo: ${resultado.motivo}`);
                    }

                    if (tentativas < maxTentativas) {
                        log(
                            `üîÑ GRADIENTES MINUTAS: Reagendando tentativa em ${intervalTentativas}ms...`,
                        );
                        setTimeout(tentarAplicarGradientes, intervalTentativas);
                    } else {
                        log(
                            "‚ùå GRADIENTES MINUTAS ROBUSTA: Todas as tentativas falharam - desistindo",
                        );
                        return false;
                    }
                }
            };

            // Executar primeira tentativa imediatamente
            return tentarAplicarGradientes();
        }

        /**
         * FUNCAO PARA PADRONIZAR CORES DE BACKGROUND NA CAPA DO PROCESSO
         * Substitui cores solidas do eProc por gradientes suaves em TODOS os elementos
         * Documentacao: development/Anotacoes/cores detalhes capa do processo.md
         */
        function aplicarGradientesDetalhesCapa() {
            log("GRADIENTES DETALHES: Iniciando padronizacao de cores...");

            if (!isCapaProcessoPage()) {
                return false;
            }

            var mapeamentoRGB = {
                "35,110,142": "linear-gradient(#5A8DB5, #4A7DA5)",
                "142,53,35": "linear-gradient(#D6807A, #C26B58)",
                "89,89,89": "linear-gradient(#8A9EA5, #778C93)",
                "105,142,35": "linear-gradient(#8CBF5A, #7AAF4A)",
            };

            function extrairRGB(cor) {
                if (!cor) return null;
                var m = cor.match(/rgb[a]?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
                if (m) return m[1] + "," + m[2] + "," + m[3];
                return null;
            }

            function buscarGradiente(corComputed) {
                var rgb = extrairRGB(corComputed);
                if (!rgb) return null;
                return mapeamentoRGB[rgb] || null;
            }

            var processados = 0;

            try {
                var todosElementos = document.querySelectorAll(
                    "#fldCapa *, #divInfraAreaProcesso *, label.infraEventoDescricao, span.infraEventoDescricao, a.infraNomeParte, #tblEventos *, #divInfraAreaTeor *",
                );

                log(
                    "GRADIENTES DETALHES: " +
                        todosElementos.length +
                        " elementos para verificar",
                );

                for (var i = 0; i < todosElementos.length; i++) {
                    var el = todosElementos[i];
                    var bgAtual = el.style.background || "";
                    if (bgAtual.indexOf("gradient") !== -1) continue;

                    var computed = window.getComputedStyle(el);
                    var corBg = computed.backgroundColor;

                    var gradiente = buscarGradiente(corBg);
                    if (gradiente) {
                        el.style.setProperty(
                            "background",
                            gradiente,
                            "important",
                        );
                        processados++;
                    }
                }

                log(
                    "GRADIENTES DETALHES: " +
                        processados +
                        " elementos padronizados",
                );
                return { sucesso: processados > 0, processados: processados };
            } catch (error) {
                console.error("GRADIENTES DETALHES: Erro:", error);
                return {
                    sucesso: false,
                    motivo: error.message,
                    processados: processados,
                };
            }
        }

        /**
         * Aplicacao robusta de gradientes nos detalhes da capa com retry
         */
        function aplicarGradientesDetalhesCapaRobusta() {
            if (!isCapaProcessoPage()) {
                return false;
            }

            var tentativas = 0;
            var maxTentativas = 4;
            var intervalo = 800;

            var tentarAplicar = function () {
                tentativas++;
                log(
                    "GRADIENTES DETALHES: Tentativa " +
                        tentativas +
                        "/" +
                        maxTentativas,
                );

                var resultado = aplicarGradientesDetalhesCapa();
                var sucesso = resultado && resultado.sucesso;

                if (sucesso) {
                    log(
                        "GRADIENTES DETALHES ROBUSTA: " +
                            resultado.processados +
                            " elementos padronizados",
                    );
                } else if (tentativas < maxTentativas) {
                    setTimeout(tentarAplicar, intervalo);
                } else {
                    log(
                        "GRADIENTES DETALHES ROBUSTA: Nenhum elemento encontrado apos todas tentativas",
                    );
                }
            };

            tentarAplicar();
            return true;
        }

        // Adicionar funcoes do escopo externo (IIFE #9) ao namespace ja exportado pela IIFE #10
        // Estas funcoes estao definidas FORA da IIFE interna e precisam ser adicionadas separadamente
        Object.assign(window.SENT1_AUTO, {
            // Funcoes de controle de processo (escopo IIFE #9, definidas antes da IIFE #10)
            corrigirCorDeFundoConservadora: corrigirCorDeFundoConservadora,
            processoJaFoiProcessado: processoJaFoiProcessado,
            marcarProcessoComoProcessado: marcarProcessoComoProcessado,

            // Funcoes de dados de sessao (escopo IIFE #9, declaradas antecipadamente)
            hasDataSessaoPautado: hasDataSessaoPautado,
            getDataSessaoPautado: getDataSessaoPautado,
            resetDataSessaoPautado: resetDataSessaoPautado,
            resetControlesRequisicao: resetControlesRequisicao,
            obterNumeroProcesso: obterNumeroProcesso,
            inserirDataSessaoNaInterface: inserirDataSessaoNaInterface,

            // Funcoes de gradientes (definidas apos IIFE #10, escopo IIFE #9)
            isCapaProcessoPage: isCapaProcessoPage,
            aplicarGradientesCapaProcesso: aplicarGradientesCapaProcesso,
            aplicarGradientesCapaProcessoRobusta:
                aplicarGradientesCapaProcessoRobusta,
            aplicarGradientesLegMinutas: aplicarGradientesLegMinutas,
            aplicarGradientesLegMinutasRobusta:
                aplicarGradientesLegMinutasRobusta,
            aplicarGradientesDetalhesCapa: aplicarGradientesDetalhesCapa,
            aplicarGradientesDetalhesCapaRobusta:
                aplicarGradientesDetalhesCapaRobusta,

            // Tema (exposto globalmente via window em themeApply.js)
            applyThemeStyles:
                window.applyThemeStyles ||
                (() => console.log("applyThemeStyles nao disponivel")),

            // Metadados
            status: "sistema-principal-ativo",
            versao: "2.0.0",
            timestamp: new Date().toISOString(),
        });

        // Calcular total de funcoes disponiveis
        window.SENT1_AUTO.totalFuncoes = Object.keys(window.SENT1_AUTO).filter(
            (key) => typeof window.SENT1_AUTO[key] === "function",
        ).length;

        console.log(
            "NAMESPACE: window.SENT1_AUTO criado com",
            window.SENT1_AUTO.totalFuncoes,
            "funcoes disponiveis",
        );

        // Executar correcoes criticas via namespace
        try {
            if (
                typeof window.SENT1_AUTO.corrigirPointerEventsBotoes ===
                "function"
            ) {
                window.SENT1_AUTO.corrigirPointerEventsBotoes();
            }
        } catch (error) {
            console.error("Erro na correcao de pointer-events:", error);
        }

        logCritical(
            "eProbe Extension carregada com sucesso - Sistema completo inicializado!",
        );

        // Teste imediato das funcoes criticas
        setTimeout(() => {
            try {
                if (typeof window.SENT1_AUTO === "object") {
                    const funcoesCriticas = [
                        "detectarCardSessaoSimplificado",
                        "detectarSessoesUnificado",
                        "runFullAutomation",
                        "forcarFlexboxNavbar",
                    ];
                    const resultados = funcoesCriticas.map((nome) => {
                        const existe =
                            typeof window.SENT1_AUTO[nome] === "function";
                        return `${existe ? "[OK]" : "[AUSENTE]"} ${nome}`;
                    });
                    logCritical("TESTE NAMESPACE:");
                    resultados.forEach((r) => logCritical(`  ${r}`));
                    logCritical(
                        "Total funcoes: " + window.SENT1_AUTO.totalFuncoes,
                    );
                }
            } catch (error) {
                console.error("Erro no teste de namespace:", error);
            }
        }, 100);

        // ‚úÖ MARCAR EXECU√á√ÉO COMO COMPLETA E CANCELAR TIMEOUT DE EMERG√äNCIA
        mainExecutionCompleted = true;
        namespaceCreated = true;
        clearTimeout(timeoutSeguranca);
        logCritical(
            "üõ°Ô∏è PROTE√á√ÉO: Timeout de emerg√™ncia cancelado - execu√ß√£o normal completa",
        );
    } catch (error) {
        logError("üí• IIFE: ERRO CR√çTICO durante execu√ß√£o:", error);
        logError("üìç ERRO em:", error.stack);

        // üÜò EM CASO DE ERRO: Tentar criar namespace de emerg√™ncia imediatamente
        logError(
            "üÜò ERRO: Tentando criar namespace de emerg√™ncia devido ao erro...",
        );
        clearTimeout(timeoutSeguranca);
        garantirNamespace();

        // Re-throw para ativar o .catch() da IIFE
        throw error;
    }
})().catch((error) => {
    console.error("üí• ASYNC IIFE: Erro n√£o capturado:", error);
    console.error("üîç Stack trace:", error.stack);
    // Tentar criar namespace de emerg√™ncia mesmo com erro
    try {
        if (typeof garantirNamespace === "function") {
            garantirNamespace();
        }
    } catch (emergencyError) {
        console.error(
            "‚ùå FALHA CR√çTICA: N√£o foi poss√≠vel criar namespace de emerg√™ncia:",
            emergencyError,
        );
    }
});
